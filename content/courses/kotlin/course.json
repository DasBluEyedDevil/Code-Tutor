{
  "id": "kotlin",
  "language": "kotlin",
  "title": "Kotlin Programming Complete Course",
  "description": "Master Kotlin from basics to advanced with 63+ interactive lessons, coding challenges, and comprehensive quizzes.",
  "difficulty": "beginner",
  "estimatedHours": 75,
  "prerequisites": [],
  "modules": [
    {
      "id": "module-01",
      "title": "Part 1: Kotlin Fundamentals",
      "description": "Learn Kotlin programming - Part 1",
      "difficulty": "beginner",
      "estimatedHours": 10,
      "lessons": [
        {
          "id": "1.1",
          "title": "Lesson 1.1: Introduction to Kotlin & Development Setup",
          "moduleId": "module-01",
          "order": 1,
          "estimatedMinutes": 45,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 45 minutes\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Topic Introduction",
              "content": "\nWelcome to your journey into programming with Kotlin! Whether you've never written a line of code before or you're coming from another programming language, this course will teach you everything you need to know to become a confident Kotlin developer.\n\nIn this first lesson, you'll learn what programming really means, why Kotlin is an excellent choice, and how to set up your development environment. By the end, you'll write and run your very first Kotlin program!\n\n---\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "The Concept",
              "content": "\n### What is Programming?\n\nThink of programming like writing a recipe for a robot chef:\n\n**Cooking with a Human Chef**:\n- \"Add some salt\" (they know what \"some\" means)\n- \"Cook until golden brown\" (they recognize golden brown)\n- \"Stir occasionally\" (they decide when \"occasionally\" is)\n\n**Cooking with a Robot Chef** (Programming):\n- \"Add exactly 5 grams of salt\"\n- \"Cook for 8 minutes at 180¬∞C\"\n- \"Stir every 2 minutes for 10 seconds\"\n\nComputers are like robot chefs‚Äîthey need **exact, unambiguous instructions**. Programming is the art of writing these instructions in a language computers can understand.\n\n### What is a Programming Language?\n\nYou speak English (or another human language). Computers speak in binary‚Äîmillions of 1s and 0s. Programming languages are the bridge:\n\n\n**Kotlin** is our bridge language. It's designed to be:\n- **Readable**: Looks almost like English\n- **Precise**: No ambiguity for the computer\n- **Safe**: Catches mistakes before they cause problems\n\n---\n\n",
              "code": "You (Human)  ‚Üí  [Programming Language]  ‚Üí  Computer (Binary)\n\"Print Hello\"  ‚Üí  [Kotlin Compiler]  ‚Üí  10101001001...",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Why Kotlin?",
              "content": "\n### The Kotlin Story\n\nKotlin was created by JetBrains (makers of IntelliJ IDEA) in 2011 and officially released in 2016. In 2017, Google announced Kotlin as an official language for Android development. In 2019, Google declared Kotlin the **preferred language** for Android.\n\n### Kotlin's Superpowers\n\n**1. Modern & Concise**\n\nCompare Java vs Kotlin for the same task:\n\n\n\n**Same functionality, 90% less code!**\n\n**2. Null Safety Built-In**\n\nOne of the most common programming errors is the \"null pointer exception\" (trying to use something that doesn't exist). Kotlin prevents this at compile-time:\n\n\n**3. Multiplatform**\n\nWrite code once, run it everywhere:\n- **Android**: Mobile apps\n- **JVM**: Backend servers, desktop apps\n- **JavaScript**: Web frontend\n- **Native**: iOS apps, embedded systems\n\n### Industry Adoption\n\nCompanies using Kotlin:\n- **Google**: Android OS and apps\n- **Netflix**: Mobile apps\n- **Uber**: Internal tools\n- **Pinterest**: Mobile apps\n- **Trello**: Android app\n- **Coursera**: Android app\n- **Evernote**: Android app\n\n**Job Market**: Over 50,000 Kotlin developer jobs posted in 2024 (Indeed, LinkedIn).\n\n---\n\n",
              "code": "var name: String = \"Alice\"\nname = null  // ‚ùå Compiler error: \"Null can not be a value of a non-null type String\"\n\nvar nullableName: String? = \"Bob\"\nnullableName = null  // ‚úÖ OK, we explicitly said this can be null",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Setting Up Your Development Environment",
              "content": "\nYou have two options: online playground (quick start) or full IDE (professional setup).\n\n### Option 1: Kotlin Playground (Beginner-Friendly)\n\n**Best for**: Complete beginners, trying Kotlin quickly\n\n**Steps**:\n1. Open your web browser\n2. Go to [play.kotlinlang.org](https://play.kotlinlang.org/)\n3. You'll see a code editor with example code\n4. That's it! No installation needed.\n\n**Try it now**: Type this code in the playground:\n\n\nClick the green **Run** button. You should see:\n\n‚úÖ **Pros**: Instant start, no installation, great for learning\n‚ùå **Cons**: Limited features, requires internet\n\n---\n\n### Option 2: IntelliJ IDEA (Professional Setup)\n\n**Best for**: Serious learning, building real projects\n\n**Steps**:\n\n1. **Download IntelliJ IDEA Community Edition** (Free)\n   - Go to [jetbrains.com/idea/download](https://www.jetbrains.com/idea/download/)\n   - Choose your operating system\n   - Download the **Community Edition** (free, open-source)\n\n2. **Install IntelliJ IDEA**\n   - **Windows**: Run the `.exe` installer, follow prompts\n   - **macOS**: Drag the app to Applications folder\n   - **Linux**: Extract the archive, run `bin/idea.sh`\n\n3. **Create Your First Kotlin Project**\n\n   a. Open IntelliJ IDEA\n\n   b. Click **New Project**\n\n   c. Select **Kotlin** from the left menu\n\n   d. Choose **JVM | Application**\n\n   e. Project settings:\n      - **Name**: MyFirstKotlinProject\n      - **Location**: Choose where to save (e.g., Documents/KotlinProjects)\n      - **Build system**: Gradle Kotlin (recommended)\n      - **JDK**: 17 or higher (IntelliJ will download if needed)\n      - **Gradle DSL**: Kotlin\n\n   f. Click **Create**\n\n4. **Create Your First Kotlin File**\n\n   a. In the Project panel (left side), navigate to:\n      ```\n      src ‚Üí main ‚Üí kotlin\n      ```\n\n   b. Right-click on `kotlin` folder\n\n   c. Select **New ‚Üí Kotlin Class/File**\n\n   d. Choose **File**\n\n   e. Name it `Main` (creates `Main.kt`)\n\n5. **Write Your First Program**\n\n\n6. **Run Your Program**\n   - Click the green play button (‚ñ∂) next to `fun main()`\n   - Or press **Ctrl+Shift+F10** (Windows/Linux) or **Cmd+Shift+R** (macOS)\n\n**Output**:\n\nüéâ **Congratulations! You just ran your first Kotlin program!**\n\n---\n\n",
              "code": "Hello, World!\nMy name is [Your Name]\nI'm learning Kotlin!",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Understanding Your First Program",
              "content": "\nLet's break down what you just wrote:\n\n\n### Line-by-Line Breakdown\n\n**`fun main()`**:\n- `fun` = keyword that declares a **function** (a reusable block of code)\n- `main` = the name of this function (special name: every program starts here)\n- `()` = parentheses hold parameters (inputs to the function‚Äînone in this case)\n\nThe `main` function is the **entry point** of every Kotlin program. Think of it as the front door‚Äîwhen you run your program, the computer enters through `main()`.\n\n**`{` and `}`**:\n- Curly braces create a **code block**\n- Everything inside the braces is part of the `main` function\n\n**`println(\"Hello, World!\")`**:\n- `println` = a built-in function that **print**s a **line** of text\n- `\"Hello, World!\"` = a **string** (text) to print\n- `;` is optional in Kotlin (unlike Java)\n\n**How It Works**:\n\n---\n\n",
              "code": "1. Computer starts program\n   ‚Üì\n2. Finds main() function\n   ‚Üì\n3. Executes code inside { }\n   ‚Üì\n4. Calls println() function\n   ‚Üì\n5. Displays \"Hello, World!\" on screen\n   ‚Üì\n6. Program ends",
              "language": "kotlin"
            },
            {
              "type": "EXAMPLE",
              "title": "How Kotlin Code Becomes a Running Program",
              "content": "\nThis is what happens when you click \"Run\":\n\n\n**Step-by-Step**:\n\n1. **You write code** in a `.kt` file (Kotlin source file)\n2. **Kotlin Compiler** translates your code into **bytecode**\n3. **Bytecode** is a language the JVM understands\n4. **JVM** (Java Virtual Machine) runs the bytecode\n5. **Output** appears on your screen\n\n**Why JVM?**\n- JVM is incredibly mature and optimized (30+ years old)\n- Works on Windows, macOS, Linux, and more\n- Kotlin leverages all of Java's ecosystem\n\n---\n\n",
              "code": "Your Code (Main.kt)\n        ‚Üì\n   [Kotlin Compiler]\n        ‚Üì\n   Bytecode (.class files)\n        ‚Üì\n   [Java Virtual Machine (JVM)]\n        ‚Üì\n   Running Program (Output)",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Your First Interactive Program",
              "content": "\nLet's make something more interesting‚Äîa program that talks back!\n\n\n**Run this program** and interact with it:\n\n\n### New Concepts Introduced\n\n**`readln()`**:\n- Reads a line of text from user input\n- Waits for user to type something and press Enter\n\n**`val name = readln()`**:\n- `val` = declares a **val**ue (a named container for data)\n- `name` = the name of this container\n- `=` = assigns the result of `readln()` to `name`\n\n**`\"Hello, $name!\"`**:\n- `$name` = **string interpolation** (inserting a variable's value into text)\n- Dollar sign tells Kotlin: \"Replace this with the value of `name`\"\n\n**`toInt()`**:\n- Converts text to an integer (whole number)\n- `\"25\".toInt()` becomes `25` (number)\n\n---\n\n",
              "code": "=== Kotlin Greeter ===\nWhat's your name?\nAlice\nHello, Alice!\nWelcome to Kotlin programming!\n\nHow old are you?\n25\nYou have 75 years until you're 100 years old!",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 1: Personalized Greeting",
              "content": "\n**Goal**: Create a program that asks for name, favorite color, and hobby, then prints a personalized message.\n\n**Requirements**:\n1. Ask for the user's name\n2. Ask for their favorite color\n3. Ask for their hobby\n4. Print: \"Hi [name]! Your favorite color is [color] and you love [hobby]!\"\n\n**Starter Code**:\n\n**Expected Output**:\n\n---\n\n",
              "code": "What's your name?\nBob\nWhat's your favorite color?\nBlue\nWhat's your hobby?\nPhotography\nHi Bob! Your favorite color is Blue and you love Photography!",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Solution: Personalized Greeting",
              "content": "\n\n**Explanation**:\n- We use `val` three times to store three pieces of user input\n- String interpolation (`$name`, `$color`, `$hobby`) inserts values into our message\n- `\\n` creates a blank line for better formatting\n\n---\n\n",
              "code": "fun main() {\n    println(\"=== Personal Profile ===\")\n\n    println(\"What's your name?\")\n    val name = readln()\n\n    println(\"What's your favorite color?\")\n    val color = readln()\n\n    println(\"What's your hobby?\")\n    val hobby = readln()\n\n    println(\"\\n--- Your Profile ---\")\n    println(\"Hi $name! Your favorite color is $color and you love $hobby!\")\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 2: Simple Calculator",
              "content": "\n**Goal**: Create a calculator that adds two numbers.\n\n**Requirements**:\n1. Ask for first number\n2. Ask for second number\n3. Add them together\n4. Print the result\n\n**Hint**: Use `readln().toInt()` to read numbers.\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution: Simple Calculator",
              "content": "\n\n**Sample Run**:\n\n**What's Happening**:\n1. We read two numbers from the user\n2. We add them: `val sum = num1 + num2`\n3. We print the result with string interpolation\n\n---\n\n",
              "code": "=== Simple Calculator ===\nEnter first number:\n15\nEnter second number:\n27\n15 + 27 = 42",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Programming Best Practices (Start Building Good Habits!)",
              "content": "\n### 1. Use Meaningful Names\n\n\n### 2. Add Comments\n\n\n**Comment Types**:\n- `// Single-line comment`\n- `/* Multi-line\n     comment */`\n\n### 3. Use Blank Lines for Readability\n\n\n---\n\n",
              "code": "// ‚ùå Cramped\nfun main() {\n    println(\"What's your name?\")\n    val name = readln()\n    println(\"Hello, $name!\")\n}\n\n// ‚úÖ Readable\nfun main() {\n    println(\"What's your name?\")\n    val name = readln()\n\n    println(\"Hello, $name!\")\n}",
              "language": "kotlin"
            },
            {
              "type": "WARNING",
              "title": "Common Beginner Mistakes",
              "content": "\n### Mistake 1: Forgetting Quotes Around Text\n\n\n### Mistake 2: Wrong Capitalization\n\n\nKotlin is **case-sensitive**: `main` ‚â† `Main`.\n\n### Mistake 3: Missing Parentheses\n\n\n---\n\n",
              "code": "// ‚ùå Error\nfun main {  // Missing ()\n    println(\"Hello\")\n}\n\n// ‚úÖ Correct\nfun main() {  // Parentheses required\n    println(\"Hello\")\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Checkpoint Quiz",
              "content": "\nTest your understanding of this lesson!\n\n### Question 1\nWhat does the `main` function do?\n\nA) Displays output to the screen\nB) Reads input from the user\nC) Serves as the entry point where the program starts\nD) Calculates mathematical operations\n\n### Question 2\nWhat does `println()` do?\n\nA) Reads a line of input\nB) Prints a line of text to the console\nC) Creates a new variable\nD) Ends the program\n\n### Question 3\nWhat is string interpolation?\n\nA) Inserting variable values into text using `$variableName`\nB) Connecting multiple strings with `+`\nC) Converting text to numbers\nD) Reading user input\n\n### Question 4\nWhich symbol is used for comments in Kotlin?\n\nA) `#`\nB) `--`\nC) `//`\nD) `/* */` (both C and D are correct)\n\n### Question 5\nWhat does `readln().toInt()` do?\n\nA) Prints an integer\nB) Creates a random number\nC) Reads user input and converts it to an integer\nD) Adds two numbers together\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Answers",
              "content": "\n**Question 1: C) Serves as the entry point where the program starts**\n\nThe `main()` function is special‚Äîevery Kotlin program begins execution here. When you run your program, the computer looks for `fun main()` and starts executing the code inside its curly braces.\n\n\n---\n\n**Question 2: B) Prints a line of text to the console**\n\n`println()` stands for \"print line.\" It displays text on the screen and moves to the next line.\n\n\nOutput:\n\n---\n\n**Question 3: A) Inserting variable values into text using `$variableName`**\n\nString interpolation lets you embed variables directly in strings:\n\n\nThe `$` tells Kotlin to insert the variable's value.\n\n---\n\n**Question 4: D) `/* */` (both C and D are correct)**\n\nKotlin supports two comment styles:\n\n\nComments are ignored by the compiler‚Äîthey're for human readers only.\n\n---\n\n**Question 5: C) Reads user input and converts it to an integer**\n\n\nThis does two things:\n1. `readln()` reads text from user: `\"25\"`\n2. `.toInt()` converts text to number: `25`\n\nWithout `.toInt()`, you'd have text, not a number you can do math with.\n\n---\n\n",
              "code": "val age = readln().toInt()",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "What You've Learned",
              "content": "\n‚úÖ What programming is (precise instructions for computers)\n‚úÖ Why Kotlin is an excellent language to learn\n‚úÖ How to set up your development environment (playground or IntelliJ IDEA)\n‚úÖ How to write and run your first Kotlin program\n‚úÖ Understanding `fun main()`, `println()`, and `readln()`\n‚úÖ String interpolation with `$variableName`\n‚úÖ Converting text to numbers with `.toInt()`\n‚úÖ Best practices: meaningful names, comments, readability\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Next Steps",
              "content": "\nIn **Lesson 1.2: Variables, Data Types & Operators**, you'll learn:\n- Different types of data (numbers, text, true/false)\n- How to store and manipulate data in variables\n- Mathematical and logical operations\n- Type conversions and type safety\n\nGet ready to dive deeper into the building blocks of programming!\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Additional Resources",
              "content": "\n**Official Kotlin Documentation**:\n- [Kotlin Basics](https://kotlinlang.org/docs/basic-syntax.html)\n- [Kotlin Playground](https://play.kotlinlang.org/)\n\n**Community**:\n- [Kotlin Slack](https://surveys.jetbrains.com/s3/kotlin-slack-sign-up)\n- [r/Kotlin on Reddit](https://www.reddit.com/r/Kotlin/)\n\n**Practice**:\n- [Kotlin Koans](https://play.kotlinlang.org/koans/overview) - Interactive exercises\n\n---\n\n**Congratulations on completing Lesson 1.1!** üéâ\n\nYou've taken your first steps into the world of programming. Every expert programmer started exactly where you are now. Keep going!\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "1.2",
          "title": "Lesson 1.2: Variables, Data Types & Operators",
          "moduleId": "module-01",
          "order": 2,
          "estimatedMinutes": 55,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 55 minutes\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Topic Introduction",
              "content": "\nIn the previous lesson, you wrote your first Kotlin programs and learned about `main()`, `println()`, and `readln()`. Now it's time to understand how to store and manipulate data‚Äîthe core of all programming.\n\nImagine you're building a calculator app. You need to store numbers, perform operations on them, and display results. This lesson teaches you exactly how to do that with **variables**, **data types**, and **operators**.\n\n---\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "The Concept",
              "content": "\n### The Box Analogy\n\nThink of variables like labeled boxes in a warehouse:\n\n**Physical Warehouse**:\n- **Box**: Container that holds something\n- **Label**: Name on the box (\"Books\", \"Toys\", \"Electronics\")\n- **Contents**: What's inside the box\n- **Type**: What kind of things can go in (books only, toys only, etc.)\n\n**Programming Warehouse**:\n- **Variable**: Container that holds data\n- **Name**: What you call the variable (`age`, `name`, `price`)\n- **Value**: The data stored inside\n- **Type**: What kind of data it can hold (numbers, text, true/false)\n\n\n---\n\n",
              "code": "val age = 25        // Box labeled \"age\" contains number 25\nval name = \"Alice\"  // Box labeled \"name\" contains text \"Alice\"\nval isStudent = true  // Box labeled \"isStudent\" contains true/false",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Variables: val vs var",
              "content": "\nIn Kotlin, you can create two kinds of variables:\n\n### `val` - Immutable (Read-Only)\n\n\n`val` stands for **value**. Once you put something in the box, you **cannot** change it.\n\n**When to use**: Use `val` by default for values that won't change.\n\n**Real-World Examples**:\n\n### `var` - Mutable (Can Change)\n\n\n`var` stands for **variable**. You can change what's in the box anytime.\n\n**When to use**: Use `var` only when the value needs to change.\n\n**Real-World Examples**:\n\n### Best Practice: Prefer `val` Over `var`\n\n\n**Why prefer `val`?**\n- Prevents accidental changes\n- Makes code easier to understand (you know it won't change)\n- Safer for multi-threaded programs (advanced topic)\n\n---\n\n",
              "code": "// ‚úÖ Good - Using val by default\nval name = \"Bob\"\nval age = 30\nvar score = 0  // var only when needed\n\n// ‚ùå Bad - Using var unnecessarily\nvar name = \"Bob\"  // Name won't change, should be val\nvar age = 30      // Age won't change (in one program), should be val",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Data Types",
              "content": "\nEvery variable has a **type** that determines what kind of data it can hold.\n\n### Basic Data Types\n\n| Type | Description | Example Values | Memory Size |\n|------|-------------|----------------|-------------|\n| `Int` | Whole numbers | -2,147,483,648 to 2,147,483,647 | 32 bits |\n| `Long` | Large whole numbers | -9 quintillion to 9 quintillion | 64 bits |\n| `Short` | Small whole numbers | -32,768 to 32,767 | 16 bits |\n| `Byte` | Tiny whole numbers | -128 to 127 | 8 bits |\n| `Double` | Decimal numbers | 3.14, -0.001, 1.5e10 | 64 bits |\n| `Float` | Smaller decimals | 3.14f, 2.5f | 32 bits |\n| `Boolean` | True or false | true, false | 1 bit |\n| `Char` | Single character | 'A', 'z', '5', '@' | 16 bits |\n| `String` | Text (sequence of characters) | \"Hello\", \"Kotlin\" | Variable |\n\n### Examples of Each Type\n\n\n**Note**: Underscores in numbers improve readability:\n\n---\n\n",
              "code": "val million = 1_000_000  // Same as 1000000\nval billion = 1_000_000_000L",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Type Inference",
              "content": "\nKotlin is smart‚Äîit can figure out types automatically!\n\n\n**When to use explicit types**:\n- When the type isn't obvious\n- For documentation/clarity\n- Most of the time, let Kotlin infer!\n\n\n---\n\n",
              "code": "// Inference is clear\nval count = 10  // Obviously Int\n\n// Explicit might help readability\nval result: Boolean = checkStatus()  // Makes intent clear",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Type Safety and Type Checking",
              "content": "\nKotlin is **strongly typed**‚Äîyou can't mix types without converting:\n\n\n**Check a variable's type**:\n\n---\n\n",
              "code": "val number = 42\n\nprintln(number is Int)     // true\nprintln(number is String)  // false\nprintln(number is Double)  // false",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Type Conversions",
              "content": "\nConvert between types explicitly:\n\n### Number Conversions\n\n\n### Common Conversion Methods\n\n| Method | From ‚Üí To | Example |\n|--------|-----------|---------|\n| `toInt()` | Any number/String ‚Üí Int | `\"42\".toInt()` ‚Üí 42 |\n| `toDouble()` | Any number/String ‚Üí Double | `42.toDouble()` ‚Üí 42.0 |\n| `toLong()` | Any number/String ‚Üí Long | `42.toLong()` ‚Üí 42L |\n| `toFloat()` | Any number/String ‚Üí Float | `42.toFloat()` ‚Üí 42.0f |\n| `toString()` | Any type ‚Üí String | `42.toString()` ‚Üí \"42\" |\n| `toBoolean()` | String ‚Üí Boolean | `\"true\".toBoolean()` ‚Üí true |\n\n### Handling Conversion Errors\n\n\n---\n\n",
              "code": "// ‚ùå This will crash if input isn't a valid number\nval number = readln().toInt()  // User types \"abc\" ‚Üí NumberFormatException\n\n// ‚úÖ Safe conversion with default value\nval number = readln().toIntOrNull() ?: 0  // Returns 0 if conversion fails\n\n// ‚úÖ Safe conversion with error handling\nval input = readln()\nval number = input.toIntOrNull()\n\nif (number != null) {\n    println(\"Valid number: $number\")\n} else {\n    println(\"Invalid input!\")\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Operators",
              "content": "\nOperators perform operations on values.\n\n### Arithmetic Operators\n\n\n**Important**: Integer division truncates decimals:\n\n### Compound Assignment Operators\n\nShortcut operators that modify a variable:\n\n\n### Increment and Decrement Operators\n\n\n**Prefix vs Postfix**:\n\n### Comparison Operators\n\nReturn `true` or `false`:\n\n\n**String Comparison**:\n\n### Logical Operators\n\nCombine boolean values:\n\n\n**Truth Tables**:\n\n| A | B | A && B | A \\|\\| B | !A |\n|---|---|--------|----------|-----|\n| T | T | T      | T        | F   |\n| T | F | F      | T        | F   |\n| F | T | F      | T        | T   |\n| F | F | F      | F        | T   |\n\n**Short-Circuit Evaluation**:\n\n---\n\n",
              "code": "val a = true\nval b = false\n\n// && stops if first is false\nif (b && expensiveFunction()) {  // expensiveFunction() NOT called\n    // ...\n}\n\n// || stops if first is true\nif (a || expensiveFunction()) {  // expensiveFunction() NOT called\n    // ...\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "String Operations",
              "content": "\n### String Concatenation\n\n\n### String Properties and Methods\n\n\n### Multi-line Strings\n\n\n---\n\n",
              "code": "val poem = \"\"\"\n    Roses are red,\n    Violets are blue,\n    Kotlin is awesome,\n    And so are you!\n\"\"\".trimIndent()\n\nprintln(poem)",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 1: Temperature Converter",
              "content": "\n**Goal**: Create a program that converts temperature from Celsius to Fahrenheit and Kelvin.\n\n**Formula**:\n- Fahrenheit = (Celsius √ó 9/5) + 32\n- Kelvin = Celsius + 273.15\n\n**Requirements**:\n1. Ask user for temperature in Celsius\n2. Calculate Fahrenheit and Kelvin\n3. Display all three temperatures\n\n**Expected Output**:\n\n---\n\n",
              "code": "Enter temperature in Celsius:\n25\n25.0¬∞C = 77.0¬∞F = 298.15K",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Solution 1: Temperature Converter",
              "content": "\n\n**Key Points**:\n- We use `toDouble()` to allow decimal temperatures\n- Formula uses decimal division (9 / 5 works because we're in Double context)\n- String interpolation displays all values\n\n---\n\n",
              "code": "fun main() {\n    println(\"=== Temperature Converter ===\")\n    println(\"Enter temperature in Celsius:\")\n\n    val celsius = readln().toDouble()\n\n    val fahrenheit = (celsius * 9 / 5) + 32\n    val kelvin = celsius + 273.15\n\n    println(\"$celsius¬∞C = $fahrenheit¬∞F = ${kelvin}K\")\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 2: Rectangle Calculator",
              "content": "\n**Goal**: Calculate the area and perimeter of a rectangle.\n\n**Formulas**:\n- Area = width √ó height\n- Perimeter = 2 √ó (width + height)\n\n**Requirements**:\n1. Ask for width and height\n2. Calculate area and perimeter\n3. Display results with appropriate units\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 2: Rectangle Calculator",
              "content": "\n\n---\n\n",
              "code": "fun main() {\n    println(\"=== Rectangle Calculator ===\")\n\n    println(\"Enter width (meters):\")\n    val width = readln().toDouble()\n\n    println(\"Enter height (meters):\")\n    val height = readln().toDouble()\n\n    val area = width * height\n    val perimeter = 2 * (width + height)\n\n    println(\"\\nResults:\")\n    println(\"Area: $area square meters\")\n    println(\"Perimeter: $perimeter meters\")\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 3: Age Calculator",
              "content": "\n**Goal**: Calculate how many days, hours, and minutes old someone is.\n\n**Requirements**:\n1. Ask for age in years\n2. Calculate approximate days (years √ó 365)\n3. Calculate hours (days √ó 24)\n4. Calculate minutes (hours √ó 60)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 3: Age Calculator",
              "content": "\n\n**Sample Output**:\n\n---\n\n",
              "code": "=== Age Calculator ===\nEnter your age in years:\n25\n\nYou are approximately:\n9125 days old\n219000 hours old\n13140000 minutes old",
              "language": "kotlin"
            },
            {
              "type": "WARNING",
              "title": "Common Mistakes and How to Avoid Them",
              "content": "\n### Mistake 1: Integer Division Surprise\n\n\n### Mistake 2: Trying to Reassign val\n\n\n### Mistake 3: Type Mismatch\n\n\n### Mistake 4: NumberFormatException\n\n\n---\n\n",
              "code": "// ‚ùå Crashes if user types non-number\nval number = readln().toInt()  // User types \"hello\" ‚Üí crash!\n\n// ‚úÖ Safe conversion\nval number = readln().toIntOrNull() ?: 0  // Returns 0 if invalid",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Checkpoint Quiz",
              "content": "\n### Question 1\nWhat's the difference between `val` and `var`?\n\nA) `val` is for numbers, `var` is for text\nB) `val` cannot be reassigned, `var` can be reassigned\nC) `val` is faster than `var`\nD) There is no difference\n\n### Question 2\nWhat is the result of `10 / 3` in Kotlin?\n\nA) 3.333...\nB) 3.0\nC) 3\nD) Error\n\n### Question 3\nWhich data type should you use to store `3.14159`?\n\nA) Int\nB) Float\nC) Double\nD) Decimal\n\n### Question 4\nWhat does `\"Hello\".length` return?\n\nA) \"Hello\"\nB) 5\nC) true\nD) Error\n\n### Question 5\nWhat is the result of `10 % 3`?\n\nA) 3\nB) 1\nC) 0\nD) 3.333...\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Answers",
              "content": "\n**Question 1: B) `val` cannot be reassigned, `var` can be reassigned**\n\n\n`val` = immutable (read-only), `var` = mutable (changeable).\n\n---\n\n**Question 2: C) 3**\n\nInteger division in Kotlin truncates the decimal part:\n\n\n---\n\n**Question 3: C) Double**\n\n`Double` is the default type for decimal numbers:\n\n\n`Double` has higher precision (64 bits) than `Float` (32 bits).\n\n---\n\n**Question 4: B) 5**\n\n`.length` is a property that returns the number of characters:\n\n\n---\n\n**Question 5: B) 1**\n\nThe `%` operator (modulus) returns the remainder after division:\n\n\nUseful for checking if a number is even: `number % 2 == 0`\n\n---\n\n",
              "code": "10 % 3  // 1 (10 √∑ 3 = 3 remainder 1)\n15 % 4  // 3 (15 √∑ 4 = 3 remainder 3)\n20 % 5  // 0 (20 √∑ 5 = 4 remainder 0)",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "What You've Learned",
              "content": "\n‚úÖ Difference between `val` (immutable) and `var` (mutable)\n‚úÖ Basic data types: Int, Double, Boolean, Char, String\n‚úÖ Type inference and type safety\n‚úÖ Type conversions (`toInt()`, `toDouble()`, etc.)\n‚úÖ Arithmetic operators: +, -, *, /, %\n‚úÖ Comparison operators: ==, !=, <, >, <=, >=\n‚úÖ Logical operators: &&, ||, !\n‚úÖ String operations and string interpolation\n‚úÖ Common mistakes and how to avoid them\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Next Steps",
              "content": "\nIn **Lesson 1.3: Control Flow - Conditionals & Loops**, you'll learn:\n- `if`-`else` statements for decision making\n- `when` expressions (Kotlin's powerful switch)\n- `for` loops for repetition\n- `while` and `do-while` loops\n- Breaking and continuing loops\n\nGet ready to make your programs smart and responsive!\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Practice Challenges",
              "content": "\nTry these on your own:\n\n1. **BMI Calculator**: Ask for height (meters) and weight (kg), calculate BMI = weight / (height¬≤)\n\n2. **Time Converter**: Convert hours to minutes and seconds\n\n3. **Compound Interest**: Calculate final amount given principal, rate, and time\n\n4. **Grade Calculator**: Average three test scores and display the result\n\n---\n\n**Great job completing Lesson 1.2!** üéâ\n\nYou now understand how to store and manipulate data‚Äîthe foundation of all programming!\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "1.3",
          "title": "Lesson 1.3: Control Flow - Conditionals & Loops",
          "moduleId": "module-01",
          "order": 3,
          "estimatedMinutes": 60,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 60 minutes\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Topic Introduction",
              "content": "\nSo far, your programs execute line by line from top to bottom. But real programs need to make decisions (\"if it's raining, bring an umbrella\") and repeat tasks (\"keep adding numbers until we reach 100\").\n\nThis lesson teaches you **control flow**‚Äîhow to make your programs smart and efficient with conditionals and loops.\n\n---\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "The Concept",
              "content": "\n### The GPS Analogy\n\nThink of control flow like GPS navigation:\n\n**Conditionals** (if/else): \"IF there's traffic ahead, THEN take alternate route, ELSE continue on current road\"\n\n**Loops** (for/while): \"WHILE you haven't reached destination, keep giving directions\"\n\nYour programs use the same logic!\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "If-Else Statements",
              "content": "\n### Basic If Statement\n\n\n**Structure**:\n\n### If-Else Statement\n\n\n### If-Else-If Chain\n\n\n### If as an Expression\n\nIn Kotlin, `if` returns a value:\n\n\n---\n\n",
              "code": "val age = 20\nval status = if (age >= 18) \"Adult\" else \"Minor\"\nprintln(status)  // \"Adult\"\n\n// Multi-line\nval message = if (age >= 18) {\n    \"You can vote\"\n} else {\n    \"You cannot vote yet\"\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "When Expression",
              "content": "\nKotlin's `when` is like a powerful `switch` statement:\n\n### Basic When\n\n\n### When as Expression\n\n\n### When with Ranges\n\n\n### When with Multiple Conditions\n\n\n### When with Boolean Conditions\n\n\n---\n\n",
              "code": "val temperature = 25\n\nwhen {\n    temperature < 0 -> println(\"Freezing\")\n    temperature < 15 -> println(\"Cold\")\n    temperature < 25 -> println(\"Moderate\")\n    else -> println(\"Warm\")\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Loops",
              "content": "\n### For Loop with Ranges\n\n\n### While Loop\n\n\n### Do-While Loop\n\nRuns at least once:\n\n\n### Break and Continue\n\n\n---\n\n",
              "code": "// Break - exit loop early\nfor (i in 1..10) {\n    if (i == 5) break\n    println(i)  // 1, 2, 3, 4\n}\n\n// Continue - skip current iteration\nfor (i in 1..10) {\n    if (i % 2 == 0) continue  // Skip even numbers\n    println(i)  // 1, 3, 5, 7, 9\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 1: Number Guessing Game",
              "content": "\nCreate a simple number guessing game.\n\n**Expected Output**:\n\n---\n\n",
              "code": "Guess a number between 1 and 10:\n5\nToo low!\n7\nToo high!\n6\nCorrect!",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Solution 1",
              "content": "\n\n---\n\n",
              "code": "fun main() {\n    val secretNumber = (1..10).random()\n    var guess: Int\n\n    do {\n        println(\"Guess a number between 1 and 10:\")\n        guess = readln().toInt()\n\n        when {\n            guess < secretNumber -> println(\"Too low!\")\n            guess > secretNumber -> println(\"Too high!\")\n            else -> println(\"Correct!\")\n        }\n    } while (guess != secretNumber)\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Checkpoint Quiz",
              "content": "\n### Question 1\nWhat's the output of this code?\n\nA) A\nB) B\nC) Error\nD) Nothing\n\n### Question 2\nWhat's the difference between `while` and `do-while`?\n\nA) No difference\nB) `do-while` runs at least once\nC) `while` is faster\nD) `do-while` can't use break\n\n### Question 3\nWhat does `1..5` represent?\n\nA) Array with values 1 and 5\nB) Range from 1 to 5 (inclusive)\nC) Division: 1/5\nD) Error\n\n### Question 4\nWhat does `break` do in a loop?\n\nA) Skips current iteration\nB) Exits the loop entirely\nC) Pauses the loop\nD) Restarts the loop\n\n### Question 5\nIn a `when` expression, what is `else`?\n\nA) Optional branch\nB) Required catch-all branch\nC) Error condition\nD) Loop terminator\n\n---\n\n",
              "code": "val x = 5\nif (x > 10) println(\"A\") else println(\"B\")",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Quiz Answers",
              "content": "\n**Question 1: B**\n`x` is 5, which is not greater than 10, so the else branch executes printing \"B\".\n\n**Question 2: B**\n`do-while` executes the body first, then checks the condition, guaranteeing at least one execution.\n\n**Question 3: B**\n`1..5` creates a range including both 1 and 5: [1, 2, 3, 4, 5]\n\n**Question 4: B**\n`break` immediately exits the current loop.\n\n**Question 5: B**\nWhen used as an expression, `else` is required to ensure all cases are covered.\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "What You've Learned",
              "content": "\n‚úÖ If-else statements for decision making\n‚úÖ When expressions for multiple conditions\n‚úÖ For loops with ranges\n‚úÖ While and do-while loops\n‚úÖ Break and continue statements\n‚úÖ Using conditionals as expressions\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Next Steps",
              "content": "\nIn **Lesson 1.4: Functions**, you'll learn to organize code into reusable blocks!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "1.3.1",
              "title": "Hello World",
              "description": "Write a program that prints 'Hello, World!' to the screen.",
              "instructions": "Write a program that prints 'Hello, World!' to the screen.",
              "starterCode": "fun main() {\n    // Write your code here\n    \n}",
              "solution": "fun main() {\n    println(\"Hello, World!\")\n}",
              "language": "kotlin",
              "testCases": [
                {
                  "description": "Prints 'Hello, World!'",
                  "expectedOutput": "Hello, World!",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the println() function"
                },
                {
                  "level": 2,
                  "text": "Put text in quotes: \"Hello, World!\""
                },
                {
                  "level": 3,
                  "text": "Don't forget the parentheses!"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "1.4",
          "title": "Lesson 1.4: Functions & Basic Syntax",
          "moduleId": "module-01",
          "order": 4,
          "estimatedMinutes": 60,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 60 minutes\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Topic Introduction",
              "content": "\nImagine you're writing a recipe book. Instead of writing \"crack 3 eggs, beat them, add milk, stir\" every single time you need beaten eggs, you create a recipe called \"Make Beaten Eggs\" and just reference it whenever needed.\n\n**Functions** are exactly this in programming‚Äîreusable blocks of code that perform specific tasks. Instead of repeating the same code over and over, you write it once in a function and call it whenever you need it.\n\nIn this lesson, you'll learn how to create functions, pass data to them, get results back, and make your code more organized and maintainable.\n\n---\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "The Concept",
              "content": "\n### The Kitchen Helper Analogy\n\nThink of functions as kitchen helpers with specific jobs:\n\n**Chef's Kitchen (Your Program)**:\n- **Dishwasher Helper**: You give them dirty dishes ‚Üí They return clean dishes\n- **Prep Helper**: You give them vegetables ‚Üí They return chopped vegetables\n- **Baking Helper**: You give them ingredients ‚Üí They return a finished cake\n\n**Programming Functions**:\n\n**Key Concepts**:\n- **Input** (parameters): What you give the function\n- **Processing**: What the function does\n- **Output** (return value): What the function gives back\n\n---\n\n",
              "code": "fun washDishes(dirtyDishes: List<String>): List<String> {\n    // Washing logic here\n    return cleanDishes\n}\n\nfun chopVegetables(vegetables: List<String>): List<String> {\n    // Chopping logic here\n    return choppedVegetables\n}\n\nfun bakeCake(ingredients: List<String>): Cake {\n    // Baking logic here\n    return finishedCake\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Function Basics",
              "content": "\n### Function Declaration\n\n\n**Output**:\n\n**Anatomy of a Function**:\n\n- `fun` = keyword to declare a function\n- `functionName` = what you call the function\n- `()` = parameters go here (empty if none)\n- `{}` = function body (code to execute)\n\n---\n\n",
              "code": "fun functionName() {\n    // Function body\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Parameters: Passing Data to Functions",
              "content": "\n### Single Parameter\n\n\n**Parameter Structure**:\n\n### Multiple Parameters\n\n\n### Parameters with Different Types\n\n\n**Output**:\n\n---\n\n",
              "code": "Subtotal: $59.97\nTax: $4.7976\nTotal: $64.7676",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Return Values: Getting Data Back",
              "content": "\n### Basic Return\n\n\n**Return Type Syntax**:\n\n### Multiple Return Statements\n\n\n### Unit Return Type (No Return Value)\n\n\n`Unit` is like `void` in other languages‚Äîthe function doesn't return a value.\n\n---\n\n",
              "code": "// These are equivalent:\nfun sayHello(): Unit {\n    println(\"Hello!\")\n}\n\nfun sayGoodbye() {  // Unit is implicit if omitted\n    println(\"Goodbye!\")\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Single-Expression Functions",
              "content": "\nWhen a function returns a single expression, you can use shorthand:\n\n### Long Form vs Short Form\n\n\n### More Examples\n\n\n---\n\n",
              "code": "fun square(x: Int) = x * x\n\nfun isEven(n: Int) = n % 2 == 0\n\nfun max(a: Int, b: Int) = if (a > b) a else b\n\nfun getDiscount(isPremium: Boolean) = if (isPremium) 0.20 else 0.10\n\nfun main() {\n    println(square(5))        // 25\n    println(isEven(7))        // false\n    println(max(10, 20))      // 20\n    println(getDiscount(true)) // 0.2\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Default Parameters",
              "content": "\nProvide default values for parameters:\n\n\n### Multiple Default Parameters\n\n\n---\n\n",
              "code": "fun createUser(\n    name: String,\n    age: Int = 18,\n    country: String = \"USA\",\n    isPremium: Boolean = false\n) {\n    println(\"User: $name, Age: $age, Country: $country, Premium: $isPremium\")\n}\n\nfun main() {\n    createUser(\"Alice\")\n    // User: Alice, Age: 18, Country: USA, Premium: false\n\n    createUser(\"Bob\", 25)\n    // User: Bob, Age: 25, Country: USA, Premium: false\n\n    createUser(\"Carol\", 30, \"Canada\", true)\n    // User: Carol, Age: 30, Country: Canada, Premium: true\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Named Arguments",
              "content": "\nCall functions with parameter names for clarity:\n\n\n**Benefits of Named Arguments**:\n- Code is more readable\n- Order doesn't matter\n- Especially useful with many parameters or default values\n\n\n---\n\n",
              "code": "fun formatText(\n    text: String,\n    uppercase: Boolean = false,\n    trim: Boolean = true,\n    reverse: Boolean = false\n) {\n    var result = text\n    if (trim) result = result.trim()\n    if (uppercase) result = result.uppercase()\n    if (reverse) result = result.reversed()\n    println(result)\n}\n\nfun main() {\n    formatText(\"  hello  \", uppercase = true, reverse = true)\n    // Output: OLLEH\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Extension Functions",
              "content": "\nAdd new functions to existing types without modifying their source code:\n\n### Basic Extension Function\n\n\nIn extension functions, `this` refers to the object the function is called on.\n\n### More Extension Examples\n\n\n### Why Extension Functions?\n\nThey make code more readable:\n\n\n---\n\n",
              "code": "// Without extension\nval doubled = multiplyBy2(number)\nval formatted = formatAsCurrency(price)\n\n// With extension\nval doubled = number.double()\nval formatted = price.asCurrency()",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Variable Number of Arguments (Vararg)",
              "content": "\nAccept any number of arguments:\n\n\n### Practical Vararg Example\n\n\n---\n\n",
              "code": "fun printAll(vararg messages: String) {\n    for (message in messages) {\n        println(\"- $message\")\n    }\n}\n\nfun main() {\n    printAll(\"Apple\", \"Banana\", \"Cherry\")\n    // Output:\n    // - Apple\n    // - Banana\n    // - Cherry\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Function Scope and Variables",
              "content": "\n### Local Variables\n\nVariables inside functions are **local**‚Äîthey only exist within that function:\n\n\n### Function Parameters are Read-Only\n\n\n---\n\n",
              "code": "fun modifyValue(number: Int) {\n    // number = number + 1  // ‚ùå Error: Val cannot be reassigned\n    val newNumber = number + 1  // ‚úÖ Create new variable\n    println(newNumber)\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 1: Temperature Converter Functions",
              "content": "\n**Goal**: Create a temperature converter with reusable functions.\n\n**Requirements**:\n1. Create `celsiusToFahrenheit(celsius: Double): Double` function\n2. Create `celsiusToKelvin(celsius: Double): Double` function\n3. Create `fahrenheitToCelsius(fahrenheit: Double): Double` function\n4. In `main()`, ask user for temperature in Celsius and display all conversions\n\n**Formulas**:\n- F = (C √ó 9/5) + 32\n- K = C + 273.15\n- C = (F - 32) √ó 5/9\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 1: Temperature Converter Functions",
              "content": "\n\n**Sample Output**:\n\n---\n\n",
              "code": "=== Temperature Converter ===\nEnter temperature in Celsius:\n25\n\nResults:\n25.0¬∞C = 77.0¬∞F = 298.15K",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 2: BMI Calculator with Functions",
              "content": "\n**Goal**: Create a BMI calculator using functions.\n\n**Requirements**:\n1. Create `calculateBMI(weight: Double, height: Double): Double` function\n2. Create `getBMICategory(bmi: Double): String` function that returns:\n   - \"Underweight\" if BMI < 18.5\n   - \"Normal weight\" if BMI 18.5-24.9\n   - \"Overweight\" if BMI 25-29.9\n   - \"Obese\" if BMI ‚â• 30\n3. Create `displayBMIReport(name: String, bmi: Double, category: String)` function\n4. In `main()`, get user input and display formatted report\n\n**Formula**: BMI = weight (kg) / height¬≤ (m)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 2: BMI Calculator with Functions",
              "content": "\n\n**Sample Output**:\n\n---\n\n",
              "code": "=== BMI Calculator ===\nEnter your name:\nAlice\nEnter your weight (kg):\n65\nEnter your height (meters):\n1.70\n\n=== BMI Report for Alice ===\nBMI: 22.49\nCategory: Normal weight\n==============================",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 3: Simple Banking Functions",
              "content": "\n**Goal**: Create basic banking operations using functions.\n\n**Requirements**:\n1. Create `deposit(balance: Double, amount: Double): Double` function\n2. Create `withdraw(balance: Double, amount: Double): Double` function\n   - Only allow withdrawal if balance is sufficient\n   - Return updated balance\n3. Create `displayBalance(balance: Double)` function\n4. In `main()`, create a simple menu system to deposit, withdraw, or check balance\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 3: Simple Banking Functions",
              "content": "\n\n**Sample Output**:\n\n---\n\n",
              "code": "=== Simple Banking System ===\nCurrent Balance: $1000.00\n\nDepositing $500...\nDeposited: $500.0\nCurrent Balance: $1500.00\n\nWithdrawing $200...\nWithdrawn: $200.0\nCurrent Balance: $1300.00\n\nAttempting to withdraw $2000...\nInsufficient funds! Current balance: $1300.0\nCurrent Balance: $1300.00",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Best Practices for Functions",
              "content": "\n### 1. Single Responsibility Principle\n\nEach function should do ONE thing well:\n\n\n### 2. Descriptive Function Names\n\n\n### 3. Keep Functions Short\n\nAim for functions that fit on one screen (~20-30 lines max).\n\n### 4. Avoid Side Effects When Possible\n\n\n---\n\n",
              "code": "// ‚ùå Bad - modifies external state\nvar total = 0\nfun addToTotal(amount: Int) {\n    total += amount\n}\n\n// ‚úÖ Good - returns new value\nfun add(current: Int, amount: Int): Int {\n    return current + amount\n}",
              "language": "kotlin"
            },
            {
              "type": "WARNING",
              "title": "Common Mistakes",
              "content": "\n### Mistake 1: Forgetting Return Type\n\n\n### Mistake 2: Not Returning a Value\n\n\n### Mistake 3: Wrong Argument Order\n\n\n---\n\n",
              "code": "fun createProfile(name: String, age: Int, city: String) { /* ... */ }\n\n// ‚ùå Error - wrong order\ncreateProfile(25, \"Alice\", \"NYC\")  // Type mismatch!\n\n// ‚úÖ Correct\ncreateProfile(\"Alice\", 25, \"NYC\")\n\n// ‚úÖ Better - use named arguments\ncreateProfile(name = \"Alice\", age = 25, city = \"NYC\")",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Checkpoint Quiz",
              "content": "\n### Question 1\nWhat keyword is used to declare a function in Kotlin?\n\nA) function\nB) def\nC) fun\nD) func\n\n### Question 2\nWhat is the return type of a function that doesn't return a value?\n\nA) void\nB) null\nC) Unit\nD) Nothing\n\n### Question 3\nWhich is a valid single-expression function?\n\nA) `fun double(x: Int) { x * 2 }`\nB) `fun double(x: Int) = x * 2`\nC) `fun double(x: Int) => x * 2`\nD) `fun double(x: Int): x * 2`\n\n### Question 4\nWhat are named arguments used for?\n\nA) Making code faster\nB) Reducing memory usage\nC) Improving code readability and allowing any parameter order\nD) Required for all functions\n\n### Question 5\nIn an extension function, what does `this` refer to?\n\nA) The function itself\nB) The class containing the function\nC) The receiver object (the object the function is called on)\nD) The return value\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Answers",
              "content": "\n**Question 1: C) fun**\n\nKotlin uses `fun` keyword to declare functions:\n\n\n---\n\n**Question 2: C) Unit**\n\n`Unit` is Kotlin's type for \"no meaningful return value\":\n\n\n---\n\n**Question 3: B) `fun double(x: Int) = x * 2`**\n\nSingle-expression functions use `=` instead of curly braces:\n\n\n---\n\n**Question 4: C) Improving code readability and allowing any parameter order**\n\nNamed arguments make function calls clearer:\n\n\n---\n\n**Question 5: C) The receiver object (the object the function is called on)**\n\nIn extension functions, `this` is the object being extended:\n\n\n---\n\n",
              "code": "fun String.shout(): String {\n    return this.uppercase() + \"!!!\"\n    //     ^^^^\n    //     The String object\n}\n\n\"hello\".shout()  // this = \"hello\"",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "What You've Learned",
              "content": "\n‚úÖ How to declare and call functions\n‚úÖ Function parameters and return types\n‚úÖ Single-expression functions for concise code\n‚úÖ Default parameters and named arguments\n‚úÖ Extension functions to add functionality to existing types\n‚úÖ Vararg for variable number of arguments\n‚úÖ Function scope and local variables\n‚úÖ Best practices for writing clean, maintainable functions\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Next Steps",
              "content": "\nIn **Lesson 1.5: Collections & Arrays**, you'll learn:\n- Lists, sets, and maps for storing multiple values\n- Array basics\n- Common collection operations like filter, map, and forEach\n- When to use each collection type\n\nGet ready to work with groups of data efficiently!\n\n---\n\n**Congratulations on completing Lesson 1.4!**\n\nYou now know how to organize code into reusable, maintainable functions‚Äîa crucial skill for any programmer!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "1.4.1",
              "title": "Create and Print Variable",
              "description": "Create a variable named 'age' with value 25, then print it.",
              "instructions": "Create a variable named 'age' with value 25, then print it.",
              "starterCode": "fun main() {\n    // Create a variable called age with value 25\n    \n    // Print the age\n    \n}",
              "solution": "fun main() {\n    val age = 25\n    println(age)\n}",
              "language": "kotlin",
              "testCases": [
                {
                  "description": "Prints the number 25",
                  "expectedOutput": "25",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use 'val' to create a variable"
                },
                {
                  "level": 2,
                  "text": "Syntax: val name = value"
                },
                {
                  "level": 3,
                  "text": "Use println() to print the variable"
                }
              ],
              "difficulty": "beginner"
            },
            {
              "type": "FREE_CODING",
              "id": "1.4.2",
              "title": "String Template",
              "description": "Create a variable 'name' with your name, then print 'Hello, [name]!' using string templates.",
              "instructions": "Create a variable 'name' with your name, then print 'Hello, [name]!' using string templates.",
              "starterCode": "fun main() {\n    val name = \"YourName\"\n    // Print Hello, [name]! using $name\n    \n}",
              "solution": "fun main() {\n    val name = \"Alice\"\n    println(\"Hello, $name!\")\n}",
              "language": "kotlin",
              "testCases": [
                {
                  "description": "Prints greeting with name",
                  "expectedOutput": "Hello, Alice!",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use $name inside the string"
                },
                {
                  "level": 2,
                  "text": "String templates: \"text $variable text\""
                },
                {
                  "level": 3,
                  "text": "Remember quotes around the whole string"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "1.5",
          "title": "Lesson 1.5: Collections & Arrays",
          "moduleId": "module-01",
          "order": 5,
          "estimatedMinutes": 65,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 65 minutes\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Topic Introduction",
              "content": "\nSo far, you've worked with individual values‚Äîone number, one string, one boolean. But real programs often need to work with **groups** of data: a list of students, a shopping cart of items, a phonebook of contacts.\n\nThis lesson teaches you how to store and manipulate collections of data using **Lists**, **Sets**, **Maps**, and **Arrays**‚Äîessential tools for any Kotlin programmer.\n\n---\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "The Concept",
              "content": "\n### The Container Analogy\n\nThink of collections as different types of containers:\n\n**List** = Playlist\n- Ordered sequence of songs\n- Can have duplicates (same song twice)\n- You can access by position: \"Play song #3\"\n\n**Set** = Unique Badge Collection\n- No duplicates allowed\n- Unordered (or natural order)\n- Great for checking membership: \"Do I have the gold badge?\"\n\n**Map** = Dictionary\n- Key-value pairs\n- Look up definitions by word\n- Each key is unique: \"What does 'hello' mean in Spanish?\"\n\n**Array** = Fixed-size parking lot\n- Fixed number of spaces\n- Direct access by position\n- Size cannot change after creation\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Lists",
              "content": "\nLists are ordered collections that can contain duplicates.\n\n### Read-Only Lists (listOf)\n\n\n### Accessing List Elements\n\n\n### Mutable Lists (mutableListOf)\n\n\n### List Operations\n\n\n---\n\n",
              "code": "val numbers = listOf(1, 2, 3, 4, 5)\n\n// Check if contains\nprintln(numbers.contains(3))     // true\nprintln(3 in numbers)            // true (same thing)\nprintln(10 in numbers)           // false\n\n// Get index\nprintln(numbers.indexOf(3))      // 2\nprintln(numbers.indexOf(10))     // -1 (not found)\n\n// Sublist\nprintln(numbers.subList(1, 4))   // [2, 3, 4]\n\n// Reverse\nprintln(numbers.reversed())      // [5, 4, 3, 2, 1]\n\n// Sort (returns new list)\nval unsorted = listOf(5, 2, 8, 1, 9)\nprintln(unsorted.sorted())       // [1, 2, 5, 8, 9]\nprintln(unsorted.sortedDescending())  // [9, 8, 5, 2, 1]",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Sets",
              "content": "\nSets are collections of **unique** elements (no duplicates).\n\n### Read-Only Sets (setOf)\n\n\n### Mutable Sets (mutableSetOf)\n\n\n### Set Operations\n\n\n### When to Use Sets\n\nUse sets when:\n- You need unique elements\n- Order doesn't matter\n- You need fast membership checking\n\n\n---\n\n",
              "code": "// Example: Track unique visitors\nval visitors = mutableSetOf<String>()\n\nvisitors.add(\"Alice\")\nvisitors.add(\"Bob\")\nvisitors.add(\"Alice\")  // Duplicate, ignored\nvisitors.add(\"Carol\")\n\nprintln(\"Unique visitors: ${visitors.size}\")  // 3",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Maps",
              "content": "\nMaps store **key-value pairs** (like a dictionary).\n\n### Read-Only Maps (mapOf)\n\n\n### Mutable Maps (mutableMapOf)\n\n\n### Iterating Over Maps\n\n\n**Output**:\n\n### Map Operations\n\n\n---\n\n",
              "code": "val grades = mapOf(\"Math\" to 95, \"English\" to 88, \"Science\" to 92)\n\nprintln(grades.size)           // 3\nprintln(grades.isEmpty())      // false\nprintln(grades.containsKey(\"Math\"))    // true\nprintln(grades.containsValue(95))      // true\n\n// Get all keys and values\nprintln(grades.keys)    // [Math, English, Science]\nprintln(grades.values)  // [95, 88, 92]",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Arrays",
              "content": "\nArrays are **fixed-size** collections with indexed access.\n\n### Creating Arrays\n\n\n### Accessing Array Elements\n\n\n### Array vs List\n\n\n**When to use Arrays vs Lists**:\n- **Arrays**: Performance-critical code, fixed size, interop with Java\n- **Lists**: Most Kotlin code (more flexible, better API)\n\n---\n\n",
              "code": "// Array (fixed size, mutable elements)\nval array = arrayOf(1, 2, 3)\narray[0] = 10  // ‚úÖ OK\n// array.add(4)  // ‚ùå Error: Can't change size\n\n// List (immutable)\nval list = listOf(1, 2, 3)\n// list[0] = 10  // ‚ùå Error: Can't modify\n// list.add(4)   // ‚ùå Error: Can't add\n\n// Mutable list (flexible)\nval mutableList = mutableListOf(1, 2, 3)\nmutableList[0] = 10  // ‚úÖ OK\nmutableList.add(4)   // ‚úÖ OK",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Common Collection Operations",
              "content": "\n### forEach - Execute action for each element\n\n\n### filter - Select elements matching a condition\n\n\n### map - Transform each element\n\n\n### Combining Operations\n\n\n### More Useful Operations\n\n\n---\n\n",
              "code": "val numbers = listOf(1, 2, 3, 4, 5)\n\n// sum\nprintln(numbers.sum())  // 15\n\n// average\nprintln(numbers.average())  // 3.0\n\n// max and min\nprintln(numbers.max())  // 5\nprintln(numbers.min())  // 1\n\n// count\nprintln(numbers.count { it > 3 })  // 2 (elements: 4, 5)\n\n// any - check if any element matches\nprintln(numbers.any { it > 4 })  // true\n\n// all - check if all elements match\nprintln(numbers.all { it > 0 })  // true\n\n// none - check if no elements match\nprintln(numbers.none { it < 0 })  // true\n\n// find - get first matching element\nprintln(numbers.find { it > 3 })  // 4\n\n// take - get first n elements\nprintln(numbers.take(3))  // [1, 2, 3]\n\n// drop - skip first n elements\nprintln(numbers.drop(2))  // [3, 4, 5]",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 1: Student Grade Manager",
              "content": "\n**Goal**: Create a program to manage student grades using a map.\n\n**Requirements**:\n1. Create a mutable map to store student names and grades\n2. Add at least 5 students with their grades\n3. Display all students and grades\n4. Calculate and display the average grade\n5. Display students who scored above 80\n6. Display the highest and lowest grades\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 1: Student Grade Manager",
              "content": "\n\n**Sample Output**:\n\n---\n\n",
              "code": "=== Student Grade Manager ===\n\nAll Students:\n  Alice: 92\n  Bob: 78\n  Carol: 95\n  Dave: 88\n  Eve: 73\n\nAverage Grade: 85.20\n\nStudents with grade > 80:\n  Alice: 92\n  Carol: 95\n  Dave: 88\n\nHighest Grade: Carol with 95\nLowest Grade: Eve with 73",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 2: Shopping Cart with Unique Items",
              "content": "\n**Goal**: Create a shopping cart that tracks items and quantities.\n\n**Requirements**:\n1. Use a mutable map where keys are item names and values are quantities\n2. Create `addItem(cart, item, quantity)` function\n3. Create `removeItem(cart, item)` function\n4. Create `updateQuantity(cart, item, newQuantity)` function\n5. Create `displayCart(cart)` function that shows all items\n6. Calculate total number of items in cart\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 2: Shopping Cart with Unique Items",
              "content": "\n\n**Sample Output**:\n\n---\n\n",
              "code": "Added 5 x Apple\nAdded 3 x Banana\nAdded 4 x Orange\n\n=== Shopping Cart ===\n  Apple: 5\n  Banana: 3\n  Orange: 4\nTotal items: 12\n\nAdded 2 x Apple\n\n=== Shopping Cart ===\n  Apple: 7\n  Banana: 3\n  Orange: 4\nTotal items: 14\n\nUpdated Banana quantity to 6\n\n=== Shopping Cart ===\n  Apple: 7\n  Banana: 6\n  Orange: 4\nTotal items: 17\n\nRemoved Orange from cart\n\n=== Shopping Cart ===\n  Apple: 7\n  Banana: 6\nTotal items: 13",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 3: Word Frequency Counter",
              "content": "\n**Goal**: Count how many times each word appears in a sentence.\n\n**Requirements**:\n1. Take a sentence as input\n2. Split it into words\n3. Count frequency of each word (case-insensitive)\n4. Display words and their counts\n5. Show the most common word\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 3: Word Frequency Counter",
              "content": "\n\n**Sample Run**:\n\n---\n\n",
              "code": "Enter a sentence:\nThe quick brown fox jumps over the lazy dog. The fox is quick!\n\n=== Word Frequency ===\nthe: 3\nquick: 2\nfox: 2\nbrown: 1\njumps: 1\nover: 1\nlazy: 1\ndog: 1\nis: 1\n\nMost common word: 'the' (appears 3 times)\n\nTotal unique words: 9\nTotal words: 12",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Collection Type Selection Guide",
              "content": "\n| Collection | When to Use | Example Use Case |\n|------------|-------------|------------------|\n| **List** | Ordered elements, duplicates OK | Shopping cart items, playlist |\n| **MutableList** | Need to add/remove elements | To-do list, dynamic data |\n| **Set** | Unique elements only | User IDs, tags, categories |\n| **MutableSet** | Unique elements, add/remove | Active users, visited URLs |\n| **Map** | Key-value lookups | Phone book, inventory, settings |\n| **MutableMap** | Need to update key-values | Cache, session data |\n| **Array** | Fixed size, performance-critical | Low-level operations, Java interop |\n\n---\n\n"
            },
            {
              "type": "WARNING",
              "title": "Common Mistakes",
              "content": "\n### Mistake 1: Modifying Read-Only Collections\n\n\n### Mistake 2: Index Out of Bounds\n\n\n### Mistake 3: Forgetting Map Values are Nullable\n\n\n---\n\n",
              "code": "val phoneBook = mapOf(\"Alice\" to \"555-1234\")\n\n// ‚ùå Potential null\nval number = phoneBook[\"Bob\"]  // Returns String?, not String!\n\n// ‚úÖ Handle null\nval number = phoneBook[\"Bob\"] ?: \"Unknown\"\nval number2 = phoneBook.getOrDefault(\"Bob\", \"Unknown\")",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Checkpoint Quiz",
              "content": "\n### Question 1\nWhat's the difference between `listOf` and `mutableListOf`?\n\nA) No difference\nB) `listOf` is read-only, `mutableListOf` allows adding/removing elements\nC) `listOf` is faster\nD) `mutableListOf` can't contain duplicates\n\n### Question 2\nWhich collection type should you use for unique elements?\n\nA) List\nB) Array\nC) Set\nD) Map\n\n### Question 3\nHow do you access a value in a map?\n\nA) `map.get(key)`\nB) `map[key]`\nC) Both A and B\nD) `map.value(key)`\n\n### Question 4\nWhat does the `filter` function return?\n\nA) A single element\nB) A boolean\nC) A new collection with elements matching the condition\nD) The original collection modified\n\n### Question 5\nWhat is the result of `listOf(1, 2, 2, 3).toSet()`?\n\nA) `[1, 2, 2, 3]`\nB) `[1, 2, 3]`\nC) Error\nD) `[1, 3]`\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Answers",
              "content": "\n**Question 1: B) `listOf` is read-only, `mutableListOf` allows adding/removing elements**\n\n\n---\n\n**Question 2: C) Set**\n\nSets automatically remove duplicates:\n\n\n---\n\n**Question 3: C) Both A and B**\n\nBoth syntaxes work:\n\n\n---\n\n**Question 4: C) A new collection with elements matching the condition**\n\n`filter` returns a new collection; it doesn't modify the original:\n\n\n---\n\n**Question 5: B) `[1, 2, 3]`**\n\nConverting a list to a set removes duplicates:\n\n\n---\n\n",
              "code": "val list = listOf(1, 2, 2, 3)\nval set = list.toSet()\nprintln(set)  // [1, 2, 3]",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "What You've Learned",
              "content": "\n‚úÖ Lists for ordered collections with duplicates\n‚úÖ Sets for unique elements\n‚úÖ Maps for key-value pairs\n‚úÖ Arrays for fixed-size collections\n‚úÖ Difference between read-only and mutable collections\n‚úÖ Common operations: forEach, filter, map\n‚úÖ When to use each collection type\n‚úÖ How to iterate and manipulate collections\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Next Steps",
              "content": "\nIn **Lesson 1.6: Null Safety & Safe Calls**, you'll learn:\n- Kotlin's null safety system\n- Safe call operator (`?.`)\n- Elvis operator (`?:`)\n- Not-null assertion (`!!`)\n- How to write crash-free code\n\nGet ready to learn one of Kotlin's most powerful features!\n\n---\n\n**Congratulations on completing Lesson 1.5!**\n\nYou now know how to work with collections‚Äîessential for managing groups of data in real applications!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "1.5.1",
              "title": "Calculate Sum",
              "description": "Create two Int variables (a=10, b=20) and print their sum.",
              "instructions": "Create two Int variables (a=10, b=20) and print their sum.",
              "starterCode": "fun main() {\n    val a = 10\n    val b = 20\n    // Calculate and print the sum\n    \n}",
              "solution": "fun main() {\n    val a = 10\n    val b = 20\n    val sum = a + b\n    println(sum)\n}",
              "language": "kotlin",
              "testCases": [
                {
                  "description": "Prints 30",
                  "expectedOutput": "30",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use + to add numbers"
                },
                {
                  "level": 2,
                  "text": "Store result in a variable"
                },
                {
                  "level": 3,
                  "text": "Print the result"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "1.6",
          "title": "Lesson 1.6: Null Safety & Safe Calls",
          "moduleId": "module-01",
          "order": 6,
          "estimatedMinutes": 55,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 55 minutes\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Topic Introduction",
              "content": "\nOne of the most common bugs in programming is the dreaded **NullPointerException** (NPE)‚Äîtrying to use something that doesn't exist. It's been called the \"billion-dollar mistake\" by its inventor, Tony Hoare.\n\nKotlin solves this problem with its **null safety** system. The compiler prevents most null-related crashes at compile-time, not runtime. This lesson teaches you how to safely work with values that might not exist.\n\n---\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "The Concept",
              "content": "\n### The Box Analogy\n\nThink of variables as boxes that can hold values:\n\n**Regular Box (Non-Nullable)**:\n- Must always contain something\n- Opening it always gives you a value\n- Safe to use anytime\n\n\n**Special Box (Nullable)**:\n- Might contain something, might be empty\n- Must check before using\n- Prevents surprises\n\n\n---\n\n",
              "code": "val name: String? = null  // Box might be empty\n// println(name.length)  // ‚ùå Compiler error: might be null!\nprintln(name?.length)  // ‚úÖ Safe: checks first",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Understanding Null",
              "content": "\n### What is null?\n\n`null` represents **absence of a value**‚Äînothing, empty, doesn't exist.\n\n**Real-World Examples**:\n- Phone number field when user hasn't provided one\n- Middle name when person doesn't have one\n- Search result when nothing matches\n- User session when not logged in\n\n### The Problem with Null (in other languages)\n\n\n**In Kotlin**: This doesn't compile! The compiler catches it.\n\n---\n\n",
              "code": "// Java example - this crashes at runtime!\nString name = null;\nint length = name.length();  // NullPointerException!",
              "language": "java"
            },
            {
              "type": "THEORY",
              "title": "Nullable vs Non-Nullable Types",
              "content": "\n### Non-Nullable Types (Default)\n\n\n**By default, all types in Kotlin are non-nullable.**\n\n### Nullable Types (Type?)\n\nAdd `?` to make a type nullable:\n\n\n**Examples**:\n\n---\n\n",
              "code": "val age: Int = 25       // Cannot be null\nval age: Int? = null    // Can be null\n\nval price: Double = 19.99  // Cannot be null\nval price: Double? = null  // Can be null\n\nval isActive: Boolean = true  // Cannot be null\nval isActive: Boolean? = null // Can be null",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Safe Call Operator (?.)",
              "content": "\nThe safe call operator `?.` safely accesses properties/methods on nullable objects.\n\n### Basic Usage\n\n\n### How it Works\n\n\n**If the object is null, the entire expression returns null.**\n\n### Chaining Safe Calls\n\n\n### Safe Calls with Methods\n\n\n---\n\n",
              "code": "val text: String? = \"  Hello  \"\n\nprintln(text?.trim())       // \"Hello\"\nprintln(text?.uppercase())  // \"HELLO\"\n\nval nullText: String? = null\nprintln(nullText?.trim())   // null",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Elvis Operator (?:)",
              "content": "\nThe Elvis operator `?:` provides a default value when something is null.\n\n### Basic Usage\n\n\n**How it works**:\n\n### Real-World Examples\n\n\n### Combining Safe Call and Elvis\n\n\n### Elvis with Expressions\n\n\n---\n\n",
              "code": "fun getDiscount(customerType: String?): Double {\n    return when (customerType ?: \"regular\") {\n        \"premium\" -> 0.20\n        \"gold\" -> 0.15\n        else -> 0.05\n    }\n}\n\nfun main() {\n    println(getDiscount(\"premium\"))  // 0.2\n    println(getDiscount(null))       // 0.05 (uses default \"regular\")\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Not-Null Assertion (!!)",
              "content": "\nThe `!!` operator tells the compiler \"I'm sure this isn't null!\"\n\n### When to Use (Rarely!)\n\n\n### Danger: It Can Crash!\n\n\n**When to use `!!`**:\n- You're absolutely certain the value isn't null\n- In test code\n- Rarely in production code\n\n**Better alternatives**:\n\n---\n\n",
              "code": "// ‚ùå Risky\nval length = name!!.length\n\n// ‚úÖ Better: Safe call with default\nval length = name?.length ?: 0\n\n// ‚úÖ Better: Explicit null check\nif (name != null) {\n    val length = name.length\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Safe Casts (as?)",
              "content": "\nCast to a type safely, returning null if the cast fails.\n\n### Regular Cast (as)\n\n\n### Safe Cast (as?)\n\n\n### Practical Example\n\n\n---\n\n",
              "code": "fun printLength(obj: Any) {\n    val str = obj as? String\n    println(\"Length: ${str?.length ?: \"Not a string\"}\")\n}\n\nfun main() {\n    printLength(\"Hello\")     // Length: 5\n    printLength(42)          // Length: Not a string\n    printLength(listOf(1, 2)) // Length: Not a string\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "The let Function",
              "content": "\n`let` executes a block of code only if the value is not null.\n\n### Basic Usage\n\n\n### When Value is Null\n\n\n### Practical Example\n\n\n### let with Return Value\n\n\n---\n\n",
              "code": "val name: String? = \"Alice\"\n\nval uppercaseName = name?.let {\n    it.uppercase()\n} ?: \"UNKNOWN\"\n\nprintln(uppercaseName)  // ALICE",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Null Safety Patterns",
              "content": "\n### Pattern 1: Safe Call with Default\n\n\n### Pattern 2: Explicit Null Check\n\n\n### Pattern 3: Early Return\n\n\n### Pattern 4: let for Complex Logic\n\n\n---\n\n",
              "code": "fun processOrder(orderId: String?) {\n    orderId?.let { id ->\n        println(\"Processing order: $id\")\n        // Multiple operations on id\n        val order = findOrder(id)\n        sendConfirmation(id)\n        updateInventory(id)\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 1: Safe User Profile Display",
              "content": "\n**Goal**: Create a user profile system that handles missing data safely.\n\n**Requirements**:\n1. Create a `User` data class with nullable fields: name, email, phone, address\n2. Create `displayProfile(user: User?)` function that:\n   - Shows all available information\n   - Shows \"Not provided\" for missing fields\n   - Shows \"No user data\" if user is null\n3. Test with different combinations of null/non-null values\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 1: Safe User Profile Display",
              "content": "\n\n**Sample Output**:\n\n---\n\n",
              "code": "=== User Profile ===\nName: Alice Johnson\nEmail: alice@example.com\nPhone: 555-1234\nAddress: 123 Main St\n\n=== User Profile ===\nName: Bob Smith\nEmail: bob@example.com\nPhone: Not provided\nAddress: Not provided\n\nNo user data available",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 2: String Processor with Null Safety",
              "content": "\n**Goal**: Create safe string processing functions.\n\n**Requirements**:\n1. Create `safeLength(str: String?): Int` - returns length or 0\n2. Create `safeUppercase(str: String?): String` - returns uppercase or \"EMPTY\"\n3. Create `extractFirstWord(str: String?): String?` - returns first word or null\n4. Create `processText(text: String?)` - displays all information using above functions\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 2: String Processor with Null Safety",
              "content": "\n\n**Sample Output**:\n\n---\n\n",
              "code": "=== Text Processing ===\nInput: Hello World from Kotlin\nLength: 24\nUppercase: HELLO WORLD FROM KOTLIN\nFirst word: Hello\nReversed: niltoK morf dlroW olleH\nWord count: 4\n\n=== Text Processing ===\nInput:    Kotlin\nLength: 12\nUppercase:    KOTLIN\nFirst word: Kotlin\nReversed:    niltoK\nWord count: 1\n\n=== Text Processing ===\nInput:\nLength: 0\nUppercase: EMPTY\nFirst word: none\n\n=== Text Processing ===\nInput: null\nLength: 0\nUppercase: EMPTY\nFirst word: none",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 3: Safe Config Reader",
              "content": "\n**Goal**: Create a configuration reader that safely handles missing values.\n\n**Requirements**:\n1. Create a map to store configuration (String keys, nullable String values)\n2. Create `getConfig(key: String, default: String): String` function\n3. Create `getIntConfig(key: String, default: Int): Int` function\n4. Create `getBoolConfig(key: String, default: Boolean): Boolean` function\n5. Test with various keys and defaults\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 3: Safe Config Reader",
              "content": "\n\n**Sample Output**:\n\n---\n\n",
              "code": "=== Configuration ===\nappName = MyApp\nversion = 1.0.0\nport = 8080\ndebug = true\ntimeout = null\napiKey = null\n\n=== Reading Config ===\nApp Name: MyApp\nVersion: 1.0.0\nPort: 8080\nDebug: true\nTimeout: 30\nAPI Key: default-key\nMissing: fallback",
              "language": "kotlin"
            },
            {
              "type": "WARNING",
              "title": "Common Mistakes",
              "content": "\n### Mistake 1: Overusing !!\n\n\n### Mistake 2: Forgetting to Handle Null\n\n\n### Mistake 3: Unnecessary Null Checks\n\n\n---\n\n",
              "code": "val name: String = \"Alice\"  // Non-nullable\n\n// ‚ùå Unnecessary\nif (name != null) {\n    println(name.length)\n}\n\n// ‚úÖ Just use it directly\nprintln(name.length)",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Checkpoint Quiz",
              "content": "\n### Question 1\nWhat does `String?` mean?\n\nA) A String that might be null\nB) An optional String parameter\nC) A String or Integer\nD) A String array\n\n### Question 2\nWhat does `name?.length` return if `name` is null?\n\nA) 0\nB) null\nC) Error\nD) Empty string\n\n### Question 3\nWhat does the Elvis operator `?:` do?\n\nA) Checks if a value is null\nB) Provides a default value when something is null\nC) Asserts that a value is not null\nD) Safely casts a value\n\n### Question 4\nWhen should you use `!!`?\n\nA) Always, it's the safest option\nB) Rarely, only when you're certain a value isn't null\nC) For all nullable types\nD) Never\n\n### Question 5\nWhat does `obj as? String` return if `obj` is not a String?\n\nA) Error\nB) null\nC) Empty string\nD) The original object\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Answers",
              "content": "\n**Question 1: A) A String that might be null**\n\nThe `?` makes a type nullable:\n\n\n---\n\n**Question 2: B) null**\n\nSafe call returns null if the receiver is null:\n\n\n---\n\n**Question 3: B) Provides a default value when something is null**\n\n\n---\n\n**Question 4: B) Rarely, only when you're certain a value isn't null**\n\n`!!` can cause crashes‚Äîuse it sparingly:\n\n\n---\n\n**Question 5: B) null**\n\nSafe cast returns null on failure:\n\n\n---\n\n",
              "code": "val num: Any = 42\nval str = num as? String  // null (safe, no crash)",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "What You've Learned",
              "content": "\n‚úÖ Kotlin's null safety system prevents NullPointerExceptions\n‚úÖ Nullable types with `?`\n‚úÖ Safe call operator `?.` for safe access\n‚úÖ Elvis operator `?:` for default values\n‚úÖ Not-null assertion `!!` (use carefully!)\n‚úÖ Safe casts with `as?`\n‚úÖ The `let` function for null-safe operations\n‚úÖ Common patterns for handling null values\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Next Steps",
              "content": "\nIn **Lesson 1.7: Part 1 Capstone Project - CLI Calculator**, you'll build:\n- A complete command-line calculator\n- Menu system with when expressions\n- Input validation with null safety\n- All arithmetic operations\n- Loop until user exits\n\nTime to apply everything you've learned!\n\n---\n\n**Congratulations on completing Lesson 1.6!**\n\nYou now understand one of Kotlin's most powerful features‚Äînull safety. This prevents countless bugs and makes your code more reliable!\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "1.7",
          "title": "Lesson 1.7: Part 1 Capstone Project - CLI Calculator",
          "moduleId": "module-01",
          "order": 7,
          "estimatedMinutes": 90,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 90 minutes\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Project Introduction",
              "content": "\nCongratulations on making it to the capstone project! You've learned variables, control flow, functions, collections, and null safety. Now it's time to combine all these skills into a real, practical application.\n\nIn this project, you'll build a **Command-Line Calculator** that:\n- Performs all basic arithmetic operations (+, -, *, /, %)\n- Has a professional menu system\n- Validates user input\n- Handles errors gracefully\n- Keeps a history of calculations\n- Runs until the user chooses to exit\n\nThis is a complete, production-style application that demonstrates best practices and real-world programming patterns.\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Project Requirements",
              "content": "\n### Core Features\n\n1. **Menu System**\n   - Display clear menu options\n   - Use when expression for menu selection\n   - Loop until user exits\n\n2. **Operations**\n   - Addition\n   - Subtraction\n   - Multiplication\n   - Division (with divide-by-zero check)\n   - Modulus (remainder)\n\n3. **Input Validation**\n   - Handle invalid numbers\n   - Handle invalid menu choices\n   - Provide helpful error messages\n\n4. **Calculation History**\n   - Store past calculations\n   - Display history on request\n   - Clear history option\n\n5. **Professional Polish**\n   - Clear formatting\n   - Helpful prompts\n   - Graceful error handling\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Project Architecture",
              "content": "\nWe'll structure our calculator with these components:\n\n\n---\n\n",
              "code": "1. Data Models\n   - Calculation (stores a single calculation)\n\n2. Core Functions\n   - add(), subtract(), multiply(), divide(), modulus()\n   - formatResult()\n\n3. UI Functions\n   - displayMenu()\n   - displayHistory()\n   - clearHistory()\n\n4. Input Functions\n   - getNumber()\n   - getMenuChoice()\n\n5. Main Program\n   - Main loop\n   - Menu handling\n   - Operation execution",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Step-by-Step Implementation",
              "content": "\n### Step 1: Data Model\n\nFirst, let's create a data class to store calculations:\n\n\n**What this does**:\n- Stores all information about a calculation\n- Custom `toString()` for nice display\n- Example: \"10.0 + 5.0 = 15.0\"\n\n---\n\n### Step 2: Core Calculation Functions\n\n\n**Key Points**:\n- Simple, focused functions (Single Responsibility)\n- Division and modulus return `Double?` (nullable) for error handling\n- Error messages provided at the point of failure\n\n---\n\n### Step 3: Input Validation Functions\n\n\n**Why nullable returns?**\n- Safely handle invalid input\n- Caller decides how to handle errors\n- No crashes from bad input\n\n---\n\n### Step 4: UI Functions\n\n\n**Design choices**:\n- Clean, professional-looking menu\n- Box drawing for visual appeal\n- Clear section headers\n- Formatted output\n\n---\n\n### Step 5: Operation Handler\n\n\n---\n\n### Step 6: Main Program Loop\n\n\n---\n\n",
              "code": "fun main() {\n    val history = mutableListOf<Calculation>()\n    var running = true\n\n    println(\"Welcome to Kotlin Calculator!\")\n\n    while (running) {\n        displayMenu()\n\n        val choice = getMenuChoice()\n\n        if (choice == null) {\n            println(\"Invalid input! Please enter a number.\")\n            continue\n        }\n\n        when (choice) {\n            in 1..5 -> {\n                performOperation(choice, history)\n            }\n            6 -> {\n                displayHistory(history)\n            }\n            7 -> {\n                history.clear()\n                println(\"History cleared!\")\n            }\n            8 -> {\n                println(\"\\nThank you for using Kotlin Calculator!\")\n                println(\"Goodbye!\")\n                running = false\n            }\n            else -> {\n                println(\"Invalid choice! Please select 1-8.\")\n            }\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Complete Solution",
              "content": "\nHere's the full calculator application:\n\n\n---\n\n",
              "code": "// ========================================\n// Data Models\n// ========================================\n\ndata class Calculation(\n    val operation: String,\n    val num1: Double,\n    val num2: Double,\n    val result: Double\n) {\n    override fun toString(): String {\n        return \"$num1 $operation $num2 = $result\"\n    }\n}\n\n// ========================================\n// Core Calculation Functions\n// ========================================\n\nfun add(a: Double, b: Double): Double = a + b\n\nfun subtract(a: Double, b: Double): Double = a - b\n\nfun multiply(a: Double, b: Double): Double = a * b\n\nfun divide(a: Double, b: Double): Double? {\n    if (b == 0.0) {\n        println(\"Error: Cannot divide by zero!\")\n        return null\n    }\n    return a / b\n}\n\nfun modulus(a: Double, b: Double): Double? {\n    if (b == 0.0) {\n        println(\"Error: Cannot calculate modulus with zero!\")\n        return null\n    }\n    return a % b\n}\n\n// ========================================\n// Input Functions\n// ========================================\n\nfun getNumber(prompt: String): Double? {\n    print(prompt)\n    val input = readln()\n    return input.toDoubleOrNull()\n}\n\nfun getMenuChoice(): Int? {\n    print(\"Enter your choice: \")\n    val input = readln()\n    return input.toIntOrNull()\n}\n\n// ========================================\n// UI Functions\n// ========================================\n\nfun displayMenu() {\n    println(\"\\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\")\n    println(\"‚ïë      KOTLIN CALCULATOR         ‚ïë\")\n    println(\"‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\")\n    println(\"‚ïë  1. Addition (+)               ‚ïë\")\n    println(\"‚ïë  2. Subtraction (-)            ‚ïë\")\n    println(\"‚ïë  3. Multiplication (*)         ‚ïë\")\n    println(\"‚ïë  4. Division (/)               ‚ïë\")\n    println(\"‚ïë  5. Modulus (%)                ‚ïë\")\n    println(\"‚ïë  6. View History               ‚ïë\")\n    println(\"‚ïë  7. Clear History              ‚ïë\")\n    println(\"‚ïë  8. Exit                       ‚ïë\")\n    println(\"‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\")\n}\n\nfun displayHistory(history: List<Calculation>) {\n    println(\"\\n=== Calculation History ===\")\n    if (history.isEmpty()) {\n        println(\"No calculations yet.\")\n    } else {\n        history.forEachIndexed { index, calc ->\n            println(\"${index + 1}. $calc\")\n        }\n    }\n}\n\nfun displayResult(result: Double) {\n    println(\"\\nResult: ${\"%.2f\".format(result)}\")\n}\n\n// ========================================\n// Operation Handler\n// ========================================\n\nfun performOperation(\n    operation: Int,\n    history: MutableList<Calculation>\n): Boolean {\n    val num1 = getNumber(\"Enter first number: \")\n    if (num1 == null) {\n        println(\"Invalid number!\")\n        return true\n    }\n\n    val num2 = getNumber(\"Enter second number: \")\n    if (num2 == null) {\n        println(\"Invalid number!\")\n        return true\n    }\n\n    val result: Double?\n    val opSymbol: String\n\n    when (operation) {\n        1 -> {\n            opSymbol = \"+\"\n            result = add(num1, num2)\n        }\n        2 -> {\n            opSymbol = \"-\"\n            result = subtract(num1, num2)\n        }\n        3 -> {\n            opSymbol = \"*\"\n            result = multiply(num1, num2)\n        }\n        4 -> {\n            opSymbol = \"/\"\n            result = divide(num1, num2)\n        }\n        5 -> {\n            opSymbol = \"%\"\n            result = modulus(num1, num2)\n        }\n        else -> {\n            println(\"Invalid operation!\")\n            return true\n        }\n    }\n\n    if (result != null) {\n        displayResult(result)\n        history.add(Calculation(opSymbol, num1, num2, result))\n    }\n\n    return true\n}\n\n// ========================================\n// Main Program\n// ========================================\n\nfun main() {\n    val history = mutableListOf<Calculation>()\n    var running = true\n\n    println(\"Welcome to Kotlin Calculator!\")\n\n    while (running) {\n        displayMenu()\n\n        val choice = getMenuChoice()\n\n        if (choice == null) {\n            println(\"Invalid input! Please enter a number.\")\n            continue\n        }\n\n        when (choice) {\n            in 1..5 -> {\n                performOperation(choice, history)\n            }\n            6 -> {\n                displayHistory(history)\n            }\n            7 -> {\n                history.clear()\n                println(\"History cleared!\")\n            }\n            8 -> {\n                println(\"\\nThank you for using Kotlin Calculator!\")\n                println(\"Goodbye!\")\n                running = false\n            }\n            else -> {\n                println(\"Invalid choice! Please select 1-8.\")\n            }\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Sample Output",
              "content": "\n\n---\n\n",
              "code": "Welcome to Kotlin Calculator!\n\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë      KOTLIN CALCULATOR         ‚ïë\n‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\n‚ïë  1. Addition (+)               ‚ïë\n‚ïë  2. Subtraction (-)            ‚ïë\n‚ïë  3. Multiplication (*)         ‚ïë\n‚ïë  4. Division (/)               ‚ïë\n‚ïë  5. Modulus (%)                ‚ïë\n‚ïë  6. View History               ‚ïë\n‚ïë  7. Clear History              ‚ïë\n‚ïë  8. Exit                       ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\nEnter your choice: 1\nEnter first number: 15\nEnter second number: 7\n\nResult: 22.00\n\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n...\nEnter your choice: 3\nEnter first number: 8\nEnter second number: 4\n\nResult: 32.00\n\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n...\nEnter your choice: 6\n\n=== Calculation History ===\n1. 15.0 + 7.0 = 22.0\n2. 8.0 * 4.0 = 32.0\n\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n...\nEnter your choice: 4\nEnter first number: 10\nEnter second number: 0\nError: Cannot divide by zero!\n\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n...\nEnter your choice: 8\n\nThank you for using Kotlin Calculator!\nGoodbye!",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "What You've Demonstrated",
              "content": "\n‚úÖ **Variables**: Storing calculation history, user input, results\n‚úÖ **Data Types**: Int, Double, String, Boolean\n‚úÖ **Control Flow**: while loops, when expressions, if-else\n‚úÖ **Functions**: Organized, single-purpose functions\n‚úÖ **Collections**: MutableList for history\n‚úÖ **Null Safety**: Safe input handling, nullable return types\n‚úÖ **Error Handling**: Division by zero, invalid input\n‚úÖ **Code Organization**: Clean structure, readable code\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Extension Challenges",
              "content": "\nReady for more? Try adding these features:\n\n### Challenge 1: Scientific Operations\n\nAdd these operations:\n- Power (x^y)\n- Square root\n- Absolute value\n\n\n### Challenge 2: Memory Functions\n\nAdd calculator memory (M+, M-, MR, MC):\n\n\n### Challenge 3: Save/Load History\n\nSave history to a file:\n\n\n### Challenge 4: Expression Evaluator\n\nParse and evaluate expressions like \"2 + 3 * 4\":\n\n\n### Challenge 5: Unit Converter\n\nAdd unit conversion:\n- Temperature (C ‚Üî F ‚Üî K)\n- Length (m ‚Üî ft ‚Üî in)\n- Weight (kg ‚Üî lb)\n\n### Challenge 6: Percentage Calculations\n\nAdd percentage operations:\n- What is 15% of 200?\n- What percentage is 30 of 150?\n- Increase/decrease by percentage\n\n---\n\n",
              "code": "fun evaluateExpression(expression: String): Double? {\n    // Parse expression\n    // Handle order of operations\n    // Return result\n}",
              "language": "kotlin"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Quality Review",
              "content": "\nLet's review what makes this code high-quality:\n\n### 1. Single Responsibility Principle\n\nEach function does ONE thing:\n\n### 2. Descriptive Names\n\nNames clearly indicate purpose:\n\n### 3. Error Handling\n\nGraceful error handling throughout:\n\n### 4. Null Safety\n\nProper use of nullable types:\n\n### 5. Code Organization\n\nClear sections and structure:\n- Data models first\n- Core functions\n- UI functions\n- Main program\n\n### 6. User Experience\n\nProfessional, helpful interface:\n- Clear menu\n- Helpful error messages\n- Confirmation messages\n- Nice formatting\n\n---\n\n",
              "code": "val num1 = getNumber(\"Enter first number: \")\nif (num1 == null) {\n    println(\"Invalid number!\")\n    return true\n}\n// num1 is smart-cast to Double here",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Testing Your Calculator",
              "content": "\nTry these test cases:\n\n**Basic Operations**:\n- 10 + 5 = 15\n- 20 - 8 = 12\n- 6 * 7 = 42\n- 100 / 4 = 25\n- 17 % 5 = 2\n\n**Edge Cases**:\n- 10 / 0 ‚Üí Error message\n- abc (invalid input) ‚Üí Error message\n- -5 + 3 = -2 (negative numbers)\n- 0.5 * 0.5 = 0.25 (decimals)\n\n**User Flow**:\n1. Perform several calculations\n2. View history ‚Üí See all calculations\n3. Clear history\n4. View history ‚Üí \"No calculations yet\"\n5. Exit ‚Üí Goodbye message\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Congratulations!",
              "content": "\nYou've built a complete, professional calculator application! This project demonstrates:\n\n‚úÖ Real-world application structure\n‚úÖ Professional error handling\n‚úÖ Clean, maintainable code\n‚úÖ All Part 1 concepts in practice\n‚úÖ User-friendly interface\n‚úÖ Production-ready quality\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nYou've completed **Part 1: Kotlin Fundamentals**! You now have a solid foundation in:\n- Variables and data types\n- Control flow\n- Functions\n- Collections\n- Null safety\n\nIn **Part 2: Object-Oriented Programming**, you'll learn:\n- Classes and objects\n- Inheritance and interfaces\n- Data classes\n- Object declarations\n- Companion objects\n- And much more!\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Final Reflection",
              "content": "\nTake a moment to appreciate your progress:\n\n**Lesson 1.1**: You wrote \"Hello, World!\"\n**Lesson 1.7**: You built a complete calculator with error handling, history, and professional UI!\n\nThat's incredible growth! Keep building, keep learning, and most importantly‚Äîhave fun with Kotlin!\n\n---\n\n**Congratulations on completing Part 1 of the Kotlin Training Course!**\n\nYou're well on your way to becoming a skilled Kotlin developer. The journey continues in Part 2!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "1.7.1",
              "title": "Create a Simple Function",
              "description": "Create a function called 'greet' that prints 'Welcome!', then call it.",
              "instructions": "Create a function called 'greet' that prints 'Welcome!', then call it.",
              "starterCode": "// Create the greet function here\n\n\nfun main() {\n    // Call the greet function\n    \n}",
              "solution": "fun greet() {\n    println(\"Welcome!\")\n}\n\nfun main() {\n    greet()\n}",
              "language": "kotlin",
              "testCases": [
                {
                  "description": "Prints 'Welcome!'",
                  "expectedOutput": "Welcome!",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use 'fun' keyword to create a function"
                },
                {
                  "level": 2,
                  "text": "Syntax: fun name() { code }"
                },
                {
                  "level": 3,
                  "text": "Call it with: greet()"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "1.8",
          "title": "Lesson 1.8: Functions with Parameters and Return Values",
          "moduleId": "module-01",
          "order": 8,
          "estimatedMinutes": 65,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 65 minutes\n\n**Difficulty**: Beginner\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Topic Introduction",
              "content": "\nYou've already learned the basics of functions‚Äîreusable blocks of code that help organize your program. But so far, your functions have been like vending machines that dispense the same item every time. What if you want to customize what you get?\n\nIn this lesson, you'll learn how to make your functions truly flexible and powerful by:\n- **Passing data INTO functions** (parameters)\n- **Getting data BACK from functions** (return values)\n- **Creating reusable, customizable code blocks** that adapt to different situations\n\nThink of it this way: A chef doesn't just make \"a sandwich\"‚Äîthey take specific ingredients (parameters) and create a customized sandwich (return value) based on what you ordered. That's exactly what we're learning today!\n\nBy the end of this lesson, you'll be able to write functions that accept input, process it, and give you back exactly what you need.\n\n---\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "The Concept",
              "content": "\n### The Recipe Analogy\n\n**Simple Functions** (what you know already):\n\n**Functions with Parameters** (what you're learning now):\n\n**Real-World Examples**:\n- **Coffee Shop**: `makeCoffee(size, type, milk)` ‚Üí Takes your preferences, returns your custom coffee\n- **ATM Machine**: `withdraw(accountNumber, amount)` ‚Üí Takes account and amount, returns cash\n- **Calculator**: `add(number1, number2)` ‚Üí Takes two numbers, returns their sum\n\n### Parameters vs Arguments\n\nThese terms are often confused, but they're different:\n\n- **Parameter**: The placeholder variable in the function definition (like a recipe ingredient slot)\n- **Argument**: The actual value you pass when calling the function (like the real ingredient)\n\n\nThink of it like a form:\n- **Parameter**: The blank field \"Name: _______\"\n- **Argument**: What you write in that field \"Name: Alice\"\n\n---\n\n",
              "code": "fun greet(name: String) {  // 'name' is a PARAMETER\n    println(\"Hello, $name!\")\n}\n\nfun main() {\n    greet(\"Alice\")  // \"Alice\" is an ARGUMENT\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Parameters: Giving Functions Input",
              "content": "\n### Single Parameter\n\nThe simplest case‚Äîone input to customize the function:\n\n\n**Output**:\n\n**Breaking it down**:\n\n---\n\n### Multiple Parameters\n\nFunctions can accept multiple inputs:\n\n\n**Output**:\n\n**Important**: Order matters!\n- First argument ‚Üí first parameter\n- Second argument ‚Üí second parameter\n- Third argument ‚Üí third parameter\n\n\n---\n\n### Parameters with Different Types\n\nYou can mix and match any data types:\n\n\n**Output**:\n\n---\n\n### Practical Example: Calculation Function\n\n\n**Output**:\n\n---\n\n",
              "code": "Item Price: $19.99\nQuantity: 3\nSubtotal: $59.97\nTax (8.0%): $4.80\nTotal: $64.77",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Return Values: Getting Results Back",
              "content": "\nSo far, our functions only **do** things (print output). But what if you want a function to **calculate** something and give you the result to use elsewhere?\n\n**That's where return values come in!**\n\n### The Return Statement\n\n\n**Output**:\n\n**Anatomy of a Return Function**:\n\n---\n\n### Return Types Explained\n\nThe return type tells you what kind of value the function will give back:\n\n\n---\n\n### Using Return Values\n\nOnce a function returns a value, you can use it in many ways:\n\n#### 1. Store in a Variable\n\n#### 2. Use Directly in Expressions\n\n#### 3. Print Directly\n\n#### 4. Use in Conditions\n\n#### 5. Chain Function Calls\n\n---\n\n### Functions with Early Return\n\nA function can have multiple return statements:\n\n\n**How it works**:\n- When a return is executed, the function immediately exits\n- No code after the return runs\n- Very useful for handling different cases\n\n---\n\n### Void Functions (Unit Type)\n\nWhat about functions that don't return anything meaningful?\n\n\n**Unit** is Kotlin's way of saying \"this function doesn't return a useful value.\" It's like `void` in other languages, but in Kotlin, you usually just omit it.\n\n---\n\n",
              "code": "fun printWelcome(name: String): Unit {\n    println(\"Welcome, $name!\")\n    // No return statement needed\n}\n\n// Unit can be omitted (it's the default)\nfun printGoodbye(name: String) {\n    println(\"Goodbye, $name!\")\n}\n\nfun main() {\n    printWelcome(\"Alice\")  // Welcome, Alice!\n    printGoodbye(\"Bob\")    // Goodbye, Bob!\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Single-Expression Functions",
              "content": "\nWhen a function is simple and returns a single expression, Kotlin has a shortcut:\n\n### Traditional Way vs. Shortcut\n\n\nAll three versions do exactly the same thing, but the single-expression version is more concise!\n\n---\n\n### More Single-Expression Examples\n\n\n**When to use single-expression functions**:\n- ‚úÖ Function body is one simple expression\n- ‚úÖ Makes code more readable and concise\n- ‚ùå Don't use if the logic is complex or needs multiple lines\n\n---\n\n",
              "code": "// Math operations\nfun square(x: Int) = x * x\nfun cube(x: Int) = x * x * x\nfun double(x: Int) = x * 2\n\n// Boolean checks\nfun isEven(n: Int) = n % 2 == 0\nfun isPositive(n: Int) = n > 0\nfun isAdult(age: Int) = age >= 18\n\n// String operations\nfun greet(name: String) = \"Hello, $name!\"\nfun shout(text: String) = text.uppercase() + \"!\"\n\n// Conditional expressions\nfun max(a: Int, b: Int) = if (a > b) a else b\nfun min(a: Int, b: Int) = if (a < b) a else b\nfun absoluteValue(n: Int) = if (n >= 0) n else -n\n\nfun main() {\n    println(square(5))           // 25\n    println(isEven(4))           // true\n    println(greet(\"Alice\"))      // Hello, Alice!\n    println(max(10, 20))         // 20\n    println(absoluteValue(-7))   // 7\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Default Parameters",
              "content": "\nKotlin lets you provide default values for parameters:\n\n\n**Output**:\n\n---\n\n### Multiple Default Parameters\n\n\n**Output**:\n\n---\n\n### Named Arguments\n\nYou can specify parameter names when calling functions:\n\n\n**Benefits of named arguments**:\n- Code is more readable\n- Order doesn't matter\n- Great when functions have many parameters\n- Especially useful with default parameters\n\n---\n\n",
              "code": "fun makeRecipe(dish: String, cookTime: Int, difficulty: String, serves: Int) {\n    println(\"$dish - Serves $serves\")\n    println(\"Cooking time: $cookTime minutes\")\n    println(\"Difficulty: $difficulty\")\n    println()\n}\n\nfun main() {\n    // Positional arguments (order matters)\n    makeRecipe(\"Pizza\", 30, \"Easy\", 4)\n\n    // Named arguments (order doesn't matter!)\n    makeRecipe(\n        dish = \"Pasta\",\n        serves = 2,\n        difficulty = \"Medium\",\n        cookTime = 20\n    )\n\n    // Mix of both\n    makeRecipe(\"Cake\", cookTime = 45, difficulty = \"Hard\", serves = 8)\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Hands-On Exercises",
              "content": "\n### Exercise 1: Temperature Converter\n\n**Goal**: Create a comprehensive temperature converter.\n\n**Requirements**:\n1. Create `celsiusToFahrenheit(celsius: Double): Double`\n2. Create `fahrenheitToCelsius(fahrenheit: Double): Double`\n3. Create `celsiusToKelvin(celsius: Double): Double`\n4. Create `displayConversions(temp: Double, unit: String)` that shows all conversions\n5. Test with different temperatures\n\n**Formulas**:\n- F = (C √ó 9/5) + 32\n- C = (F - 32) √ó 5/9\n- K = C + 273.15\n\n**Try it yourself first, then check the solution!**\n\n<details>\n<summary>Click to see Solution</summary>\n\n\n**Output**:\n\n</details>\n\n---\n\n### Exercise 2: Shopping Cart Calculator\n\n**Goal**: Create a shopping cart calculator with tax and discounts.\n\n**Requirements**:\n1. Create `calculateSubtotal(price: Double, quantity: Int): Double`\n2. Create `calculateTax(amount: Double, taxRate: Double = 0.08): Double`\n3. Create `applyDiscount(amount: Double, discountPercent: Double = 0.0): Double`\n4. Create `calculateTotal(price: Double, quantity: Int, taxRate: Double, discountPercent: Double): Double`\n5. Create `displayReceipt(itemName: String, price: Double, quantity: Int, taxRate: Double, discountPercent: Double)`\n\n<details>\n<summary>Click to see Solution</summary>\n\n\n</details>\n\n---\n\n### Exercise 3: Grade Calculator\n\n**Goal**: Create a student grade calculator.\n\n**Requirements**:\n1. Create `calculateAverage(score1: Int, score2: Int, score3: Int): Double`\n2. Create `getLetterGrade(average: Double): String`\n3. Create `isPassing(grade: String): Boolean`\n4. Create `displayGradeReport(name: String, score1: Int, score2: Int, score3: Int)`\n\n**Grading Scale**:\n- A: 90-100\n- B: 80-89\n- C: 70-79\n- D: 60-69\n- F: Below 60\n- Passing: C or better\n\n<details>\n<summary>Click to see Solution</summary>\n\n\n**Output**:\n\n</details>\n\n---\n\n### Exercise 4: BMI Calculator\n\n**Goal**: Create a Body Mass Index calculator with health recommendations.\n\n**Requirements**:\n1. Create `calculateBMI(weightKg: Double, heightM: Double): Double`\n2. Create `getBMICategory(bmi: Double): String`\n3. Create `getHealthAdvice(category: String): String`\n4. Test with different values\n\n**BMI Categories**:\n- Underweight: < 18.5\n- Normal: 18.5-24.9\n- Overweight: 25-29.9\n- Obese: ‚â• 30\n\n**Formula**: BMI = weight (kg) / height¬≤ (m)\n\n<details>\n<summary>Click to see Solution</summary>\n\n\n</details>\n\n---\n\n",
              "code": "fun calculateBMI(weightKg: Double, heightM: Double): Double {\n    return weightKg / (heightM * heightM)\n}\n\nfun getBMICategory(bmi: Double): String {\n    return when {\n        bmi < 18.5 -> \"Underweight\"\n        bmi < 25.0 -> \"Normal weight\"\n        bmi < 30.0 -> \"Overweight\"\n        else -> \"Obese\"\n    }\n}\n\nfun getHealthAdvice(category: String): String {\n    return when (category) {\n        \"Underweight\" -> \"Consider consulting a nutritionist to gain weight healthily.\"\n        \"Normal weight\" -> \"Great! Maintain your current healthy lifestyle.\"\n        \"Overweight\" -> \"Consider a balanced diet and regular exercise.\"\n        \"Obese\" -> \"Consult a healthcare provider for a personalized health plan.\"\n        else -> \"Unknown category\"\n    }\n}\n\nfun displayBMIReport(name: String, weightKg: Double, heightM: Double) {\n    val bmi = calculateBMI(weightKg, heightM)\n    val category = getBMICategory(bmi)\n    val advice = getHealthAdvice(category)\n\n    println(\"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\")\n    println(\"         BMI HEALTH REPORT\")\n    println(\"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\")\n    println()\n    println(\"Name: $name\")\n    println(\"Weight: ${weightKg}kg\")\n    println(\"Height: ${heightM}m\")\n    println()\n    println(\"BMI: ${\"%.1f\".format(bmi)}\")\n    println(\"Category: $category\")\n    println()\n    println(\"Health Advice:\")\n    println(advice)\n    println()\n    println(\"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\")\n    println()\n}\n\nfun main() {\n    displayBMIReport(\"Alice\", 65.0, 1.70)\n    displayBMIReport(\"Bob\", 95.0, 1.80)\n    displayBMIReport(\"Charlie\", 55.0, 1.75)\n}",
              "language": "kotlin"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls and Best Practices",
              "content": "\n### Common Mistakes\n\n#### Mistake 1: Wrong Number of Arguments\n\n\n---\n\n#### Mistake 2: Wrong Argument Type\n\n\n---\n\n#### Mistake 3: Wrong Argument Order\n\n\n---\n\n#### Mistake 4: Forgetting Return Statement\n\n\n---\n\n#### Mistake 5: Incorrect Return Type\n\n\n---\n\n### Best Practices\n\n#### 1. Use Descriptive Parameter Names\n\n\n---\n\n#### 2. Keep Functions Focused (Single Responsibility)\n\n\n---\n\n#### 3. Use Default Parameters for Optional Values\n\n\n---\n\n#### 4. Use Single-Expression Functions for Simple Logic\n\n\n---\n\n#### 5. Validate Input Parameters\n\n\n---\n\n",
              "code": "fun divide(a: Double, b: Double): Double {\n    if (b == 0.0) {\n        println(\"Error: Cannot divide by zero!\")\n        return 0.0\n    }\n    return a / b\n}\n\nfun createUser(name: String, age: Int) {\n    if (name.isBlank()) {\n        println(\"Error: Name cannot be empty!\")\n        return\n    }\n    if (age < 0 || age > 150) {\n        println(\"Error: Invalid age!\")\n        return\n    }\n    println(\"User created: $name, age $age\")\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Quick Quiz",
              "content": "\nTest your understanding!\n\n### Question 1\nWhat's the difference between a parameter and an argument?\n\nA) They are the same thing\nB) Parameter is in the function definition, argument is the actual value passed\nC) Argument is in the function definition, parameter is the actual value passed\nD) Parameters are for strings, arguments are for numbers\n\n<details>\n<summary>Show Answer</summary>\n\n**Answer: B) Parameter is in the function definition, argument is the actual value passed**\n\nExplanation:\n\nParameters are placeholders in the function signature. Arguments are the actual values you provide when calling the function.\n\n</details>\n\n---\n\n### Question 2\nWhat does this function return?\n\n\nA) 0\nB) The value of x multiplied by 2\nC) Nothing - it's an error\nD) Unit\n\n<details>\n<summary>Show Answer</summary>\n\n**Answer: C) Nothing - it's an error**\n\nExplanation: The function has a return type of `Int` but no `return` statement. The calculation `x * 2` happens but the result is not returned.\n\n**Correct version**:\n\n</details>\n\n---\n\n### Question 3\nWhich of the following is a valid single-expression function?\n\nA) `fun add(a: Int, b: Int): Int { a + b }`\nB) `fun add(a: Int, b: Int) = a + b`\nC) `fun add(a: Int, b: Int) => a + b`\nD) `fun add(a: Int, b: Int) return a + b`\n\n<details>\n<summary>Show Answer</summary>\n\n**Answer: B) `fun add(a: Int, b: Int) = a + b`**\n\nExplanation: Single-expression functions use `=` instead of curly braces and don't need the `return` keyword.\n\n\n</details>\n\n---\n\n### Question 4\nWhat will this code output?\n\n\nA) Error: Missing arguments\nB) Hello, Guest!\nC) Guest, Hello!\nD) Nothing\n\n<details>\n<summary>Show Answer</summary>\n\n**Answer: B) Hello, Guest!**\n\nExplanation: When a function has default parameters, you can call it without providing those arguments. The default values are used:\n- `name` defaults to \"Guest\"\n- `greeting` defaults to \"Hello\"\n\nSo `greet()` becomes `greet(\"Guest\", \"Hello\")` which prints \"Hello, Guest!\"\n\n</details>\n\n---\n\n",
              "code": "fun greet(name: String = \"Guest\", greeting: String = \"Hello\") {\n    println(\"$greeting, $name!\")\n}\n\nfun main() {\n    greet()\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Summary",
              "content": "\nCongratulations! You've learned how to create powerful, flexible functions in Kotlin:\n\n### Key Concepts Covered:\n\n**Parameters**:\n- Parameters are inputs that customize function behavior\n- Can have multiple parameters of different types\n- Order matters (unless using named arguments)\n\n**Return Values**:\n- Functions can return values using the `return` keyword\n- Return type is specified after the parameter list: `: Type`\n- Returned values can be stored, used in expressions, or passed to other functions\n\n**Single-Expression Functions**:\n- Use `=` instead of `{}` for simple functions\n- More concise and readable for simple logic\n- Syntax: `fun name(params) = expression`\n\n**Default Parameters**:\n- Provide default values for parameters\n- Make parameters optional\n- Syntax: `param: Type = defaultValue`\n\n**Named Arguments**:\n- Specify parameter names when calling functions\n- Make code more readable\n- Allow calling parameters in any order\n\n**Best Practices**:\n- Use descriptive parameter names\n- Keep functions focused (single responsibility)\n- Validate input parameters\n- Use single-expression functions for simple logic\n- Provide sensible default values\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nYou've now mastered all the fundamental building blocks of Kotlin programming! In the next lesson, **Lesson 1.9: Part 1 Capstone - Personal Profile Generator**, you'll put everything together:\n\n- Variables and data types\n- User input\n- Functions with parameters\n- Return values\n- String templates\n- Calculations\n\nYou'll build a complete, interactive program that showcases all your new skills!\n\n---\n\n**Congratulations on completing Lesson 1.8!**\n\nYou now know how to create flexible, reusable functions that are the foundation of organized, maintainable code. Functions with parameters and return values are essential tools in every programmer's toolkit.\n\nKeep practicing, and get ready for the capstone project!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "1.8.1",
              "title": "Function with Parameter",
              "description": "Create a function 'square' that takes an Int and returns its square.",
              "instructions": "Create a function 'square' that takes an Int and returns its square.",
              "starterCode": "fun square(n: Int): Int {\n    // Return n * n\n    \n}\n\nfun main() {\n    val result = square(5)\n    println(result)\n}",
              "solution": "fun square(n: Int): Int {\n    return n * n\n}\n\nfun main() {\n    val result = square(5)\n    println(result)\n}",
              "language": "kotlin",
              "testCases": [
                {
                  "description": "Prints 25 (5 squared)",
                  "expectedOutput": "25",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use 'return' to send back a value"
                },
                {
                  "level": 2,
                  "text": "Multiply n by itself: n * n"
                },
                {
                  "level": 3,
                  "text": "Function signature is already provided"
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "1.8.2",
              "title": "Function with Multiple Parameters",
              "description": "Create a function 'multiply' that takes two Ints and returns their product.",
              "instructions": "Create a function 'multiply' that takes two Ints and returns their product.",
              "starterCode": "fun multiply(a: Int, b: Int): Int {\n    // Return a * b\n    \n}\n\nfun main() {\n    println(multiply(6, 7))\n}",
              "solution": "fun multiply(a: Int, b: Int): Int {\n    return a * b\n}\n\nfun main() {\n    println(multiply(6, 7))\n}",
              "language": "kotlin",
              "testCases": [
                {
                  "description": "Prints 42",
                  "expectedOutput": "42",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Return a * b"
                },
                {
                  "level": 2,
                  "text": "Use return keyword"
                },
                {
                  "level": 3,
                  "text": "Test with multiply(6, 7) = 42"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "1.9",
          "title": "Lesson 1.9: Part 1 Capstone - Personal Profile Generator",
          "moduleId": "module-01",
          "order": 9,
          "estimatedMinutes": 80,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 80 minutes\n\n**Difficulty**: Beginner Capstone Project\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Project Introduction",
              "content": "\nCongratulations! You've reached the capstone project for Part 1 of the Kotlin Training Course. This is where everything comes together!\n\nOver the past lessons, you've learned:\n- ‚úÖ How to write and run Kotlin code\n- ‚úÖ How to use variables (`val` and `var`)\n- ‚úÖ Different data types (Int, Double, String, Boolean)\n- ‚úÖ How to get user input with `readln()`\n- ‚úÖ How to create and call functions\n- ‚úÖ How to pass parameters to functions\n- ‚úÖ How to return values from functions\n- ‚úÖ String templates for formatted output\n\nNow you'll combine **all of these skills** to build a complete, interactive application: **The Personal Profile Generator**!\n\n### What You'll Build\n\nAn interactive command-line application that:\n1. Asks users for personal information\n2. Performs calculations on that data\n3. Displays a beautifully formatted profile\n4. Uses well-organized functions\n5. Handles multiple pieces of data\n6. Creates a professional user experience\n\nThis project demonstrates that you can build real, practical applications with what you've learned!\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Project Requirements",
              "content": "\nYour Personal Profile Generator must include:\n\n### Core Features\n\n**1. Data Collection**\n- Name (String)\n- Age (Int)\n- Birth year (Int)\n- Height in meters (Double)\n- Favorite hobby (String)\n- Favorite number (Int)\n- Dream job (String)\n\n**2. Calculations**\n- Calculate age in 10 years\n- Calculate age in 20 years\n- Calculate birth decade (1990s, 2000s, etc.)\n- Double their favorite number\n- Triple their favorite number\n- Calculate height in feet (1 meter = 3.28084 feet)\n\n**3. Functions Required**\n- At least 4 helper functions with descriptive names\n- At least 2 functions that take parameters\n- At least 2 functions that return values\n- A main display function that shows the profile\n\n**4. Professional Output**\n- Clear section headers\n- Decorative borders\n- Well-formatted information\n- Easy to read layout\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Project Architecture",
              "content": "\nBefore coding, let's plan the structure:\n\n\nThis modular approach makes code easier to write, test, and maintain!\n\n---\n\n",
              "code": "Personal Profile Generator\n‚îÇ\n‚îú‚îÄ‚îÄ Data Collection Functions\n‚îÇ   ‚îî‚îÄ‚îÄ getUserInput() - Gets all user data\n‚îÇ\n‚îú‚îÄ‚îÄ Calculation Functions\n‚îÇ   ‚îú‚îÄ‚îÄ calculateFutureAge(currentAge, years)\n‚îÇ   ‚îú‚îÄ‚îÄ calculateBirthDecade(birthYear)\n‚îÇ   ‚îú‚îÄ‚îÄ metersToFeet(meters)\n‚îÇ   ‚îî‚îÄ‚îÄ multiplyNumber(number, multiplier)\n‚îÇ\n‚îú‚îÄ‚îÄ Display Functions\n‚îÇ   ‚îú‚îÄ‚îÄ printSectionHeader(title)\n‚îÇ   ‚îú‚îÄ‚îÄ printDecorativeLine()\n‚îÇ   ‚îî‚îÄ‚îÄ displayProfile(userData)\n‚îÇ\n‚îî‚îÄ‚îÄ Main Program\n    ‚îî‚îÄ‚îÄ main() - Orchestrates everything",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Step-by-Step Implementation",
              "content": "\nLet's build this project step by step!\n\n### Step 1: Create Display Helper Functions\n\nThese functions will make our output look professional:\n\n\n**Why these functions?**\n- **Reusability**: Call them whenever you need formatting\n- **Consistency**: All section headers look the same\n- **Easy to change**: Want different borders? Change once, affects everywhere!\n\n---\n\n### Step 2: Create Calculation Functions\n\nThese functions process user data:\n\n\n**Key points**:\n- Each function has a single, clear purpose\n- Descriptive names explain what they do\n- Parameters and return types are explicit\n\n---\n\n### Step 3: Create Data Input Function\n\nLet's gather all the user information:\n\n\nThis function provides a welcoming introduction. We'll collect the actual data in `main()`.\n\n---\n\n### Step 4: Build the Main Program\n\nNow let's put it all together:\n\n\n---\n\n### Step 5: Create the Profile Display Function\n\nThis function creates the beautiful output:\n\n\n---\n\n",
              "code": "fun displayProfile(\n    name: String,\n    age: Int,\n    birthYear: Int,\n    heightMeters: Double,\n    heightFeet: Double,\n    hobby: String,\n    favoriteNumber: Int,\n    dreamJob: String,\n    ageIn10Years: Int,\n    ageIn20Years: Int,\n    birthDecade: String,\n    doubledNumber: Int,\n    tripledNumber: Int\n) {\n    // Header\n    printSectionHeader(\"YOUR PERSONAL PROFILE\")\n\n    // Basic Information\n    println(\"üë§ BASIC INFORMATION\")\n    printSimpleLine()\n    println(\"Name: $name\")\n    println(\"Current Age: $age years old\")\n    println(\"Birth Year: $birthYear\")\n    println(\"Birth Decade: $birthDecade\")\n    println(\"Height: ${String.format(\"%.2f\", heightMeters)}m (${String.format(\"%.2f\", heightFeet)} feet)\")\n    println()\n\n    // Future Projections\n    println(\"üîÆ FUTURE PROJECTIONS\")\n    printSimpleLine()\n    println(\"In 10 years (${2024 + 10}), you will be: $ageIn10Years years old\")\n    println(\"In 20 years (${2024 + 20}), you will be: $ageIn20Years years old\")\n    println()\n\n    // Interests & Dreams\n    println(\"‚≠ê INTERESTS & DREAMS\")\n    printSimpleLine()\n    println(\"Favorite Hobby: $hobby\")\n    println(\"Dream Job: $dreamJob\")\n    println()\n\n    // Fun Facts\n    println(\"üé≤ FUN NUMBER FACTS\")\n    printSimpleLine()\n    println(\"Your favorite number: $favoriteNumber\")\n    println(\"Doubled: $doubledNumber\")\n    println(\"Tripled: $tripledNumber\")\n    println()\n\n    // Footer\n    printDecorativeLine()\n    println(\"     Thank you for using Profile Generator!\")\n    println(\"           Keep dreaming big, $name!\")\n    printDecorativeLine()\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Complete Solution",
              "content": "\nHere's the full, working program:\n\n\n---\n\n",
              "code": "// ========================================\n// DISPLAY HELPER FUNCTIONS\n// ========================================\n\nfun printDecorativeLine() {\n    println(\"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\")\n}\n\nfun printSectionHeader(title: String) {\n    println()\n    printDecorativeLine()\n    println(\"  $title\")\n    printDecorativeLine()\n    println()\n}\n\nfun printSimpleLine() {\n    println(\"---\")\n}\n\n// ========================================\n// CALCULATION FUNCTIONS\n// ========================================\n\nfun calculateFutureAge(currentAge: Int, yearsInFuture: Int): Int {\n    return currentAge + yearsInFuture\n}\n\nfun calculateBirthDecade(birthYear: Int): String {\n    val decade = (birthYear / 10) * 10\n    return \"${decade}s\"\n}\n\nfun metersToFeet(meters: Double): Double {\n    return meters * 3.28084\n}\n\nfun multiplyNumber(number: Int, multiplier: Int): Int {\n    return number * multiplier\n}\n\n// ========================================\n// INPUT FUNCTION\n// ========================================\n\nfun displayWelcome() {\n    println(\"‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\")\n    println(\"‚ïë  PERSONAL PROFILE GENERATOR            ‚ïë\")\n    println(\"‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\")\n    println()\n    println(\"Let's create your profile!\")\n    println(\"Please answer the following questions:\")\n    println()\n}\n\n// ========================================\n// PROFILE DISPLAY FUNCTION\n// ========================================\n\nfun displayProfile(\n    name: String,\n    age: Int,\n    birthYear: Int,\n    heightMeters: Double,\n    heightFeet: Double,\n    hobby: String,\n    favoriteNumber: Int,\n    dreamJob: String,\n    ageIn10Years: Int,\n    ageIn20Years: Int,\n    birthDecade: String,\n    doubledNumber: Int,\n    tripledNumber: Int\n) {\n    // Header\n    printSectionHeader(\"YOUR PERSONAL PROFILE\")\n\n    // Basic Information\n    println(\"üë§ BASIC INFORMATION\")\n    printSimpleLine()\n    println(\"Name: $name\")\n    println(\"Current Age: $age years old\")\n    println(\"Birth Year: $birthYear\")\n    println(\"Birth Decade: $birthDecade\")\n    println(\"Height: ${String.format(\"%.2f\", heightMeters)}m (${String.format(\"%.2f\", heightFeet)} feet)\")\n    println()\n\n    // Future Projections\n    println(\"üîÆ FUTURE PROJECTIONS\")\n    printSimpleLine()\n    println(\"In 10 years (${2024 + 10}), you will be: $ageIn10Years years old\")\n    println(\"In 20 years (${2024 + 20}), you will be: $ageIn20Years years old\")\n    println()\n\n    // Interests & Dreams\n    println(\"‚≠ê INTERESTS & DREAMS\")\n    printSimpleLine()\n    println(\"Favorite Hobby: $hobby\")\n    println(\"Dream Job: $dreamJob\")\n    println()\n\n    // Fun Facts\n    println(\"üé≤ FUN NUMBER FACTS\")\n    printSimpleLine()\n    println(\"Your favorite number: $favoriteNumber\")\n    println(\"Doubled: $doubledNumber\")\n    println(\"Tripled: $tripledNumber\")\n    println()\n\n    // Footer\n    printDecorativeLine()\n    println(\"     Thank you for using Profile Generator!\")\n    println(\"           Keep dreaming big, $name!\")\n    printDecorativeLine()\n}\n\n// ========================================\n// MAIN PROGRAM\n// ========================================\n\nfun main() {\n    // Display welcome message\n    displayWelcome()\n\n    // Collect user data\n    print(\"What is your name? \")\n    val name = readln()\n\n    print(\"How old are you? \")\n    val age = readln().toInt()\n\n    print(\"What year were you born? \")\n    val birthYear = readln().toInt()\n\n    print(\"What is your height in meters? (e.g., 1.75) \")\n    val heightMeters = readln().toDouble()\n\n    print(\"What is your favorite hobby? \")\n    val hobby = readln()\n\n    print(\"What is your favorite number? \")\n    val favoriteNumber = readln().toInt()\n\n    print(\"What is your dream job? \")\n    val dreamJob = readln()\n\n    // Perform calculations\n    val ageIn10Years = calculateFutureAge(age, 10)\n    val ageIn20Years = calculateFutureAge(age, 20)\n    val birthDecade = calculateBirthDecade(birthYear)\n    val heightFeet = metersToFeet(heightMeters)\n    val doubledNumber = multiplyNumber(favoriteNumber, 2)\n    val tripledNumber = multiplyNumber(favoriteNumber, 3)\n\n    // Display beautiful profile\n    displayProfile(\n        name, age, birthYear, heightMeters, heightFeet,\n        hobby, favoriteNumber, dreamJob,\n        ageIn10Years, ageIn20Years, birthDecade,\n        doubledNumber, tripledNumber\n    )\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Sample Output",
              "content": "\nHere's what your program will look like when running:\n\n\n---\n\n",
              "code": "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë  PERSONAL PROFILE GENERATOR            ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\nLet's create your profile!\nPlease answer the following questions:\n\nWhat is your name? Alex Johnson\nHow old are you? 22\nWhat year were you born? 2002\nWhat is your height in meters? (e.g., 1.75) 1.78\nWhat is your favorite hobby? Photography\nWhat is your favorite number? 7\nWhat is your dream job? Software Developer\n\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n  YOUR PERSONAL PROFILE\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\nüë§ BASIC INFORMATION\n---\nName: Alex Johnson\nCurrent Age: 22 years old\nBirth Year: 2002\nBirth Decade: 2000s\nHeight: 1.78m (5.84 feet)\n\nüîÆ FUTURE PROJECTIONS\n---\nIn 10 years (2034), you will be: 32 years old\nIn 20 years (2044), you will be: 42 years old\n\n‚≠ê INTERESTS & DREAMS\n---\nFavorite Hobby: Photography\nDream Job: Software Developer\n\nüé≤ FUN NUMBER FACTS\n---\nYour favorite number: 7\nDoubled: 14\nTripled: 21\n\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n     Thank you for using Profile Generator!\n           Keep dreaming big, Alex Johnson!\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Your Turn: Build the Project!",
              "content": "\nNow it's time to build this yourself! Follow these steps:\n\n### Level 1: Follow the Guide (Recommended for First-Timers)\n\n1. Copy the complete solution above into Kotlin Playground\n2. Run it and test it with different inputs\n3. Read through each function and understand what it does\n4. Add comments explaining the code in your own words\n\n### Level 2: Customize It\n\nMake these enhancements to make the project your own:\n\n1. **Add More Questions**:\n   - Favorite color\n   - Favorite food\n   - Number of siblings\n   - Pet's name\n\n2. **Add More Calculations**:\n   - Calculate what year they'll turn 100\n   - Calculate height in inches (1 foot = 12 inches)\n   - Calculate decades lived\n\n3. **Improve the Display**:\n   - Change the border style\n   - Add colors using ANSI codes (advanced)\n   - Rearrange sections\n\n4. **Add Validation**:\n   - Check if age is positive\n   - Check if height is reasonable\n   - Handle empty name input\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Challenge Extensions",
              "content": "\nReady to level up? Try these advanced challenges:\n\n### Challenge 1: Add BMI Calculator\n\nAdd height and weight questions, then calculate and display BMI:\n\n\n<details>\n<summary>Click to see implementation hint</summary>\n\n\n</details>\n\n---\n\n### Challenge 2: Add Zodiac Sign Calculator\n\nCalculate Western zodiac sign based on birth month and day:\n\n<details>\n<summary>Click to see solution</summary>\n\n\n</details>\n\n---\n\n### Challenge 3: Add Life Events Timeline\n\nCalculate and display significant life milestones:\n\n<details>\n<summary>Click to see solution</summary>\n\n\n</details>\n\n---\n\n### Challenge 4: Save Profile to File (Advanced)\n\nSave the generated profile to a text file:\n\n<details>\n<summary>Click to see solution</summary>\n\n\nNote: File I/O requires additional imports and is an advanced topic!\n\n</details>\n\n---\n\n### Challenge 5: Multiple Profiles\n\nAllow creating profiles for multiple people:\n\n<details>\n<summary>Click to see implementation hint</summary>\n\n\n</details>\n\n---\n\n",
              "code": "fun main() {\n    var continueCreating = true\n\n    while (continueCreating) {\n        // Run profile creation code\n\n        println()\n        print(\"Create another profile? (yes/no): \")\n        val response = readln().lowercase()\n        continueCreating = response == \"yes\" || response == \"y\"\n    }\n\n    println(\"Thank you for using Profile Generator!\")\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "What You've Demonstrated",
              "content": "\nBy completing this capstone project, you've proven mastery of:\n\n### Technical Skills\n‚úÖ **Variables**: Using `val` to store user input and calculations\n‚úÖ **Data Types**: Working with String, Int, Double\n‚úÖ **Type Conversion**: Converting String input to Int/Double with `toInt()`, `toDouble()`\n‚úÖ **String Templates**: Formatting output with `$variable` and `${expression}`\n‚úÖ **Functions**: Creating reusable, organized code\n‚úÖ **Parameters**: Passing data to functions\n‚úÖ **Return Values**: Getting results from functions\n‚úÖ **User Input**: Reading from console with `readln()`\n‚úÖ **Calculations**: Performing mathematical operations\n‚úÖ **String Formatting**: Using `String.format()` for decimal precision\n\n### Software Design Skills\n‚úÖ **Code Organization**: Separating concerns into logical functions\n‚úÖ **Modularity**: Creating reusable components\n‚úÖ **Readability**: Writing clean, understandable code\n‚úÖ **User Experience**: Creating professional, polished output\n‚úÖ **Problem Decomposition**: Breaking complex problems into smaller parts\n\n### Professional Practices\n‚úÖ **Planning**: Designing before coding\n‚úÖ **Structure**: Organizing code into sections\n‚úÖ **Documentation**: Using clear function and variable names\n‚úÖ **Testing**: Running with different inputs\n‚úÖ **Iteration**: Starting simple and adding features\n\n---\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Quality Review",
              "content": "\nLet's analyze what makes this project high-quality:\n\n### 1. Single Responsibility Principle\n\nEach function has one clear job:\n\n\n### 2. Descriptive Naming\n\nNames clearly indicate purpose:\n\n\n### 3. Consistent Formatting\n\n\n### 4. Reusability\n\nFunctions can be used in different contexts:\n\n\n### 5. Parameter Flexibility\n\nFunctions accept parameters for customization:\n\n\n---\n\n",
              "code": "// Same function, different uses\nval ageIn10Years = calculateFutureAge(age, 10)\nval ageIn20Years = calculateFutureAge(age, 20)\nval ageIn50Years = calculateFutureAge(age, 50)",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Reflection Questions",
              "content": "\nBefore moving to Part 2, reflect on your learning:\n\n1. **How did using functions improve your code organization?**\n   - Without functions: All code in main(), hard to read\n   - With functions: Clear sections, easy to understand and modify\n\n2. **What would you need to change to add a new feature?**\n   - Example: Adding \"favorite movie\" would require:\n     - One input line in main()\n     - One line in displayProfile()\n     - No changes to calculation functions (good design!)\n\n3. **How does this project compare to your first \"Hello, World!\"?**\n   - Lesson 1.1: Simple print statement\n   - Lesson 1.9: Complete interactive application!\n   - Amazing progress in just a few lessons!\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Testing Your Program",
              "content": "\nTry these test cases to ensure everything works:\n\n### Test Case 1: Young Person\n\n### Test Case 2: Different Numbers\n\n### Test Case 3: Edge Cases\n\nMake sure your program handles all cases gracefully!\n\n---\n\n",
              "code": "Name: A\nAge: 1\nBirth Year: 2023\nHeight: 0.5\nHobby: Sleeping\nNumber: 0\nDream Job: Growing",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Congratulations!",
              "content": "\nYou've completed your first major Kotlin project! This is a significant achievement.\n\n### Your Journey So Far\n\n**Lesson 1.1**: You wrote \"Hello, World!\"\n\n**Lesson 1.9**: You built a complete interactive application with:\n- User input collection\n- Data processing\n- Multiple functions\n- Professional output formatting\n- Calculations and conversions\n\n**That's incredible growth in just 9 lessons!**\n\n---\n\n",
              "code": "println(\"Hello, World!\")",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "What You've Learned",
              "content": "\n### Part 1: Absolute Basics - Complete!\n\n‚úÖ **Lesson 1.1**: Introduction to Programming & Kotlin\n‚úÖ **Lesson 1.2**: Your First Kotlin Program\n‚úÖ **Lesson 1.3**: Variables & Data Types\n‚úÖ **Lesson 1.4**: Functions & Basic Syntax\n‚úÖ **Lesson 1.5**: Collections & Arrays\n‚úÖ **Lesson 1.6**: Null Safety\n‚úÖ **Lesson 1.7**: More on Variables & Type Conversion\n‚úÖ **Lesson 1.8**: Functions with Parameters & Return Values\n‚úÖ **Lesson 1.9**: Capstone Project (You Are Here!)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nCongratulations on completing **Part 1: Absolute Basics**!\n\nYou now have a solid foundation in Kotlin fundamentals. You can:\n- Write and run Kotlin programs\n- Work with variables and different data types\n- Create and use functions effectively\n- Get user input and display output\n- Build complete, working applications\n\n### In Part 2: Object-Oriented Programming, you'll learn:\n\n**Classes & Objects**: Creating custom data types\n\n**Inheritance**: Building on existing code\n\n**Interfaces**: Defining contracts for classes\n**Data Classes**: Special classes for holding data\n**Object Declarations**: Singletons and companions\n**And much more!**\n\nThis is where Kotlin really starts to shine!\n\n---\n\n",
              "code": "open class Animal {\n    open fun makeSound() { }\n}\n\nclass Dog : Animal() {\n    override fun makeSound() {\n        println(\"Woof!\")\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Final Thoughts",
              "content": "\n### Celebrate Your Achievement\n\nYou should be incredibly proud of yourself! You've:\n- Learned a new programming language from scratch\n- Built multiple working programs\n- Completed a comprehensive capstone project\n- Demonstrated real programming skills\n\n### Keep the Momentum Going\n\n**Programming is a journey, not a destination.**\n\n- ‚úÖ You're no longer a complete beginner\n- ‚úÖ You have real, practical skills\n- ‚úÖ You can build useful applications\n- ‚úÖ You're ready for more advanced topics\n\n### Before Moving On\n\n1. **Run your program** - See it work with different inputs\n2. **Experiment** - Try the challenge extensions\n3. **Share** - Show someone what you built\n4. **Reflect** - Appreciate how far you've come\n\n### The Adventure Continues\n\nPart 2 awaits! You'll learn how to create your own data types, organize code with classes, and build even more sophisticated applications.\n\n**You've got this!**\n\n---\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "\n**Project Development**:\n- Plan before you code\n- Break problems into small functions\n- Test frequently\n- Iterate and improve\n\n**Function Design**:\n- One function, one purpose\n- Use descriptive names\n- Accept parameters for flexibility\n- Return values for reusability\n\n**Code Organization**:\n- Group related functions\n- Use comments to separate sections\n- Keep main() clean and organized\n- Make code readable for others (and future you!)\n\n**User Experience**:\n- Clear prompts and instructions\n- Professional formatting\n- Meaningful output\n- Graceful error handling\n\n---\n\n**Congratulations on completing Part 1 of the Kotlin Training Course!**\n\nYou're officially a Kotlin programmer! The skills you've learned here are the foundation for everything else in software development.\n\n**Ready for Part 2?** Take a break, celebrate your achievement, and then dive into Object-Oriented Programming!\n\nüéâ **PART 1 COMPLETE** üéâ\n\n---\n\n*\"The journey of a thousand apps begins with a single println.\"* - Ancient Kotlin Proverb (probably)\n\n**Keep coding, keep learning, and most importantly‚Äîhave fun!**\n\n"
            }
          ],
          "challenges": []
        }
      ],
      "quizzes": [
        {
          "id": "part1-quiz-1.1",
          "title": "What is Programming? - Knowledge Check",
          "description": "Knowledge check for What is Programming? - Knowledge Check",
          "moduleId": "module-01",
          "passingScore": 70,
          "estimatedMinutes": 6,
          "questions": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "1.1.q1",
              "title": "What is programming?",
              "description": "What is programming?",
              "options": [
                "Writing stories for computers",
                "Giving precise, step-by-step instructions to a computer",
                "Installing software on a computer",
                "Designing websites"
              ],
              "correctAnswer": 1,
              "explanation": "Programming is about giving computers precise, step-by-step instructions to accomplish tasks. It's like writing a recipe that a computer follows exactly."
            },
            {
              "type": "TRUE_FALSE",
              "id": "1.1.q2",
              "title": "Computers can understand vague or incomplete instructions.",
              "description": "Computers can understand vague or incomplete instructions.",
              "question": "Computers can understand vague or incomplete instructions.",
              "correctAnswer": false,
              "explanation": "False. Computers require precise, complete instructions. Unlike humans, they cannot infer meaning or fill in gaps."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "1.1.q3",
              "title": "Which of the following is a programming language?",
              "description": "Which of the following is a programming language?",
              "options": [
                "English",
                "Spanish",
                "Kotlin",
                "Sign Language"
              ],
              "correctAnswer": 2,
              "explanation": "Kotlin is a programming language designed for communicating with computers. Natural languages like English are for human communication."
            }
          ]
        },
        {
          "id": "part1-quiz-1.3",
          "title": "Talking to the Computer - println() Quiz",
          "description": "Knowledge check for Talking to the Computer - println() Quiz",
          "moduleId": "module-01",
          "passingScore": 70,
          "estimatedMinutes": 6,
          "questions": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "1.3.q1",
              "title": "What does println() do?",
              "description": "What does println() do?",
              "options": [
                "Reads input from the user",
                "Prints text to the screen",
                "Creates a new variable",
                "Deletes text"
              ],
              "correctAnswer": 1,
              "explanation": "println() prints (displays) text to the output screen and adds a new line at the end."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "1.3.q2",
              "title": "How do you print the text 'Hello' in Kotlin?",
              "description": "How do you print the text 'Hello' in Kotlin?",
              "options": [
                "print Hello",
                "println(Hello)",
                "println(\"Hello\")",
                "show(\"Hello\")"
              ],
              "correctAnswer": 2,
              "explanation": "Text (strings) must be enclosed in double quotes. The correct syntax is println(\"Hello\")."
            },
            {
              "type": "TRUE_FALSE",
              "id": "1.3.q3",
              "title": "The code println(42) will print the number 42.",
              "description": "The code println(42) will print the number 42.",
              "question": "The code println(42) will print the number 42.",
              "correctAnswer": true,
              "explanation": "True. Numbers don't need quotes. println(42) will print: 42"
            }
          ]
        },
        {
          "id": "part1-quiz-1.4",
          "title": "Variables Quiz",
          "description": "Knowledge check for Variables Quiz",
          "moduleId": "module-01",
          "passingScore": 70,
          "estimatedMinutes": 8,
          "questions": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "1.4.q1",
              "title": "Which keyword creates a variable that CANNOT be changed?",
              "description": "Which keyword creates a variable that CANNOT be changed?",
              "options": [
                "var",
                "val",
                "const",
                "let"
              ],
              "correctAnswer": 1,
              "explanation": "val creates an immutable (read-only) variable. Once assigned, its value cannot be changed."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "1.4.q2",
              "title": "Which keyword creates a variable that CAN be changed?",
              "description": "Which keyword creates a variable that CAN be changed?",
              "options": [
                "val",
                "var",
                "final",
                "mutable"
              ],
              "correctAnswer": 1,
              "explanation": "var creates a mutable variable whose value can be changed after initial assignment."
            },
            {
              "type": "TRUE_FALSE",
              "id": "1.4.q3",
              "title": "The code 'val age = 25' creates a variable named 'age' with value 25.",
              "description": "The code 'val age = 25' creates a variable named 'age' with value 25.",
              "question": "The code 'val age = 25' creates a variable named 'age' with value 25.",
              "correctAnswer": true,
              "explanation": "True. This creates an immutable variable called 'age' and assigns it the value 25."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "1.4.q4",
              "title": "What happens if you try to change a 'val' variable?",
              "description": "What happens if you try to change a 'val' variable?",
              "options": [
                "It works fine",
                "The program crashes",
                "You get a compilation error",
                "Nothing happens"
              ],
              "correctAnswer": 2,
              "explanation": "Trying to reassign a val variable results in a compilation error. The code won't even compile."
            }
          ]
        },
        {
          "id": "part1-quiz-1.5",
          "title": "Data Types Quiz",
          "description": "Knowledge check for Data Types Quiz",
          "moduleId": "module-01",
          "passingScore": 70,
          "estimatedMinutes": 10,
          "questions": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "1.5.q1",
              "title": "Which type is used for whole numbers?",
              "description": "Which type is used for whole numbers?",
              "options": [
                "String",
                "Double",
                "Int",
                "Boolean"
              ],
              "correctAnswer": 2,
              "explanation": "Int is used for integer (whole) numbers like 42, -10, 0."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "1.5.q2",
              "title": "Which type is used for decimal numbers?",
              "description": "Which type is used for decimal numbers?",
              "options": [
                "Int",
                "Double",
                "Float",
                "Decimal"
              ],
              "correctAnswer": 1,
              "explanation": "Double is used for decimal (floating-point) numbers like 3.14, -0.5, 2.0."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "1.5.q3",
              "title": "Which type is used for text?",
              "description": "Which type is used for text?",
              "options": [
                "Text",
                "String",
                "Char",
                "Word"
              ],
              "correctAnswer": 1,
              "explanation": "String is used for text (sequences of characters) enclosed in double quotes."
            },
            {
              "type": "TRUE_FALSE",
              "id": "1.5.q4",
              "title": "Boolean type can only be true or false.",
              "description": "Boolean type can only be true or false.",
              "question": "Boolean type can only be true or false.",
              "correctAnswer": true,
              "explanation": "True. Boolean has exactly two possible values: true or false."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "1.5.q5",
              "title": "What is the result of 10 / 3 in Kotlin (using Int division)?",
              "description": "What is the result of 10 / 3 in Kotlin (using Int division)?",
              "options": [
                "3.333",
                "3",
                "3.0",
                "4"
              ],
              "correctAnswer": 1,
              "explanation": "Integer division discards the decimal part. 10 / 3 = 3 (not 3.333...)."
            }
          ]
        },
        {
          "id": "part1-quiz-1.7",
          "title": "Functions Quiz",
          "description": "Knowledge check for Functions Quiz",
          "moduleId": "module-01",
          "passingScore": 70,
          "estimatedMinutes": 6,
          "questions": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "1.7.q1",
              "title": "What keyword is used to define a function in Kotlin?",
              "description": "What keyword is used to define a function in Kotlin?",
              "options": [
                "function",
                "def",
                "fun",
                "func"
              ],
              "correctAnswer": 2,
              "explanation": "Kotlin uses the 'fun' keyword to define functions."
            },
            {
              "type": "TRUE_FALSE",
              "id": "1.7.q2",
              "title": "Functions help you avoid repeating the same code multiple times.",
              "description": "Functions help you avoid repeating the same code multiple times.",
              "question": "Functions help you avoid repeating the same code multiple times.",
              "correctAnswer": true,
              "explanation": "True. Functions let you write code once and reuse it many times, following the DRY principle."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "1.7.q3",
              "title": "How do you call a function named 'greet'?",
              "description": "How do you call a function named 'greet'?",
              "options": [
                "call greet",
                "greet()",
                "run greet",
                "execute greet()"
              ],
              "correctAnswer": 1,
              "explanation": "Functions are called by writing their name followed by parentheses: greet()"
            }
          ]
        },
        {
          "id": "part1-quiz-1.8",
          "title": "Functions with Parameters Quiz",
          "description": "Knowledge check for Functions with Parameters Quiz",
          "moduleId": "module-01",
          "passingScore": 70,
          "estimatedMinutes": 8,
          "questions": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "1.8.q1",
              "title": "What are parameters?",
              "description": "What are parameters?",
              "options": [
                "The values a function returns",
                "The inputs a function accepts",
                "The name of a function",
                "Keywords in Kotlin"
              ],
              "correctAnswer": 1,
              "explanation": "Parameters are the inputs that a function accepts. They're like ingredients in a recipe."
            },
            {
              "type": "TRUE_FALSE",
              "id": "1.8.q2",
              "title": "A function can have multiple parameters.",
              "description": "A function can have multiple parameters.",
              "question": "A function can have multiple parameters.",
              "correctAnswer": true,
              "explanation": "True. Functions can accept zero, one, or many parameters separated by commas."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "1.8.q3",
              "title": "What does the 'return' keyword do?",
              "description": "What does the 'return' keyword do?",
              "options": [
                "Ends the program",
                "Sends a value back from a function",
                "Starts a loop",
                "Prints to the screen"
              ],
              "correctAnswer": 1,
              "explanation": "The return keyword sends a value back to the code that called the function."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "1.8.q4",
              "title": "In 'fun add(a: Int, b: Int): Int', what does ': Int' after the parameters mean?",
              "description": "In 'fun add(a: Int, b: Int): Int', what does ': Int' after the parameters mean?",
              "options": [
                "The function takes Int parameters",
                "The function returns an Int",
                "The function is named Int",
                "The function creates an Int variable"
              ],
              "correctAnswer": 1,
              "explanation": "The ': Int' after the parameters specifies the return type - what type of value the function returns."
            }
          ]
        }
      ]
    },
    {
      "id": "module-02",
      "title": "Part 2: Kotlin Fundamentals",
      "description": "Learn Kotlin programming - Part 2",
      "difficulty": "beginner",
      "estimatedHours": 8,
      "lessons": [
        {
          "id": "2.1",
          "title": "Lesson 2.1: Making Decisions - If Statements and Conditional Logic",
          "moduleId": "module-02",
          "order": 1,
          "estimatedMinutes": 60,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 60 minutes\n**Difficulty**: Beginner\n**Prerequisites**: Part 1 (Kotlin fundamentals)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Topic Introduction",
              "content": "\nWelcome to Part 2: Controlling the Flow! You've mastered Kotlin fundamentals‚Äîvariables, data types, functions, and basic input/output. Now it's time to make your programs **intelligent** by teaching them to make decisions.\n\nUp until now, your programs have executed line-by-line in a straight path, like following a recipe exactly. But real-world programs need to adapt and respond to different situations. Should you bring an umbrella? **If** it's raining, yes. **Otherwise**, no. That's conditional logic!\n\nIn this lesson, you'll learn:\n- What conditional logic is and why it's essential\n- How to use `if`, `else`, and `else if` statements\n- Comparison operators (`==`, `!=`, `<`, `>`, `<=`, `>=`)\n- How to make decisions based on Boolean conditions\n- Kotlin's unique `if` expression feature\n- Common patterns and best practices\n\nBy the end, you'll write programs that adapt their behavior based on conditions‚Äîthe foundation of all intelligent software!\n\n---\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "The Concept: Conditional Logic",
              "content": "\n### Real-World Decision Making\n\nEvery day, you make countless decisions based on conditions:\n\n\n\n\nYour brain evaluates conditions and chooses different paths automatically. Programming lets computers do the same!\n\n### The Traffic Light Analogy\n\nThink of a traffic light controlling your program's flow:\n\n- **Red light (condition false)**: Skip this block of code\n- **Green light (condition true)**: Execute this block of code\n- **Yellow light (else)**: Default path when others are false\n\nJust as traffic lights control the flow of cars, conditional statements control the flow of code execution.\n\n### What Makes a Condition?\n\nA condition is any expression that evaluates to **true** or **false** (a Boolean value):\n\n\nThe program checks the condition and decides which code to execute based on the result.\n\n---\n\n",
              "code": "age >= 18           // true if age is 18 or more\ntemperature < 32    // true if temperature is less than 32\nname == \"Alice\"     // true if name exactly equals \"Alice\"\nisRaining           // already a Boolean variable",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "The Fundamentals: If Statements",
              "content": "\n### Basic If Statement\n\nThe simplest form of conditional logic is the **if statement**:\n\n\n**Output:**\n\n**How it works:**\n1. Program evaluates `temperature > 90` ‚Üí `95 > 90` ‚Üí `true`\n2. Because the condition is true, the code inside the braces `{ }` executes\n3. Program continues to the next line after the if statement\n\n**If the temperature was 85:**\n\n**Output:**\n\n### Anatomy of an If Statement\n\n\n**Parts:**\n- `if` - Keyword that starts the conditional statement\n- `(condition)` - A Boolean expression that evaluates to true or false\n- `{ }` - Code block containing statements to execute when true\n- Indentation - Makes the code readable (best practice: 4 spaces)\n\n### Multiple Independent If Statements\n\nYou can have multiple separate if statements:\n\n\n**Output:**\n\n**Important:** Each if statement is checked independently. If `score = 85`, both the second and third conditions are true, so both messages print.\n\n---\n\n",
              "code": "Great job!\nGood effort!",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Comparison Operators",
              "content": "\nTo create conditions, you need to compare values using **comparison operators**:\n\n| Operator | Meaning | Example | Result |\n|----------|---------|---------|--------|\n| `==` | Equal to | `5 == 5` | `true` |\n| `==` | Equal to | `5 == 3` | `false` |\n| `!=` | Not equal to | `5 != 3` | `true` |\n| `!=` | Not equal to | `5 != 5` | `false` |\n| `<` | Less than | `3 < 5` | `true` |\n| `<` | Less than | `5 < 3` | `false` |\n| `>` | Greater than | `5 > 3` | `true` |\n| `<=` | Less than or equal | `5 <= 5` | `true` |\n| `>=` | Greater than or equal | `5 >= 3` | `true` |\n\n### Common Comparison Examples\n\n**Numeric comparisons:**\n\n**String comparisons:**\n\n**Boolean comparisons:**\n\n### Critical Mistake: = vs ==\n\n**The #1 beginner mistake:**\n\n‚ùå **WRONG:**\n\n‚úÖ **CORRECT:**\n\n**Remember:**\n- `=` is for **assignment** (storing a value)\n- `==` is for **comparison** (checking equality)\n\n---\n\n",
              "code": "if (age == 18) {  // This COMPARES age to 18\n    println(\"You are 18\")\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "The Else Clause",
              "content": "\nOften you want to do one thing if a condition is true, and something **different** if it's false. That's where `else` comes in:\n\n\n**Output:**\n\n**How it works:**\n- If the condition (`age >= 18`) is **true**, execute the first block\n- If the condition is **false**, execute the else block\n- Exactly ONE of the two blocks will execute, never both\n\n### The Either/Or Pattern\n\nThink of if-else as a fork in the road:\n\n\n**Real-world example:**\n\n**Output:**\n\n---\n\n",
              "code": "Opening door with key\nEntering home",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Else If: Multiple Conditions",
              "content": "\nWhat if you have more than two possibilities? Use **else if** to chain conditions:\n\n\n**Output:**\n\n### How Else If Works\n\nThe program checks conditions **in order** from top to bottom:\n\n1. Check first condition (`score >= 90`) ‚Üí `85 >= 90` ‚Üí **false**, skip\n2. Check second condition (`score >= 80`) ‚Üí `85 >= 80` ‚Üí **true**, execute and **STOP**\n3. Don't check any remaining conditions\n\n**Critical:** Once a condition is true, the rest are ignored. Order matters!\n\n**Example showing order importance:**\n\n‚ùå **WRONG ORDER:**\n**Output:** `Grade: D` (Wrong! Should be A)\n\n‚úÖ **CORRECT ORDER:**\n**Output:** `Grade: A` (Correct!)\n\n**Rule:** Put the most specific conditions first, most general conditions last.\n\n---\n\n",
              "code": "val score = 95\n\nif (score >= 90) {\n    println(\"Grade: A\")  // This executes!\n} else if (score >= 60) {\n    println(\"Grade: D\")  // Never reached (but that's okay)\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Nested If Statements",
              "content": "\nYou can put if statements inside other if statements:\n\n\n**Output:**\n\n**How it works:**\n1. Check outer condition (`age >= 16`) ‚Üí true, enter outer block\n2. Print \"You are old enough to drive\"\n3. Check inner condition (`hasLicense`) ‚Üí true, execute\n4. Print \"You can drive legally!\"\n\n**Nested if statement pattern:**\n\n**Alternative:** In the next lesson, you'll learn about **logical operators** (`&&`, `||`) which often eliminate the need for nesting.\n\n---\n\n",
              "code": "if (outerCondition) {\n    // Outer block\n    if (innerCondition) {\n        // Inner block (only reached if BOTH conditions are true)\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "If as an Expression (Kotlin Special Feature!)",
              "content": "\nHere's something unique to Kotlin: `if` is not just a statement, it's an **expression** that can return a value!\n\n**Traditional approach (statement):**\n\n**Kotlin's expression approach:**\n\nBoth do the same thing, but the expression form is cleaner and more concise!\n\n### More Expression Examples\n\n**Example 1: Max of two numbers**\n\n**Example 2: Fee calculation**\n\n**Example 3: Multi-line expression blocks**\n\n**Important:** When using if as an expression, you **must** have an else clause (the expression must always produce a value).\n\n---\n\n",
              "code": "val result = if (score >= 60) {\n    val bonus = 10\n    score + bonus  // Last expression is returned\n} else {\n    score  // Last expression is returned\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Hands-On Practice",
              "content": "\n### Exercise 1: Temperature Advisor\n\n**Challenge:** Write a program that:\n1. Takes a temperature value\n2. Prints different advice based on the temperature:\n   - If temp >= 100: \"Extreme heat warning! Stay indoors.\"\n   - If temp >= 80: \"It's hot! Stay hydrated.\"\n   - If temp >= 60: \"Nice weather!\"\n   - If temp < 60: \"It's chilly! Bring a jacket.\"\n\n<details>\n<summary>Click to see solution</summary>\n\n\n**Output:**\n\n**Key concepts:**\n- Multiple conditions with else if\n- Ordered from most specific to least specific\n- Each temperature falls into exactly one category\n</details>\n\n---\n\n### Exercise 2: Even or Odd Checker\n\n**Challenge:** Write a program that:\n1. Takes a number\n2. Checks if it's even or odd\n3. Prints the result\n\n**Hint:** Use the modulo operator `%`. A number is even if `number % 2 == 0`.\n\n<details>\n<summary>Click to see solution</summary>\n\n\n**Output:**\n\n**How it works:**\n- `%` (modulo) gives the remainder after division\n- `17 % 2` = 1 (remainder when dividing 17 by 2)\n- `1 == 0` is false, so else block executes\n\n**Even number example:**\n- `18 % 2` = 0\n- `0 == 0` is true, so if block executes\n</details>\n\n---\n\n### Exercise 3: Login System\n\n**Challenge:** Create a simple login system that:\n1. Stores a correct username and password\n2. Takes user input for username and password\n3. Checks if both match\n4. Prints \"Login successful\" or \"Login failed\"\n\n<details>\n<summary>Click to see solution</summary>\n\n\n**Sample run:**\n\n**Note:** We're using `&&` (AND operator) which you'll learn more about in the next lesson. For now, understand that both conditions must be true for the if block to execute.\n</details>\n\n---\n\n### Exercise 4: Discount Calculator\n\n**Challenge:** Write a program that:\n1. Takes a purchase amount\n2. Applies discounts based on the amount:\n   - $100+: 20% discount\n   - $50-$99: 10% discount\n   - Under $50: No discount\n3. Prints the final price\n\n<details>\n<summary>Click to see solution</summary>\n\n\n**Output:**\n\n**Key concepts:**\n- Using if as an expression to calculate the discount\n- Storing the result in a variable\n- Performing calculations with the result\n</details>\n\n---\n\n",
              "code": "Original price: $75.0\nDiscount: 10.0%\nFinal price: $67.5",
              "language": "kotlin"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls and Best Practices",
              "content": "\n### Pitfall 1: Missing Braces\n\nWhile braces are optional for single statements, **always use them** for clarity:\n\n‚ö†Ô∏è **Risky (works but confusing):**\n\n‚úÖ **Better (clear and safe):**\n\n### Pitfall 2: Semicolons After Conditions\n\n‚ùå **WRONG:**\n\nThis creates an empty if statement, and the code block always executes!\n\n‚úÖ **CORRECT:**\n\n### Pitfall 3: Comparing Floating-Point Numbers with ==\n\nFloating-point arithmetic can be imprecise:\n\n‚ùå **Risky:**\n\n‚úÖ **Better:**\n\n### Best Practice 1: Readable Conditions\n\nUse descriptive variable names and comments for complex conditions:\n\n‚ùå **Unclear:**\n\n‚úÖ **Clear:**\n\n### Best Practice 2: Positive Conditions\n\nWhen possible, write conditions in positive form:\n\n‚ö†Ô∏è **Harder to read:**\n\n‚úÖ **Easier to read:**\n\n---\n\n",
              "code": "if (isValid) {\n    // Do something\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Quick Quiz",
              "content": "\nTest your understanding:\n\n**Question 1:** What will this code print?\n\n<details>\n<summary>Answer</summary>\n\n**Output:** `Keep trying!`\n\n**Explanation:** `75 >= 80` is false, so the else block executes.\n</details>\n\n---\n\n**Question 2:** What's wrong with this code?\n\n<details>\n<summary>Answer</summary>\n\n**Error:** Using `=` instead of `==`\n\n`=` is assignment, `==` is comparison. Should be:\n</details>\n\n---\n\n**Question 3:** What will this print if temperature = 85?\n\n<details>\n<summary>Answer</summary>\n\n**Output:**\n\n**Explanation:** These are three separate if statements (not else if). Both `85 > 80` and `85 > 70` are true, so both B and C print.\n</details>\n\n---\n\n**Question 4:** Is this valid Kotlin code?\n\n<details>\n<summary>Answer</summary>\n\n**Yes!** This is valid. In Kotlin, `if` is an expression and can return a value. The result will be \"Positive\" if x > 0, otherwise \"Non-positive\".\n</details>\n\n---\n\n",
              "code": "val result = if (x > 0) \"Positive\" else \"Non-positive\"",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Advanced Bonus: When to Use If vs When",
              "content": "\nWhile you'll learn about `when` expressions in the next lesson, here's a preview of when to use each:\n\n**Use if/else for:**\n- Binary decisions (two outcomes)\n- Range comparisons\n- Simple conditions\n\n**Use when (covered next lesson) for:**\n- Multiple specific values\n- Complex condition patterns\n- More than 3-4 options\n\n**Example - if is fine here:**\n\n**Example - when is better (preview):**\n\n---\n\n",
              "code": "when (dayOfWeek) {\n    1 -> \"Monday\"\n    2 -> \"Tuesday\"\n    3 -> \"Wednesday\"\n    // ... cleaner than many else ifs\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Summary",
              "content": "\nCongratulations! You've mastered conditional logic with if statements. Let's recap:\n\n**Key Concepts:**\n- **Conditional logic** lets programs make decisions based on conditions\n- **If statements** execute code blocks when conditions are true\n- **Comparison operators** (`==`, `!=`, `<`, `>`, `<=`, `>=`) create conditions\n- **Else** provides an alternative path when the condition is false\n- **Else if** chains multiple conditions (checked top to bottom)\n- **Nested if** statements check conditions within conditions\n- **Kotlin's if expression** can return values (unique feature!)\n\n**Common Patterns:**\n\n**Best Practices:**\n- Always use `==` for comparison, not `=`\n- Use braces `{ }` even for single statements\n- Order else-if conditions from specific to general\n- Use descriptive variable names for complex conditions\n- Prefer positive conditions over negative when possible\n\n---\n\n",
              "code": "// Simple if\nif (condition) { /* code */ }\n\n// If-else\nif (condition) { /* code */ } else { /* code */ }\n\n// If-else if chain\nif (condition1) { /* code */ }\nelse if (condition2) { /* code */ }\nelse { /* code */ }\n\n// If as expression\nval result = if (condition) value1 else value2",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nYou can now make basic decisions, but what if you need to combine multiple conditions? \"IF it's raining AND I don't have an umbrella, THEN get wet!\"\n\nIn the next lesson, you'll learn **logical operators** (`&&`, `||`, `!`) to combine and invert conditions, making your decision-making even more powerful!\n\n**Preview:**\n\n---\n\n**Great work! You've completed Lesson 2.1. Mark it complete and continue to Lesson 2.2!** üéâ\n\n",
              "code": "if (isRaining && !hasUmbrella) {\n    println(\"You'll get wet!\")\n}\n\nif (age < 13 || age > 65) {\n    println(\"Discounted ticket\")\n}",
              "language": "kotlin"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "2.1.1",
              "title": "Age Checker",
              "description": "Write a program that checks if age >= 18 and prints 'Adult' or 'Minor'.",
              "instructions": "Write a program that checks if age >= 18 and prints 'Adult' or 'Minor'.",
              "starterCode": "fun main() {\n    val age = 20\n    // Use if/else to check age\n    \n}",
              "solution": "fun main() {\n    val age = 20\n    if (age >= 18) {\n        println(\"Adult\")\n    } else {\n        println(\"Minor\")\n    }\n}",
              "language": "kotlin",
              "testCases": [
                {
                  "description": "For age 20, prints 'Adult'",
                  "expectedOutput": "Adult",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use if (condition) { } else { }"
                },
                {
                  "level": 2,
                  "text": "Check: age >= 18"
                },
                {
                  "level": 3,
                  "text": "Print appropriate message in each branch"
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "2.1.2",
              "title": "Grade Calculator",
              "description": "Given a score, print the letter grade (A: 90+, B: 80+, C: 70+, D: 60+, F: below 60).",
              "instructions": "Given a score, print the letter grade (A: 90+, B: 80+, C: 70+, D: 60+, F: below 60).",
              "starterCode": "fun main() {\n    val score = 85\n    // Use if/else if/else to determine grade\n    \n}",
              "solution": "fun main() {\n    val score = 85\n    if (score >= 90) {\n        println(\"A\")\n    } else if (score >= 80) {\n        println(\"B\")\n    } else if (score >= 70) {\n        println(\"C\")\n    } else if (score >= 60) {\n        println(\"D\")\n    } else {\n        println(\"F\")\n    }\n}",
              "language": "kotlin",
              "testCases": [
                {
                  "description": "For score 85, prints 'B'",
                  "expectedOutput": "B",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use else if for multiple conditions"
                },
                {
                  "level": 2,
                  "text": "Check from highest to lowest"
                },
                {
                  "level": 3,
                  "text": "Score 85 should print 'B'"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "2.2",
          "title": "Lesson 2.2: Combining Conditions - Logical Operators",
          "moduleId": "module-02",
          "order": 2,
          "estimatedMinutes": 55,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 55 minutes\n**Difficulty**: Beginner\n**Prerequisites**: Lesson 2.1 (If statements)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Topic Introduction",
              "content": "\nIn the last lesson, you learned to make decisions with if statements and simple conditions. But real-world decisions often involve **multiple conditions** working together:\n\n- \"**IF** it's raining **AND** I don't have an umbrella, **THEN** I'll get wet\"\n- \"**IF** you're under 13 **OR** over 65, **THEN** you get a discount\"\n- \"**IF** the door is **NOT** locked, **THEN** you can enter\"\n\nNotice the words **AND**, **OR**, and **NOT**? These are **logical operators**, and they let you combine and modify conditions to create more sophisticated decision-making logic.\n\nIn this lesson, you'll learn:\n- The three logical operators: AND (`&&`), OR (`||`), and NOT (`!`)\n- How to combine multiple conditions\n- Truth tables and how logical operators work\n- Short-circuit evaluation for efficiency\n- Common patterns and best practices\n- How to simplify complex conditional logic\n\nBy the end, you'll write elegant code that handles complex real-world scenarios!\n\n---\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "The Concept: Logical Operators",
              "content": "\n### Real-World Logic\n\nThink about these everyday decisions:\n\n**AND logic (both must be true):**\n\n**OR logic (at least one must be true):**\n\n**NOT logic (invert/flip the condition):**\n\nProgramming uses these exact same patterns!\n\n### The Three Logical Operators\n\n| Operator | Name | Symbol | Meaning |\n|----------|------|--------|---------|\n| AND | Logical AND | `&&` | Both conditions must be true |\n| OR | Logical OR | `\\|\\|` | At least one condition must be true |\n| NOT | Logical NOT | `!` | Inverts/flips the condition |\n\n---\n\n",
              "code": "IF the alarm is NOT set:\n    You can leave without disabling it",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "The AND Operator (&&)",
              "content": "\nThe AND operator (`&&`) returns `true` only when **BOTH** conditions are true.\n\n### Truth Table for AND\n\n| Condition A | Condition B | A && B |\n|-------------|-------------|--------|\n| true | true | **true** |\n| true | false | false |\n| false | true | false |\n| false | false | false |\n\n**Think of it as:** \"This **AND** that\" - you need **both**.\n\n### Basic AND Example\n\n\n**Output:**\n\n**What if hasID was false?**\n\n**Output:**\n\n### Real-World AND Examples\n\n**Example 1: Age and license check**\n\n**Example 2: Login validation**\n\n**Example 3: Range check (value between two numbers)**\n\n### Chaining Multiple AND Conditions\n\nYou can chain more than two conditions:\n\n\nAll three conditions must be true for the message to print.\n\n---\n\n",
              "code": "fun main() {\n    val hasPassport = true\n    val hasVisa = true\n    val hasTicket = true\n\n    if (hasPassport && hasVisa && hasTicket) {\n        println(\"You're ready for international travel!\")\n    } else {\n        println(\"Missing required documents\")\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "The OR Operator (||)",
              "content": "\nThe OR operator (`||`) returns `true` when **AT LEAST ONE** condition is true.\n\n### Truth Table for OR\n\n| Condition A | Condition B | A \\|\\| B |\n|-------------|-------------|----------|\n| true | true | **true** |\n| true | false | **true** |\n| false | true | **true** |\n| false | false | false |\n\n**Think of it as:** \"This **OR** that\" - you need **at least one**.\n\n### Basic OR Example\n\n\n**Output:**\n\nEven though `isPremiumMember` is false, `hasVIPPass` is true, so the condition succeeds!\n\n### Real-World OR Examples\n\n**Example 1: Weekend check**\n\n**Example 2: Discount eligibility**\n\n**Output:**\n\nThe person is over 65, so they qualify (even though they're not a student).\n\n**Example 3: Emergency access**\n\n---\n\n",
              "code": "fun main() {\n    val isAdmin = false\n    val isEmergency = true\n\n    if (isAdmin || isEmergency) {\n        println(\"Access granted\")\n    } else {\n        println(\"Access denied\")\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "The NOT Operator (!)",
              "content": "\nThe NOT operator (`!`) **inverts** (flips) a Boolean value.\n\n### Truth Table for NOT\n\n| Condition | !Condition |\n|-----------|------------|\n| true | **false** |\n| false | **true** |\n\n**Think of it as:** \"The opposite of...\"\n\n### Basic NOT Example\n\n\n**Output:**\n\n`isRaining` is false, so `!isRaining` becomes true, and the if block executes.\n\n### Real-World NOT Examples\n\n**Example 1: Checking if not equal**\n\n**Note:** This is the same as `status != \"completed\"`. The `!=` operator is actually a shorthand for `!(... == ...)`.\n\n**Example 2: Door lock check**\n\n**Example 3: Inverting complex conditions**\n\n**Output:**\n\n---\n\n",
              "code": "Access granted",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Combining Logical Operators",
              "content": "\nYou can combine AND, OR, and NOT in the same expression!\n\n### Example: Comprehensive Access Control\n\n\n**How it evaluates:**\n1. `age >= 18` ‚Üí `17 >= 18` ‚Üí false\n2. `hasParentConsent` ‚Üí true\n3. `false || true` ‚Üí **true** (at least one is true)\n4. `!isVIP` ‚Üí `!false` ‚Üí **true**\n5. `true && true` ‚Üí **true** (both parts are true)\n6. Execute the if block\n\n### Order of Operations (Precedence)\n\nJust like math has PEMDAS, logical operators have precedence:\n\n1. **`!` (NOT)** - Highest priority\n2. **`&&` (AND)** - Medium priority\n3. **`||` (OR)** - Lowest priority\n\n**Example:**\n\n**Evaluation order:**\n1. `!false` ‚Üí true (NOT first)\n2. `true && true` ‚Üí true (AND second)\n3. `true || false` ‚Üí true (OR last)\n\n**Use parentheses for clarity:**\n\n### Complex Real-World Example: Movie Ticket Eligibility\n\n\n**Breaking it down:**\n- Age check: `age >= 17` is false, but `age >= 13 && hasParentConsent` is true ‚Üí **passes**\n- Showing access: `isMember` is true ‚Üí **passes**\n- Both conditions pass ‚Üí **can watch!**\n\n---\n\n",
              "code": "fun main() {\n    val age = 16\n    val hasParentConsent = true\n    val isMatinee = false\n    val isMember = true\n\n    // Movie is R-rated, requires 17+ OR 13-16 with parent consent\n    // Additionally, members get access to any showing, non-members only matinee\n    val canWatch = (age >= 17 || (age >= 13 && hasParentConsent)) &&\n                   (isMember || isMatinee)\n\n    if (canWatch) {\n        println(\"Enjoy the movie!\")\n    } else {\n        println(\"Cannot watch this movie\")\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Short-Circuit Evaluation",
              "content": "\nThis is an important optimization that logical operators use:\n\n### AND Short-Circuit\n\nWith `&&`, if the **first** condition is false, the second condition **isn't even checked** (because the result will be false regardless).\n\n\nSince `a` is false, `b` is **never evaluated**! This saves time.\n\n**Practical example:**\n\nIf the list is empty, `numbers[0]` would crash the program! But short-circuit evaluation saves us‚Äîit never checks `numbers[0]` because `numbers.isNotEmpty()` is already false.\n\n### OR Short-Circuit\n\nWith `||`, if the **first** condition is true, the second condition **isn't checked** (because the result will be true regardless).\n\n\nSince `isAdmin` is true, `hasSpecialPermission` is **never checked**!\n\n**Important:** Be careful with side effects! Don't put critical code in conditions that might not execute:\n\n‚ùå **WRONG:**\n\n---\n\n",
              "code": "if (isLoggedIn || performLogin()) {  // performLogin might not run!\n    // ...\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Hands-On Practice",
              "content": "\n### Exercise 1: Age and Height Restriction\n\n**Challenge:** An amusement park ride requires:\n- Age >= 12 AND height >= 48 inches\n\nWrite a program that checks if someone can ride.\n\n<details>\n<summary>Click to see solution</summary>\n\n\n**Output:**\n\n**Both conditions must be true:**\n- `14 >= 12` ‚Üí true\n- `50 >= 48` ‚Üí true\n- `true && true` ‚Üí true\n</details>\n\n---\n\n### Exercise 2: Weekend or Holiday\n\n**Challenge:** Write a program that prints \"Day off!\" if it's either:\n- Saturday OR Sunday OR a holiday\n\n<details>\n<summary>Click to see solution</summary>\n\n\n**Output:**\n\n**At least one condition is true:**\n- `day == \"Saturday\"` ‚Üí false\n- `day == \"Sunday\"` ‚Üí false\n- `isHoliday` ‚Üí true\n- `false || false || true` ‚Üí true\n</details>\n\n---\n\n### Exercise 3: Password Validation\n\n**Challenge:** Create a password validator that checks if a password is valid. A valid password must:\n- Be at least 8 characters long AND\n- NOT be \"password123\" (too common)\n\n<details>\n<summary>Click to see solution</summary>\n\n\n**Output:**\n\n**Evaluation:**\n- `password.length >= 8` ‚Üí `12 >= 8` ‚Üí true\n- `password != \"password123\"` ‚Üí true\n- `true && true` ‚Üí true\n</details>\n\n---\n\n### Exercise 4: Temperature Alert System\n\n**Challenge:** Write a program that alerts if temperature is dangerous:\n- Below 32¬∞F (freezing) OR above 100¬∞F (heat danger)\n\n<details>\n<summary>Click to see solution</summary>\n\n\n**Output:**\n\n**Evaluation:**\n- `28 < 32` ‚Üí true\n- `28 > 100` ‚Üí false\n- `true || false` ‚Üí true\n</details>\n\n---\n\n",
              "code": "‚ö†Ô∏è Temperature alert! Take precautions.",
              "language": "kotlin"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls and Best Practices",
              "content": "\n### Pitfall 1: Confusing && with ||\n\n‚ùå **WRONG (wants AND but uses OR):**\n\n‚úÖ **CORRECT:**\n\n### Pitfall 2: Redundant Comparisons\n\n‚ùå **Redundant:**\n\n‚úÖ **Clean:**\n\n‚ùå **Redundant:**\n\n‚úÖ **Clean:**\n\n### Pitfall 3: Complex Nested Conditions\n\n‚ùå **Hard to read:**\n\n‚úÖ **Use variables for clarity:**\n\n### Best Practice 1: Use Parentheses for Complex Logic\n\nMake your intent crystal clear:\n\n\n### Best Practice 2: DeMorgan's Laws\n\nSometimes you can simplify logic using DeMorgan's Laws:\n\n**DeMorgan's Law 1:**\n\n**DeMorgan's Law 2:**\n\n**Example:**\n\n---\n\n",
              "code": "// These are equivalent:\nif (!(isWeekend && isHoliday)) { /* ... */ }\nif (!isWeekend || !isHoliday) { /* ... */ }",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Quick Quiz",
              "content": "\n**Question 1:** What will this code print?\n\n<details>\n<summary>Answer</summary>\n\n**Output:** `B`\n\n**Explanation:** `true && false` is false, so the else block executes.\n</details>\n\n---\n\n**Question 2:** What will this code print?\n\n<details>\n<summary>Answer</summary>\n\n**Output:** `Yes`\n\n**Explanation:**\n- `x > 0` ‚Üí `5 > 0` ‚Üí true\n- `y < 0` ‚Üí `10 < 0` ‚Üí false\n- `true || false` ‚Üí true\n\nAt least one condition is true, so \"Yes\" prints.\n</details>\n\n---\n\n**Question 3:** Simplify this condition:\n\n<details>\n<summary>Answer</summary>\n\n**Simplified:**\n\n**Explanation:** \"NOT less than 18\" is the same as \"greater than or equal to 18\".\n</details>\n\n---\n\n",
              "code": "if (age >= 18) {\n    println(\"Adult\")\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Summary",
              "content": "\nCongratulations! You've mastered logical operators. Let's recap:\n\n**Key Concepts:**\n- **AND (`&&`)**: Both conditions must be true\n- **OR (`||`)**: At least one condition must be true\n- **NOT (`!`)**: Inverts/flips a Boolean value\n- **Short-circuit evaluation**: Optimization that skips unnecessary checks\n- **Precedence**: `!` ‚Üí `&&` ‚Üí `||` (use parentheses for clarity)\n\n**Truth Tables:**\n\n**Common Patterns:**\n\n**Best Practices:**\n- Use parentheses to make complex conditions clear\n- Extract complex logic into named Boolean variables\n- Remember short-circuit evaluation for efficiency\n- Avoid redundant comparisons with Boolean variables\n\n---\n\n",
              "code": "// Range check\nif (x >= min && x <= max) { }\n\n// Multiple options\nif (option1 || option2 || option3) { }\n\n// Exclusion check\nif (condition && !exception) { }\n\n// Complex logic\nif ((condition1 || condition2) && !condition3) { }",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nYou can now combine multiple conditions, but what if you have many different cases to check? \"If grade is A, print this. If B, print that. If C, print something else...\"\n\nIn the next lesson, you'll learn the **when expression**‚ÄîKotlin's elegant way to handle multiple specific cases without writing long if-else chains!\n\n**Preview:**\n\n---\n\n**Excellent progress! Mark this lesson complete and continue to Lesson 2.3!** üéâ\n\n",
              "code": "when (grade) {\n    'A' -> println(\"Excellent!\")\n    'B' -> println(\"Great!\")\n    'C' -> println(\"Good!\")\n    else -> println(\"Keep trying!\")\n}",
              "language": "kotlin"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "2.2.1",
              "title": "Can Drive Check",
              "description": "Check if someone can drive (age >= 16 AND hasLicense is true).",
              "instructions": "Check if someone can drive (age >= 16 AND hasLicense is true).",
              "starterCode": "fun main() {\n    val age = 17\n    val hasLicense = true\n    // Check if can drive\n    \n}",
              "solution": "fun main() {\n    val age = 17\n    val hasLicense = true\n    if (age >= 16 && hasLicense) {\n        println(\"Can drive\")\n    } else {\n        println(\"Cannot drive\")\n    }\n}",
              "language": "kotlin",
              "testCases": [
                {
                  "description": "Prints 'Can drive' for age 17 with license",
                  "expectedOutput": "Can drive",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use && for AND logic"
                },
                {
                  "level": 2,
                  "text": "Both conditions must be true"
                },
                {
                  "level": 3,
                  "text": "Syntax: if (condition1 && condition2)"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "2.3",
          "title": "Lesson 2.3: The When Expression - Elegant Multi-Way Decisions",
          "moduleId": "module-02",
          "order": 3,
          "estimatedMinutes": 60,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 60 minutes\n**Difficulty**: Beginner\n**Prerequisites**: Lesson 2.1 (If statements), Lesson 2.2 (Logical operators)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Topic Introduction",
              "content": "\nYou've learned how to make decisions with `if-else` statements and combine conditions with logical operators. But what happens when you need to check many different possibilities? Imagine writing a program that converts day numbers to day names, or grades to letter marks. Using `if-else` chains becomes verbose and hard to read.\n\nEnter Kotlin's `when` expression‚Äîan elegant, powerful alternative that makes multi-way decisions clean and expressive. Think of it as a sophisticated switchboard operator, efficiently routing your program to the right destination based on various conditions.\n\nIn this lesson, you'll learn:\n- What the `when` expression is and when to use it\n- How to match against specific values\n- Using `when` with ranges and complex conditions\n- The power of `when` as an expression\n- Pattern matching and smart casts\n- Best practices for clean, maintainable code\n\nBy the end, you'll be able to write elegant decision logic that's both powerful and easy to understand!\n\n---\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "The Concept: When as a Switchboard",
              "content": "\n### Real-World Analogy: The Hotel Concierge\n\nImagine a hotel concierge helping guests:\n\n\nThe concierge efficiently routes to one answer based on the weather. That's exactly what `when` does‚Äîit evaluates an expression once and routes to the matching branch.\n\n### The if-else-if Problem\n\nLet's see why we need `when`. Here's a day-of-week converter using if-else:\n\n\nThis works, but it's:\n- **Repetitive**: `dayNumber ==` appears 7 times\n- **Verbose**: 19 lines for a simple mapping\n- **Error-prone**: Easy to make mistakes in long chains\n\n**The same logic with `when`:**\n\n\nOnly 10 lines! Clean, readable, and elegant.\n\n---\n\n",
              "code": "val dayNumber = 3\nval dayName = when (dayNumber) {\n    1 -> \"Monday\"\n    2 -> \"Tuesday\"\n    3 -> \"Wednesday\"\n    4 -> \"Thursday\"\n    5 -> \"Friday\"\n    6 -> \"Saturday\"\n    7 -> \"Sunday\"\n    else -> \"Invalid day\"\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Basic When Expression",
              "content": "\n### Syntax and Structure\n\n\n**Parts:**\n- `when` - Keyword starting the expression\n- `(expression)` - The value to match against\n- `value ->` - Match condition followed by arrow\n- `result` - What to return/execute when matched\n- `else` - Default case (like the final \"otherwise\")\n\n### Your First When Expression\n\n\n**Output:**\n\n**How it works:**\n1. Evaluate the expression: `trafficLight` = \"Red\"\n2. Check each branch from top to bottom\n3. Find match: `\"Red\"` matches first branch\n4. Return result: `\"Stop\"`\n5. Assign to `action` variable\n6. Skip remaining branches\n\n---\n\n",
              "code": "Traffic light is Red: Stop",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "When with Multiple Values",
              "content": "\nYou can match multiple values in one branch using commas:\n\n\n**Output:**\n\nThis is much cleaner than:\n\n### Practical Example: Weekend Checker\n\n\n**Output:**\n\n---\n\n",
              "code": "Saturday is a Weekend\nTime to relax!",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "When with Ranges",
              "content": "\nOne of `when`'s superpowers is matching against ranges using the `in` keyword:\n\n\n**Output:**\n\n### How Ranges Work\n\n**Range syntax:**\n- `0..10` - Includes both 0 and 10 (closed range)\n- `in range` - Checks if value is within the range\n\n**Examples:**\n\n### Temperature Advisory System\n\n\n**Output:**\n\n---\n\n",
              "code": "Temperature: 75¬∞F\nWarm and pleasant",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "When with Conditions (No Argument)",
              "content": "\nYou can use `when` without an argument to write complex conditions:\n\n\n**Output:**\n\n**This form is perfect when:**\n- Conditions are complex\n- You're checking different variables\n- Conditions don't follow a simple pattern\n\n### Example: Shipping Cost Calculator\n\n\n**Output:**\n\n---\n\n",
              "code": "Weight: 15.0 lbs, Distance: 500 miles\nShipping cost: $0.0",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "When as a Statement vs Expression",
              "content": "\n### When as Expression (Returns a Value)\n\n\n### When as Statement (Just Executes Code)\n\n\n### Complete Example\n\n\n**Output:**\n\n---\n\n",
              "code": "Checking credentials...\nWelcome back!\nLog entry: User logged in",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "When with Type Checking (Smart Casts)",
              "content": "\nKotlin's `when` can check types and automatically cast variables:\n\n\n**Output:**\n\n**Note:** After `is String`, Kotlin knows `value` is a String and lets you use `.length` without casting!\n\n---\n\n",
              "code": "Text: 'Hello' (length: 5)\nNumber: 42 (doubled: 84)\nBoolean: true (opposite: false)\nList with 3 items",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Hands-On Exercises",
              "content": "\n### Exercise 1: Calculator\n\n**Challenge:** Create a simple calculator using `when` that:\n1. Takes two numbers and an operator (+, -, *, /)\n2. Performs the operation\n3. Returns the result\n\n<details>\n<summary>Click to see solution</summary>\n\n\n**Output:**\n\n**Key concepts:**\n- Using `when` for operator selection\n- Handling division by zero\n- Returning calculated values\n</details>\n\n---\n\n### Exercise 2: Movie Rating System\n\n**Challenge:** Create a movie rating system that converts numeric ratings to descriptions:\n- 10: \"Masterpiece\"\n- 8-9: \"Excellent\"\n- 6-7: \"Good\"\n- 4-5: \"Average\"\n- 1-3: \"Poor\"\n- 0: \"Terrible\"\n\n<details>\n<summary>Click to see solution</summary>\n\n\n**Output:**\n</details>\n\n---\n\n### Exercise 3: Password Strength Checker\n\n**Challenge:** Create a password strength checker that evaluates based on length:\n- Less than 6: \"Weak\"\n- 6-8: \"Medium\"\n- 9-12: \"Strong\"\n- 13+: \"Very Strong\"\n\nAlso check if the password is a common password (use when without argument).\n\n<details>\n<summary>Click to see solution</summary>\n\n\n**Output:**\n\n**Key concepts:**\n- Using when without an argument\n- Checking membership with `in`\n- Combining multiple conditions\n</details>\n\n---\n\n### Exercise 4: BMI Category Calculator\n\n**Challenge:** Calculate BMI category:\n- BMI < 18.5: \"Underweight\"\n- BMI 18.5-24.9: \"Normal weight\"\n- BMI 25.0-29.9: \"Overweight\"\n- BMI ‚â• 30.0: \"Obese\"\n\n<details>\n<summary>Click to see solution</summary>\n\n\n**Output:**\n</details>\n\n---\n\n",
              "code": "BMI: 22.9\nCategory: Normal weight",
              "language": "kotlin"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls and Best Practices",
              "content": "\n### Pitfall 1: Missing else in Expressions\n\n‚ùå **Error:**\n\n‚úÖ **Correct:**\n\n**Rule:** When used as an expression (returning a value), `else` is required unless the compiler can prove all cases are covered.\n\n### Pitfall 2: Overlapping Ranges\n\n‚ùå **Problem:**\n\nThe second range is completely covered by the first. `when` executes the **first** matching branch.\n\n‚úÖ **Correct:**\n\n### Pitfall 3: Forgetting Braces for Multiple Statements\n\n‚ùå **Won't compile:**\n\n‚úÖ **Correct:**\n\n### Best Practice 1: Order Matters\n\nPut the most specific cases first:\n\n‚úÖ **Good:**\n\n### Best Practice 2: Use When for 3+ Options\n\n- **2 options:** Use `if-else`\n- **3+ options:** Use `when`\n\n\n### Best Practice 3: Exhaustive When\n\nFor enums and sealed classes, you can make `when` exhaustive without `else`:\n\n\n---\n\n",
              "code": "enum class Direction { NORTH, SOUTH, EAST, WEST }\n\nfun move(direction: Direction) = when (direction) {\n    Direction.NORTH -> \"Going north\"\n    Direction.SOUTH -> \"Going south\"\n    Direction.EAST -> \"Going east\"\n    Direction.WEST -> \"Going west\"\n    // No else needed - all cases covered!\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Quick Quiz",
              "content": "\n**Question 1:** What will this print?\n\n<details>\n<summary>Answer</summary>\n\n**Output:** `Medium`\n\n**Explanation:** `5` is in the range `4..6`, so \"Medium\" is returned.\n</details>\n\n---\n\n**Question 2:** Is this valid code?\n\n<details>\n<summary>Answer</summary>\n\n**Yes!** This is valid. When used as a **statement** (not returning a value), `else` is optional. If `day = 3`, nothing will print.\n</details>\n\n---\n\n**Question 3:** What's wrong with this?\n\n<details>\n<summary>Answer</summary>\n\n**Problem:** The second branch (`in 90..100`) will never execute because it's completely covered by the first branch (`in 0..100`). Always put more specific conditions first!\n\n**Fixed:**\n</details>\n\n---\n\n**Question 4:** Can you use `when` with strings?\n\n<details>\n<summary>Answer</summary>\n\n**Yes!** `when` works with any type:\n\n</details>\n\n---\n\n",
              "code": "val fruit = \"apple\"\nwhen (fruit) {\n    \"apple\" -> println(\"Red or green\")\n    \"banana\" -> println(\"Yellow\")\n    else -> println(\"Unknown fruit\")\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Summary",
              "content": "\nCongratulations! You've mastered Kotlin's `when` expression. Let's recap:\n\n**Key Concepts:**\n- **When expression** provides elegant multi-way decisions\n- **Value matching** checks against specific values\n- **Multiple values** can be matched with commas\n- **Ranges** use `in` keyword for range checking\n- **Conditions** can be complex with argument-less when\n- **Type checking** with `is` and smart casts\n- **Expression vs statement** - expressions need else\n\n**When Syntax Patterns:**\n\n**Best Practices:**\n- Use `when` for 3+ options\n- Put specific cases before general ones\n- Always include `else` for expressions\n- Use braces for multi-statement branches\n- Consider ranges for numeric values\n\n---\n\n",
              "code": "// Basic value matching\nwhen (x) {\n    1 -> \"One\"\n    2, 3 -> \"Two or Three\"\n    else -> \"Other\"\n}\n\n// Range matching\nwhen (score) {\n    in 90..100 -> \"A\"\n    in 80..89 -> \"B\"\n    else -> \"C or lower\"\n}\n\n// Condition matching\nwhen {\n    x > 10 -> \"Large\"\n    x > 5 -> \"Medium\"\n    else -> \"Small\"\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nYou can now make sophisticated decisions with `when`, but what about repeating tasks? What if you need to print \"Hello\" 100 times, or process every item in a list?\n\nIn **Lesson 2.4: Repeating Tasks - For Loops**, you'll learn:\n- How to repeat code with for loops\n- Iterating through ranges and collections\n- Advanced loop techniques: step, downTo, until\n- Practical applications of iteration\n\n**Preview:**\n\n---\n\n**Excellent work! You've completed Lesson 2.3. Continue to master loops next!** üéâ\n\n",
              "code": "for (i in 1..10) {\n    println(\"Count: $i\")\n}\n\nfor (day in listOf(\"Mon\", \"Tue\", \"Wed\")) {\n    println(\"Today is $day\")\n}",
              "language": "kotlin"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "2.3.1",
              "title": "Day of Week",
              "description": "Use 'when' to print if a day number (1-7) is a weekday or weekend.",
              "instructions": "Use 'when' to print if a day number (1-7) is a weekday or weekend.",
              "starterCode": "fun main() {\n    val day = 6\n    // Use when to check day\n    \n}",
              "solution": "fun main() {\n    val day = 6\n    when (day) {\n        in 1..5 -> println(\"Weekday\")\n        6, 7 -> println(\"Weekend\")\n        else -> println(\"Invalid\")\n    }\n}",
              "language": "kotlin",
              "testCases": [
                {
                  "description": "For day 6, prints 'Weekend'",
                  "expectedOutput": "Weekend",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use 'when (day) { }'"
                },
                {
                  "level": 2,
                  "text": "Use 'in 1..5' for range"
                },
                {
                  "level": 3,
                  "text": "Day 6 is Weekend"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "2.4",
          "title": "Lesson 2.4: Repeating Tasks - For Loops and Iteration",
          "moduleId": "module-02",
          "order": 4,
          "estimatedMinutes": 60,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 60 minutes\n**Difficulty**: Beginner\n**Prerequisites**: Lesson 2.3 (When expressions)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Topic Introduction",
              "content": "\nImagine you need to send birthday invitations to 50 friends. Would you write 50 separate print statements? Of course not! You'd use a loop to repeat the same task with different values. That's the power of iteration‚Äîdoing something multiple times without writing repetitive code.\n\nIn programming, we frequently need to:\n- Process every item in a list\n- Repeat an action a specific number of times\n- Count through a sequence of numbers\n- Iterate through collections of data\n\nKotlin's `for` loop makes all of this elegant and easy. Unlike many languages where loops can be complex and error-prone, Kotlin's for loop is designed to be safe, concise, and expressive.\n\nIn this lesson, you'll learn:\n- What iteration means and why it's essential\n- How to use for loops with ranges\n- Iterating through collections and lists\n- Working with indices\n- Advanced loop techniques: step, downTo, until\n- Best practices for clean, efficient loops\n\nBy the end, you'll be able to process data efficiently and write powerful, concise code!\n\n---\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "The Concept: Repetition in Programming",
              "content": "\n### Real-World Iteration\n\nYou perform iteration constantly in daily life:\n\n**Making pancakes:**\n\n**Checking email:**\n\n**Grading papers:**\n\nIn each case, you're **repeating the same steps** for different items. That's exactly what loops do in programming!\n\n### The Manual vs Loop Comparison\n\n**Without loops (manual repetition):**\n\n**With loops (automatic repetition):**\n\nThe loop version:\n- Works for any number of names\n- Less code to write and maintain\n- Easy to modify (change the greeting in one place)\n- No chance of typos from copying and pasting\n\n---\n\n",
              "code": "val names = listOf(\"Alice\", \"Bob\", \"Charlie\", \"Diana\", \"Eve\")\nfor (name in names) {\n    println(\"Welcome, $name!\")\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Basic For Loop with Ranges",
              "content": "\n### Your First For Loop\n\n\n**Output:**\n\n**How it works:**\n1. `for` - Keyword that starts the loop\n2. `i` - Loop variable (can be any name)\n3. `in` - Keyword meaning \"within\" or \"through\"\n4. `1..5` - Range from 1 to 5 (inclusive)\n5. Loop body executes once for each value in the range\n\n### Anatomy of a For Loop\n\n\n**Visual flow:**\n\n### Practical Example: Countdown Timer\n\n\n**Output:**\n\n---\n\n",
              "code": "Rocket launch countdown:\n10...\n9...\n8...\n...\n1...\nüöÄ BLAST OFF!",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Understanding Ranges",
              "content": "\nKotlin has several ways to create ranges:\n\n### Inclusive Range (..)\n\n\nBoth 1 and 10 are **included**.\n\n### Exclusive Range (until)\n\n\n10 is **excluded** (stops before 10).\n\n**Use case:** Perfect for array/list indices which start at 0:\n\n### Reverse Range (downTo)\n\n\nCounts **backwards** from 10 to 1.\n\n### Step Ranges (step)\n\n\nIncrements by 2 instead of 1 (counts even numbers).\n\n**Combined example:**\n\n### Range Quick Reference\n\n\n---\n\n",
              "code": "1..10       // 1, 2, 3, ..., 10 (inclusive)\n1 until 10  // 1, 2, 3, ..., 9 (exclusive end)\n10 downTo 1 // 10, 9, 8, ..., 1 (reverse)\n1..10 step 2 // 1, 3, 5, 7, 9 (every 2nd)",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Iterating Through Collections",
              "content": "\n### For Loop with Lists\n\n\n**Output:**\n\n**How it works:** The loop variable `fruit` takes on each value in the list, one at a time.\n\n### For Loop with Strings\n\nStrings are collections of characters, so you can iterate through them:\n\n\n**Output:**\n\n### Practical Example: Shopping Cart Total\n\n\n**Output:**\n\n---\n\n",
              "code": "Shopping cart total: $215.95",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Working with Indices",
              "content": "\nSometimes you need both the **index** (position) and the **value**:\n\n### Using indices Property\n\n\n**Output:**\n\n**Note:** `languages.indices` creates a range `0 until languages.size`.\n\n### Using withIndex()\n\nThe elegant approach‚Äîget both index and value:\n\n\n**Output:** (same as above)\n\n**Bonus:** More readable and less error-prone!\n\n### Practical Example: Leaderboard\n\n\n**Output:**\n\n---\n\n",
              "code": "=== Game Leaderboard ===\n#1 - Alice: 950 points\n#2 - Bob: 880 points\n#3 - Charlie: 920 points\n#4 - Diana: 900 points",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Nested Loops",
              "content": "\nYou can put loops inside other loops:\n\n### Basic Nested Loop\n\n\n**Output:**\n\n**How it works:**\n- Outer loop runs 3 times (i = 1, 2, 3)\n- For each outer iteration, inner loop runs 3 times (j = 1, 2, 3)\n- Total: 3 √ó 3 = 9 iterations\n\n### Practical Example: Multiplication Table\n\n\n**Output:**\n\n### Pattern Printing: Triangle\n\n\n**Output:**\n\n---\n\n",
              "code": "*\n* *\n* * *\n* * * *\n* * * * *",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Hands-On Exercises",
              "content": "\n### Exercise 1: Sum of Numbers\n\n**Challenge:** Calculate the sum of all numbers from 1 to 100 using a for loop.\n\n<details>\n<summary>Click to see solution</summary>\n\n\n**Output:**\n\n**Key concepts:**\n- Using a range with for loop\n- Accumulating values in a variable\n- The `+=` compound operator\n\n**Bonus - Math fact:** The formula is n(n+1)/2 = 100(101)/2 = 5050\n</details>\n\n---\n\n### Exercise 2: FizzBuzz\n\n**Challenge:** The classic FizzBuzz problem:\n- Print numbers 1 to 30\n- For multiples of 3, print \"Fizz\" instead\n- For multiples of 5, print \"Buzz\" instead\n- For multiples of both 3 and 5, print \"FizzBuzz\"\n\n<details>\n<summary>Click to see solution</summary>\n\n\n**Output:**\n\n**Key concepts:**\n- Combining for loops with when expressions\n- Using modulo operator for divisibility\n- Order matters (check 15 before 3 or 5)\n</details>\n\n---\n\n### Exercise 3: Reverse a String\n\n**Challenge:** Write a program that reverses a string using a for loop.\n\n**Example:** \"KOTLIN\" ‚Üí \"NILTOK\"\n\n<details>\n<summary>Click to see solution</summary>\n\n\n**Output:**\n\n**Alternative solution using indices:**\n\n**Key concepts:**\n- String indexing\n- Reverse iteration with downTo\n- String concatenation\n</details>\n\n---\n\n### Exercise 4: Find Maximum Value\n\n**Challenge:** Given a list of numbers, find the maximum value using a for loop.\n\n<details>\n<summary>Click to see solution</summary>\n\n\n**Output:**\n\n**Alternative using indices:**\n\n**Key concepts:**\n- Tracking maximum value\n- Comparing values in a loop\n- Initializing with first element\n</details>\n\n---\n\n",
              "code": "fun main() {\n    val numbers = listOf(45, 23, 67, 12, 89, 34, 56)\n    var max = numbers[0]\n    var maxIndex = 0\n\n    for (i in numbers.indices) {\n        if (numbers[i] > max) {\n            max = numbers[i]\n            maxIndex = i\n        }\n    }\n\n    println(\"Maximum value: $max at index $maxIndex\")\n}",
              "language": "kotlin"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls and Best Practices",
              "content": "\n### Pitfall 1: Off-By-One Errors\n\n‚ùå **Common mistake:**\n\n‚úÖ **Correct:**\n\n### Pitfall 2: Modifying Collection While Iterating\n\n‚ùå **Dangerous:**\n\n‚úÖ **Safe approach:**\n\nOr use built-in functions:\n\n### Pitfall 3: Unnecessary Index Variables\n\n‚ö†Ô∏è **Okay but verbose:**\n\n‚úÖ **Better:**\n\n**Rule:** Only use indices when you actually need them.\n\n### Best Practice 1: Descriptive Variable Names\n\n‚ùå **Unclear:**\n\n‚úÖ **Clear:**\n\n### Best Practice 2: Use Ranges Appropriately\n\n\n### Best Practice 3: Choose the Right Loop Type\n\n\n---\n\n",
              "code": "// Need the value only? Iterate directly\nfor (fruit in fruits) { println(fruit) }\n\n// Need index and value? Use withIndex()\nfor ((index, fruit) in fruits.withIndex()) {\n    println(\"$index: $fruit\")\n}\n\n// Need just the index? Use indices\nfor (i in fruits.indices) {\n    println(\"Position $i\")\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Quick Quiz",
              "content": "\n**Question 1:** What does this print?\n\n<details>\n<summary>Answer</summary>\n\n**Output:** `1 3 5`\n\n**Explanation:** Starts at 1, increments by 2 each time, up to 5.\n- First iteration: i = 1\n- Second iteration: i = 3\n- Third iteration: i = 5\n- Stop (next would be 7, which is > 5)\n</details>\n\n---\n\n**Question 2:** How many times does this loop run?\n\n<details>\n<summary>Answer</summary>\n\n**Answer:** 10 times (prints 0 through 9)\n\n**Explanation:** `until` is exclusive of the end value. So `0 until 10` means 0, 1, 2, 3, 4, 5, 6, 7, 8, 9.\n</details>\n\n---\n\n**Question 3:** What's the output?\n\n<details>\n<summary>Answer</summary>\n\n**Output:** `H i`\n\n**Explanation:** Strings are iterable. The loop goes through each character: 'H' then 'i'.\n</details>\n\n---\n\n**Question 4:** How do you loop backwards from 10 to 1?\n\n<details>\n<summary>Answer</summary>\n\n\n**Explanation:** Use `downTo` to create a reverse range.\n</details>\n\n---\n\n",
              "code": "for (i in 10 downTo 1) {\n    println(i)\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Summary",
              "content": "\nCongratulations! You've mastered for loops in Kotlin. Let's recap:\n\n**Key Concepts:**\n- **For loops** repeat code for each item in a collection or range\n- **Ranges** define sequences: `1..10`, `1 until 10`, `10 downTo 1`\n- **Step** allows custom increments: `0..100 step 5`\n- **Collections** can be iterated directly or with indices\n- **withIndex()** provides both index and value\n- **Nested loops** enable multi-dimensional iteration\n\n**For Loop Patterns:**\n\n**Best Practices:**\n- Iterate directly when you don't need indices\n- Use `indices` or `until` to avoid off-by-one errors\n- Use descriptive variable names\n- Don't modify collections while iterating\n- Choose the simplest loop form for your needs\n\n---\n\n",
              "code": "// Range iteration\nfor (i in 1..10) { }\n\n// Collection iteration\nfor (item in collection) { }\n\n// With index\nfor ((index, item) in collection.withIndex()) { }\n\n// Using indices\nfor (i in collection.indices) { }\n\n// Reverse\nfor (i in 10 downTo 1) { }\n\n// With step\nfor (i in 0..100 step 10) { }",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nFor loops are great when you know how many times to iterate, but what about situations where you need to repeat until a condition is met? What if you need to keep asking for valid input until the user gets it right?\n\nIn **Lesson 2.5: While Loops and Do-While**, you'll learn:\n- While loops for condition-based repetition\n- Do-while loops (execute at least once)\n- Break and continue for loop control\n- Infinite loops and how to guard against them\n\n**Preview:**\n\n---\n\n**Fantastic progress! You've completed Lesson 2.4. Keep up the momentum!** üéâ\n\n",
              "code": "var attempts = 0\nwhile (attempts < 3) {\n    println(\"Attempt ${attempts + 1}\")\n    attempts++\n}\n\ndo {\n    val input = readln()\n} while (input != \"quit\")",
              "language": "kotlin"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "2.4.1",
              "title": "Count to 10",
              "description": "Use a for loop to print numbers 1 to 10, each on a new line.",
              "instructions": "Use a for loop to print numbers 1 to 10, each on a new line.",
              "starterCode": "fun main() {\n    // Use for loop to print 1 to 10\n    \n}",
              "solution": "fun main() {\n    for (i in 1..10) {\n        println(i)\n    }\n}",
              "language": "kotlin",
              "testCases": [
                {
                  "description": "Prints numbers 1-10",
                  "expectedOutput": "1\n2\n3\n4\n5\n6\n7\n8\n9\n10",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use for (i in 1..10)"
                },
                {
                  "level": 2,
                  "text": "println(i) inside the loop"
                },
                {
                  "level": 3,
                  "text": "Range is inclusive: 1..10 includes both 1 and 10"
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "2.4.2",
              "title": "Sum of Range",
              "description": "Calculate the sum of numbers from 1 to 5 using a for loop.",
              "instructions": "Calculate the sum of numbers from 1 to 5 using a for loop.",
              "starterCode": "fun main() {\n    var sum = 0\n    // Use for loop to add numbers 1 to 5\n    \n    println(sum)\n}",
              "solution": "fun main() {\n    var sum = 0\n    for (i in 1..5) {\n        sum += i\n    }\n    println(sum)\n}",
              "language": "kotlin",
              "testCases": [
                {
                  "description": "Prints 15",
                  "expectedOutput": "15",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Initialize sum = 0"
                },
                {
                  "level": 2,
                  "text": "Use sum += i in the loop"
                },
                {
                  "level": 3,
                  "text": "1+2+3+4+5 = 15"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "2.5",
          "title": "Lesson 2.5: While Loops and Do-While - Condition-Based Repetition",
          "moduleId": "module-02",
          "order": 5,
          "estimatedMinutes": 55,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 55 minutes\n**Difficulty**: Beginner\n**Prerequisites**: Lesson 2.4 (For loops)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Topic Introduction",
              "content": "\nYou've mastered for loops, which are perfect when you know exactly how many times to repeat something. But programming often requires a different kind of repetition‚Äîrepeating until a condition is met, not a fixed number of times.\n\nThink about real-life scenarios:\n- Keep entering your password **until** it's correct\n- Keep rolling dice **until** you get a six\n- Keep asking for menu input **until** the user chooses \"quit\"\n- Download data **while** there's more to download\n\nThese situations don't have a predetermined number of iterations‚Äîthey continue based on a **condition**. That's where `while` and `do-while` loops shine!\n\nIn this lesson, you'll learn:\n- The difference between while and do-while loops\n- When to use each type of loop\n- How to control loops with break and continue\n- Avoiding infinite loops\n- Common patterns and best practices\n\nBy the end, you'll know how to choose the right loop for any situation!\n\n---\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "The Concept: Condition-Based Repetition",
              "content": "\n### Real-World While Loops\n\nYou use condition-based repetition constantly:\n\n**Making coffee:**\n\n**Waiting in line:**\n\n**Learning to ride a bike:**\n\nThe key difference from for loops: **You don't know beforehand how many times you'll repeat**. You repeat until a condition changes.\n\n### For vs While: The Fundamental Difference\n\n**Use FOR when:**\n- You know the number of iterations upfront\n- You're iterating through a collection\n- You're counting within a specific range\n\n\n**Use WHILE when:**\n- You repeat until a condition changes\n- The number of iterations is unknown\n- You're waiting for user input or external event\n\n\n---\n\n",
              "code": "// I don't know when user will enter \"quit\"\nvar input = \"\"\nwhile (input != \"quit\") {\n    input = readln()\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "The While Loop",
              "content": "\n### Basic While Loop Syntax\n\n\n**How it works:**\n1. Check the condition\n2. If true, execute the body\n3. Return to step 1\n4. If false, skip the body and continue\n\n### Your First While Loop\n\n\n**Output:**\n\n**Flow:**\n\n### Practical Example: Password Validator\n\n\n**Sample Run:**\n\n---\n\n",
              "code": "Enter password: hello\nIncorrect. 2 attempts remaining.\nEnter password: world\nIncorrect. 1 attempts remaining.\nEnter password: kotlin123\nAccess granted!",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "The Do-While Loop",
              "content": "\n### The Critical Difference\n\n**While loop:** Check condition FIRST, then execute (may not execute at all)\n\n**Do-while loop:** Execute FIRST, then check condition (executes at least once)\n\n### Do-While Syntax\n\n\n### Comparison Example\n\n\n**Output:**\n\n### When to Use Do-While\n\nPerfect for situations where you **must** execute the code at least once:\n\n**Menu systems:**\n\n**Sample Run:**\n\n### Input Validation Example\n\n\n**Sample Run:**\n\n---\n\n",
              "code": "Enter your age (1-120): 150\nInvalid age. Please try again.\nEnter your age (1-120): abc\nInvalid age. Please try again.\nEnter your age (1-120): 25\nAge recorded: 25",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Break and Continue",
              "content": "\n### The break Statement\n\n**Purpose:** Exit the loop immediately, even if the condition is still true.\n\n\n**Output:**\n\n**Practical example: Search**\n\n**Output:**\n\n### The continue Statement\n\n**Purpose:** Skip the rest of the current iteration and move to the next one.\n\n\n**Output:**\n\n**How it works:**\n- When `number` is even, `continue` is executed\n- Skip `println(number)`\n- Jump back to the condition check\n- Continue with next iteration\n\n### Break vs Continue Comparison\n\n\n**Output:**\n\n---\n\n",
              "code": "=== Break Example ===\n1 2 3 4\n\n=== Continue Example ===\n1 2 3 4 6 7 8 9 10",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Infinite Loops and Guards",
              "content": "\n### What is an Infinite Loop?\n\nAn infinite loop is a loop that never ends because its condition never becomes false:\n\n\n**This will:**\n- Run indefinitely\n- Freeze your program\n- Consume CPU and memory\n- Require force-stopping\n\n### Intentional Infinite Loops\n\nSometimes infinite loops are **intentional** and controlled with `break`:\n\n\nThis is safe because we have a guaranteed exit condition.\n\n### Common Infinite Loop Mistakes\n\n‚ùå **Mistake 1: Forgetting to update the condition**\n\n‚ùå **Mistake 2: Wrong update direction**\n\n‚ùå **Mistake 3: Condition that can't change**\n\n### Infinite Loop Guards\n\nAlways ask yourself:\n1. **Does my condition eventually become false?**\n2. **Do I update the variables in the condition?**\n3. **Is there a guaranteed exit (break)?**\n\n‚úÖ **Safe pattern:**\n\n---\n\n",
              "code": "var attempts = 0\nval maxAttempts = 1000  // Safety limit\n\nwhile (condition && attempts < maxAttempts) {\n    // Loop body\n    attempts++\n}\n\nif (attempts >= maxAttempts) {\n    println(\"Warning: Loop limit reached\")\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Hands-On Exercises",
              "content": "\n### Exercise 1: Number Guessing Game\n\n**Challenge:** Create a number guessing game where:\n1. Computer picks a random number 1-100\n2. User keeps guessing until correct\n3. Provide \"higher\" or \"lower\" hints\n4. Count the number of guesses\n\n<details>\n<summary>Click to see solution</summary>\n\n\n**Sample Run:**\n\n**Key concepts:**\n- Do-while ensures at least one guess\n- Using random numbers\n- Tracking attempts with a counter\n</details>\n\n---\n\n### Exercise 2: Sum Until Zero\n\n**Challenge:** Keep asking user for numbers and sum them. Stop when user enters 0.\n\n<details>\n<summary>Click to see solution</summary>\n\n\n**Sample Run:**\n</details>\n\n---\n\n### Exercise 3: Fibonacci Sequence\n\n**Challenge:** Print Fibonacci numbers while they're less than 1000.\n\nFibonacci: Each number is the sum of the previous two (1, 1, 2, 3, 5, 8, 13...)\n\n<details>\n<summary>Click to see solution</summary>\n\n\n**Output:**\n\n**Key concepts:**\n- While(true) with break for complex conditions\n- Updating multiple variables\n- Fibonacci algorithm\n</details>\n\n---\n\n### Exercise 4: Print Even Numbers\n\n**Challenge:** Print even numbers from 1 to 20 using a while loop and continue.\n\n<details>\n<summary>Click to see solution</summary>\n\n\n**Output:**\n\n**Alternative without continue:**\n</details>\n\n---\n\n",
              "code": "fun main() {\n    var number = 0\n\n    println(\"Even numbers from 1 to 20:\")\n\n    while (number < 20) {\n        number++\n\n        if (number % 2 == 0) {\n            print(\"$number \")\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls and Best Practices",
              "content": "\n### Pitfall 1: Infinite Loops from Typos\n\n‚ùå **Dangerous typo:**\n\n‚úÖ **Safe:**\n\n### Pitfall 2: Off-by-One Errors\n\n‚ùå **Subtle bug:**\n\n‚úÖ **Correct:**\n\n### Pitfall 3: Not Validating Input\n\n‚ùå **Crash risk:**\n\n‚úÖ **Safe:**\n\n### Best Practice 1: Always Have an Exit\n\nEvery loop should have a clear, guaranteed exit condition:\n\n\n### Best Practice 2: Initialize Before Loop\n\n\n### Best Practice 3: Choose the Right Loop\n\n\n---\n\n",
              "code": "// Use while when condition-based\nvar keepGoing = true\nwhile (keepGoing) {\n    val choice = readln()\n    if (choice == \"quit\") keepGoing = false\n}\n\n// Use for when count-based\nfor (i in 1..10) {\n    println(i)\n}\n\n// Use do-while when must execute once\ndo {\n    showMenu()\n    choice = readln()\n} while (choice != \"exit\")",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Quick Quiz",
              "content": "\n**Question 1:** What's the output?\n\n<details>\n<summary>Answer</summary>\n\n**Output:** `5 4 3 2 1`\n\n**Explanation:** Starts at 5, prints and decrements until x reaches 0 (loop stops when x is not > 0).\n</details>\n\n---\n\n**Question 2:** How many times does this execute?\n\n<details>\n<summary>Answer</summary>\n\n**Answer:** 0 times\n\n**Explanation:** The condition `10 < 5` is false from the start, so the loop body never executes.\n</details>\n\n---\n\n**Question 3:** What's the difference between these?\n\n<details>\n<summary>Answer</summary>\n\n**Answer:**\n- **A (while):** Checks condition FIRST. Might not execute at all.\n- **B (do-while):** Executes FIRST, then checks. Always executes at least once.\n\n**Example:**\nOutput: `B`\n</details>\n\n---\n\n**Question 4:** What does break do?\n\n<details>\n<summary>Answer</summary>\n\n**Answer:** `break` immediately exits the loop, regardless of the condition.\n\n**Example:**\n</details>\n\n---\n\n",
              "code": "while (true) {\n    val input = readln()\n    if (input == \"quit\") {\n        break  // Exit the infinite loop\n    }\n    println(\"You said: $input\")\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Summary",
              "content": "\nCongratulations! You've mastered condition-based loops. Let's recap:\n\n**Key Concepts:**\n- **While loops** repeat based on conditions, not counts\n- **Do-while loops** execute at least once before checking\n- **Break** exits the loop immediately\n- **Continue** skips to the next iteration\n- **Infinite loops** can be intentional with proper guards\n\n**Loop Decision Guide:**\n\n**Control Flow:**\n\n**Best Practices:**\n- Always ensure loops can exit\n- Validate user input\n- Initialize variables before loops\n- Use meaningful variable names\n- Guard against infinite loops\n\n**Common Patterns:**\n\n---\n\n",
              "code": "// Input validation\ndo {\n    // Get input\n} while (invalid)\n\n// Menu systems\nwhile (choice != \"quit\") {\n    // Show menu\n}\n\n// Search until found\nwhile (!found && index < size) {\n    // Search logic\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nYou now have complete control over program flow‚Äîdecisions and loops! But how do you store and work with multiple pieces of related data? What if you need to manage a shopping cart with many items, or a class roster with dozens of students?\n\nIn **Lesson 2.6: Lists - Storing Multiple Items**, you'll learn:\n- Creating and using lists\n- Mutable vs immutable lists\n- Adding, removing, and accessing elements\n- Powerful list operations: filter, map, and more\n- Real-world list applications\n\n**Preview:**\n\n---\n\n**Outstanding work! You've completed Lesson 2.5. Lists await you next!** üéâ\n\n",
              "code": "val fruits = listOf(\"Apple\", \"Banana\", \"Cherry\")\nval numbers = mutableListOf(1, 2, 3)\nnumbers.add(4)\n\nval doubled = numbers.map { it * 2 }\nval evens = numbers.filter { it % 2 == 0 }",
              "language": "kotlin"
            }
          ],
          "challenges": []
        },
        {
          "id": "2.6",
          "title": "Lesson 2.6: Lists - Storing Multiple Items",
          "moduleId": "module-02",
          "order": 6,
          "estimatedMinutes": 65,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 65 minutes\n**Difficulty**: Beginner\n**Prerequisites**: Lesson 2.5 (While loops)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Topic Introduction",
              "content": "\nSo far, you've stored individual pieces of data in variables‚Äîa single name, one number, a single temperature. But real-world programs need to manage collections of related data: a shopping cart with multiple items, a class roster with dozens of students, a playlist with hundreds of songs.\n\nImagine creating a task manager app. Would you create separate variables for each task?\n\n\nThis is impractical and impossible to maintain. **Lists** solve this problem elegantly by storing multiple items in a single, ordered collection.\n\nIn this lesson, you'll learn:\n- What lists are and why they're essential\n- Creating immutable and mutable lists\n- Accessing, adding, and removing elements\n- Essential list operations and functions\n- Powerful functional programming with lists\n- Best practices for working with collections\n\nBy the end, you'll be able to manage collections of data like a pro!\n\n---\n\n",
              "code": "val task1 = \"Buy groceries\"\nval task2 = \"Call dentist\"\nval task3 = \"Finish homework\"\n// ... task50?",
              "language": "kotlin"
            },
            {
              "type": "ANALOGY",
              "title": "The Concept: Lists as Containers",
              "content": "\n### Real-World List Analogy\n\nThink of a list as a **numbered filing cabinet**:\n\n\n**Properties of this cabinet:**\n- **Ordered**: Items have specific positions (0, 1, 2, 3)\n- **Indexed**: You can access any item by its position\n- **Dynamic**: You can add or remove items (if mutable)\n- **Homogeneous**: Usually stores items of the same type\n\n### Why Use Lists?\n\n**Without lists:**\n\n**With lists:**\n\nLists give you:\n- ‚úÖ Organization: Group related data\n- ‚úÖ Flexibility: Easily add/remove items\n- ‚úÖ Iteration: Loop through all items\n- ‚úÖ Built-in operations: Sort, filter, search, and more\n\n---\n\n",
              "code": "val students = listOf(\"Alice\", \"Bob\", \"Charlie\")\n\n// Easy to loop through\nfor (student in students) {\n    println(student)\n}\n\n// Easy to add more (with mutableListOf)",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Creating Lists",
              "content": "\n### Immutable Lists (Read-Only)\n\nCreated with `listOf()`:\n\n\n**Immutable means:**\n- ‚ùå Can't add items\n- ‚ùå Can't remove items\n- ‚ùå Can't change items\n- ‚úÖ Can read and iterate\n- ‚úÖ Thread-safe and predictable\n\n**When to use:** When your collection won't change (days of the week, menu options, etc.)\n\n### Mutable Lists (Can Change)\n\nCreated with `mutableListOf()`:\n\n\n**Output:**\n\n**When to use:** When your collection needs to change (shopping cart, todo list, etc.)\n\n### Empty Lists\n\n\n### Lists with Type Inference\n\n\n---\n\n",
              "code": "// Kotlin infers type from values\nval numbers = listOf(1, 2, 3, 4, 5)  // List<Int>\nval names = listOf(\"Alice\", \"Bob\")    // List<String>\nval mixed = listOf<Any>(1, \"two\", 3.0) // List<Any>\n\n// Explicit type declaration\nval scores: List<Int> = listOf(95, 87, 92)",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Accessing List Elements",
              "content": "\n### Indexing (Zero-Based)\n\nLists use **zero-based indexing**‚Äîthe first element is at position 0:\n\n\n**Visual representation:**\n\n### Safe Access Methods\n\n\n### First, Last, and More\n\n\n---\n\n",
              "code": "fun main() {\n    val numbers = listOf(10, 20, 30, 40, 50)\n\n    println(\"First: ${numbers.first()}\")     // 10\n    println(\"Last: ${numbers.last()}\")       // 50\n    println(\"Size: ${numbers.size}\")         // 5\n    println(\"Is empty: ${numbers.isEmpty()}\") // false\n\n    // Safe versions\n    val empty = emptyList<Int>()\n    println(empty.firstOrNull())  // null (no error)\n    println(empty.lastOrNull())   // null\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Modifying Mutable Lists",
              "content": "\n### Adding Elements\n\n\n### Removing Elements\n\n\n### Updating Elements\n\n\n---\n\n",
              "code": "fun main() {\n    val tasks = mutableListOf(\"Buy milk\", \"Call mom\", \"Study Kotlin\")\n\n    // Update by index\n    tasks[0] = \"Buy groceries\"\n    println(tasks)  // [Buy groceries, Call mom, Study Kotlin]\n\n    // Update with set()\n    tasks.set(1, \"Video call mom\")\n    println(tasks)  // [Buy groceries, Video call mom, Study Kotlin]\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Common List Operations",
              "content": "\n### Checking Contents\n\n\n### Finding Elements\n\n\n### Sorting Lists\n\n\n---\n\n",
              "code": "fun main() {\n    val numbers = mutableListOf(5, 2, 8, 1, 9)\n\n    // Sort in place (modifies original)\n    numbers.sort()\n    println(\"Sorted: $numbers\")  // [1, 2, 5, 8, 9]\n\n    // Reverse sort\n    numbers.sortDescending()\n    println(\"Descending: $numbers\")  // [9, 8, 5, 2, 1]\n\n    // Sorted (returns new list, original unchanged)\n    val original = listOf(5, 2, 8, 1, 9)\n    val sorted = original.sorted()\n    println(\"Original: $original\")  // [5, 2, 8, 1, 9]\n    println(\"Sorted: $sorted\")      // [1, 2, 5, 8, 9]\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Functional Operations on Lists",
              "content": "\n### Map (Transform Each Element)\n\n\n**Map pattern:**\n\n### Filter (Keep Only Matching Items)\n\n\n**Filter pattern:**\n\n### Combining Map and Filter\n\n\n### Other Useful Operations\n\n\n---\n\n",
              "code": "fun main() {\n    val numbers = listOf(1, 2, 3, 4, 5)\n\n    // Sum\n    println(\"Sum: ${numbers.sum()}\")  // 15\n\n    // Average\n    println(\"Average: ${numbers.average()}\")  // 3.0\n\n    // Max and Min\n    println(\"Max: ${numbers.maxOrNull()}\")  // 5\n    println(\"Min: ${numbers.minOrNull()}\")  // 1\n\n    // Any (at least one matches)\n    println(\"Any > 3? ${numbers.any { it > 3 }}\")  // true\n\n    // All (all match)\n    println(\"All > 0? ${numbers.all { it > 0 }}\")  // true\n\n    // None (none match)\n    println(\"None < 0? ${numbers.none { it < 0 }}\")  // true\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Hands-On Exercises",
              "content": "\n### Exercise 1: Shopping Cart Manager\n\n**Challenge:** Create a shopping cart system that:\n1. Starts with an empty mutable list\n2. Allows adding items\n3. Displays all items\n4. Calculates total (assume each item costs $10)\n5. Removes items\n\n<details>\n<summary>Click to see solution</summary>\n\n\n**Output:**\n</details>\n\n---\n\n### Exercise 2: Grade Analyzer\n\n**Challenge:** Given a list of test scores:\n1. Calculate average\n2. Find highest and lowest scores\n3. Count how many passed (‚â•60)\n4. Filter and display only passing grades\n\n<details>\n<summary>Click to see solution</summary>\n\n\n**Output:**\n</details>\n\n---\n\n### Exercise 3: Word Filter\n\n**Challenge:** Create a program that:\n1. Takes a list of words\n2. Filters words longer than 5 characters\n3. Converts them to uppercase\n4. Sorts them alphabetically\n\n<details>\n<summary>Click to see solution</summary>\n\n\n**Output:**\n</details>\n\n---\n\n### Exercise 4: Number Statistics\n\n**Challenge:** Create a statistics program that takes a list of numbers and displays:\n1. Sum\n2. Average\n3. Numbers above average\n4. Numbers below average\n5. Median (middle value when sorted)\n\n<details>\n<summary>Click to see solution</summary>\n\n\n**Output:**\n</details>\n\n---\n\n",
              "code": "Numbers: [23, 45, 12, 67, 34, 89, 15, 56, 78, 91]\n\nSum: 510\nAverage: 51.0\n\nAbove average (5): [67, 89, 56, 78, 91]\nBelow average (5): [23, 45, 12, 34, 15]\n\nSorted: [12, 15, 23, 34, 45, 56, 67, 78, 89, 91]\nMedian: 50.5",
              "language": "kotlin"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls and Best Practices",
              "content": "\n### Pitfall 1: Index Out of Bounds\n\n‚ùå **Crash:**\n\n‚úÖ **Safe:**\n\n### Pitfall 2: Modifying Immutable Lists\n\n‚ùå **Error:**\n\n‚úÖ **Correct:**\n\n### Pitfall 3: Forgetting Lists Are Zero-Indexed\n\n‚ùå **Confusion:**\n\n‚úÖ **Remember:**\n\n### Best Practice 1: Use val with Mutable Lists\n\n\n### Best Practice 2: Prefer Immutable When Possible\n\n\n### Best Practice 3: Use Collection Functions\n\n\n---\n\n",
              "code": "// ‚ùå Manual (verbose)\nval numbers = listOf(1, 2, 3, 4, 5)\nval evens = mutableListOf<Int>()\nfor (num in numbers) {\n    if (num % 2 == 0) {\n        evens.add(num)\n    }\n}\n\n// ‚úÖ Functional (concise)\nval evens2 = numbers.filter { it % 2 == 0 }",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Quick Quiz",
              "content": "\n**Question 1:** What's the output?\n\n<details>\n<summary>Answer</summary>\n\n**Output:**\n\n**Explanation:** `list[0]` gets the first element, `last()` gets the last element.\n</details>\n\n---\n\n**Question 2:** What's wrong with this code?\n\n<details>\n<summary>Answer</summary>\n\n**Error:** `listOf()` creates an **immutable** list. You can't add to it.\n\n**Fix:** Use `mutableListOf()` instead:\n</details>\n\n---\n\n**Question 3:** What does this produce?\n\n<details>\n<summary>Answer</summary>\n\n**Output:** `[6, 8, 10]`\n\n**Explanation:**\n1. Filter keeps: `[3, 4, 5]` (values > 2)\n2. Map doubles: `[6, 8, 10]`\n</details>\n\n---\n\n**Question 4:** What's the size?\n\n<details>\n<summary>Answer</summary>\n\n**Output:** `3`\n\n**Explanation:**\n1. Start: `[1, 2, 3]` (size 3)\n2. Add 4: `[1, 2, 3, 4]` (size 4)\n3. Remove 2: `[1, 3, 4]` (size 3)\n</details>\n\n---\n\n",
              "code": "val list = mutableListOf(1, 2, 3)\nlist.add(4)\nlist.remove(2)\nprintln(list.size)",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Summary",
              "content": "\nCongratulations! You've mastered lists in Kotlin. Let's recap:\n\n**Key Concepts:**\n- **Lists** store multiple items in order\n- **Immutable lists** (`listOf`) can't be changed\n- **Mutable lists** (`mutableListOf`) can be modified\n- **Zero-indexed**: First element is at index 0\n- **Rich operations**: map, filter, sort, find, and more\n\n**List Creation:**\n\n**Common Operations:**\n\n**Best Practices:**\n- Use immutable lists by default\n- Prefer collection functions over manual loops\n- Use safe access methods (getOrNull)\n- Remember zero-based indexing\n- Use val with mutable lists\n\n---\n\n",
              "code": "// Access\nlist[0], list.first(), list.last()\n\n// Modify (mutable only)\nlist.add(item)\nlist.remove(item)\nlist.removeAt(index)\n\n// Transform\nlist.map { }      // Transform each\nlist.filter { }   // Keep matching\nlist.sorted()     // Sort\n\n// Aggregate\nlist.sum()\nlist.average()\nlist.maxOrNull()",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nYou can now store and manipulate lists of items, but what if you need to look up data by a key? Like finding a phone number by name, or a definition by word?\n\nIn **Lesson 2.7: Maps and Part 2 Capstone**, you'll learn:\n- Maps for key-value pairs\n- Creating and using maps\n- Map operations and functions\n- **Part 2 Capstone Project**: Combine everything you've learned!\n\n**Preview:**\n\nGet ready for the final lesson of Part 2 and an exciting capstone project!\n\n---\n\n**Amazing progress! You've completed Lesson 2.6. One more lesson to go!** üéâ\n\n",
              "code": "val phoneBook = mapOf(\n    \"Alice\" to \"555-1234\",\n    \"Bob\" to \"555-5678\"\n)\n\nprintln(phoneBook[\"Alice\"])  // 555-1234",
              "language": "kotlin"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "2.6.1",
              "title": "Find Maximum",
              "description": "Find and print the maximum number in a list.",
              "instructions": "Find and print the maximum number in a list.",
              "starterCode": "fun main() {\n    val numbers = listOf(3, 7, 2, 9, 4)\n    // Find and print the maximum\n    \n}",
              "solution": "fun main() {\n    val numbers = listOf(3, 7, 2, 9, 4)\n    val max = numbers.maxOrNull()\n    println(max)\n}",
              "language": "kotlin",
              "testCases": [
                {
                  "description": "Prints 9",
                  "expectedOutput": "9",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use maxOrNull() function"
                },
                {
                  "level": 2,
                  "text": "List has built-in max function"
                },
                {
                  "level": 3,
                  "text": "Answer should be 9"
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "2.6.2",
              "title": "Filter Even Numbers",
              "description": "Filter and print only even numbers from a list.",
              "instructions": "Filter and print only even numbers from a list.",
              "starterCode": "fun main() {\n    val numbers = listOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n    // Filter even numbers and print\n    \n}",
              "solution": "fun main() {\n    val numbers = listOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n    val evens = numbers.filter { it % 2 == 0 }\n    println(evens)\n}",
              "language": "kotlin",
              "testCases": [
                {
                  "description": "Prints list of even numbers",
                  "expectedOutput": "[2, 4, 6, 8, 10]",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use filter { }"
                },
                {
                  "level": 2,
                  "text": "Check it % 2 == 0"
                },
                {
                  "level": 3,
                  "text": "Result: [2, 4, 6, 8, 10]"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "2.7",
          "title": "Lesson 2.7: Maps and Part 2 Capstone Project",
          "moduleId": "module-02",
          "order": 7,
          "estimatedMinutes": 70,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 70 minutes\n**Difficulty**: Beginner\n**Prerequisites**: Lesson 2.6 (Lists)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Topic Introduction",
              "content": "\nYou've mastered lists‚Äîordered collections accessed by numeric indices. But what if you need to look up data by something more meaningful than a number? What if you need to:\n\n- Find a phone number by a person's name\n- Look up a product price by its name\n- Get a user's email by their username\n- Translate a word from English to Spanish\n\nYou *could* use two parallel lists (one for keys, one for values), but that's clunky and error-prone. **Maps** solve this elegantly by storing **key-value pairs**‚Äîlike a real-world dictionary where you look up a word (key) to find its definition (value).\n\nIn this lesson, you'll learn:\n- What maps are and when to use them\n- Creating immutable and mutable maps\n- Accessing, adding, and removing entries\n- Iterating through maps\n- Common map operations\n- **Part 2 Capstone Project**: Build a complete contact management system!\n\nThis is the final lesson of Part 2, so we'll finish strong with a comprehensive project that combines everything you've learned!\n\n---\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "The Concept: Key-Value Pairs",
              "content": "\n### Real-World Map Analogy\n\nThink of a map like a **phone book** or **dictionary**:\n\n\n**Properties:**\n- **Keys are unique**: Can't have two \"Alice\" entries\n- **Keys map to values**: Each key has exactly one value\n- **Fast lookup**: Find value by key instantly\n- **Unordered**: Entries aren't in a specific order (usually)\n\n### List vs Map Comparison\n\n**List (Index ‚Üí Value):**\n\n**Map (Key ‚Üí Value):**\n\n**When to use maps:**\n- ‚úÖ Looking up by meaningful keys (name, ID, word)\n- ‚úÖ Need fast key-based access\n- ‚úÖ Associating related data (country ‚Üí capital)\n\n**When to use lists:**\n- ‚úÖ Ordered sequence of items\n- ‚úÖ Accessing by position\n- ‚úÖ Simple collection of values\n\n---\n\n",
              "code": "val colorCodes = mapOf(\n    \"Red\" to \"#FF0000\",\n    \"Green\" to \"#00FF00\",\n    \"Blue\" to \"#0000FF\"\n)\nprintln(colorCodes[\"Red\"])  // \"#FF0000\"",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Creating Maps",
              "content": "\n### Immutable Maps (Read-Only)\n\nCreated with `mapOf()`:\n\n\n**Output:**\n\n**The `to` keyword** creates a Pair: `\"USA\" to \"Washington D.C.\"` ‚Üí `Pair(\"USA\", \"Washington D.C.\")`\n\n### Mutable Maps (Can Change)\n\nCreated with `mutableMapOf()`:\n\n\n**Output:**\n\n### Empty Maps\n\n\n### Maps with Different Types\n\n\n---\n\n",
              "code": "// String keys, Int values\nval ages = mapOf(\"Alice\" to 25, \"Bob\" to 30)\n\n// Int keys, String values\nval weekDays = mapOf(\n    1 to \"Monday\",\n    2 to \"Tuesday\",\n    3 to \"Wednesday\"\n)\n\n// String keys, Any values (mixed)\nval mixed = mapOf(\n    \"name\" to \"Alice\",\n    \"age\" to 25,\n    \"active\" to true\n)",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Accessing Map Values",
              "content": "\n### Basic Access\n\n\n### Safe Access Patterns\n\n\n---\n\n",
              "code": "fun main() {\n    val contacts = mapOf(\n        \"Alice\" to \"alice@email.com\",\n        \"Bob\" to \"bob@email.com\"\n    )\n\n    // Nullable return\n    val aliceEmail: String? = contacts[\"Alice\"]\n    println(aliceEmail)  // alice@email.com\n\n    // With default\n    val charlieEmail = contacts.getOrElse(\"Charlie\") { \"unknown@email.com\" }\n    println(charlieEmail)  // unknown@email.com\n\n    // Check before accessing\n    if (\"Alice\" in contacts) {\n        println(\"Alice's email: ${contacts[\"Alice\"]}\")\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Modifying Mutable Maps",
              "content": "\n### Adding and Updating\n\n\n**Output:**\n\n### Removing Entries\n\n\n**Output:**\n\n---\n\n",
              "code": "{alice=password123, charlie=pass789}\nRemoved: password123\n{charlie=pass789}\nAfter clear: {}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Iterating Through Maps",
              "content": "\n### Iterate Over Entries\n\n\n**Output:**\n\n### Iterate Over Keys or Values Only\n\n\n**Output:**\n\n---\n\n",
              "code": "Countries:\n- USA\n- France\n- Japan\n\nCapitals:\n- Washington D.C.\n- Paris\n- Tokyo",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Common Map Operations",
              "content": "\n### Checking Contents\n\n\n### Filtering Maps\n\n\n**Output:**\n\n### Map Transformations\n\n\n---\n\n",
              "code": "fun main() {\n    val numbers = mapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)\n\n    // Transform values only\n    val doubled = numbers.mapValues { it.value * 2 }\n    println(doubled)  // {one=2, two=4, three=6}\n\n    // Transform keys only\n    val upperKeys = numbers.mapKeys { it.key.uppercase() }\n    println(upperKeys)  // {ONE=1, TWO=2, THREE=3}\n\n    // Convert to list of pairs\n    val pairs = numbers.toList()\n    println(pairs)  // [(one, 1), (two, 2), (three, 3)]\n}",
              "language": "kotlin"
            },
            {
              "type": "EXAMPLE",
              "title": "Practical Examples",
              "content": "\n### Example 1: Grade Book\n\n\n**Output:**\n\n### Example 2: Inventory System\n\n\n**Output:**\n\n---\n\n",
              "code": "=== Store Inventory ===\nLaptop: 15 units (Low stock)\nMouse: 50 units (In stock)\nKeyboard: 30 units (In stock)\n\n=== Restocking Low Items ===\nRestocked Laptop: 15 ‚Üí 45\n\n=== Updated Inventory ===\n{Laptop=45, Mouse=50, Keyboard=30}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Part 2 Capstone Project: Contact Management System",
              "content": "\nNow it's time to put everything together! You'll build a complete contact management system using all the concepts from Part 2.\n\n### Project Requirements\n\nBuild a console application that manages contacts with these features:\n\n1. **Add Contact**: Store name, phone, and email\n2. **View All Contacts**: Display all contacts\n3. **Search Contact**: Find by name\n4. **Update Contact**: Modify phone or email\n5. **Delete Contact**: Remove a contact\n6. **Statistics**: Show total contacts, contacts with/without email\n7. **Menu System**: User-friendly interface with loops\n\n**Concepts used:**\n- ‚úÖ If statements (validation)\n- ‚úÖ When expressions (menu choices)\n- ‚úÖ For loops (displaying contacts)\n- ‚úÖ While/do-while loops (menu loop)\n- ‚úÖ Lists (managing multiple fields)\n- ‚úÖ Maps (storing contacts)\n\n### Capstone Solution\n\n<details>\n<summary>Click to see complete solution</summary>\n\n\n**Sample Run:**\n\n**Key features:**\n- ‚úÖ Data class for structured contact info\n- ‚úÖ Input validation\n- ‚úÖ Error handling\n- ‚úÖ User-friendly messages with emojis\n- ‚úÖ Confirmation for destructive actions\n- ‚úÖ Smart search with suggestions\n- ‚úÖ Comprehensive statistics\n- ‚úÖ Clean code organization with functions\n</details>\n\n### Challenge Extensions\n\nWant to go further? Try adding:\n\n1. **Export/Import**: Save contacts to a file\n2. **Sorting**: View contacts alphabetically\n3. **Groups**: Categorize contacts (family, work, friends)\n4. **Favorites**: Mark important contacts\n5. **Birthday tracking**: Store and remind birthdays\n6. **Multiple phones**: Support home, work, mobile\n\n---\n\n",
              "code": "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë  CONTACT MANAGEMENT SYSTEM v1.0   ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\n=== MAIN MENU ===\n1. Add Contact\n2. View All Contacts\n3. Search Contact\n4. Update Contact\n5. Delete Contact\n6. Statistics\n7. Exit\n\nEnter choice (1-7): 1\n\n=== ADD NEW CONTACT ===\nEnter name: Alice\nEnter phone: 555-1234\nEnter email (optional): alice@email.com\n‚úÖ Contact 'Alice' added successfully!\n\n=== MAIN MENU ===\n1. Add Contact\n2. View All Contacts\n3. Search Contact\n4. Update Contact\n5. Delete Contact\n6. Statistics\n7. Exit\n\nEnter choice (1-7): 2\n\n=== ALL CONTACTS (1) ===\n\n[1] Alice\n    üìû Phone: 555-1234\n    üìß Email: alice@email.com\n\n=== MAIN MENU ===\n...",
              "language": "kotlin"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls and Best Practices",
              "content": "\n### Pitfall 1: Modifying While Iterating\n\n‚ùå **Dangerous:**\n\n‚úÖ **Safe:**\n\n### Pitfall 2: Null Values from Missing Keys\n\n‚ùå **Can crash:**\n\n‚úÖ **Safe:**\n\n### Best Practice 1: Use Appropriate Map Type\n\n\n### Best Practice 2: Descriptive Key Names\n\n\n### Best Practice 3: Check Before Access\n\n\n---\n\n",
              "code": "// ‚úÖ Safe pattern\nif (\"Alice\" in contacts) {\n    val contact = contacts[\"Alice\"]!!\n    // Use contact\n} else {\n    println(\"Contact not found\")\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Quick Quiz",
              "content": "\n**Question 1:** What's the output?\n\n<details>\n<summary>Answer</summary>\n\n**Output:** `null`\n\n**Explanation:** The key \"c\" doesn't exist, so accessing it returns null.\n</details>\n\n---\n\n**Question 2:** How do you add to a mutable map?\n\n<details>\n<summary>Answer</summary>\n\n</details>\n\n---\n\n**Question 3:** What's wrong here?\n\n<details>\n<summary>Answer</summary>\n\n**Error:** `mapOf()` creates an **immutable** map. Can't add to it.\n\n**Fix:**\n</details>\n\n---\n\n**Question 4:** How do you iterate through keys and values?\n\n<details>\n<summary>Answer</summary>\n\n</details>\n\n---\n\n",
              "code": "val map = mapOf(\"a\" to 1, \"b\" to 2)\n\n// With destructuring (recommended)\nfor ((key, value) in map) {\n    println(\"$key -> $value\")\n}\n\n// Or with entry\nfor (entry in map) {\n    println(\"${entry.key} -> ${entry.value}\")\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Part 2 Summary",
              "content": "\nüéâ **Congratulations!** You've completed Part 2: Controlling the Flow!\n\n**You've mastered:**\n\n**Decision Making:**\n- ‚úÖ If/else statements for binary decisions\n- ‚úÖ Logical operators (&&, ||, !)\n- ‚úÖ When expressions for multi-way decisions\n\n**Loops:**\n- ‚úÖ For loops for counted iteration\n- ‚úÖ While loops for condition-based repetition\n- ‚úÖ Do-while for \"at least once\" loops\n- ‚úÖ Break and continue for flow control\n\n**Collections:**\n- ‚úÖ Lists for ordered data\n- ‚úÖ Maps for key-value associations\n- ‚úÖ Mutable vs immutable collections\n- ‚úÖ Collection operations (map, filter, etc.)\n\n**You can now:**\n- üéØ Make complex decisions in your programs\n- üîÑ Repeat tasks efficiently\n- üì¶ Store and manage collections of data\n- üèóÔ∏è Build complete, interactive applications\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nIn **Part 3: Functional Programming in Kotlin**, you'll level up with:\n- Lambda expressions and higher-order functions\n- Advanced collection operations\n- Sequences for lazy evaluation\n- Scope functions (let, apply, with, run, also)\n- Function composition and chaining\n\n**Preview:**\n\nGet ready to write more expressive, concise, and powerful Kotlin code!\n\n---\n\n**üèÜ Outstanding work completing Part 2! You're becoming a Kotlin developer!** üéâ\n\n",
              "code": "val numbers = listOf(1, 2, 3, 4, 5)\n\nnumbers\n    .filter { it % 2 == 0 }\n    .map { it * it }\n    .forEach { println(it) }\n\nval result = listOf(\"apple\", \"banana\", \"cherry\")\n    .filter { it.length > 5 }\n    .map { it.uppercase() }\n    .joinToString(\", \")",
              "language": "kotlin"
            }
          ],
          "challenges": []
        }
      ],
      "quizzes": [
        {
          "id": "part2-quiz-2.1",
          "title": "If Statements Quiz",
          "description": "Knowledge check for If Statements Quiz",
          "moduleId": "module-02",
          "passingScore": 70,
          "estimatedMinutes": 6,
          "questions": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "2.1.q1",
              "title": "What does an 'if' statement do?",
              "description": "What does an 'if' statement do?",
              "options": [
                "Repeats code multiple times",
                "Makes decisions based on conditions",
                "Defines a function",
                "Creates a variable"
              ],
              "correctAnswer": 1,
              "explanation": "An if statement allows your program to make decisions by executing different code based on whether a condition is true or false."
            },
            {
              "type": "TRUE_FALSE",
              "id": "2.1.q2",
              "title": "The 'else' block executes when the 'if' condition is true.",
              "description": "The 'else' block executes when the 'if' condition is true.",
              "question": "The 'else' block executes when the 'if' condition is true.",
              "correctAnswer": false,
              "explanation": "False. The else block executes when the if condition is FALSE."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "2.1.q3",
              "title": "Which comparison operator checks if two values are equal?",
              "description": "Which comparison operator checks if two values are equal?",
              "options": [
                "=",
                "==",
                "===",
                "equals"
              ],
              "correctAnswer": 1,
              "explanation": "== is the equality comparison operator. A single = is for assignment, not comparison."
            }
          ]
        },
        {
          "id": "part2-quiz-2.2",
          "title": "Logical Operators Quiz",
          "description": "Knowledge check for Logical Operators Quiz",
          "moduleId": "module-02",
          "passingScore": 70,
          "estimatedMinutes": 8,
          "questions": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "2.2.q1",
              "title": "Which operator represents 'AND' logic?",
              "description": "Which operator represents 'AND' logic?",
              "options": [
                "&",
                "and",
                "&&",
                "AND"
              ],
              "correctAnswer": 2,
              "explanation": "&& is the logical AND operator. Both conditions must be true for the result to be true."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "2.2.q2",
              "title": "Which operator represents 'OR' logic?",
              "description": "Which operator represents 'OR' logic?",
              "options": [
                "|",
                "or",
                "||",
                "OR"
              ],
              "correctAnswer": 2,
              "explanation": "|| is the logical OR operator. At least one condition must be true for the result to be true."
            },
            {
              "type": "TRUE_FALSE",
              "id": "2.2.q3",
              "title": "The expression (true && false) evaluates to true.",
              "description": "The expression (true && false) evaluates to true.",
              "question": "The expression (true && false) evaluates to true.",
              "correctAnswer": false,
              "explanation": "False. With AND (&&), both conditions must be true. true AND false = false."
            },
            {
              "type": "TRUE_FALSE",
              "id": "2.2.q4",
              "title": "The expression (true || false) evaluates to true.",
              "description": "The expression (true || false) evaluates to true.",
              "question": "The expression (true || false) evaluates to true.",
              "correctAnswer": true,
              "explanation": "True. With OR (||), at least one condition must be true. true OR false = true."
            }
          ]
        },
        {
          "id": "part2-quiz-2.3",
          "title": "When Expression Quiz",
          "description": "Knowledge check for When Expression Quiz",
          "moduleId": "module-02",
          "passingScore": 70,
          "estimatedMinutes": 6,
          "questions": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "2.3.q1",
              "title": "What is the 'when' expression best used for?",
              "description": "What is the 'when' expression best used for?",
              "options": [
                "Looping through lists",
                "Checking multiple conditions in a cleaner way",
                "Creating variables",
                "Defining functions"
              ],
              "correctAnswer": 1,
              "explanation": "when is Kotlin's replacement for switch statements, providing a cleaner way to check multiple conditions."
            },
            {
              "type": "TRUE_FALSE",
              "id": "2.3.q2",
              "title": "The 'else' branch in a when expression is optional.",
              "description": "The 'else' branch in a when expression is optional.",
              "question": "The 'else' branch in a when expression is optional.",
              "correctAnswer": true,
              "explanation": "True. The else branch is optional, but it's a good practice to include it as a catch-all."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "2.3.q3",
              "title": "Can a 'when' expression return a value?",
              "description": "Can a 'when' expression return a value?",
              "options": [
                "No, never",
                "Yes, always",
                "Only if it has an else branch",
                "Only with numbers"
              ],
              "correctAnswer": 1,
              "explanation": "Yes, when expressions can return values, making them very versatile in Kotlin."
            }
          ]
        },
        {
          "id": "part2-quiz-2.4",
          "title": "For Loops Quiz",
          "description": "Knowledge check for For Loops Quiz",
          "moduleId": "module-02",
          "passingScore": 70,
          "estimatedMinutes": 6,
          "questions": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "2.4.q1",
              "title": "What does a 'for' loop do?",
              "description": "What does a 'for' loop do?",
              "options": [
                "Makes decisions",
                "Repeats code a specific number of times",
                "Creates variables",
                "Compares values"
              ],
              "correctAnswer": 1,
              "explanation": "A for loop repeats code for each item in a range or collection."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "2.4.q2",
              "title": "What does '1..5' represent?",
              "description": "What does '1..5' represent?",
              "options": [
                "Numbers 1, 2, 3, 4 (excluding 5)",
                "Numbers 1, 2, 3, 4, 5",
                "Numbers 0, 1, 2, 3, 4, 5",
                "Just the number 1.5"
              ],
              "correctAnswer": 1,
              "explanation": "1..5 is a range that includes both endpoints: 1, 2, 3, 4, and 5."
            },
            {
              "type": "TRUE_FALSE",
              "id": "2.4.q3",
              "title": "The keyword 'in' is used in for loops to iterate over ranges and collections.",
              "description": "The keyword 'in' is used in for loops to iterate over ranges and collections.",
              "question": "The keyword 'in' is used in for loops to iterate over ranges and collections.",
              "correctAnswer": true,
              "explanation": "True. 'in' is used in for loops: for (i in 1..5) means 'for each i in the range 1 to 5'."
            }
          ]
        },
        {
          "id": "part2-quiz-2.5",
          "title": "While Loops Quiz",
          "description": "Knowledge check for While Loops Quiz",
          "moduleId": "module-02",
          "passingScore": 70,
          "estimatedMinutes": 6,
          "questions": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "2.5.q1",
              "title": "When does a 'while' loop stop?",
              "description": "When does a 'while' loop stop?",
              "options": [
                "After 10 iterations",
                "When the condition becomes false",
                "Never",
                "When you press a key"
              ],
              "correctAnswer": 1,
              "explanation": "A while loop continues as long as its condition is true, and stops when it becomes false."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "2.5.q2",
              "title": "What's the difference between 'while' and 'do-while'?",
              "description": "What's the difference between 'while' and 'do-while'?",
              "options": [
                "There is no difference",
                "do-while always executes at least once",
                "while is faster",
                "do-while can't use conditions"
              ],
              "correctAnswer": 1,
              "explanation": "do-while checks the condition AFTER running the code, so it always runs at least once. while checks BEFORE."
            },
            {
              "type": "TRUE_FALSE",
              "id": "2.5.q3",
              "title": "An infinite loop occurs when a while loop's condition never becomes false.",
              "description": "An infinite loop occurs when a while loop's condition never becomes false.",
              "question": "An infinite loop occurs when a while loop's condition never becomes false.",
              "correctAnswer": true,
              "explanation": "True. If the condition never becomes false, the loop runs forever (infinite loop)."
            }
          ]
        },
        {
          "id": "part2-quiz-2.6",
          "title": "Lists Quiz",
          "description": "Knowledge check for Lists Quiz",
          "moduleId": "module-02",
          "passingScore": 70,
          "estimatedMinutes": 6,
          "questions": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "2.6.q1",
              "title": "What function creates an immutable list?",
              "description": "What function creates an immutable list?",
              "options": [
                "mutableListOf()",
                "listOf()",
                "arrayOf()",
                "createList()"
              ],
              "correctAnswer": 1,
              "explanation": "listOf() creates an immutable (read-only) list that cannot be modified."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "2.6.q2",
              "title": "What function creates a mutable list?",
              "description": "What function creates a mutable list?",
              "options": [
                "listOf()",
                "mutableListOf()",
                "arrayOf()",
                "newList()"
              ],
              "correctAnswer": 1,
              "explanation": "mutableListOf() creates a mutable list that can be modified (add, remove elements)."
            },
            {
              "type": "TRUE_FALSE",
              "id": "2.6.q3",
              "title": "List indices start at 0 in Kotlin.",
              "description": "List indices start at 0 in Kotlin.",
              "question": "List indices start at 0 in Kotlin.",
              "correctAnswer": true,
              "explanation": "True. Like most programming languages, Kotlin uses zero-based indexing."
            }
          ]
        },
        {
          "id": "part2-quiz-2.7",
          "title": "Maps Quiz",
          "description": "Knowledge check for Maps Quiz",
          "moduleId": "module-02",
          "passingScore": 70,
          "estimatedMinutes": 6,
          "questions": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "2.7.q1",
              "title": "What is a Map?",
              "description": "What is a Map?",
              "options": [
                "A list of numbers",
                "A collection of key-value pairs",
                "A type of loop",
                "A geographic location"
              ],
              "correctAnswer": 1,
              "explanation": "A Map stores data as key-value pairs, like a dictionary where you look up values by their keys."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "2.7.q2",
              "title": "How do you create an immutable map?",
              "description": "How do you create an immutable map?",
              "options": [
                "mutableMapOf()",
                "mapOf()",
                "hashMapOf()",
                "createMap()"
              ],
              "correctAnswer": 1,
              "explanation": "mapOf() creates an immutable (read-only) map."
            },
            {
              "type": "TRUE_FALSE",
              "id": "2.7.q3",
              "title": "In a map, keys must be unique.",
              "description": "In a map, keys must be unique.",
              "question": "In a map, keys must be unique.",
              "correctAnswer": true,
              "explanation": "True. Each key in a map must be unique. If you add a duplicate key, it overwrites the previous value."
            }
          ]
        }
      ]
    },
    {
      "id": "module-03",
      "title": "Part 3: Kotlin Fundamentals",
      "description": "Learn Kotlin programming - Part 3",
      "difficulty": "beginner",
      "estimatedHours": 7,
      "lessons": [
        {
          "id": "3.1",
          "title": "Lesson 2.1: Introduction to Object-Oriented Programming",
          "moduleId": "module-03",
          "order": 1,
          "estimatedMinutes": 60,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 60 minutes\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Topic Introduction",
              "content": "\nWelcome to Part 2 of the Kotlin Training Course! You've mastered the fundamentals‚Äîvariables, control flow, functions, and collections. Now it's time to learn **Object-Oriented Programming (OOP)**, a paradigm that will transform how you design and structure your code.\n\nOOP is more than just a programming technique‚Äîit's a way of thinking about problems. Instead of writing procedural code that executes step-by-step, you'll learn to model real-world entities as **objects** with their own data and behavior.\n\nBy the end of this lesson, you'll understand what OOP is, why it matters, and how to create your first classes and objects in Kotlin.\n\n---\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "The Concept",
              "content": "\n### What is Object-Oriented Programming?\n\n**Object-Oriented Programming (OOP)** is a programming paradigm that organizes code around **objects**‚Äîself-contained units that combine data (properties) and behavior (methods).\n\n**Real-World Analogy: A Car**\n\nThink about a car in the real world:\n\n**Properties (Data)**:\n- Color: \"Red\"\n- Brand: \"Toyota\"\n- Model: \"Camry\"\n- Current Speed: 0 mph\n- Fuel Level: 100%\n\n**Behaviors (Actions)**:\n- Start engine\n- Accelerate\n- Brake\n- Turn left/right\n- Refuel\n\nA car is an **object** with both data and functionality. OOP lets you model concepts like this in code!\n\n### Why OOP Matters\n\n**Before OOP (Procedural Programming)**:\n\n\n**Problems**:\n- Data and behavior are disconnected\n- Hard to manage multiple cars\n- No clear organization\n- Prone to errors (which car are we accelerating?)\n\n**With OOP**:\n\n\n**Benefits**:\n- ‚úÖ Data and behavior are bundled together\n- ‚úÖ Easy to create multiple cars\n- ‚úÖ Clear organization and structure\n- ‚úÖ Safer and more maintainable\n\n---\n\n",
              "code": "class Car(val color: String, val brand: String) {\n    var speed = 0\n\n    fun accelerate() {\n        speed += 10\n    }\n\n    fun brake() {\n        speed -= 10\n    }\n}\n\nval myCar = Car(\"Red\", \"Toyota\")\nmyCar.accelerate()\nprintln(myCar.speed)  // 10",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Classes and Objects",
              "content": "\n### What is a Class?\n\nA **class** is a blueprint or template for creating objects. It defines:\n- **Properties**: What data the object holds\n- **Methods**: What actions the object can perform\n\n**Analogy**: A class is like a cookie cutter, and objects are the cookies.\n\n\n### Creating Your First Class\n\n**Syntax**:\n\n\n**Example: Person Class**\n\n\n**Key Points**:\n- `class Person` defines the blueprint\n- `Person()` creates a new instance (object)\n- Each object has its own independent data\n- `person1` and `person2` are separate objects\n\n---\n\n",
              "code": "class Person {\n    var name: String = \"\"\n    var age: Int = 0\n\n    fun introduce() {\n        println(\"Hi, I'm $name and I'm $age years old.\")\n    }\n}\n\nfun main() {\n    // Create an object (instance) of Person\n    val person1 = Person()\n    person1.name = \"Alice\"\n    person1.age = 25\n    person1.introduce()  // Hi, I'm Alice and I'm 25 years old.\n\n    // Create another object\n    val person2 = Person()\n    person2.name = \"Bob\"\n    person2.age = 30\n    person2.introduce()  // Hi, I'm Bob and I'm 30 years old.\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Properties",
              "content": "\n**Properties** are variables that belong to a class. They define the state of an object.\n\n**Two Types**:\n- **`val`** (immutable): Cannot be changed after initialization\n- **`var`** (mutable): Can be changed\n\n\n---\n\n",
              "code": "class BankAccount {\n    val accountNumber: String = \"123456\"  // Can't change\n    var balance: Double = 0.0              // Can change\n\n    fun deposit(amount: Double) {\n        balance += amount\n    }\n\n    fun withdraw(amount: Double) {\n        if (amount <= balance) {\n            balance -= amount\n        } else {\n            println(\"Insufficient funds!\")\n        }\n    }\n}\n\nfun main() {\n    val account = BankAccount()\n    println(account.balance)  // 0.0\n\n    account.deposit(100.0)\n    println(account.balance)  // 100.0\n\n    account.withdraw(30.0)\n    println(account.balance)  // 70.0\n\n    // account.accountNumber = \"999999\"  // ‚ùå Error: Val cannot be reassigned\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Constructors",
              "content": "\n### Primary Constructor\n\nA **constructor** is a special function that initializes an object when it's created. The **primary constructor** is defined in the class header.\n\n**Without Constructor** (tedious):\n\n\n**With Constructor** (clean):\n\n\n**Explanation**:\n- `class Person(val name: String, val age: Int)` defines properties in the constructor\n- `val` or `var` makes them properties (accessible throughout the class)\n- Without `val`/`var`, they're just constructor parameters\n\n**Constructor with Default Values**:\n\n\n### Init Block\n\nThe **`init` block** runs when an object is created. Use it for validation or setup logic.\n\n\n### Secondary Constructors\n\n**Secondary constructors** provide alternative ways to create objects.\n\n\n**Note**: In modern Kotlin, **default parameters** are preferred over secondary constructors.\n\n---\n\n",
              "code": "class Person(val name: String, val age: Int) {\n    var email: String = \"\"\n\n    // Secondary constructor\n    constructor(name: String, age: Int, email: String) : this(name, age) {\n        this.email = email\n    }\n\n    fun displayInfo() {\n        println(\"Name: $name, Age: $age, Email: $email\")\n    }\n}\n\nfun main() {\n    val person1 = Person(\"Alice\", 25)\n    person1.displayInfo()  // Name: Alice, Age: 25, Email:\n\n    val person2 = Person(\"Bob\", 30, \"bob@example.com\")\n    person2.displayInfo()  // Name: Bob, Age: 30, Email: bob@example.com\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Methods",
              "content": "\n**Methods** are functions that belong to a class. They define the behavior of an object.\n\n\n---\n\n",
              "code": "class Calculator {\n    fun add(a: Int, b: Int): Int {\n        return a + b\n    }\n\n    fun subtract(a: Int, b: Int): Int {\n        return a - b\n    }\n\n    fun multiply(a: Int, b: Int): Int {\n        return a * b\n    }\n\n    fun divide(a: Int, b: Int): Double {\n        require(b != 0) { \"Cannot divide by zero\" }\n        return a.toDouble() / b\n    }\n}\n\nfun main() {\n    val calc = Calculator()\n\n    println(calc.add(5, 3))        // 8\n    println(calc.subtract(10, 4))  // 6\n    println(calc.multiply(3, 7))   // 21\n    println(calc.divide(15, 3))    // 5.0\n}",
              "language": "kotlin"
            },
            {
              "type": "KEY_POINT",
              "title": "The `this` Keyword",
              "content": "\n**`this`** refers to the current instance of the class. Use it to:\n1. Distinguish between properties and parameters with the same name\n2. Reference the current object\n\n\n---\n\n",
              "code": "class Person(name: String, age: Int) {\n    var name: String = name\n    var age: Int = age\n\n    fun updateName(name: String) {\n        this.name = name  // this.name is the property, name is the parameter\n    }\n\n    fun haveBirthday() {\n        this.age++  // Optional: this.age++ is the same as age++\n    }\n\n    fun compareAge(otherPerson: Person): String {\n        return when {\n            this.age > otherPerson.age -> \"$name is older than ${otherPerson.name}\"\n            this.age < otherPerson.age -> \"$name is younger than ${otherPerson.name}\"\n            else -> \"$name and ${otherPerson.name} are the same age\"\n        }\n    }\n}\n\nfun main() {\n    val alice = Person(\"Alice\", 25)\n    val bob = Person(\"Bob\", 30)\n\n    alice.updateName(\"Alicia\")\n    println(alice.name)  // Alicia\n\n    println(alice.compareAge(bob))  // Alicia is younger than Bob\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 1: Create a Student Class",
              "content": "\n**Goal**: Create a `Student` class with properties and methods.\n\n**Requirements**:\n1. Properties: `name` (String), `studentId` (String), `grade` (Int, 0-100)\n2. Method: `isPass()` returns true if grade >= 60, false otherwise\n3. Method: `displayInfo()` prints student details\n4. Create 3 students and test the methods\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution: Student Class",
              "content": "\n\n**Output**:\n\n---\n\n",
              "code": "Student: Alice Johnson (ID: S001)\nGrade: 85 - PASS\n\nStudent: Bob Smith (ID: S002)\nGrade: 55 - FAIL\n\nStudent: Carol Davis (ID: S003)\nGrade: 92 - PASS",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 2: Create a Rectangle Class",
              "content": "\n**Goal**: Create a `Rectangle` class that calculates area and perimeter.\n\n**Requirements**:\n1. Properties: `width` (Double), `height` (Double)\n2. Method: `area()` returns width * height\n3. Method: `perimeter()` returns 2 * (width + height)\n4. Method: `isSquare()` returns true if width == height\n5. Create rectangles and test all methods\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution: Rectangle Class",
              "content": "\n\n**Output**:\n\n---\n\n",
              "code": "Rectangle: 5.0 x 10.0\n  Area: 50.0\n  Perimeter: 30.0\n  Is Square: false\n\nRectangle: 7.0 x 7.0\n  Area: 49.0\n  Perimeter: 28.0\n  Is Square: true",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 3: Create a BankAccount Class",
              "content": "\n**Goal**: Build a complete bank account system.\n\n**Requirements**:\n1. Properties: `accountHolder` (String), `accountNumber` (String), `balance` (Double, private)\n2. Method: `deposit(amount: Double)` adds to balance\n3. Method: `withdraw(amount: Double)` subtracts from balance (check sufficient funds)\n4. Method: `getBalance()` returns current balance\n5. Method: `transfer(amount: Double, targetAccount: BankAccount)` transfers money\n6. Create accounts and perform transactions\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution: BankAccount Class",
              "content": "\n\n**Output**:\n\n---\n\n",
              "code": "Deposited $1000.0. New balance: $1000.0\n\nWithdrew $200.0. New balance: $800.0\n\nInsufficient funds! Balance: $800.0, Requested: $1000.0\n\nTransferring $300.0 from Alice Johnson to Bob Smith\nWithdrew $300.0. New balance: $500.0\nDeposited $300.0. New balance: $300.0\nTransfer successful!\n\nAccount Holder: Alice Johnson\nAccount Number: ACC001\nBalance: $500.0\n\nAccount Holder: Bob Smith\nAccount Number: ACC002\nBalance: $300.0",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Checkpoint Quiz",
              "content": "\n### Question 1\nWhat is a class in OOP?\n\nA) A function that performs calculations\nB) A blueprint or template for creating objects\nC) A variable that stores data\nD) A loop that iterates over collections\n\n### Question 2\nWhat is the difference between `val` and `var` for properties?\n\nA) `val` is for integers, `var` is for strings\nB) `val` is immutable (read-only), `var` is mutable (read-write)\nC) `val` is for classes, `var` is for functions\nD) There is no difference\n\n### Question 3\nWhat does the `this` keyword refer to?\n\nA) The main function\nB) The parent class\nC) The current instance of the class\nD) A static variable\n\n### Question 4\nWhat is a constructor?\n\nA) A method that destroys objects\nB) A special function that initializes objects when they're created\nC) A variable that stores class data\nD) A loop that creates multiple objects\n\n### Question 5\nWhich of the following correctly creates an instance of a `Car` class?\n\nA) `Car car = new Car()`\nB) `val car = Car()`\nC) `Car car()`\nD) `new Car() as car`\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Answers",
              "content": "\n**Question 1: B) A blueprint or template for creating objects**\n\nA class defines the structure (properties) and behavior (methods) that objects will have. It's like a blueprint for a house‚Äîthe blueprint itself isn't a house, but you can build many houses from it.\n\n\n---\n\n**Question 2: B) `val` is immutable (read-only), `var` is mutable (read-write)**\n\n\n---\n\n**Question 3: C) The current instance of the class**\n\n`this` refers to the object itself. It's useful when you need to distinguish between properties and parameters with the same name.\n\n\n---\n\n**Question 4: B) A special function that initializes objects when they're created**\n\nConstructors set up the initial state of an object.\n\n\n---\n\n**Question 5: B) `val car = Car()`**\n\nKotlin doesn't use the `new` keyword like Java. You create objects by calling the class name with parentheses.\n\n\n---\n\n",
              "code": "// ‚úÖ Correct Kotlin syntax\nval car = Car(\"Toyota\")\n\n// ‚ùå Wrong - Java syntax\n// Car car = new Car(\"Toyota\")",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "What You've Learned",
              "content": "\n‚úÖ What OOP is and why it's powerful\n‚úÖ How to define classes with properties and methods\n‚úÖ Creating objects (instances) from classes\n‚úÖ Using constructors (primary, init blocks, secondary)\n‚úÖ The difference between `val` and `var` properties\n‚úÖ The `this` keyword and when to use it\n‚úÖ Building practical classes (Student, Rectangle, BankAccount)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Next Steps",
              "content": "\nIn **Lesson 2.2: Properties and Initialization**, you'll learn:\n- Custom getters and setters\n- Late initialization with `lateinit`\n- Lazy initialization for performance\n- Backing fields for advanced property control\n- Property delegation basics\n\nYou're building a strong OOP foundation! Keep going!\n\n---\n\n**Congratulations on completing Lesson 2.1!** üéâ\n\nYou've taken your first steps into Object-Oriented Programming. This is a fundamental shift in how you think about code‚Äîfrom procedures to objects that model the real world.\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "3.1.1",
              "title": "Create a Simple Class",
              "description": "Create a class called `Book` with properties for title (String), author (String), and pages (Int). Create an instance and print its properties.",
              "instructions": "Create a class called `Book` with properties for title (String), author (String), and pages (Int). Create an instance and print its properties.",
              "starterCode": "// Create your Book class here\n\nfun main() {\n    // Create a book instance and print its properties\n}",
              "solution": "class Book(val title: String, val author: String, val pages: Int)\n\nfun main() {\n    val myBook = Book(\"1984\", \"George Orwell\", 328)\n    println(\"Title: ${myBook.title}\")\n    println(\"Author: ${myBook.author}\")\n    println(\"Pages: ${myBook.pages}\")\n}",
              "language": "kotlin",
              "testCases": [
                {
                  "description": "Book class should exist with correct properties",
                  "expectedOutput": "Title:",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the class keyword followed by the class name"
                },
                {
                  "level": 2,
                  "text": "Define properties in the primary constructor"
                },
                {
                  "level": 3,
                  "text": "Use val for read-only properties"
                },
                {
                  "level": 4,
                  "text": "Access properties using dot notation"
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "3.1.2",
              "title": "Class with Methods",
              "description": "Create a `BankAccount` class with properties for accountNumber (String) and balance (Double). Add a method `deposit(amount: Double)` and `withdraw(amount: Double)` that modify the balance.",
              "instructions": "Create a `BankAccount` class with properties for accountNumber (String) and balance (Double). Add a method `deposit(amount: Double)` and `withdraw(amount: Double)` that modify the balance.",
              "starterCode": "class BankAccount(val accountNumber: String, var balance: Double) {\n    // Add deposit method\n    \n    // Add withdraw method\n    \n}\n\nfun main() {\n    val account = BankAccount(\"12345\", 1000.0)\n    println(\"Initial balance: ${account.balance}\")\n    account.deposit(500.0)\n    println(\"After deposit: ${account.balance}\")\n    account.withdraw(200.0)\n    println(\"After withdrawal: ${account.balance}\")\n}",
              "solution": "class BankAccount(val accountNumber: String, var balance: Double) {\n    fun deposit(amount: Double) {\n        balance += amount\n    }\n    \n    fun withdraw(amount: Double) {\n        balance -= amount\n    }\n}\n\nfun main() {\n    val account = BankAccount(\"12345\", 1000.0)\n    println(\"Initial balance: ${account.balance}\")\n    account.deposit(500.0)\n    println(\"After deposit: ${account.balance}\")\n    account.withdraw(200.0)\n    println(\"After withdrawal: ${account.balance}\")\n}",
              "language": "kotlin",
              "testCases": [
                {
                  "description": "Initial balance should be 1000.0",
                  "expectedOutput": "Initial balance: 1000.0",
                  "isVisible": true
                },
                {
                  "description": "After deposit should be 1500.0",
                  "expectedOutput": "After deposit: 1500.0",
                  "isVisible": true
                },
                {
                  "description": "After withdrawal should be 1300.0",
                  "expectedOutput": "After withdrawal: 1300.0",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Methods are defined inside the class body"
                },
                {
                  "level": 2,
                  "text": "Use 'fun' keyword to define methods"
                },
                {
                  "level": 3,
                  "text": "balance must be 'var' to be modifiable"
                },
                {
                  "level": 4,
                  "text": "Use += to add to balance, -= to subtract"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "3.2",
          "title": "Lesson 2.2: Properties and Initialization",
          "moduleId": "module-03",
          "order": 2,
          "estimatedMinutes": 65,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 65 minutes\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Topic Introduction",
              "content": "\nIn Lesson 2.1, you learned the basics of classes and objects. Now it's time to dive deeper into **properties**‚Äîthe data that objects hold.\n\nKotlin provides powerful features for managing properties that go far beyond simple variables:\n- **Custom getters and setters** for computed or validated values\n- **Late initialization** for properties that can't be set immediately\n- **Lazy initialization** for expensive operations that should only happen when needed\n- **Backing fields** for advanced property control\n- **Property delegation** to reuse property logic\n\nThese features make Kotlin properties more flexible and powerful than in most other languages. Let's explore them!\n\n---\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "The Concept",
              "content": "\n### Properties vs Fields\n\nIn many languages (like Java), classes have **fields** (private variables) and **getter/setter methods** to access them:\n\n**Java (verbose)**:\n\n**Kotlin (clean)**:\n\nIn Kotlin, properties automatically have getters (and setters for `var`). You access them like fields, but they're actually calling methods behind the scenes!\n\n\n---\n\n",
              "code": "val person = Person()\nperson.name = \"Alice\"  // Calls setter\nprintln(person.name)    // Calls getter",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Custom Getters and Setters",
              "content": "\n### Custom Getters\n\nA **custom getter** computes a value every time the property is accessed.\n\n**Example: Computed Properties**\n\n\n**Why use a custom getter instead of a method?**\n- More natural syntax: `rect.area` vs `rect.getArea()`\n- Semantic: it looks like a property because it behaves like one\n- Lightweight computation that doesn't change the object state\n\n**Example: Derived Properties**\n\n\n### Custom Setters\n\nA **custom setter** validates or transforms values when they're assigned.\n\n**Example: Input Validation**\n\n\n**Key Points**:\n- `set(value)` defines custom logic when the property is assigned\n- `field` refers to the **backing field** (the actual stored value)\n- Use `field` to avoid infinite recursion (don't use the property name inside its own setter!)\n\n### Visibility Modifiers for Setters\n\nYou can make a property readable publicly but only writable internally:\n\n\n---\n\n",
              "code": "class BankAccount(initialBalance: Double) {\n    var balance: Double = initialBalance\n        private set  // Can only be modified inside the class\n\n    fun deposit(amount: Double) {\n        require(amount > 0) { \"Amount must be positive\" }\n        balance += amount\n    }\n\n    fun withdraw(amount: Double) {\n        require(amount > 0 && amount <= balance) { \"Invalid withdrawal\" }\n        balance -= amount\n    }\n}\n\nfun main() {\n    val account = BankAccount(1000.0)\n\n    println(account.balance)  // ‚úÖ Can read: 1000.0\n    account.deposit(500.0)\n    println(account.balance)  // 1500.0\n\n    // account.balance = 9999.0  // ‚ùå Error: Cannot assign to 'balance': the setter is private\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Late Initialization (`lateinit`)",
              "content": "\nSometimes you can't initialize a property immediately (e.g., in Android, views are initialized after the object is created). **`lateinit`** lets you declare a non-null property without initializing it right away.\n\n### When to Use `lateinit`\n\nUse `lateinit` when:\n- The property will be initialized before use (but not in the constructor)\n- The property is non-null\n- The property type is non-primitive (not Int, Double, Boolean, etc.)\n\n**Example: Setup Method**\n\n\n**Checking if `lateinit` is Initialized**:\n\n\n**Warning**: Accessing an uninitialized `lateinit` property throws `UninitializedPropertyAccessException`!\n\n**Example: Dependency Injection**\n\n\n**Output**:\n\n---\n\n",
              "code": "[LOG] Fetching user 42\nResult of: SELECT * FROM users WHERE id = 42",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Lazy Initialization",
              "content": "\n**Lazy properties** are initialized only when they're first accessed. Perfect for expensive operations that might not be needed.\n\n### The `lazy` Delegate\n\n\n**Output**:\n\n**Key Points**:\n- The lambda `{ ... }` is only executed once, on first access\n- The result is cached and reused for subsequent accesses\n- Thread-safe by default\n- Can only be used with `val` (not `var`)\n\n**Example: Configuration Loading**\n\n\n**Output**:\n\n---\n\n",
              "code": "App object created\nApplication starting...\nLoading configuration from file...\nApp: MyApp v1.0.0\nDatabase: localhost",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Backing Fields",
              "content": "\nA **backing field** is the actual storage for a property. Kotlin generates it automatically when needed.\n\n**When Kotlin generates a backing field**:\n- Property has a default accessor (getter/setter)\n- Property has a custom accessor that uses `field`\n\n**When Kotlin does NOT generate a backing field**:\n- Property only has a custom getter that doesn't use `field`\n\n\n**Example: Tracking Property Changes**\n\n\n---\n\n",
              "code": "class Product(name: String, price: Double) {\n    var name: String = name\n        set(value) {\n            println(\"Name changed from '$field' to '$value'\")\n            field = value\n        }\n\n    var price: Double = price\n        set(value) {\n            require(value >= 0) { \"Price cannot be negative\" }\n            println(\"Price changed from $$field to $$value\")\n            field = value\n        }\n}\n\nfun main() {\n    val product = Product(\"Laptop\", 999.99)\n\n    product.name = \"Gaming Laptop\"  // Name changed from 'Laptop' to 'Gaming Laptop'\n    product.price = 1299.99          // Price changed from $999.99 to $1299.99\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Property Delegation Basics",
              "content": "\n**Property delegation** allows you to reuse property logic by delegating to another object.\n\n**Syntax**: `var/val propertyName: Type by delegate`\n\n### Built-in Delegates\n\n**1. `lazy` (already covered)**\n\n**2. `observable` - Notified on property changes**\n\n\n**3. `vetoable` - Validate changes before accepting**\n\n\n---\n\n",
              "code": "import kotlin.properties.Delegates\n\nclass Settings {\n    var fontSize: Int by Delegates.vetoable(12) { property, oldValue, newValue ->\n        newValue in 8..24  // Only accept values between 8 and 24\n    }\n}\n\nfun main() {\n    val settings = Settings()\n\n    println(settings.fontSize)  // 12\n\n    settings.fontSize = 16\n    println(settings.fontSize)  // 16\n\n    settings.fontSize = 50  // Rejected (out of range)\n    println(settings.fontSize)  // Still 16\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 1: Temperature Converter",
              "content": "\n**Goal**: Create a `Temperature` class with Celsius and Fahrenheit properties that stay in sync.\n\n**Requirements**:\n1. Property: `celsius` (Double, with setter)\n2. Property: `fahrenheit` (Double, computed from celsius)\n3. When `celsius` changes, `fahrenheit` updates automatically\n4. Formulas: `F = C * 9/5 + 32`, `C = (F - 32) * 5/9`\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution: Temperature Converter",
              "content": "\n\n---\n\n",
              "code": "class Temperature(celsius: Double = 0.0) {\n    var celsius: Double = celsius\n        set(value) {\n            field = value\n            println(\"Temperature set to $value¬∞C (${fahrenheit}¬∞F)\")\n        }\n\n    val fahrenheit: Double\n        get() = celsius * 9 / 5 + 32\n\n    fun setFahrenheit(f: Double) {\n        celsius = (f - 32) * 5 / 9\n    }\n\n    fun display() {\n        println(\"$celsius¬∞C = $fahrenheit¬∞F\")\n    }\n}\n\nfun main() {\n    val temp = Temperature()\n\n    temp.celsius = 0.0    // Temperature set to 0.0¬∞C (32.0¬∞F)\n    temp.display()        // 0.0¬∞C = 32.0¬∞F\n\n    temp.celsius = 100.0  // Temperature set to 100.0¬∞C (212.0¬∞F)\n    temp.display()        // 100.0¬∞C = 212.0¬∞F\n\n    temp.setFahrenheit(98.6)\n    temp.display()        // 37.0¬∞C = 98.6¬∞F\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 2: Shopping Cart with Validation",
              "content": "\n**Goal**: Build a `ShoppingCart` class with validation and computed properties.\n\n**Requirements**:\n1. Property: `items` (mutable list of `CartItem`)\n2. Property: `totalPrice` (computed, read-only)\n3. Property: `itemCount` (computed, read-only)\n4. Method: `addItem(name: String, price: Double, quantity: Int)` - validate price > 0 and quantity > 0\n5. Method: `removeItem(name: String)`\n6. Method: `displayCart()`\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution: Shopping Cart",
              "content": "\n\n**Output**:\n\n---\n\n",
              "code": "Added Laptop to cart\nAdded Mouse to cart\nAdded Keyboard to cart\n\n=== Shopping Cart ===\nLaptop: $999.99 x 1 = $999.99\nMouse: $29.99 x 2 = $59.98\nKeyboard: $79.99 x 1 = $79.99\n---\nTotal Items: 4\nTotal Price: $1139.96\n===================\n\nUpdated Mouse quantity\n\n=== Shopping Cart ===\nLaptop: $999.99 x 1 = $999.99\nMouse: $29.99 x 3 = $89.97\nKeyboard: $79.99 x 1 = $79.99\n---\nTotal Items: 5\nTotal Price: $1169.95\n===================\n\nRemoved Keyboard from cart\n\n=== Shopping Cart ===\nLaptop: $999.99 x 1 = $999.99\nMouse: $29.99 x 3 = $89.97\n---\nTotal Items: 4\nTotal Price: $1089.96\n===================",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 3: User Profile with Lazy Loading",
              "content": "\n**Goal**: Create a `UserProfile` class that lazily loads expensive data.\n\n**Requirements**:\n1. Properties: `username`, `email`\n2. Lazy property: `profilePicture` (simulated expensive load)\n3. Lazy property: `activityHistory` (simulated database query)\n4. Method: `displayProfile()` - shows all info (triggers lazy loading)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution: User Profile",
              "content": "\n\n**Output**:\n\n---\n\n",
              "code": "Creating user profile...\nProfile object created (data not loaded yet)\n\nCalling displayProfile() for the first time...\nLoading profile picture from server...\nLoading activity history from database...\n\n=== User Profile ===\nUsername: alice_coder\nEmail: alice@example.com\nProfile Picture Size: 1024 bytes\nRecent Activities:\n  - Logged in at 2025-01-15 08:30:00\n  - Updated profile at 2025-01-15 09:15:00\n  - Posted comment at 2025-01-15 10:45:00\n===================\n\nCalling displayProfile() again (data already cached)...\n\n=== User Profile ===\nUsername: alice_coder\nEmail: alice@example.com\nProfile Picture Size: 1024 bytes\nRecent Activities:\n  - Logged in at 2025-01-15 08:30:00\n  - Updated profile at 2025-01-15 09:15:00\n  - Posted comment at 2025-01-15 10:45:00\n===================",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Checkpoint Quiz",
              "content": "\n### Question 1\nWhat is the difference between a regular property and a property with a custom getter?\n\nA) Custom getters can only be used with `var`\nB) Custom getters compute the value each time the property is accessed\nC) Custom getters are slower\nD) There is no difference\n\n### Question 2\nWhen should you use `lateinit`?\n\nA) For all properties\nB) For properties that will be initialized later, before first use\nC) For computed properties\nD) For primitive types like Int and Double\n\n### Question 3\nWhat does the `field` keyword refer to in a custom setter?\n\nA) The parameter passed to the setter\nB) The backing field (actual storage) of the property\nC) The class instance\nD) The property name\n\n### Question 4\nWhat is the main benefit of lazy initialization?\n\nA) Properties are initialized faster\nB) Expensive operations are deferred until needed\nC) Properties use less memory\nD) Properties can be null\n\n### Question 5\nWhat happens if you access an uninitialized `lateinit` property?\n\nA) It returns null\nB) It returns a default value\nC) It throws `UninitializedPropertyAccessException`\nD) The code doesn't compile\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Answers",
              "content": "\n**Question 1: B) Custom getters compute the value each time the property is accessed**\n\nCustom getters don't store a value‚Äîthey compute it when accessed.\n\n\n---\n\n**Question 2: B) For properties that will be initialized later, before first use**\n\n`lateinit` is perfect for dependency injection, Android views, or any scenario where you can't initialize in the constructor but will initialize before use.\n\n\n**Note**: Can't be used with primitive types (Int, Double, etc.) or nullable types.\n\n---\n\n**Question 3: B) The backing field (actual storage) of the property**\n\n`field` lets you access the actual stored value in custom accessors.\n\n\nWithout `field`, you'd get infinite recursion!\n\n---\n\n**Question 4: B) Expensive operations are deferred until needed**\n\nLazy initialization improves performance by delaying expensive operations until they're actually needed.\n\n\n---\n\n**Question 5: C) It throws `UninitializedPropertyAccessException`**\n\nAlways initialize `lateinit` properties before using them, or check with `::property.isInitialized`.\n\n\n---\n\n",
              "code": "lateinit var name: String\n\n// println(name)  // ‚ùå UninitializedPropertyAccessException\n\nif (::name.isInitialized) {\n    println(name)  // ‚úÖ Safe\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "What You've Learned",
              "content": "\n‚úÖ Custom getters for computed properties\n‚úÖ Custom setters for validation and transformation\n‚úÖ Private setters for controlled access\n‚úÖ `lateinit` for delayed initialization\n‚úÖ Lazy initialization with the `lazy` delegate\n‚úÖ Backing fields with the `field` keyword\n‚úÖ Property delegation basics (`observable`, `vetoable`)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Next Steps",
              "content": "\nIn **Lesson 2.3: Inheritance and Polymorphism**, you'll learn:\n- Creating class hierarchies with inheritance\n- Overriding methods and properties\n- Abstract classes for shared behavior\n- Polymorphism: treating objects of different types uniformly\n- Type checking and casting\n\nYou're mastering Kotlin's powerful property system!\n\n---\n\n**Congratulations on completing Lesson 2.2!** üéâ\n\nProperties are the foundation of OOP. Kotlin's property features give you fine-grained control while keeping your code clean and expressive.\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "3.2.1",
              "title": "Nullable Types",
              "description": "Create a function `findUserById` that takes an Int ID and returns a nullable String (username). Return null if ID is not found (ID < 1 or ID > 5).",
              "instructions": "Create a function `findUserById` that takes an Int ID and returns a nullable String (username). Return null if ID is not found (ID < 1 or ID > 5).",
              "starterCode": "fun findUserById(id: Int): String? {\n    // Return username or null\n}\n\nfun main() {\n    println(findUserById(3))\n    println(findUserById(10))\n}",
              "solution": "fun findUserById(id: Int): String? {\n    return when (id) {\n        1 -> \"Alice\"\n        2 -> \"Bob\"\n        3 -> \"Charlie\"\n        4 -> \"Diana\"\n        5 -> \"Eve\"\n        else -> null\n    }\n}\n\nfun main() {\n    println(findUserById(3))\n    println(findUserById(10))\n}",
              "language": "kotlin",
              "testCases": [
                {
                  "description": "Valid ID should return username",
                  "expectedOutput": "Charlie",
                  "isVisible": true
                },
                {
                  "description": "Invalid ID should return null",
                  "expectedOutput": "null",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use String? to indicate a nullable type"
                },
                {
                  "level": 2,
                  "text": "Use when expression to match IDs"
                },
                {
                  "level": 3,
                  "text": "Return null in the else branch"
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "3.2.2",
              "title": "Safe Call and Elvis Operator",
              "description": "Given a nullable string, safely get its length. If null, return 0 using the Elvis operator.",
              "instructions": "Given a nullable string, safely get its length. If null, return 0 using the Elvis operator.",
              "starterCode": "fun getLength(text: String?): Int {\n    // Use safe call and Elvis operator\n}\n\nfun main() {\n    println(getLength(\"Hello\"))  // Should print 5\n    println(getLength(null))      // Should print 0\n}",
              "solution": "fun getLength(text: String?): Int {\n    return text?.length ?: 0\n}\n\nfun main() {\n    println(getLength(\"Hello\"))  // Should print 5\n    println(getLength(null))      // Should print 0\n}",
              "language": "kotlin",
              "testCases": [
                {
                  "description": "Non-null string should return its length",
                  "expectedOutput": "5",
                  "isVisible": true
                },
                {
                  "description": "Null string should return 0",
                  "expectedOutput": "0",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use ?. for safe call on nullable types"
                },
                {
                  "level": 2,
                  "text": "Use ?: (Elvis operator) to provide default value"
                },
                {
                  "level": 3,
                  "text": "Combine them: text?.length ?: 0"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "3.3",
          "title": "Lesson 2.3: Inheritance and Polymorphism",
          "moduleId": "module-03",
          "order": 3,
          "estimatedMinutes": 70,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 70 minutes\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Topic Introduction",
              "content": "\nYou've learned to create classes and manage properties. Now it's time to explore one of OOP's most powerful features: **inheritance**.\n\nInheritance allows you to create new classes based on existing ones, reusing and extending their functionality. Combined with **polymorphism**, you can write flexible, maintainable code that models complex real-world relationships.\n\nImagine you're building a system for different types of employees: managers, developers, and interns. They all share common attributes (name, ID, salary) but have unique behaviors. Inheritance lets you capture these commonalities and differences elegantly.\n\n---\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "The Concept",
              "content": "\n### What is Inheritance?\n\n**Inheritance** is a mechanism where a new class (child/subclass) is based on an existing class (parent/superclass), inheriting its properties and methods.\n\n**Real-World Analogy: Vehicle Hierarchy**\n\n\n- **Vehicle** (parent): Has wheels, can move, has fuel\n- **Car** (child): Inherits from Vehicle, adds doors and trunk\n- **SportsCar** (grandchild): Inherits from Car, adds turbo boost\n\n**Why Inheritance?**\n- **Code Reuse**: Don't repeat common functionality\n- **Logical Organization**: Model real-world relationships\n- **Maintainability**: Change once, affect all subclasses\n- **Polymorphism**: Treat different types uniformly\n\n---\n\n",
              "code": "        Vehicle\n       /   |   \\\n     Car  Bike  Truck\n    /\n  SportsCar",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Inheritance Basics",
              "content": "\n### The `open` Keyword\n\nIn Kotlin, classes are **final by default** (cannot be inherited). Use `open` to allow inheritance.\n\n\n**Why are classes final by default?**\n- Safety: Prevents unintended inheritance\n- Performance: Compiler optimizations\n- Design: Encourages composition over inheritance\n\n### Creating a Subclass\n\nUse a colon (`:`) to inherit from a superclass.\n\n\n**Key Points**:\n- `Dog` and `Cat` inherit from `Animal`\n- They inherit `sleep()` (can use it without redefining)\n- They override `makeSound()` with their own implementation\n- They add unique methods (`fetch()`, `scratch()`)\n\n---\n\n",
              "code": "open class Animal(val name: String) {\n    open fun makeSound() {\n        println(\"Some generic animal sound\")\n    }\n\n    fun sleep() {\n        println(\"$name is sleeping...\")\n    }\n}\n\nclass Dog(name: String) : Animal(name) {\n    override fun makeSound() {\n        println(\"$name says: Woof! Woof!\")\n    }\n\n    fun fetch() {\n        println(\"$name is fetching the ball!\")\n    }\n}\n\nclass Cat(name: String) : Animal(name) {\n    override fun makeSound() {\n        println(\"$name says: Meow!\")\n    }\n\n    fun scratch() {\n        println(\"$name is scratching the furniture!\")\n    }\n}\n\nfun main() {\n    val dog = Dog(\"Buddy\")\n    dog.makeSound()  // Buddy says: Woof! Woof!\n    dog.sleep()      // Buddy is sleeping...\n    dog.fetch()      // Buddy is fetching the ball!\n\n    val cat = Cat(\"Whiskers\")\n    cat.makeSound()  // Whiskers says: Meow!\n    cat.sleep()      // Whiskers is sleeping...\n    cat.scratch()    // Whiskers is scratching the furniture!\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Overriding Methods",
              "content": "\nTo override a method from the superclass:\n1. The superclass method must be marked `open`\n2. Use the `override` keyword in the subclass\n\n\n---\n\n",
              "code": "open class Shape {\n    open fun draw() {\n        println(\"Drawing a shape\")\n    }\n\n    open fun area(): Double {\n        return 0.0\n    }\n}\n\nclass Circle(val radius: Double) : Shape() {\n    override fun draw() {\n        println(\"Drawing a circle with radius $radius\")\n    }\n\n    override fun area(): Double {\n        return Math.PI * radius * radius\n    }\n}\n\nclass Rectangle(val width: Double, val height: Double) : Shape() {\n    override fun draw() {\n        println(\"Drawing a rectangle $width x $height\")\n    }\n\n    override fun area(): Double {\n        return width * height\n    }\n}\n\nfun main() {\n    val circle = Circle(5.0)\n    circle.draw()  // Drawing a circle with radius 5.0\n    println(\"Area: ${circle.area()}\")  // Area: 78.53981633974483\n\n    val rect = Rectangle(4.0, 6.0)\n    rect.draw()  // Drawing a rectangle 4.0 x 6.0\n    println(\"Area: ${rect.area()}\")  // Area: 24.0\n}",
              "language": "kotlin"
            },
            {
              "type": "KEY_POINT",
              "title": "The `super` Keyword",
              "content": "\nUse `super` to call the superclass's implementation.\n\n\n**Output**:\n\n---\n\n",
              "code": "Employee: Alice\nSalary: $120000.0\nTeam Size: 5\nRole: Manager\n\nAlice is managing a team of 5 people\nAlice is conducting a team meeting\n\n---\n\nEmployee: Bob\nSalary: $90000.0\nLanguage: Kotlin\nRole: Developer\n\nBob is coding in Kotlin",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Abstract Classes",
              "content": "\n**Abstract classes** are classes that cannot be instantiated directly. They serve as blueprints for subclasses.\n\nUse abstract classes when:\n- You want to provide a common base with some implemented methods\n- You want to force subclasses to implement specific methods\n\n\n---\n\n",
              "code": "abstract class Vehicle(val brand: String, val model: String) {\n    var speed: Int = 0\n\n    // Abstract method (no implementation)\n    abstract fun start()\n\n    // Abstract method\n    abstract fun stop()\n\n    // Concrete method (has implementation)\n    fun accelerate(amount: Int) {\n        speed += amount\n        println(\"$brand $model accelerating to $speed km/h\")\n    }\n\n    fun brake(amount: Int) {\n        speed -= amount\n        if (speed < 0) speed = 0\n        println(\"$brand $model slowing down to $speed km/h\")\n    }\n}\n\nclass Car(brand: String, model: String) : Vehicle(brand, model) {\n    override fun start() {\n        println(\"$brand $model: Turning key, engine starts\")\n    }\n\n    override fun stop() {\n        println(\"$brand $model: Turning off engine\")\n        speed = 0\n    }\n}\n\nclass ElectricBike(brand: String, model: String) : Vehicle(brand, model) {\n    override fun start() {\n        println(\"$brand $model: Pressing power button, motor starts silently\")\n    }\n\n    override fun stop() {\n        println(\"$brand $model: Releasing throttle, motor stops\")\n        speed = 0\n    }\n}\n\nfun main() {\n    // val vehicle = Vehicle(\"Generic\", \"Model\")  // ‚ùå Cannot instantiate abstract class\n\n    val car = Car(\"Toyota\", \"Camry\")\n    car.start()          // Toyota Camry: Turning key, engine starts\n    car.accelerate(50)   // Toyota Camry accelerating to 50 km/h\n    car.accelerate(30)   // Toyota Camry accelerating to 80 km/h\n    car.brake(20)        // Toyota Camry slowing down to 60 km/h\n    car.stop()           // Toyota Camry: Turning off engine\n\n    println()\n\n    val bike = ElectricBike(\"Tesla\", \"E-Bike Pro\")\n    bike.start()         // Tesla E-Bike Pro: Pressing power button, motor starts silently\n    bike.accelerate(25)  // Tesla E-Bike Pro accelerating to 25 km/h\n    bike.stop()          // Tesla E-Bike Pro: Releasing throttle, motor stops\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Polymorphism",
              "content": "\n**Polymorphism** means \"many forms.\" It allows you to treat objects of different types through a common interface.\n\n**Example: Animal Sounds**\n\n\n**Output**:\n\n**Key Point**: Even though `animals` is a list of `Animal`, each object calls its own specific `makeSound()` implementation!\n\n---\n\n",
              "code": "Buddy: Woof! Woof!\nWhiskers: Meow!\nBessie: Moo!\nMax: Woof! Woof!\nFluffy: Meow!",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Type Checking and Casting",
              "content": "\n### Type Checking with `is`\n\n\n### Smart Casting\n\nKotlin automatically casts after type checking:\n\n\n### Explicit Casting\n\n\n---\n\n",
              "code": "val animal: Animal = Dog(\"Buddy\")\n\n// Safe cast (returns null if cast fails)\nval dog: Dog? = animal as? Dog\ndog?.fetch()\n\n// Unsafe cast (throws exception if cast fails)\nval dog2: Dog = animal as Dog\ndog2.fetch()",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 1: Employee Hierarchy",
              "content": "\n**Goal**: Create an employee management system with inheritance.\n\n**Requirements**:\n1. Abstract class `Employee` with properties: `name`, `id`, `baseSalary`\n2. Abstract method: `calculateSalary(): Double`\n3. Method: `displayInfo()`\n4. Class `FullTimeEmployee` extends `Employee`:\n   - Adds `bonus` property\n   - Implements `calculateSalary()` as baseSalary + bonus\n5. Class `Contractor` extends `Employee`:\n   - Adds `hourlyRate` and `hoursWorked` properties\n   - Implements `calculateSalary()` as hourlyRate * hoursWorked\n6. Class `Intern` extends `Employee`:\n   - Adds `stipend` property\n   - Implements `calculateSalary()` as stipend (fixed amount)\n7. Create a list of mixed employees and calculate total payroll\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution: Employee Hierarchy",
              "content": "\n\n---\n\n",
              "code": "abstract class Employee(val name: String, val id: String, val baseSalary: Double) {\n    abstract fun calculateSalary(): Double\n\n    open fun displayInfo() {\n        println(\"ID: $id\")\n        println(\"Name: $name\")\n        println(\"Salary: $${calculateSalary()}\")\n    }\n}\n\nclass FullTimeEmployee(\n    name: String,\n    id: String,\n    baseSalary: Double,\n    val bonus: Double\n) : Employee(name, id, baseSalary) {\n\n    override fun calculateSalary(): Double {\n        return baseSalary + bonus\n    }\n\n    override fun displayInfo() {\n        println(\"=== Full-Time Employee ===\")\n        super.displayInfo()\n        println(\"Base Salary: $$baseSalary\")\n        println(\"Bonus: $$bonus\")\n    }\n}\n\nclass Contractor(\n    name: String,\n    id: String,\n    val hourlyRate: Double,\n    val hoursWorked: Double\n) : Employee(name, id, 0.0) {\n\n    override fun calculateSalary(): Double {\n        return hourlyRate * hoursWorked\n    }\n\n    override fun displayInfo() {\n        println(\"=== Contractor ===\")\n        super.displayInfo()\n        println(\"Hourly Rate: $$hourlyRate\")\n        println(\"Hours Worked: $hoursWorked\")\n    }\n}\n\nclass Intern(\n    name: String,\n    id: String,\n    val stipend: Double\n) : Employee(name, id, 0.0) {\n\n    override fun calculateSalary(): Double {\n        return stipend\n    }\n\n    override fun displayInfo() {\n        println(\"=== Intern ===\")\n        super.displayInfo()\n        println(\"Monthly Stipend: $$stipend\")\n    }\n}\n\nfun main() {\n    val employees: List<Employee> = listOf(\n        FullTimeEmployee(\"Alice Johnson\", \"FT001\", 80000.0, 10000.0),\n        FullTimeEmployee(\"Bob Smith\", \"FT002\", 75000.0, 8000.0),\n        Contractor(\"Carol Davis\", \"CT001\", 50.0, 160.0),\n        Contractor(\"David Wilson\", \"CT002\", 60.0, 120.0),\n        Intern(\"Eve Brown\", \"IN001\", 2000.0),\n        Intern(\"Frank Miller\", \"IN002\", 1800.0)\n    )\n\n    employees.forEach { employee ->\n        employee.displayInfo()\n        println()\n    }\n\n    val totalPayroll = employees.sumOf { it.calculateSalary() }\n    println(\"=== Payroll Summary ===\")\n    println(\"Total Employees: ${employees.size}\")\n    println(\"Total Payroll: $$totalPayroll\")\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 2: Shape Hierarchy",
              "content": "\n**Goal**: Create a comprehensive shape system.\n\n**Requirements**:\n1. Abstract class `Shape` with abstract methods: `area()`, `perimeter()`, `draw()`\n2. Class `Circle` extends `Shape` with radius\n3. Class `Rectangle` extends `Shape` with width and height\n4. Class `Triangle` extends `Shape` with three sides\n5. Create a function that prints total area of all shapes\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution: Shape Hierarchy",
              "content": "\n\n---\n\n",
              "code": "import kotlin.math.sqrt\n\nabstract class Shape(val color: String) {\n    abstract fun area(): Double\n    abstract fun perimeter(): Double\n    abstract fun draw()\n\n    fun displayInfo() {\n        println(\"Color: $color\")\n        println(\"Area: ${String.format(\"%.2f\", area())}\")\n        println(\"Perimeter: ${String.format(\"%.2f\", perimeter())}\")\n    }\n}\n\nclass Circle(color: String, val radius: Double) : Shape(color) {\n    override fun area(): Double = Math.PI * radius * radius\n\n    override fun perimeter(): Double = 2 * Math.PI * radius\n\n    override fun draw() {\n        println(\"‚≠ï Drawing a $color circle with radius $radius\")\n    }\n}\n\nclass Rectangle(color: String, val width: Double, val height: Double) : Shape(color) {\n    override fun area(): Double = width * height\n\n    override fun perimeter(): Double = 2 * (width + height)\n\n    override fun draw() {\n        println(\"‚ñ≠ Drawing a $color rectangle ${width}x${height}\")\n    }\n}\n\nclass Triangle(color: String, val side1: Double, val side2: Double, val side3: Double) : Shape(color) {\n\n    init {\n        require(isValid()) { \"Invalid triangle: sides don't satisfy triangle inequality\" }\n    }\n\n    private fun isValid(): Boolean {\n        return side1 + side2 > side3 && side1 + side3 > side2 && side2 + side3 > side1\n    }\n\n    override fun area(): Double {\n        // Heron's formula\n        val s = perimeter() / 2\n        return sqrt(s * (s - side1) * (s - side2) * (s - side3))\n    }\n\n    override fun perimeter(): Double = side1 + side2 + side3\n\n    override fun draw() {\n        println(\"‚ñ≥ Drawing a $color triangle with sides $side1, $side2, $side3\")\n    }\n}\n\nfun printTotalArea(shapes: List<Shape>) {\n    val total = shapes.sumOf { it.area() }\n    println(\"Total area of all shapes: ${String.format(\"%.2f\", total)}\")\n}\n\nfun main() {\n    val shapes: List<Shape> = listOf(\n        Circle(\"Red\", 5.0),\n        Rectangle(\"Blue\", 4.0, 6.0),\n        Triangle(\"Green\", 3.0, 4.0, 5.0),\n        Circle(\"Yellow\", 3.0),\n        Rectangle(\"Purple\", 10.0, 2.0)\n    )\n\n    shapes.forEach { shape ->\n        shape.draw()\n        shape.displayInfo()\n        println()\n    }\n\n    printTotalArea(shapes)\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 3: Bank Account Hierarchy",
              "content": "\n**Goal**: Build different types of bank accounts with shared and unique features.\n\n**Requirements**:\n1. Open class `BankAccount` with `accountNumber`, `holder`, `balance`\n2. Methods: `deposit()`, `withdraw()`, `displayBalance()`\n3. Class `SavingsAccount` extends `BankAccount`:\n   - Adds `interestRate` property\n   - Method `applyInterest()`\n   - Withdrawal limit of 3 times per month\n4. Class `CheckingAccount` extends `BankAccount`:\n   - Adds `overdraftLimit` property\n   - Can withdraw beyond balance up to overdraft limit\n5. Test all account types\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution: Bank Account Hierarchy",
              "content": "\n\n---\n\n",
              "code": "open class BankAccount(val accountNumber: String, val holder: String) {\n    protected var balance: Double = 0.0\n\n    open fun deposit(amount: Double) {\n        require(amount > 0) { \"Deposit amount must be positive\" }\n        balance += amount\n        println(\"Deposited $$amount. New balance: $$balance\")\n    }\n\n    open fun withdraw(amount: Double): Boolean {\n        require(amount > 0) { \"Withdrawal amount must be positive\" }\n\n        return if (amount <= balance) {\n            balance -= amount\n            println(\"Withdrew $$amount. New balance: $$balance\")\n            true\n        } else {\n            println(\"Insufficient funds! Balance: $$balance\")\n            false\n        }\n    }\n\n    fun displayBalance() {\n        println(\"Account: $accountNumber ($holder)\")\n        println(\"Balance: $$balance\")\n    }\n}\n\nclass SavingsAccount(\n    accountNumber: String,\n    holder: String,\n    val interestRate: Double\n) : BankAccount(accountNumber, holder) {\n\n    private var withdrawalsThisMonth = 0\n    private val maxWithdrawals = 3\n\n    override fun withdraw(amount: Double): Boolean {\n        if (withdrawalsThisMonth >= maxWithdrawals) {\n            println(\"Withdrawal limit reached! Maximum $maxWithdrawals withdrawals per month.\")\n            return false\n        }\n\n        val success = super.withdraw(amount)\n        if (success) {\n            withdrawalsThisMonth++\n            println(\"Withdrawals remaining this month: ${maxWithdrawals - withdrawalsThisMonth}\")\n        }\n        return success\n    }\n\n    fun applyInterest() {\n        val interest = balance * interestRate / 100\n        balance += interest\n        println(\"Interest applied: $$interest. New balance: $$balance\")\n    }\n\n    fun resetMonthlyWithdrawals() {\n        withdrawalsThisMonth = 0\n        println(\"Monthly withdrawal limit reset\")\n    }\n}\n\nclass CheckingAccount(\n    accountNumber: String,\n    holder: String,\n    val overdraftLimit: Double\n) : BankAccount(accountNumber, holder) {\n\n    override fun withdraw(amount: Double): Boolean {\n        require(amount > 0) { \"Withdrawal amount must be positive\" }\n\n        val availableFunds = balance + overdraftLimit\n\n        return if (amount <= availableFunds) {\n            balance -= amount\n            println(\"Withdrew $$amount. New balance: $$balance\")\n            if (balance < 0) {\n                println(\"‚ö†Ô∏è Account overdrawn by $${-balance}\")\n            }\n            true\n        } else {\n            println(\"Exceeds overdraft limit! Available: $$availableFunds\")\n            false\n        }\n    }\n}\n\nfun main() {\n    println(\"=== Savings Account ===\")\n    val savings = SavingsAccount(\"SAV001\", \"Alice Johnson\", 2.5)\n    savings.deposit(1000.0)\n    savings.applyInterest()\n    savings.withdraw(100.0)\n    savings.withdraw(100.0)\n    savings.withdraw(100.0)\n    savings.withdraw(100.0)  // Should fail (limit reached)\n    savings.displayBalance()\n\n    println(\"\\n=== Checking Account ===\")\n    val checking = CheckingAccount(\"CHK001\", \"Bob Smith\", 500.0)\n    checking.deposit(1000.0)\n    checking.withdraw(1200.0)  // Uses overdraft\n    checking.withdraw(400.0)   // Should fail (exceeds overdraft limit)\n    checking.displayBalance()\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Checkpoint Quiz",
              "content": "\n### Question 1\nWhat keyword is required to allow a class to be inherited?\n\nA) `extend`\nB) `open`\nC) `inherit`\nD) `abstract`\n\n### Question 2\nWhat is polymorphism?\n\nA) Creating multiple classes\nB) The ability to treat objects of different types through a common interface\nC) Overriding methods\nD) Using multiple inheritance\n\n### Question 3\nWhen should you use an abstract class?\n\nA) When you never want instances of that class\nB) When you want to provide a common base with some implemented methods\nC) When you want to force subclasses to implement specific methods\nD) Both B and C\n\n### Question 4\nWhat does the `super` keyword do?\n\nA) Creates a new superclass\nB) Calls the subclass's implementation\nC) Calls the superclass's implementation\nD) Deletes the superclass\n\n### Question 5\nWhat is smart casting in Kotlin?\n\nA) Converting strings to integers\nB) Automatic type casting after a type check with `is`\nC) Casting to any type\nD) A compiler optimization\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Answers",
              "content": "\n**Question 1: B) `open`**\n\nKotlin classes are final by default. Use `open` to allow inheritance.\n\n\n---\n\n**Question 2: B) The ability to treat objects of different types through a common interface**\n\nPolymorphism lets you write code that works with a superclass but automatically uses the correct subclass implementation.\n\n\n---\n\n**Question 3: D) Both B and C**\n\nAbstract classes provide partial implementation (some methods implemented, some abstract) and force subclasses to implement abstract methods.\n\n\n---\n\n**Question 4: C) Calls the superclass's implementation**\n\nUse `super` to access the parent class's methods or properties.\n\n\n---\n\n**Question 5: B) Automatic type casting after a type check with `is`**\n\nAfter checking a type with `is`, Kotlin automatically casts the variable.\n\n\n---\n\n",
              "code": "if (animal is Dog) {\n    animal.fetch()  // No explicit cast needed!\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "What You've Learned",
              "content": "\n‚úÖ Inheritance basics with `open` and `:` syntax\n‚úÖ Overriding methods with `override`\n‚úÖ Using `super` to call parent implementations\n‚úÖ Abstract classes for shared functionality\n‚úÖ Polymorphism for flexible code\n‚úÖ Type checking with `is` and smart casting\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Next Steps",
              "content": "\nIn **Lesson 2.4: Interfaces and Abstract Classes**, you'll learn:\n- Defining and implementing interfaces\n- Multiple interface implementation\n- Default interface methods\n- When to use interfaces vs abstract classes\n- Real-world design patterns\n\nYou're mastering inheritance! Keep building on this foundation!\n\n---\n\n**Congratulations on completing Lesson 2.3!** üéâ\n\nInheritance and polymorphism are cornerstones of OOP. You now have the tools to create flexible, maintainable class hierarchies!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "3.3.1",
              "title": "Inheritance",
              "description": "Create an open class `Animal` with a property `name` and an open method `makeSound()`. Create a subclass `Dog` that overrides `makeSound()` to print 'Woof!'.",
              "instructions": "Create an open class `Animal` with a property `name` and an open method `makeSound()`. Create a subclass `Dog` that overrides `makeSound()` to print 'Woof!'.",
              "starterCode": "// Create your Animal class (make it open)\n\n// Create your Dog class that extends Animal\n\nfun main() {\n    val dog = Dog(\"Buddy\")\n    println(\"Name: ${dog.name}\")\n    dog.makeSound()\n}",
              "solution": "open class Animal(val name: String) {\n    open fun makeSound() {\n        println(\"Some sound\")\n    }\n}\n\nclass Dog(name: String) : Animal(name) {\n    override fun makeSound() {\n        println(\"Woof!\")\n    }\n}\n\nfun main() {\n    val dog = Dog(\"Buddy\")\n    println(\"Name: ${dog.name}\")\n    dog.makeSound()\n}",
              "language": "kotlin",
              "testCases": [
                {
                  "description": "Dog should have name property",
                  "expectedOutput": "Name: Buddy",
                  "isVisible": true
                },
                {
                  "description": "Dog should override makeSound",
                  "expectedOutput": "Woof!",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use 'open' keyword to allow inheritance"
                },
                {
                  "level": 2,
                  "text": "Use : to extend a class"
                },
                {
                  "level": 3,
                  "text": "Use 'override' keyword for overriding methods"
                },
                {
                  "level": 4,
                  "text": "Call parent constructor with : ParentClass(args)"
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "3.3.2",
              "title": "Interfaces",
              "description": "Create an interface `Drivable` with a method `drive()`. Create two classes `Car` and `Bicycle` that implement this interface.",
              "instructions": "Create an interface `Drivable` with a method `drive()`. Create two classes `Car` and `Bicycle` that implement this interface.",
              "starterCode": "// Create Drivable interface\n\n// Create Car class\n\n// Create Bicycle class\n\nfun main() {\n    val car: Drivable = Car()\n    val bicycle: Drivable = Bicycle()\n    car.drive()\n    bicycle.drive()\n}",
              "solution": "interface Drivable {\n    fun drive()\n}\n\nclass Car : Drivable {\n    override fun drive() {\n        println(\"Driving a car with engine\")\n    }\n}\n\nclass Bicycle : Drivable {\n    override fun drive() {\n        println(\"Riding a bicycle with pedals\")\n    }\n}\n\nfun main() {\n    val car: Drivable = Car()\n    val bicycle: Drivable = Bicycle()\n    car.drive()\n    bicycle.drive()\n}",
              "language": "kotlin",
              "testCases": [
                {
                  "description": "Car should drive with engine",
                  "expectedOutput": "Driving a car with engine",
                  "isVisible": true
                },
                {
                  "description": "Bicycle should ride with pedals",
                  "expectedOutput": "Riding a bicycle with pedals",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use 'interface' keyword to define an interface"
                },
                {
                  "level": 2,
                  "text": "Interface methods don't have implementations"
                },
                {
                  "level": 3,
                  "text": "Implement interface with : InterfaceName"
                },
                {
                  "level": 4,
                  "text": "Use 'override' to implement interface methods"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "3.4",
          "title": "Lesson 2.4: Interfaces and Abstract Classes",
          "moduleId": "module-03",
          "order": 4,
          "estimatedMinutes": 65,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 65 minutes\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Topic Introduction",
              "content": "\nYou've learned about inheritance and abstract classes. Now let's explore **interfaces**‚Äîone of OOP's most powerful tools for designing flexible, maintainable systems.\n\nAn **interface** defines a contract: \"Any class that implements me must provide these capabilities.\" Unlike abstract classes (which you can only inherit from one), a class can implement multiple interfaces, enabling composition of behaviors.\n\nThis lesson will teach you:\n- How to define and implement interfaces\n- The difference between interfaces and abstract classes\n- When to use each\n- Default interface methods\n- Real-world design patterns\n\n---\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "The Concept",
              "content": "\n### What is an Interface?\n\nAn **interface** is a contract that defines what a class can do, without specifying how it does it.\n\n**Real-World Analogy: Power Outlets**\n\nA power outlet is an interface:\n- **Contract**: \"I provide electricity through these two/three holes\"\n- **Devices** (implementations): Phone chargers, laptops, lamps all plug into the same outlet\n- **Different implementations**: Each device uses the electricity differently, but all follow the outlet interface\n\n\n### Why Interfaces?\n\n**Problems interfaces solve**:\n1. **Multiple inheritance**: A class can implement multiple interfaces\n2. **Loose coupling**: Code depends on contracts, not implementations\n3. **Testability**: Easy to create mock implementations for testing\n4. **Flexibility**: Swap implementations without changing client code\n\n---\n\n",
              "code": "  Interface: PowerSource\n       ‚Üì\n  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n  ‚îÇ fun provideElectricity()  ‚îÇ\n  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n           ‚Üì         ‚Üì         ‚Üì\n     PhoneCharger  Laptop   Lamp",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Defining Interfaces",
              "content": "\n**Syntax**:\n\n\n**Example: Simple Interface**\n\n\n**Output**:\n\n---\n\n",
              "code": "Drawing a circle\nDrawing a square",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Implementing Multiple Interfaces",
              "content": "\nUnlike classes (single inheritance), you can implement multiple interfaces!\n\n\n**Output**:\n\n---\n\n",
              "code": "Duck is flying\nDuck is swimming\nDuck is walking\n\nFish is swimming\n\nBird is flying\nBird is walking",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Interface Properties",
              "content": "\nInterfaces can declare properties, but they can't have backing fields.\n\n\n---\n\n",
              "code": "interface Vehicle {\n    val maxSpeed: Int  // Must be overridden\n    val type: String\n        get() = \"Generic Vehicle\"  // Can provide default\n\n    fun start()\n    fun stop()\n}\n\nclass Car(override val maxSpeed: Int) : Vehicle {\n    override val type: String\n        get() = \"Car\"\n\n    override fun start() {\n        println(\"Car starting with key\")\n    }\n\n    override fun stop() {\n        println(\"Car stopping\")\n    }\n}\n\nclass Motorcycle(override val maxSpeed: Int) : Vehicle {\n    override val type: String = \"Motorcycle\"  // Can also initialize directly\n\n    override fun start() {\n        println(\"Motorcycle starting with button\")\n    }\n\n    override fun stop() {\n        println(\"Motorcycle stopping\")\n    }\n}\n\nfun main() {\n    val car = Car(180)\n    println(\"${car.type} - Max Speed: ${car.maxSpeed} km/h\")\n    car.start()\n\n    val bike = Motorcycle(220)\n    println(\"${bike.type} - Max Speed: ${bike.maxSpeed} km/h\")\n    bike.start()\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Default Interface Methods",
              "content": "\nKotlin interfaces can have default implementations (unlike Java pre-8):\n\n\n---\n\n",
              "code": "interface Logger {\n    fun log(message: String) {\n        println(\"[LOG] $message\")  // Default implementation\n    }\n\n    fun error(message: String) {\n        println(\"[ERROR] $message\")  // Default implementation\n    }\n\n    fun debug(message: String)  // Must be implemented\n}\n\nclass ConsoleLogger : Logger {\n    override fun debug(message: String) {\n        println(\"[DEBUG] $message\")\n    }\n    // log() and error() use default implementations\n}\n\nclass FileLogger : Logger {\n    override fun log(message: String) {\n        println(\"[FILE LOG] Writing to file: $message\")\n    }\n\n    override fun error(message: String) {\n        println(\"[FILE ERROR] Writing error to file: $message\")\n    }\n\n    override fun debug(message: String) {\n        println(\"[FILE DEBUG] Writing debug to file: $message\")\n    }\n}\n\nfun main() {\n    val console = ConsoleLogger()\n    console.log(\"Application started\")\n    console.error(\"Connection failed\")\n    console.debug(\"Variable value: 42\")\n\n    println()\n\n    val file = FileLogger()\n    file.log(\"Application started\")\n    file.error(\"Connection failed\")\n    file.debug(\"Variable value: 42\")\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Abstract Classes vs Interfaces",
              "content": "\n### When to Use Abstract Classes\n\nUse **abstract classes** when:\n- You have shared **state** (properties with backing fields)\n- You want to provide **common implementation** for subclasses\n- You have a clear \"is-a\" relationship\n- You need **constructors with parameters**\n\n\n### When to Use Interfaces\n\nUse **interfaces** when:\n- You want to define **capabilities** or **behaviors**\n- You need **multiple inheritance** of type\n- You don't need shared state\n- You want loose coupling\n\n\n### Comparison Table\n\n| Feature | Abstract Class | Interface |\n|---------|---------------|-----------|\n| State (backing fields) | ‚úÖ Yes | ‚ùå No |\n| Constructor | ‚úÖ Yes | ‚ùå No |\n| Multiple inheritance | ‚ùå No (single only) | ‚úÖ Yes (multiple) |\n| Default implementations | ‚úÖ Yes | ‚úÖ Yes (since Kotlin 1.0) |\n| Access modifiers | ‚úÖ Yes (public, protected, private) | ‚úÖ Limited (public only) |\n| When to use | \"is-a\" relationship | \"can-do\" capability |\n\n---\n\n",
              "code": "interface Flyable {\n    fun fly()\n}\n\ninterface Swimmable {\n    fun swim()\n}\n\n// A class can implement multiple interfaces\nclass Duck : Flyable, Swimmable {\n    override fun fly() = println(\"Duck flying\")\n    override fun swim() = println(\"Duck swimming\")\n}",
              "language": "kotlin"
            },
            {
              "type": "EXAMPLE",
              "title": "Real-World Example: E-Commerce System",
              "content": "\n\n---\n\n",
              "code": "// Interface for payment processing\ninterface PaymentProcessor {\n    fun processPayment(amount: Double): Boolean\n    fun refund(transactionId: String): Boolean\n\n    fun validatePayment(amount: Double): Boolean {\n        return amount > 0  // Default implementation\n    }\n}\n\n// Interface for notification\ninterface Notifiable {\n    fun sendNotification(message: String)\n}\n\n// Credit card payment\nclass CreditCardProcessor : PaymentProcessor {\n    override fun processPayment(amount: Double): Boolean {\n        if (!validatePayment(amount)) return false\n        println(\"Processing credit card payment: $$amount\")\n        println(\"Payment successful!\")\n        return true\n    }\n\n    override fun refund(transactionId: String): Boolean {\n        println(\"Refunding transaction: $transactionId\")\n        return true\n    }\n}\n\n// PayPal payment\nclass PayPalProcessor : PaymentProcessor, Notifiable {\n    override fun processPayment(amount: Double): Boolean {\n        if (!validatePayment(amount)) return false\n        println(\"Processing PayPal payment: $$amount\")\n        sendNotification(\"Payment processed via PayPal\")\n        return true\n    }\n\n    override fun refund(transactionId: String): Boolean {\n        println(\"Refunding PayPal transaction: $transactionId\")\n        sendNotification(\"Refund processed\")\n        return true\n    }\n\n    override fun sendNotification(message: String) {\n        println(\"üìß Email sent: $message\")\n    }\n}\n\n// Bitcoin payment\nclass BitcoinProcessor : PaymentProcessor, Notifiable {\n    override fun processPayment(amount: Double): Boolean {\n        if (!validatePayment(amount)) return false\n        println(\"Processing Bitcoin payment: $$amount\")\n        println(\"Waiting for blockchain confirmation...\")\n        sendNotification(\"Bitcoin payment received\")\n        return true\n    }\n\n    override fun refund(transactionId: String): Boolean {\n        println(\"Bitcoin refunds take 24-48 hours\")\n        return false\n    }\n\n    override fun sendNotification(message: String) {\n        println(\"üì± Push notification: $message\")\n    }\n}\n\nfun checkout(processor: PaymentProcessor, amount: Double) {\n    println(\"\\n=== Checkout ===\")\n    val success = processor.processPayment(amount)\n\n    if (success) {\n        println(\"Order confirmed!\")\n    } else {\n        println(\"Payment failed!\")\n    }\n}\n\nfun main() {\n    val creditCard = CreditCardProcessor()\n    val paypal = PayPalProcessor()\n    val bitcoin = BitcoinProcessor()\n\n    checkout(creditCard, 99.99)\n    checkout(paypal, 149.99)\n    checkout(bitcoin, 299.99)\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 1: Media Player System",
              "content": "\n**Goal**: Create a flexible media player system using interfaces.\n\n**Requirements**:\n1. Interface `Playable` with methods: `play()`, `pause()`, `stop()`\n2. Interface `Downloadable` with method: `download()`\n3. Class `Song` implements `Playable` and `Downloadable`\n4. Class `Podcast` implements `Playable` and `Downloadable`\n5. Class `LiveStream` implements only `Playable` (can't download)\n6. Create a playlist that can hold any `Playable` item\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution: Media Player System",
              "content": "\n\n---\n\n",
              "code": "interface Playable {\n    val title: String\n    var isPlaying: Boolean\n\n    fun play() {\n        isPlaying = true\n        println(\"‚ñ∂Ô∏è  Playing: $title\")\n    }\n\n    fun pause() {\n        isPlaying = false\n        println(\"‚è∏Ô∏è  Paused: $title\")\n    }\n\n    fun stop() {\n        isPlaying = false\n        println(\"‚èπÔ∏è  Stopped: $title\")\n    }\n}\n\ninterface Downloadable {\n    val sizeInMB: Double\n\n    fun download() {\n        println(\"‚¨áÔ∏è  Downloading... ($sizeInMB MB)\")\n        println(\"‚úÖ Download complete!\")\n    }\n}\n\nclass Song(\n    override val title: String,\n    val artist: String,\n    override val sizeInMB: Double\n) : Playable, Downloadable {\n    override var isPlaying: Boolean = false\n\n    override fun play() {\n        println(\"üéµ Song\")\n        super.play()\n        println(\"   Artist: $artist\")\n    }\n}\n\nclass Podcast(\n    override val title: String,\n    val host: String,\n    val episode: Int,\n    override val sizeInMB: Double\n) : Playable, Downloadable {\n    override var isPlaying: Boolean = false\n\n    override fun play() {\n        println(\"üéôÔ∏è  Podcast\")\n        super.play()\n        println(\"   Host: $host, Episode: $episode\")\n    }\n}\n\nclass LiveStream(\n    override val title: String,\n    val streamer: String\n) : Playable {\n    override var isPlaying: Boolean = false\n\n    override fun play() {\n        println(\"üì° Live Stream\")\n        super.play()\n        println(\"   Streamer: $streamer\")\n    }\n}\n\nclass MediaPlayer {\n    private val playlist = mutableListOf<Playable>()\n    private var currentIndex = 0\n\n    fun addToPlaylist(item: Playable) {\n        playlist.add(item)\n        println(\"Added to playlist: ${item.title}\")\n    }\n\n    fun playAll() {\n        println(\"\\n=== Playing All ===\")\n        playlist.forEach { it.play() }\n    }\n\n    fun downloadAll() {\n        println(\"\\n=== Downloading All (if possible) ===\")\n        playlist.forEach { item ->\n            if (item is Downloadable) {\n                item.download()\n            } else {\n                println(\"‚ö†Ô∏è  ${item.title} cannot be downloaded (live stream)\")\n            }\n        }\n    }\n}\n\nfun main() {\n    val player = MediaPlayer()\n\n    val song1 = Song(\"Bohemian Rhapsody\", \"Queen\", 5.8)\n    val song2 = Song(\"Imagine\", \"John Lennon\", 3.2)\n    val podcast = Podcast(\"Tech Talk Daily\", \"Jane Doe\", 42, 25.5)\n    val stream = LiveStream(\"Gaming Night\", \"ProGamer123\")\n\n    player.addToPlaylist(song1)\n    player.addToPlaylist(song2)\n    player.addToPlaylist(podcast)\n    player.addToPlaylist(stream)\n\n    player.playAll()\n    player.downloadAll()\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 2: Smart Home System",
              "content": "\n**Goal**: Create a smart home system with different device types.\n\n**Requirements**:\n1. Interface `SmartDevice` with properties: `name`, `isOn`, methods: `turnOn()`, `turnOff()`\n2. Interface `Schedulable` with method: `schedule(time: String)`\n3. Interface `VoiceControllable` with method: `respondToVoice(command: String)`\n4. Class `SmartLight` implements all three interfaces\n5. Class `SmartThermostat` implements `SmartDevice` and `Schedulable`\n6. Class `SmartSpeaker` implements `SmartDevice` and `VoiceControllable`\n7. Create a home controller that manages all devices\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution: Smart Home System",
              "content": "\n\n---\n\n",
              "code": "interface SmartDevice {\n    val name: String\n    var isOn: Boolean\n\n    fun turnOn() {\n        isOn = true\n        println(\"‚úÖ $name is now ON\")\n    }\n\n    fun turnOff() {\n        isOn = false\n        println(\"‚ùå $name is now OFF\")\n    }\n\n    fun getStatus(): String {\n        return \"$name: ${if (isOn) \"ON\" else \"OFF\"}\"\n    }\n}\n\ninterface Schedulable {\n    fun schedule(time: String)\n}\n\ninterface VoiceControllable {\n    fun respondToVoice(command: String)\n}\n\nclass SmartLight(\n    override val name: String,\n    var brightness: Int = 100\n) : SmartDevice, Schedulable, VoiceControllable {\n    override var isOn: Boolean = false\n\n    fun setBrightness(level: Int) {\n        require(level in 0..100) { \"Brightness must be 0-100\" }\n        brightness = level\n        println(\"üí° $name brightness set to $level%\")\n    }\n\n    override fun schedule(time: String) {\n        println(\"‚è∞ $name scheduled to turn on at $time\")\n    }\n\n    override fun respondToVoice(command: String) {\n        when {\n            \"on\" in command.lowercase() -> turnOn()\n            \"off\" in command.lowercase() -> turnOff()\n            \"brightness\" in command.lowercase() -> {\n                val level = command.filter { it.isDigit() }.toIntOrNull() ?: 50\n                setBrightness(level)\n            }\n            else -> println(\"üîä $name: Command not understood\")\n        }\n    }\n}\n\nclass SmartThermostat(\n    override val name: String,\n    var temperature: Int = 72\n) : SmartDevice, Schedulable {\n    override var isOn: Boolean = false\n\n    fun setTemperature(temp: Int) {\n        require(temp in 60..85) { \"Temperature must be 60-85¬∞F\" }\n        temperature = temp\n        println(\"üå°Ô∏è  $name temperature set to $temp¬∞F\")\n    }\n\n    override fun schedule(time: String) {\n        println(\"‚è∞ $name scheduled to set temperature at $time\")\n    }\n}\n\nclass SmartSpeaker(\n    override val name: String,\n    var volume: Int = 50\n) : SmartDevice, VoiceControllable {\n    override var isOn: Boolean = false\n\n    fun setVolume(level: Int) {\n        require(level in 0..100) { \"Volume must be 0-100\" }\n        volume = level\n        println(\"üîä $name volume set to $level\")\n    }\n\n    override fun respondToVoice(command: String) {\n        when {\n            \"play music\" in command.lowercase() -> {\n                if (isOn) println(\"üéµ Playing music...\")\n                else println(\"‚ùå Turn me on first!\")\n            }\n            \"volume\" in command.lowercase() -> {\n                val level = command.filter { it.isDigit() }.toIntOrNull() ?: 50\n                setVolume(level)\n            }\n            else -> println(\"üîä $name: I can play music or adjust volume\")\n        }\n    }\n}\n\nclass HomeController {\n    private val devices = mutableListOf<SmartDevice>()\n\n    fun addDevice(device: SmartDevice) {\n        devices.add(device)\n        println(\"‚ûï Added ${device.name} to home system\")\n    }\n\n    fun turnAllOn() {\n        println(\"\\n=== Turning All Devices ON ===\")\n        devices.forEach { it.turnOn() }\n    }\n\n    fun turnAllOff() {\n        println(\"\\n=== Turning All Devices OFF ===\")\n        devices.forEach { it.turnOff() }\n    }\n\n    fun showStatus() {\n        println(\"\\n=== Home Status ===\")\n        devices.forEach { device ->\n            println(device.getStatus())\n        }\n    }\n\n    fun scheduleAll(time: String) {\n        println(\"\\n=== Scheduling Devices ===\")\n        devices.forEach { device ->\n            if (device is Schedulable) {\n                device.schedule(time)\n            }\n        }\n    }\n\n    fun voiceCommand(command: String) {\n        println(\"\\n=== Voice Command: '$command' ===\")\n        devices.forEach { device ->\n            if (device is VoiceControllable) {\n                device.respondToVoice(command)\n            }\n        }\n    }\n}\n\nfun main() {\n    val home = HomeController()\n\n    val livingRoomLight = SmartLight(\"Living Room Light\")\n    val bedroomLight = SmartLight(\"Bedroom Light\")\n    val thermostat = SmartThermostat(\"Main Thermostat\")\n    val speaker = SmartSpeaker(\"Kitchen Speaker\")\n\n    home.addDevice(livingRoomLight)\n    home.addDevice(bedroomLight)\n    home.addDevice(thermostat)\n    home.addDevice(speaker)\n\n    home.turnAllOn()\n    home.showStatus()\n\n    home.scheduleAll(\"7:00 AM\")\n\n    home.voiceCommand(\"turn on\")\n    home.voiceCommand(\"set brightness to 75\")\n    home.voiceCommand(\"play music\")\n\n    home.turnAllOff()\n    home.showStatus()\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 3: Plugin System",
              "content": "\n**Goal**: Create an extensible plugin system.\n\n**Requirements**:\n1. Interface `Plugin` with properties: `name`, `version`, methods: `initialize()`, `execute()`, `shutdown()`\n2. Interface `Configurable` with method: `configure(settings: Map<String, String>)`\n3. Create 3 different plugin types\n4. Create a `PluginManager` that loads and manages plugins\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution: Plugin System",
              "content": "\n\n---\n\n",
              "code": "interface Plugin {\n    val name: String\n    val version: String\n\n    fun initialize()\n    fun execute()\n    fun shutdown()\n}\n\ninterface Configurable {\n    fun configure(settings: Map<String, String>)\n}\n\nclass LoggerPlugin : Plugin, Configurable {\n    override val name = \"Logger\"\n    override val version = \"1.0.0\"\n    private var logLevel = \"INFO\"\n\n    override fun initialize() {\n        println(\"[$name] Initializing logger plugin...\")\n    }\n\n    override fun execute() {\n        println(\"[$name] Logging at level: $logLevel\")\n        println(\"[$name] Log entry: Application running smoothly\")\n    }\n\n    override fun shutdown() {\n        println(\"[$name] Shutting down logger...\")\n    }\n\n    override fun configure(settings: Map<String, String>) {\n        logLevel = settings[\"logLevel\"] ?: \"INFO\"\n        println(\"[$name] Configured with log level: $logLevel\")\n    }\n}\n\nclass DatabasePlugin : Plugin, Configurable {\n    override val name = \"Database\"\n    override val version = \"2.1.0\"\n    private var connectionString = \"\"\n\n    override fun initialize() {\n        println(\"[$name] Connecting to database...\")\n    }\n\n    override fun execute() {\n        println(\"[$name] Querying database at: $connectionString\")\n        println(\"[$name] Query result: 42 records found\")\n    }\n\n    override fun shutdown() {\n        println(\"[$name] Closing database connection...\")\n    }\n\n    override fun configure(settings: Map<String, String>) {\n        connectionString = settings[\"connectionString\"] ?: \"localhost:5432\"\n        println(\"[$name] Configured to connect to: $connectionString\")\n    }\n}\n\nclass CachePlugin : Plugin {\n    override val name = \"Cache\"\n    override val version = \"1.5.2\"\n    private val cache = mutableMapOf<String, String>()\n\n    override fun initialize() {\n        println(\"[$name] Initializing cache system...\")\n    }\n\n    override fun execute() {\n        cache[\"user:1\"] = \"Alice\"\n        cache[\"user:2\"] = \"Bob\"\n        println(\"[$name] Cache populated with ${cache.size} items\")\n    }\n\n    override fun shutdown() {\n        cache.clear()\n        println(\"[$name] Cache cleared and shutdown\")\n    }\n}\n\nclass PluginManager {\n    private val plugins = mutableListOf<Plugin>()\n\n    fun registerPlugin(plugin: Plugin) {\n        plugins.add(plugin)\n        println(\"\\n‚úÖ Registered plugin: ${plugin.name} v${plugin.version}\")\n    }\n\n    fun configurePlugin(pluginName: String, settings: Map<String, String>) {\n        val plugin = plugins.find { it.name == pluginName }\n        if (plugin is Configurable) {\n            plugin.configure(settings)\n        } else {\n            println(\"‚ö†Ô∏è  Plugin '$pluginName' is not configurable\")\n        }\n    }\n\n    fun initializeAll() {\n        println(\"\\n=== Initializing All Plugins ===\")\n        plugins.forEach { it.initialize() }\n    }\n\n    fun executeAll() {\n        println(\"\\n=== Executing All Plugins ===\")\n        plugins.forEach { it.execute() }\n    }\n\n    fun shutdownAll() {\n        println(\"\\n=== Shutting Down All Plugins ===\")\n        plugins.forEach { it.shutdown() }\n    }\n\n    fun listPlugins() {\n        println(\"\\n=== Installed Plugins ===\")\n        plugins.forEach { plugin ->\n            val configurable = if (plugin is Configurable) \"(Configurable)\" else \"\"\n            println(\"${plugin.name} v${plugin.version} $configurable\")\n        }\n    }\n}\n\nfun main() {\n    val manager = PluginManager()\n\n    // Register plugins\n    val logger = LoggerPlugin()\n    val database = DatabasePlugin()\n    val cache = CachePlugin()\n\n    manager.registerPlugin(logger)\n    manager.registerPlugin(database)\n    manager.registerPlugin(cache)\n\n    manager.listPlugins()\n\n    // Configure\n    manager.configurePlugin(\"Logger\", mapOf(\"logLevel\" to \"DEBUG\"))\n    manager.configurePlugin(\"Database\", mapOf(\"connectionString\" to \"prod-db.example.com:5432\"))\n\n    // Run lifecycle\n    manager.initializeAll()\n    manager.executeAll()\n    manager.shutdownAll()\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Checkpoint Quiz",
              "content": "\n### Question 1\nWhat is the main difference between an interface and an abstract class?\n\nA) Interfaces can't have methods\nB) A class can implement multiple interfaces but inherit from only one abstract class\nC) Abstract classes are faster\nD) There is no difference\n\n### Question 2\nCan interfaces have properties with backing fields?\n\nA) Yes, always\nB) No, never\nC) Only if marked `open`\nD) Only if they're `lateinit`\n\n### Question 3\nCan interface methods have default implementations in Kotlin?\n\nA) No, never\nB) Yes, always\nC) Yes, but not in Java\nD) Yes, since Kotlin 1.0\n\n### Question 4\nWhen should you use an interface instead of an abstract class?\n\nA) When you need constructors\nB) When you need to define capabilities without shared state\nC) When you need multiple inheritance of type\nD) Both B and C\n\n### Question 5\nWhat's required for a class property declared in an interface?\n\nA) It must have a backing field\nB) It must be overridden by implementing classes (unless it has a default getter)\nC) It must be mutable\nD) It must be private\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Answers",
              "content": "\n**Question 1: B) A class can implement multiple interfaces but inherit from only one abstract class**\n\nThis is one of the key differences and a major reason to use interfaces.\n\n\n---\n\n**Question 2: B) No, never**\n\nInterfaces can't have backing fields. Properties must either be abstract or have custom getters.\n\n\n---\n\n**Question 3: D) Yes, since Kotlin 1.0**\n\nKotlin interfaces can have default method implementations from the start.\n\n\n---\n\n**Question 4: D) Both B and C**\n\nUse interfaces when you want to define capabilities (\"can-do\") without shared state, and when you need multiple inheritance.\n\n\n---\n\n**Question 5: B) It must be overridden by implementing classes (unless it has a default getter)**\n\nInterface properties without default getters must be overridden.\n\n\n---\n\n",
              "code": "interface Vehicle {\n    val speed: Int  // Must override\n    val type: String\n        get() = \"Generic\"  // Has default, override optional\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "What You've Learned",
              "content": "\n‚úÖ Defining and implementing interfaces\n‚úÖ Multiple interface implementation\n‚úÖ Interface properties (without backing fields)\n‚úÖ Default interface methods\n‚úÖ Interfaces vs abstract classes\n‚úÖ Real-world design patterns with interfaces\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Next Steps",
              "content": "\nIn **Lesson 2.5: Data Classes and Sealed Classes**, you'll learn:\n- Data classes for holding data\n- Automatic `equals()`, `hashCode()`, `toString()`, `copy()`\n- Destructuring declarations\n- Sealed classes for restricted hierarchies\n- When to use each special class type\n\nYou're building a complete OOP toolkit!\n\n---\n\n**Congratulations on completing Lesson 2.4!** üéâ\n\nInterfaces are essential for designing flexible, maintainable systems. You now understand when to use interfaces vs abstract classes!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "3.4.1",
              "title": "Data Classes",
              "description": "Create a data class `Person` with properties name, age, and email. Create two instances with the same data and compare them using ==.",
              "instructions": "Create a data class `Person` with properties name, age, and email. Create two instances with the same data and compare them using ==.",
              "starterCode": "// Create Person data class\n\nfun main() {\n    val person1 = Person(\"Alice\", 30, \"alice@example.com\")\n    val person2 = Person(\"Alice\", 30, \"alice@example.com\")\n    println(\"Are they equal? ${person1 == person2}\")\n    println(person1)\n}",
              "solution": "data class Person(val name: String, val age: Int, val email: String)\n\nfun main() {\n    val person1 = Person(\"Alice\", 30, \"alice@example.com\")\n    val person2 = Person(\"Alice\", 30, \"alice@example.com\")\n    println(\"Are they equal? ${person1 == person2}\")\n    println(person1)\n}",
              "language": "kotlin",
              "testCases": [
                {
                  "description": "Data classes with same values should be equal",
                  "expectedOutput": "Are they equal? true",
                  "isVisible": true
                },
                {
                  "description": "toString should show all properties",
                  "expectedOutput": "Person(name=Alice, age=30, email=alice@example.com)",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use 'data class' instead of 'class'"
                },
                {
                  "level": 2,
                  "text": "Data classes automatically generate equals(), hashCode(), toString()"
                },
                {
                  "level": 3,
                  "text": "Two data classes with same property values are equal"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "3.5",
          "title": "Lesson 2.5: Data Classes and Sealed Classes",
          "moduleId": "module-03",
          "order": 5,
          "estimatedMinutes": 65,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 65 minutes\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Topic Introduction",
              "content": "\nKotlin provides special class types that solve common programming patterns elegantly. You've learned about regular classes, abstract classes, and interfaces. Now let's explore two powerful Kotlin features:\n\n**Data Classes**: Classes designed to hold data with automatic implementations of `equals()`, `hashCode()`, `toString()`, and `copy()`.\n\n**Sealed Classes**: Classes with a restricted hierarchy where all subclasses are known at compile-time, perfect for representing state or result types.\n\nThese features make Kotlin code more concise, safer, and more expressive than traditional OOP languages.\n\n---\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "The Concept",
              "content": "\n### Why Special Class Types?\n\n**Problem with Regular Classes**:\n\n\n**Solution with Data Classes**:\n\n\n---\n\n",
              "code": "data class User(val name: String, val age: Int)\n\nval user1 = User(\"Alice\", 25)\nval user2 = User(\"Alice\", 25)\n\nprintln(user1 == user2)  // true (compares data!)\nprintln(user1)           // User(name=Alice, age=25) (readable!)",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Data Classes",
              "content": "\n### Creating Data Classes\n\nUse the `data` keyword before `class`:\n\n\n**What Kotlin generates automatically**:\n1. **`equals()`** - Compares data, not references\n2. **`hashCode()`** - Consistent with `equals()`\n3. **`toString()`** - Readable string representation\n4. **`copy()`** - Creates copies with modified properties\n5. **`componentN()`** - Destructuring declarations\n\n### Requirements for Data Classes\n\n1. Primary constructor must have at least one parameter\n2. All primary constructor parameters must be `val` or `var`\n3. Cannot be `abstract`, `open`, `sealed`, or `inner`\n4. May extend other classes or implement interfaces\n\n### Auto-Generated Functions\n\n**1. `toString()`** - Readable representation\n\n\n**2. `equals()` and `hashCode()`** - Structural equality\n\n\n**3. `copy()`** - Create modified copies\n\n\n**Why `copy()` matters**:\n- Immutability: Don't modify original, create new versions\n- Thread safety: Immutable data is inherently thread-safe\n- Functional programming: Transform data without side effects\n\n---\n\n",
              "code": "data class User(val name: String, val age: Int, val email: String)\n\nval user = User(\"Alice\", 25, \"alice@example.com\")\n\n// Create a copy with modified age\nval olderUser = user.copy(age = 26)\n\nprintln(user)       // User(name=Alice, age=25, email=alice@example.com)\nprintln(olderUser)  // User(name=Alice, age=26, email=alice@example.com)\n\n// Copy with multiple changes\nval differentUser = user.copy(name = \"Bob\", age = 30)\nprintln(differentUser)  // User(name=Bob, age=30, email=alice@example.com)",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Destructuring Declarations",
              "content": "\nData classes support **destructuring** - extracting multiple values at once:\n\n\n**How it works**: Kotlin generates `component1()`, `component2()`, etc. functions:\n\n\n**Partial Destructuring**:\n\n\n**Destructuring in Loops**:\n\n\n---\n\n",
              "code": "data class Person(val name: String, val age: Int)\n\nval people = listOf(\n    Person(\"Alice\", 25),\n    Person(\"Bob\", 30),\n    Person(\"Carol\", 22)\n)\n\nfor ((name, age) in people) {\n    println(\"$name is $age years old\")\n}",
              "language": "kotlin"
            },
            {
              "type": "EXAMPLE",
              "title": "Real-World Data Class Examples",
              "content": "\n### Example 1: API Response\n\n\n### Example 2: Coordinates and Geometry\n\n\n---\n\n",
              "code": "data class Point(val x: Double, val y: Double) {\n    fun distanceTo(other: Point): Double {\n        val dx = x - other.x\n        val dy = y - other.y\n        return kotlin.math.sqrt(dx * dx + dy * dy)\n    }\n}\n\ndata class Rectangle(val topLeft: Point, val bottomRight: Point) {\n    val width: Double\n        get() = bottomRight.x - topLeft.x\n\n    val height: Double\n        get() = bottomRight.y - topLeft.y\n\n    val area: Double\n        get() = width * height\n}\n\nfun main() {\n    val p1 = Point(0.0, 0.0)\n    val p2 = Point(3.0, 4.0)\n\n    println(\"Distance: ${p1.distanceTo(p2)}\")  // 5.0\n\n    val rect = Rectangle(Point(0.0, 10.0), Point(5.0, 0.0))\n    println(\"Area: ${rect.area}\")  // 50.0\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Sealed Classes",
              "content": "\n**Sealed classes** represent restricted class hierarchies where all subclasses are known at compile-time.\n\n### Why Sealed Classes?\n\n**Problem**: Modeling states or results with regular classes\n\n\n**Solution**: Sealed classes\n\n\n### Defining Sealed Classes\n\n\n**Key Points**:\n- Subclasses must be defined in the same file (or as nested classes)\n- Cannot be instantiated directly\n- Perfect for `when` expressions (exhaustive checking)\n\n---\n\n",
              "code": "sealed class NetworkResult {\n    data class Success(val data: String) : NetworkResult()\n    data class Error(val code: Int, val message: String) : NetworkResult()\n    object Loading : NetworkResult()\n    object Idle : NetworkResult()\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Sealed Classes for State Management",
              "content": "\n\n---\n\n",
              "code": "sealed class UiState {\n    object Loading : UiState()\n    data class Success(val items: List<String>) : UiState()\n    data class Error(val message: String) : UiState()\n    object Empty : UiState()\n}\n\nclass ViewModel {\n    private var state: UiState = UiState.Loading\n\n    fun loadData() {\n        state = UiState.Loading\n        displayState()\n\n        // Simulate loading\n        Thread.sleep(1000)\n\n        val items = listOf(\"Item 1\", \"Item 2\", \"Item 3\")\n        state = if (items.isNotEmpty()) {\n            UiState.Success(items)\n        } else {\n            UiState.Empty\n        }\n        displayState()\n    }\n\n    fun displayState() {\n        when (state) {\n            is UiState.Loading -> println(\"‚è≥ Loading...\")\n            is UiState.Success -> {\n                val items = (state as UiState.Success).items\n                println(\"‚úÖ Loaded ${items.size} items: $items\")\n            }\n            is UiState.Error -> {\n                val message = (state as UiState.Error).message\n                println(\"‚ùå Error: $message\")\n            }\n            UiState.Empty -> println(\"üì≠ No items found\")\n        }\n    }\n}\n\nfun main() {\n    val viewModel = ViewModel()\n    viewModel.loadData()\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Enum Classes",
              "content": "\n**Enum classes** define a fixed set of constants.\n\n\n**Enum vs Sealed Class**:\n\n| Feature | Enum | Sealed Class |\n|---------|------|--------------|\n| Fixed set of instances | ‚úÖ Yes (all at compile-time) | ‚úÖ Yes (types known at compile-time) |\n| Can have different data | ‚ùå No (same structure) | ‚úÖ Yes (different properties) |\n| Can inherit | ‚ùå No | ‚úÖ Yes |\n| When to use | Finite set of constants | Type hierarchies with different data |\n\n---\n\n",
              "code": "enum class Direction {\n    NORTH, SOUTH, EAST, WEST\n}\n\nenum class Priority(val level: Int) {\n    LOW(1),\n    MEDIUM(2),\n    HIGH(3),\n    CRITICAL(4);\n\n    fun isUrgent() = level >= 3\n}\n\nfun main() {\n    val direction = Direction.NORTH\n    println(direction)  // NORTH\n\n    val priority = Priority.HIGH\n    println(\"Level: ${priority.level}\")  // Level: 3\n    println(\"Urgent: ${priority.isUrgent()}\")  // Urgent: true\n\n    // Iterate over all values\n    Priority.values().forEach { p ->\n        println(\"${p.name}: Level ${p.level}\")\n    }\n\n    // String to enum\n    val p = Priority.valueOf(\"MEDIUM\")\n    println(p.level)  // 2\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Value Classes (Inline Classes)",
              "content": "\n**Value classes** provide type safety without runtime overhead.\n\n\n**Benefits**:\n- Type safety: Can't accidentally pass wrong type\n- Zero runtime overhead: Unwrapped at runtime\n- Validation in init block\n\n---\n\n",
              "code": "@JvmInline\nvalue class UserId(val value: Int)\n\n@JvmInline\nvalue class Email(val value: String) {\n    init {\n        require(value.contains(\"@\")) { \"Invalid email\" }\n    }\n}\n\nfun sendEmail(email: Email) {\n    println(\"Sending email to ${email.value}\")\n}\n\nfun main() {\n    val userId = UserId(123)\n    val email = Email(\"alice@example.com\")\n\n    // sendEmail(UserId(456))  // ‚ùå Type mismatch!\n    sendEmail(email)  // ‚úÖ Correct type\n\n    // At runtime, email is just a String (no wrapper object)\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 1: Product Catalog System",
              "content": "\n**Goal**: Create a product catalog using data classes.\n\n**Requirements**:\n1. Data class `Product` with: `id`, `name`, `price`, `category`, `inStock`\n2. Data class `Order` with: `orderId`, `products: List<Product>`, `total`\n3. Function to calculate total from products\n4. Function to create a modified order with discount\n5. Test with sample products and orders\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution: Product Catalog",
              "content": "\n\n---\n\n",
              "code": "data class Product(\n    val id: Int,\n    val name: String,\n    val price: Double,\n    val category: String,\n    val inStock: Boolean = true\n)\n\ndata class Order(\n    val orderId: String,\n    val products: List<Product>,\n    val discount: Double = 0.0\n) {\n    val subtotal: Double\n        get() = products.sumOf { it.price }\n\n    val total: Double\n        get() = subtotal - discount\n\n    fun applyDiscount(discountAmount: Double): Order {\n        return copy(discount = discountAmount)\n    }\n\n    fun displayOrder() {\n        println(\"\\n=== Order $orderId ===\")\n        products.forEach { product ->\n            println(\"${product.name} - $${product.price}\")\n        }\n        println(\"---\")\n        println(\"Subtotal: $$subtotal\")\n        if (discount > 0) {\n            println(\"Discount: -$$discount\")\n        }\n        println(\"Total: $$total\")\n        println(\"===================\\n\")\n    }\n}\n\nfun main() {\n    val products = listOf(\n        Product(1, \"Laptop\", 999.99, \"Electronics\"),\n        Product(2, \"Mouse\", 29.99, \"Electronics\"),\n        Product(3, \"Keyboard\", 79.99, \"Electronics\"),\n        Product(4, \"Monitor\", 299.99, \"Electronics\"),\n        Product(5, \"Desk Lamp\", 39.99, \"Furniture\", inStock = false)\n    )\n\n    // Filter in-stock products\n    val availableProducts = products.filter { it.inStock }\n\n    // Create order\n    val order = Order(\n        orderId = \"ORD-2025-001\",\n        products = listOf(\n            products[0],  // Laptop\n            products[1],  // Mouse\n            products[2]   // Keyboard\n        )\n    )\n\n    order.displayOrder()\n\n    // Apply discount\n    val discountedOrder = order.applyDiscount(50.0)\n    discountedOrder.displayOrder()\n\n    // Destructuring\n    val (orderId, items, discount) = discountedOrder\n    println(\"Order ID: $orderId\")\n    println(\"Number of items: ${items.size}\")\n    println(\"Discount: $$discount\")\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 2: API Result with Sealed Classes",
              "content": "\n**Goal**: Model API responses using sealed classes.\n\n**Requirements**:\n1. Sealed class `ApiResult<T>` with subclasses: `Success`, `Error`, `Loading`\n2. Function `fetchData()` that returns different results\n3. Function `handleResult()` that processes each case\n4. Test with different scenarios\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution: API Result",
              "content": "\n\n---\n\n",
              "code": "sealed class ApiResult<out T> {\n    data class Success<T>(val data: T) : ApiResult<T>()\n    data class Error(val code: Int, val message: String) : ApiResult<Nothing>()\n    object Loading : ApiResult<Nothing>()\n}\n\ndata class User(val id: Int, val name: String, val email: String)\n\nfun fetchUser(userId: Int): ApiResult<User> {\n    return when {\n        userId <= 0 -> ApiResult.Error(400, \"Invalid user ID\")\n        userId == 999 -> ApiResult.Loading\n        else -> ApiResult.Success(User(userId, \"User $userId\", \"user$userId@example.com\"))\n    }\n}\n\nfun <T> handleResult(result: ApiResult<T>, onSuccess: (T) -> Unit) {\n    when (result) {\n        is ApiResult.Success -> {\n            println(\"‚úÖ Success!\")\n            onSuccess(result.data)\n        }\n        is ApiResult.Error -> {\n            println(\"‚ùå Error ${result.code}: ${result.message}\")\n        }\n        ApiResult.Loading -> {\n            println(\"‚è≥ Loading...\")\n        }\n    }\n}\n\nfun main() {\n    println(\"=== Fetch User 1 ===\")\n    val result1 = fetchUser(1)\n    handleResult(result1) { user ->\n        println(\"User: ${user.name} (${user.email})\")\n    }\n\n    println(\"\\n=== Fetch Invalid User ===\")\n    val result2 = fetchUser(-1)\n    handleResult(result2) { user ->\n        println(\"User: ${user.name}\")\n    }\n\n    println(\"\\n=== Fetch Loading State ===\")\n    val result3 = fetchUser(999)\n    handleResult(result3) { user ->\n        println(\"User: ${user.name}\")\n    }\n\n    // Using when expression directly\n    println(\"\\n=== Direct when expression ===\")\n    val message = when (val result = fetchUser(5)) {\n        is ApiResult.Success -> \"Loaded: ${result.data.name}\"\n        is ApiResult.Error -> \"Failed: ${result.message}\"\n        ApiResult.Loading -> \"Please wait...\"\n    }\n    println(message)\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 3: Task Management with Sealed Classes",
              "content": "\n**Goal**: Build a task management system using sealed classes for task states.\n\n**Requirements**:\n1. Sealed class `TaskState` with: `Todo`, `InProgress`, `Completed`, `Cancelled`\n2. Data class `Task` with: `id`, `title`, `description`, `state`\n3. Functions to transition between states\n4. Track state change history\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution: Task Management",
              "content": "\n\n---\n\n",
              "code": "sealed class TaskState {\n    object Todo : TaskState() {\n        override fun toString() = \"TODO\"\n    }\n\n    data class InProgress(val assignee: String, val startedAt: Long = System.currentTimeMillis()) : TaskState() {\n        override fun toString() = \"IN_PROGRESS (Assignee: $assignee)\"\n    }\n\n    data class Completed(val completedBy: String, val completedAt: Long = System.currentTimeMillis()) : TaskState() {\n        override fun toString() = \"COMPLETED (By: $completedBy)\"\n    }\n\n    data class Cancelled(val reason: String) : TaskState() {\n        override fun toString() = \"CANCELLED (Reason: $reason)\"\n    }\n}\n\ndata class Task(\n    val id: Int,\n    val title: String,\n    val description: String,\n    val state: TaskState = TaskState.Todo,\n    val history: List<TaskState> = listOf(TaskState.Todo)\n) {\n    fun startWork(assignee: String): Task {\n        require(state is TaskState.Todo) { \"Task must be in TODO state to start\" }\n        val newState = TaskState.InProgress(assignee)\n        return copy(state = newState, history = history + newState)\n    }\n\n    fun complete(completedBy: String): Task {\n        require(state is TaskState.InProgress) { \"Task must be in progress to complete\" }\n        val newState = TaskState.Completed(completedBy)\n        return copy(state = newState, history = history + newState)\n    }\n\n    fun cancel(reason: String): Task {\n        require(state !is TaskState.Completed) { \"Cannot cancel completed task\" }\n        val newState = TaskState.Cancelled(reason)\n        return copy(state = newState, history = history + newState)\n    }\n\n    fun displayTask() {\n        println(\"\\n=== Task #$id ===\")\n        println(\"Title: $title\")\n        println(\"Description: $description\")\n        println(\"Current State: $state\")\n        println(\"\\nState History:\")\n        history.forEachIndexed { index, state ->\n            println(\"  ${index + 1}. $state\")\n        }\n        println(\"================\\n\")\n    }\n\n    fun getStatusEmoji(): String = when (state) {\n        is TaskState.Todo -> \"üìù\"\n        is TaskState.InProgress -> \"üîÑ\"\n        is TaskState.Completed -> \"‚úÖ\"\n        is TaskState.Cancelled -> \"‚ùå\"\n    }\n}\n\nclass TaskManager {\n    private val tasks = mutableMapOf<Int, Task>()\n    private var nextId = 1\n\n    fun createTask(title: String, description: String): Task {\n        val task = Task(nextId++, title, description)\n        tasks[task.id] = task\n        println(\"Created task: ${task.getStatusEmoji()} ${task.title}\")\n        return task\n    }\n\n    fun updateTask(task: Task) {\n        tasks[task.id] = task\n        println(\"Updated task: ${task.getStatusEmoji()} ${task.title} -> ${task.state}\")\n    }\n\n    fun listTasks() {\n        println(\"\\n=== All Tasks ===\")\n        tasks.values.forEach { task ->\n            println(\"${task.getStatusEmoji()} #${task.id}: ${task.title} [${task.state}]\")\n        }\n        println(\"=================\\n\")\n    }\n}\n\nfun main() {\n    val manager = TaskManager()\n\n    // Create tasks\n    var task1 = manager.createTask(\"Implement login\", \"Add JWT authentication\")\n    var task2 = manager.createTask(\"Fix bug #123\", \"Null pointer exception in profile\")\n    var task3 = manager.createTask(\"Write tests\", \"Unit tests for payment module\")\n\n    manager.listTasks()\n\n    // Start working on tasks\n    task1 = task1.startWork(\"Alice\")\n    manager.updateTask(task1)\n\n    task2 = task2.startWork(\"Bob\")\n    manager.updateTask(task2)\n\n    manager.listTasks()\n\n    // Complete a task\n    task1 = task1.complete(\"Alice\")\n    manager.updateTask(task1)\n\n    // Cancel a task\n    task3 = task3.cancel(\"Requirements changed\")\n    manager.updateTask(task3)\n\n    manager.listTasks()\n\n    // Display full history\n    task1.displayTask()\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Checkpoint Quiz",
              "content": "\n### Question 1\nWhat does the `data` keyword do?\n\nA) Makes the class immutable\nB) Automatically generates `equals()`, `hashCode()`, `toString()`, and `copy()`\nC) Makes the class faster\nD) Allows inheritance\n\n### Question 2\nWhat is destructuring in data classes?\n\nA) Deleting the class\nB) Extracting multiple properties into separate variables at once\nC) Breaking inheritance\nD) Splitting the class into multiple files\n\n### Question 3\nWhat is the main advantage of sealed classes?\n\nA) They're faster\nB) They provide exhaustive `when` expression checking\nC) They use less memory\nD) They can have multiple constructors\n\n### Question 4\nWhen should you use a data class?\n\nA) When you need inheritance\nB) When you primarily need to hold data\nC) When you need abstract methods\nD) When you need multiple constructors\n\n### Question 5\nWhat's the difference between enum and sealed classes?\n\nA) Enums are faster\nB) Sealed classes can have subclasses with different properties; enums cannot\nC) Enums can inherit; sealed classes cannot\nD) There is no difference\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Answers",
              "content": "\n**Question 1: B) Automatically generates `equals()`, `hashCode()`, `toString()`, and `copy()`**\n\nData classes save you from writing boilerplate code.\n\n\n---\n\n**Question 2: B) Extracting multiple properties into separate variables at once**\n\nDestructuring uses the `componentN()` functions generated by data classes.\n\n\n---\n\n**Question 3: B) They provide exhaustive `when` expression checking**\n\nThe compiler ensures you handle all subclasses of a sealed class.\n\n\n---\n\n**Question 4: B) When you primarily need to hold data**\n\nData classes are perfect for DTOs, API models, configuration, etc.\n\n\n---\n\n**Question 5: B) Sealed classes can have subclasses with different properties; enums cannot**\n\nEnums are for fixed constants with the same structure. Sealed classes are for type hierarchies with varying data.\n\n\n---\n\n",
              "code": "// Enum: All instances have same structure\nenum class Color(val hex: String) {\n    RED(\"#FF0000\"),\n    GREEN(\"#00FF00\")\n}\n\n// Sealed: Subclasses have different properties\nsealed class Result {\n    data class Success(val data: String) : Result()\n    data class Error(val code: Int, val message: String) : Result()\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "What You've Learned",
              "content": "\n‚úÖ Data classes and their auto-generated functions\n‚úÖ The `copy()` function for immutable updates\n‚úÖ Destructuring declarations\n‚úÖ Sealed classes for restricted hierarchies\n‚úÖ Enum classes for fixed constants\n‚úÖ Value classes for type-safe primitives\n‚úÖ When to use each special class type\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Next Steps",
              "content": "\nIn **Lesson 2.6: Object Declarations and Companion Objects**, you'll learn:\n- Object expressions for anonymous objects\n- Object declarations for singletons\n- Companion objects for static-like members\n- Factory methods and constants\n- When to use objects vs classes\n\nYou're almost done with Part 2!\n\n---\n\n**Congratulations on completing Lesson 2.5!** üéâ\n\nData classes and sealed classes are Kotlin superpowers that make your code more concise and safer!\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "3.6",
          "title": "Lesson 2.6: Object Declarations and Companion Objects",
          "moduleId": "module-03",
          "order": 6,
          "estimatedMinutes": 60,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 60 minutes\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Topic Introduction",
              "content": "\nSo far, you've created classes and instantiated them into objects. But what if you need:\n- Only **one instance** of a class (singleton pattern)?\n- **Static-like members** (methods/properties that belong to the class, not instances)?\n- **Anonymous objects** for one-time use?\n\nKotlin provides elegant solutions through:\n- **Object expressions** - Anonymous objects\n- **Object declarations** - Singletons\n- **Companion objects** - Static-like members within classes\n\nThese features eliminate boilerplate code and provide type-safe alternatives to Java's static members.\n\n---\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "The Concept",
              "content": "\n### What are Objects in Kotlin?\n\nIn Kotlin, `object` is a keyword with three uses:\n\n1. **Object Expression**: Create anonymous objects (like Java's anonymous classes)\n2. **Object Declaration**: Create singletons\n3. **Companion Object**: Define class-level members (like Java's static)\n\n**Why Objects?**\n- **Singletons**: Ensure only one instance exists (database connections, app config)\n- **Utilities**: Group related functions without instantiation\n- **Constants**: Define immutable values accessible anywhere\n- **Factory methods**: Create instances with custom logic\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Object Expressions",
              "content": "\n**Object expressions** create anonymous objects - objects of an unnamed class.\n\n### Basic Object Expression\n\n\n### Implementing Interfaces\n\nCommon use: One-time implementations of interfaces\n\n\n**Real-World Example: Event Handlers**\n\n\n**Output**:\n\n### Accessing Outer Scope\n\nObject expressions can access variables from their surrounding scope:\n\n\n---\n\n",
              "code": "fun countClicks() {\n    var clickCount = 0\n\n    val button = object {\n        fun click() {\n            clickCount++  // Access outer variable\n            println(\"Click count: $clickCount\")\n        }\n    }\n\n    button.click()  // Click count: 1\n    button.click()  // Click count: 2\n    button.click()  // Click count: 3\n}\n\nfun main() {\n    countClicks()\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Object Declarations (Singletons)",
              "content": "\n**Object declaration** creates a singleton - a class with exactly one instance.\n\n### Basic Singleton\n\n\n**Output**:\n\n**Key Points**:\n- Created on first access (lazy initialization)\n- Thread-safe by default\n- Cannot have constructors\n- Can implement interfaces and extend classes\n\n### Real-World Example: Application Config\n\n\n### Singleton with Interface\n\n\n---\n\n",
              "code": "interface Logger {\n    fun log(message: String)\n    fun error(message: String)\n}\n\nobject ConsoleLogger : Logger {\n    override fun log(message: String) {\n        println(\"[LOG] $message\")\n    }\n\n    override fun error(message: String) {\n        println(\"[ERROR] $message\")\n    }\n}\n\nfun processData(logger: Logger) {\n    logger.log(\"Processing data...\")\n    logger.error(\"An error occurred!\")\n}\n\nfun main() {\n    processData(ConsoleLogger)\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Companion Objects",
              "content": "\n**Companion objects** are object declarations inside a class, providing \"static-like\" members.\n\n### Basic Companion Object\n\n\n**Output**:\n\n### Factory Methods\n\nCompanion objects are perfect for factory methods:\n\n\n### Named Companion Objects\n\n\n### Companion Object Implementing Interface\n\n\n---\n\n",
              "code": "interface JsonSerializer {\n    fun toJson(obj: Any): String\n}\n\nclass User(val name: String, val age: Int) {\n    companion object : JsonSerializer {\n        override fun toJson(obj: Any): String {\n            if (obj !is User) return \"{}\"\n            return \"\"\"{\"name\": \"${obj.name}\", \"age\": ${obj.age}}\"\"\"\n        }\n    }\n}\n\nfun main() {\n    val user = User(\"Alice\", 25)\n    val json = User.toJson(user)\n    println(json)  // {\"name\": \"Alice\", \"age\": 25}\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Constants: `const` vs `val`",
              "content": "\n### `const` for Compile-Time Constants\n\n\n**Rules for `const`**:\n- Must be top-level, in object, or in companion object\n- Must be primitive type or String\n- Must be initialized with a compile-time constant\n- Cannot have custom getter\n\n---\n\n",
              "code": "object Constants {\n    const val MAX_USERS = 100  // ‚úÖ Compile-time constant\n    const val API_KEY = \"abc123\"  // ‚úÖ Compile-time constant\n\n    val createdAt = System.currentTimeMillis()  // ‚úÖ Runtime value (not const)\n}\n\nclass Config {\n    companion object {\n        const val TIMEOUT = 30  // ‚úÖ Top-level or companion object\n        val instance = Config()  // ‚úÖ Runtime value\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "EXAMPLE",
              "title": "Real-World Example: Database Manager",
              "content": "\n\n---\n\n",
              "code": "data class User(val id: Int, val name: String, val email: String)\n\nobject DatabaseManager {\n    private val users = mutableMapOf<Int, User>()\n    private var nextId = 1\n    private var isInitialized = false\n\n    init {\n        println(\"Initializing Database Manager...\")\n    }\n\n    fun initialize() {\n        if (isInitialized) {\n            println(\"Database already initialized\")\n            return\n        }\n        println(\"Setting up database connection...\")\n        isInitialized = true\n    }\n\n    fun insertUser(name: String, email: String): User {\n        require(isInitialized) { \"Database not initialized\" }\n        val user = User(nextId++, name, email)\n        users[user.id] = user\n        println(\"Inserted user: ${user.name}\")\n        return user\n    }\n\n    fun getUserById(id: Int): User? {\n        require(isInitialized) { \"Database not initialized\" }\n        return users[id]\n    }\n\n    fun getAllUsers(): List<User> {\n        require(isInitialized) { \"Database not initialized\" }\n        return users.values.toList()\n    }\n\n    fun deleteUser(id: Int): Boolean {\n        require(isInitialized) { \"Database not initialized\" }\n        return users.remove(id) != null\n    }\n\n    fun getUserCount() = users.size\n}\n\nfun main() {\n    DatabaseManager.initialize()\n\n    DatabaseManager.insertUser(\"Alice\", \"alice@example.com\")\n    DatabaseManager.insertUser(\"Bob\", \"bob@example.com\")\n    DatabaseManager.insertUser(\"Carol\", \"carol@example.com\")\n\n    println(\"\\nAll users:\")\n    DatabaseManager.getAllUsers().forEach { user ->\n        println(\"${user.id}: ${user.name} (${user.email})\")\n    }\n\n    println(\"\\nGet user by ID:\")\n    val user = DatabaseManager.getUserById(2)\n    println(user)\n\n    println(\"\\nDelete user 2:\")\n    DatabaseManager.deleteUser(2)\n\n    println(\"\\nRemaining users: ${DatabaseManager.getUserCount()}\")\n    DatabaseManager.getAllUsers().forEach { user ->\n        println(\"${user.id}: ${user.name}\")\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 1: Logging System",
              "content": "\n**Goal**: Create a comprehensive logging system using objects.\n\n**Requirements**:\n1. Object `Logger` with different log levels (INFO, WARNING, ERROR)\n2. Methods: `info()`, `warning()`, `error()`\n3. Property to enable/disable logging\n4. Track log count for each level\n5. Method to print statistics\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution: Logging System",
              "content": "\n\n---\n\n",
              "code": "object Logger {\n    private var enabled = true\n    private var infoCount = 0\n    private var warningCount = 0\n    private var errorCount = 0\n\n    fun enable() {\n        enabled = true\n        println(\"[LOGGER] Logging enabled\")\n    }\n\n    fun disable() {\n        enabled = false\n        println(\"[LOGGER] Logging disabled\")\n    }\n\n    fun info(message: String) {\n        if (!enabled) return\n        infoCount++\n        println(\"[INFO] $message\")\n    }\n\n    fun warning(message: String) {\n        if (!enabled) return\n        warningCount++\n        println(\"[WARNING] $message\")\n    }\n\n    fun error(message: String) {\n        if (!enabled) return\n        errorCount++\n        println(\"[ERROR] $message\")\n    }\n\n    fun printStatistics() {\n        println(\"\\n=== Logging Statistics ===\")\n        println(\"Info messages: $infoCount\")\n        println(\"Warning messages: $warningCount\")\n        println(\"Error messages: $errorCount\")\n        println(\"Total messages: ${infoCount + warningCount + errorCount}\")\n        println(\"==========================\\n\")\n    }\n\n    fun reset() {\n        infoCount = 0\n        warningCount = 0\n        errorCount = 0\n        println(\"[LOGGER] Statistics reset\")\n    }\n}\n\nfun main() {\n    Logger.info(\"Application started\")\n    Logger.info(\"Loading configuration\")\n    Logger.warning(\"Configuration file not found, using defaults\")\n    Logger.info(\"Connecting to database\")\n    Logger.error(\"Failed to connect to database\")\n    Logger.info(\"Retrying connection\")\n    Logger.info(\"Connected successfully\")\n\n    Logger.printStatistics()\n\n    Logger.disable()\n    Logger.info(\"This won't be logged\")\n\n    Logger.enable()\n    Logger.info(\"This will be logged\")\n\n    Logger.printStatistics()\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 2: Factory Pattern with Companion Objects",
              "content": "\n**Goal**: Create different types of database connections using factory methods.\n\n**Requirements**:\n1. Abstract class `DatabaseConnection` with method `connect()`\n2. Subclasses: `MySqlConnection`, `PostgreSqlConnection`, `MongoConnection`\n3. Companion object with factory methods to create each type\n4. Method to validate connection parameters\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution: Database Factory",
              "content": "\n\n---\n\n",
              "code": "abstract class DatabaseConnection(\n    protected val host: String,\n    protected val port: Int,\n    protected val database: String\n) {\n    abstract fun connect(): Boolean\n    abstract fun getConnectionString(): String\n\n    companion object Factory {\n        const val DEFAULT_MYSQL_PORT = 3306\n        const val DEFAULT_POSTGRES_PORT = 5432\n        const val DEFAULT_MONGO_PORT = 27017\n\n        fun createMySql(host: String, database: String, port: Int = DEFAULT_MYSQL_PORT): MySqlConnection {\n            return MySqlConnection(host, port, database)\n        }\n\n        fun createPostgreSql(host: String, database: String, port: Int = DEFAULT_POSTGRES_PORT): PostgreSqlConnection {\n            return PostgreSqlConnection(host, port, database)\n        }\n\n        fun createMongo(host: String, database: String, port: Int = DEFAULT_MONGO_PORT): MongoConnection {\n            return MongoConnection(host, port, database)\n        }\n\n        fun createFromType(type: String, host: String, database: String): DatabaseConnection {\n            return when (type.lowercase()) {\n                \"mysql\" -> createMySql(host, database)\n                \"postgresql\", \"postgres\" -> createPostgreSql(host, database)\n                \"mongodb\", \"mongo\" -> createMongo(host, database)\n                else -> throw IllegalArgumentException(\"Unknown database type: $type\")\n            }\n        }\n    }\n}\n\nclass MySqlConnection(host: String, port: Int, database: String) : DatabaseConnection(host, port, database) {\n    override fun connect(): Boolean {\n        println(\"Connecting to MySQL...\")\n        println(getConnectionString())\n        return true\n    }\n\n    override fun getConnectionString(): String {\n        return \"jdbc:mysql://$host:$port/$database\"\n    }\n}\n\nclass PostgreSqlConnection(host: String, port: Int, database: String) : DatabaseConnection(host, port, database) {\n    override fun connect(): Boolean {\n        println(\"Connecting to PostgreSQL...\")\n        println(getConnectionString())\n        return true\n    }\n\n    override fun getConnectionString(): String {\n        return \"jdbc:postgresql://$host:$port/$database\"\n    }\n}\n\nclass MongoConnection(host: String, port: Int, database: String) : DatabaseConnection(host, port, database) {\n    override fun connect(): Boolean {\n        println(\"Connecting to MongoDB...\")\n        println(getConnectionString())\n        return true\n    }\n\n    override fun getConnectionString(): String {\n        return \"mongodb://$host:$port/$database\"\n    }\n}\n\nfun main() {\n    println(\"=== Creating connections using factory methods ===\\n\")\n\n    val mysql = DatabaseConnection.createMySql(\"localhost\", \"myapp\")\n    mysql.connect()\n\n    println()\n\n    val postgres = DatabaseConnection.createPostgreSql(\"localhost\", \"myapp\")\n    postgres.connect()\n\n    println()\n\n    val mongo = DatabaseConnection.createMongo(\"localhost\", \"myapp\")\n    mongo.connect()\n\n    println(\"\\n=== Creating from type string ===\\n\")\n\n    val db = DatabaseConnection.createFromType(\"mysql\", \"prod-server\", \"users_db\")\n    db.connect()\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 3: Singleton Cache System",
              "content": "\n**Goal**: Build a thread-safe cache system using object declaration.\n\n**Requirements**:\n1. Object `CacheManager` to store key-value pairs\n2. Methods: `put()`, `get()`, `remove()`, `clear()`\n3. Method to check if key exists\n4. Method to get all keys\n5. Track cache size and hits/misses\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution: Cache System",
              "content": "\n\n---\n\n",
              "code": "object CacheManager {\n    private val cache = mutableMapOf<String, Any>()\n    private var hits = 0\n    private var misses = 0\n\n    fun put(key: String, value: Any) {\n        cache[key] = value\n        println(\"‚úÖ Cached: $key\")\n    }\n\n    fun get(key: String): Any? {\n        return if (cache.containsKey(key)) {\n            hits++\n            cache[key]\n        } else {\n            misses++\n            null\n        }\n    }\n\n    inline fun <reified T> getAs(key: String): T? {\n        val value = get(key)\n        return value as? T\n    }\n\n    fun remove(key: String): Boolean {\n        val removed = cache.remove(key) != null\n        if (removed) {\n            println(\"üóëÔ∏è  Removed: $key\")\n        }\n        return removed\n    }\n\n    fun clear() {\n        val count = cache.size\n        cache.clear()\n        println(\"üßπ Cleared $count items from cache\")\n    }\n\n    fun contains(key: String): Boolean = cache.containsKey(key)\n\n    fun getAllKeys(): Set<String> = cache.keys.toSet()\n\n    fun size(): Int = cache.size\n\n    fun getStatistics() {\n        val totalRequests = hits + misses\n        val hitRate = if (totalRequests > 0) (hits.toDouble() / totalRequests * 100) else 0.0\n\n        println(\"\\n=== Cache Statistics ===\")\n        println(\"Size: ${cache.size} items\")\n        println(\"Hits: $hits\")\n        println(\"Misses: $misses\")\n        println(\"Hit Rate: ${\"%.2f\".format(hitRate)}%\")\n        println(\"=======================\\n\")\n    }\n\n    fun displayContents() {\n        println(\"\\n=== Cache Contents ===\")\n        if (cache.isEmpty()) {\n            println(\"(empty)\")\n        } else {\n            cache.forEach { (key, value) ->\n                println(\"$key = $value\")\n            }\n        }\n        println(\"======================\\n\")\n    }\n}\n\ndata class User(val id: Int, val name: String)\n\nfun main() {\n    // Add items to cache\n    CacheManager.put(\"user:1\", User(1, \"Alice\"))\n    CacheManager.put(\"user:2\", User(2, \"Bob\"))\n    CacheManager.put(\"config:timeout\", 30)\n    CacheManager.put(\"config:maxUsers\", 100)\n\n    CacheManager.displayContents()\n\n    // Retrieve items\n    println(\"=== Retrieving items ===\")\n    val user1 = CacheManager.getAs<User>(\"user:1\")\n    println(\"Retrieved: $user1\")\n\n    val timeout = CacheManager.getAs<Int>(\"config:timeout\")\n    println(\"Timeout: $timeout\")\n\n    val notFound = CacheManager.get(\"user:999\")\n    println(\"Not found: $notFound\")\n\n    CacheManager.getStatistics()\n\n    // Check existence\n    println(\"Contains 'user:1': ${CacheManager.contains(\"user:1\")}\")\n    println(\"Contains 'user:999': ${CacheManager.contains(\"user:999\")}\")\n\n    // Get all keys\n    println(\"\\nAll keys: ${CacheManager.getAllKeys()}\")\n\n    // Remove item\n    CacheManager.remove(\"user:2\")\n\n    CacheManager.displayContents()\n\n    // Clear cache\n    CacheManager.clear()\n\n    CacheManager.displayContents()\n    CacheManager.getStatistics()\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Checkpoint Quiz",
              "content": "\n### Question 1\nWhat is an object declaration in Kotlin?\n\nA) A way to create multiple instances\nB) A singleton pattern with exactly one instance\nC) An abstract class\nD) A data class\n\n### Question 2\nWhat is a companion object?\n\nA) A friend class\nB) An object that provides static-like members for a class\nC) A duplicate object\nD) An object expression\n\n### Question 3\nWhen is an object declaration initialized?\n\nA) At compile time\nB) When the program starts\nC) On first access (lazy initialization)\nD) Never\n\n### Question 4\nCan companion objects implement interfaces?\n\nA) No, never\nB) Yes, but only one interface\nC) Yes, multiple interfaces\nD) Only abstract classes\n\n### Question 5\nWhat's the difference between `const val` and `val` in an object?\n\nA) No difference\nB) `const val` is a compile-time constant; `val` is computed at runtime\nC) `const val` is faster\nD) `val` is immutable; `const val` is not\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Answers",
              "content": "\n**Question 1: B) A singleton pattern with exactly one instance**\n\nObject declarations create singletons - classes with exactly one instance that's created lazily.\n\n\n---\n\n**Question 2: B) An object that provides static-like members for a class**\n\nCompanion objects give you \"static\" functionality in Kotlin.\n\n\n---\n\n**Question 3: C) On first access (lazy initialization)**\n\nObjects are created the first time they're accessed, not when the program starts.\n\n\n---\n\n**Question 4: C) Yes, multiple interfaces**\n\nCompanion objects can implement multiple interfaces, just like regular objects.\n\n\n---\n\n**Question 5: B) `const val` is a compile-time constant; `val` is computed at runtime**\n\n`const val` must be known at compile time; `val` can be computed at runtime.\n\n\n---\n\n",
              "code": "object Config {\n    const val MAX_SIZE = 100  // ‚úÖ Compile-time constant\n    val timestamp = System.currentTimeMillis()  // ‚úÖ Runtime value\n    // const val time = System.currentTimeMillis()  // ‚ùå Error!\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "What You've Learned",
              "content": "\n‚úÖ Object expressions for anonymous objects\n‚úÖ Object declarations for singletons\n‚úÖ Companion objects for static-like members\n‚úÖ Factory methods with companion objects\n‚úÖ Constants with `const val`\n‚úÖ When to use objects vs classes\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Next Steps",
              "content": "\nIn **Lesson 2.7: Part 2 Capstone - Library Management System**, you'll:\n- Build a complete OOP project\n- Apply all concepts from Part 2\n- Create classes, inheritance, interfaces\n- Use data classes and objects\n- Implement a real-world system\n\nGet ready for the capstone project!\n\n---\n\n**Congratulations on completing Lesson 2.6!** üéâ\n\nYou now understand all of Kotlin's object-related features. Ready for the capstone project!\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "3.7",
          "title": "Lesson 2.7: Part 2 Capstone - Library Management System",
          "moduleId": "module-03",
          "order": 7,
          "estimatedMinutes": 30,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 3-4 hours\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Project Overview",
              "content": "\nCongratulations on completing all the lessons in Part 2! You've learned the fundamentals of Object-Oriented Programming in Kotlin:\n\n- ‚úÖ Classes, objects, properties, and methods\n- ‚úÖ Constructors and initialization\n- ‚úÖ Inheritance and polymorphism\n- ‚úÖ Interfaces and abstract classes\n- ‚úÖ Data classes and sealed classes\n- ‚úÖ Object declarations and companion objects\n\nNow it's time to put it all together in a **comprehensive capstone project**: a **Library Management System**.\n\nThis project will challenge you to apply all OOP concepts in a real-world scenario where you manage books, members, loans, and library operations.\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "The Project: LibraryHub",
              "content": "\n**LibraryHub** is a complete library management system that allows:\n- Managing different types of books (physical and digital)\n- Registering library members\n- Borrowing and returning books\n- Reserving books that are currently unavailable\n- Searching and filtering books\n- Tracking loan history\n- Managing late fees\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Requirements",
              "content": "\n### 1. Book Management\n\n**Abstract Class: `Book`**\n- Properties: `isbn`, `title`, `author`, `publishYear`, `status`\n- Abstract method: `getDisplayInfo()`\n- Method: `isAvailable()`\n\n**Classes**:\n- `PhysicalBook` extends `Book`\n  - Additional properties: `shelfLocation`, `condition` (New, Good, Fair, Poor)\n  - Implements `getDisplayInfo()`\n\n- `DigitalBook` extends `Book`\n  - Additional properties: `fileSize` (MB), `format` (PDF, EPUB, MOBI)\n  - Method: `download()`\n  - Implements `getDisplayInfo()`\n\n**Book Status** (Sealed Class):\n- `Available`\n- `Borrowed(memberId, dueDate)`\n- `Reserved(memberId)`\n- `Maintenance`\n\n### 2. Member Management\n\n**Data Class: `Member`**\n- Properties: `memberId`, `name`, `email`, `membershipType`, `joinDate`\n- Method: `canBorrow()` - checks if member can borrow more books\n\n**Membership Types** (Enum):\n- `BASIC` - Can borrow 3 books\n- `PREMIUM` - Can borrow 5 books\n- `STUDENT` - Can borrow 4 books with discounted fees\n\n### 3. Loan System\n\n**Data Class: `Loan`**\n- Properties: `loanId`, `book`, `member`, `borrowDate`, `dueDate`, `returnDate`, `lateFee`\n- Method: `isOverdue()` - checks if loan is past due date\n- Method: `calculateLateFee()` - calculates fee based on days overdue\n\n**Interface: `Borrowable`**\n- Methods: `borrow(member)`, `returnBook()`\n\n**Interface: `Reservable`**\n- Methods: `reserve(member)`, `cancelReservation()`\n\n### 4. Library Manager\n\n**Object: `Library`**\n- Manages all books, members, and loans\n- Methods:\n  - `addBook(book)`\n  - `removeBook(isbn)`\n  - `registerMember(member)`\n  - `borrowBook(isbn, memberId)`\n  - `returnBook(isbn)`\n  - `reserveBook(isbn, memberId)`\n  - `searchBooks(query)` - search by title or author\n  - `getOverdueLoans()`\n  - `getMemberHistory(memberId)`\n  - `printStatistics()`\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Step-by-Step Implementation",
              "content": "\n### Phase 1: Book Status and Types (30 minutes)\n\nLet's start by defining our book status and types:\n\n\n### Phase 2: Book Classes (45 minutes)\n\n\n### Phase 3: Member and Loan (30 minutes)\n\n\n### Phase 4: Library Manager (60 minutes)\n\n\n### Phase 5: Main Application (30 minutes)\n\n\n---\n\n",
              "code": "// Main.kt\nimport java.time.LocalDate\n\nfun main() {\n    println(\"‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\")\n    println(\"‚ïë     Welcome to LibraryHub System      ‚ïë\")\n    println(\"‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\\n\")\n\n    // Initialize library with books\n    println(\"üìö Adding books to library...\")\n    Library.addBook(PhysicalBook(\n        isbn = \"978-0-13-468599-1\",\n        title = \"Effective Java\",\n        author = \"Joshua Bloch\",\n        publishYear = 2018,\n        shelfLocation = \"A1-15\",\n        condition = BookCondition.GOOD\n    ))\n\n    Library.addBook(PhysicalBook(\n        isbn = \"978-0-13-597764-5\",\n        title = \"Clean Code\",\n        author = \"Robert C. Martin\",\n        publishYear = 2008,\n        shelfLocation = \"A1-20\",\n        condition = BookCondition.FAIR\n    ))\n\n    Library.addBook(DigitalBook(\n        isbn = \"978-1-61729-655-2\",\n        title = \"Kotlin in Action\",\n        author = \"Dmitry Jemerov\",\n        publishYear = 2017,\n        fileSize = 15.5,\n        format = FileFormat.PDF\n    ))\n\n    Library.addBook(DigitalBook(\n        isbn = \"978-1-78899-367-8\",\n        title = \"Programming Kotlin\",\n        author = \"Venkat Subramaniam\",\n        publishYear = 2019,\n        fileSize = 12.3,\n        format = FileFormat.EPUB\n    ))\n\n    Library.addBook(PhysicalBook(\n        isbn = \"978-0-13-490733-2\",\n        title = \"Design Patterns\",\n        author = \"Gang of Four\",\n        publishYear = 1994,\n        shelfLocation = \"B2-10\",\n        condition = BookCondition.GOOD\n    ))\n\n    // Register members\n    println(\"\\nüë• Registering members...\")\n    Library.registerMember(Member(\n        memberId = \"M001\",\n        name = \"Alice Johnson\",\n        email = \"alice@example.com\",\n        membershipType = MembershipType.PREMIUM,\n        joinDate = LocalDate.now().minusMonths(6).toString()\n    ))\n\n    Library.registerMember(Member(\n        memberId = \"M002\",\n        name = \"Bob Smith\",\n        email = \"bob@example.com\",\n        membershipType = MembershipType.BASIC,\n        joinDate = LocalDate.now().minusMonths(3).toString()\n    ))\n\n    Library.registerMember(Member(\n        memberId = \"M003\",\n        name = \"Carol Davis\",\n        email = \"carol@example.com\",\n        membershipType = MembershipType.STUDENT,\n        joinDate = LocalDate.now().minusWeeks(2).toString()\n    ))\n\n    // Display initial state\n    Library.printStatistics()\n    Library.displayAllBooks()\n    Library.displayAllMembers()\n\n    // Simulate borrowing\n    println(\"\\n\" + \"=\".repeat(50))\n    println(\"üìñ Borrowing Operations\")\n    println(\"=\".repeat(50))\n\n    Library.borrowBook(\"978-0-13-468599-1\", \"M001\")  // Alice borrows Effective Java\n    Library.borrowBook(\"978-1-61729-655-2\", \"M001\")  // Alice borrows Kotlin in Action\n    Library.borrowBook(\"978-0-13-597764-5\", \"M002\")  // Bob borrows Clean Code\n    Library.borrowBook(\"978-1-78899-367-8\", \"M003\")  // Carol borrows Programming Kotlin\n\n    // Try to borrow unavailable book\n    println()\n    Library.borrowBook(\"978-0-13-468599-1\", \"M002\")  // Should fail - already borrowed\n\n    // Display updated state\n    Library.printStatistics()\n\n    // Search functionality\n    println(\"\\n\" + \"=\".repeat(50))\n    println(\"üîç Search Results for 'Kotlin'\")\n    println(\"=\".repeat(50))\n    val kotlinBooks = Library.searchBooks(\"Kotlin\")\n    kotlinBooks.forEach { book ->\n        println(\"\\n${book.title} by ${book.author}\")\n        println(\"Status: ${book.status.getDescription()}\")\n    }\n\n    // Return books\n    println(\"\\n\" + \"=\".repeat(50))\n    println(\"üì• Return Operations\")\n    println(\"=\".repeat(50))\n\n    Library.returnBook(\"978-0-13-468599-1\")  // Alice returns Effective Java\n    Library.returnBook(\"978-1-78899-367-8\")  // Carol returns Programming Kotlin\n\n    // Display active loans\n    println(\"\\nüìã Active Loans:\")\n    Library.getActiveLoans().forEach { it.display() }\n\n    // Final statistics\n    Library.printStatistics()\n\n    // Member history\n    println(\"\\n\" + \"=\".repeat(50))\n    println(\"üìú Alice's Borrowing History\")\n    println(\"=\".repeat(50))\n    val aliceHistory = Library.getMemberHistory(\"M001\")\n    aliceHistory.forEach { it.display() }\n\n    println(\"\\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\")\n    println(\"‚ïë   Thank you for using LibraryHub!     ‚ïë\")\n    println(\"‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\")\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Complete Solution",
              "content": "\nThe complete solution integrates all the pieces above. Here's what you should have:\n\n**File Structure**:\n\n---\n\n",
              "code": "LibraryHub/\n‚îú‚îÄ‚îÄ BookStatus.kt\n‚îú‚îÄ‚îÄ BookCondition.kt\n‚îú‚îÄ‚îÄ FileFormat.kt\n‚îú‚îÄ‚îÄ MembershipType.kt\n‚îú‚îÄ‚îÄ Book.kt\n‚îú‚îÄ‚îÄ PhysicalBook.kt\n‚îú‚îÄ‚îÄ DigitalBook.kt\n‚îú‚îÄ‚îÄ Member.kt\n‚îú‚îÄ‚îÄ Loan.kt\n‚îú‚îÄ‚îÄ Library.kt\n‚îî‚îÄ‚îÄ Main.kt",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Testing Your Solution",
              "content": "\nRun the main function and verify:\n\n1. ‚úÖ Books are added successfully\n2. ‚úÖ Members are registered\n3. ‚úÖ Borrowing works correctly\n4. ‚úÖ Can't borrow unavailable books\n5. ‚úÖ Can't exceed borrowing limits\n6. ‚úÖ Return functionality works\n7. ‚úÖ Search finds correct books\n8. ‚úÖ Statistics are accurate\n9. ‚úÖ Member history is tracked\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Extension Challenges",
              "content": "\nOnce you have the basic system working, try these enhancements:\n\n### Challenge 1: Reservation System (+‚≠ê)\n\nAdd ability to reserve books that are currently borrowed:\n\n\n### Challenge 2: Fine Payment System (+‚≠ê‚≠ê)\n\nAdd payment tracking:\n\n\n### Challenge 3: Book Categories (+‚≠ê)\n\nAdd categories/genres to books:\n\n\n### Challenge 4: Review System (+‚≠ê‚≠ê)\n\nAllow members to review books:\n\n\n### Challenge 5: Save/Load System (+‚≠ê‚≠ê‚≠ê)\n\nPersist data to files:\n\n\n---\n\n",
              "code": "fun saveToFile(filename: String)\nfun loadFromFile(filename: String)\n\n// Use JSON or serialization\n// Save all books, members, loans",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Evaluation Checklist",
              "content": "\nBefore considering your project complete, ensure:\n\n- [ ] All classes are properly defined with correct properties\n- [ ] Inheritance hierarchy is implemented (Book ‚Üí PhysicalBook/DigitalBook)\n- [ ] Sealed classes are used for BookStatus\n- [ ] Enums are defined for BookCondition, FileFormat, MembershipType\n- [ ] Data classes are used where appropriate (Member, Loan)\n- [ ] Object declaration is used for Library singleton\n- [ ] All interfaces are implemented correctly\n- [ ] Borrowing logic validates availability and member limits\n- [ ] Return logic updates all states correctly\n- [ ] Search functionality works\n- [ ] Statistics are accurate\n- [ ] Late fee calculation is correct\n- [ ] Code is well-organized and readable\n- [ ] No duplicate code (DRY principle)\n- [ ] Meaningful variable and function names\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Learning Outcomes",
              "content": "\nBy completing this capstone project, you have:\n\n‚úÖ **Applied OOP principles** in a real-world scenario\n‚úÖ **Designed a class hierarchy** with inheritance and polymorphism\n‚úÖ **Used interfaces** to define contracts\n‚úÖ **Leveraged sealed classes** for type-safe state management\n‚úÖ **Created data classes** for domain models\n‚úÖ **Implemented a singleton** for centralized management\n‚úÖ **Managed relationships** between objects\n‚úÖ **Handled business logic** with validation\n‚úÖ **Built a complete system** from requirements to implementation\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nCongratulations on completing Part 2: Object-Oriented Programming! üéâ\n\n**In Part 3: Functional Programming**, you'll learn:\n- Lambda expressions and higher-order functions\n- Collection operations (map, filter, reduce)\n- Function types and function composition\n- Scope functions (let, apply, run, also, with)\n- Sequences for lazy evaluation\n\n**In Part 4: Advanced Kotlin**, you'll learn:\n- Generics and variance\n- Delegation pattern\n- DSL creation\n- Coroutines basics\n- Extension functions\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Tips for Success",
              "content": "\n### Design Principles Applied\n\n**1. Single Responsibility Principle**\n- Each class has one clear purpose\n- `Book` manages book data, `Library` manages operations\n\n**2. Open/Closed Principle**\n- `Book` is open for extension (PhysicalBook, DigitalBook)\n- Closed for modification (base behavior is stable)\n\n**3. Liskov Substitution Principle**\n- `PhysicalBook` and `DigitalBook` can be used anywhere `Book` is expected\n\n**4. Interface Segregation**\n- Small, focused interfaces (Borrowable, Reservable)\n\n**5. Dependency Inversion**\n- Code depends on abstractions (Book, not specific types)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Reflection Questions",
              "content": "\nAfter completing the project, consider:\n\n1. Why did we use an abstract class for `Book` instead of an interface?\n2. When would you use a data class vs a regular class?\n3. Why is `Library` an object instead of a regular class?\n4. How does sealed classes make the status system safer?\n5. What are the benefits of using enums for fixed sets of values?\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Resources",
              "content": "\n**Kotlin Documentation**:\n- [Classes and Objects](https://kotlinlang.org/docs/classes.html)\n- [Inheritance](https://kotlinlang.org/docs/inheritance.html)\n- [Data Classes](https://kotlinlang.org/docs/data-classes.html)\n- [Sealed Classes](https://kotlinlang.org/docs/sealed-classes.html)\n- [Object Declarations](https://kotlinlang.org/docs/object-declarations.html)\n\n**Design Patterns**:\n- [Singleton Pattern](https://refactoring.guru/design-patterns/singleton)\n- [Factory Pattern](https://refactoring.guru/design-patterns/factory-method)\n\n---\n\n**üéâ Congratulations on completing Part 2: Object-Oriented Programming! üéâ**\n\nYou've built a complete, real-world application using OOP principles. This is a major milestone in your Kotlin journey!\n\nYour Library Management System demonstrates:\n- Strong understanding of OOP concepts\n- Ability to model real-world domains\n- Clean code organization\n- Practical problem-solving skills\n\nTake a moment to celebrate this achievement, then get ready for Part 3: Functional Programming! üöÄ\n\n"
            }
          ],
          "challenges": []
        }
      ],
      "quizzes": [
        {
          "id": "part3-quiz-3.1",
          "title": "Classes and Objects Quiz",
          "description": "Knowledge check for Classes and Objects Quiz",
          "moduleId": "module-03",
          "passingScore": 70,
          "estimatedMinutes": 8,
          "questions": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "3.1.q1",
              "title": "What is a class?",
              "description": "What is a class?",
              "options": [
                "A specific instance of an object",
                "A blueprint or template for creating objects",
                "A type of function",
                "A collection of variables"
              ],
              "correctAnswer": 1,
              "explanation": "A class is a blueprint that defines the structure and behavior for objects. It's like a cookie cutter."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "3.1.q2",
              "title": "What is an object?",
              "description": "What is an object?",
              "options": [
                "A blueprint for creating classes",
                "A specific instance created from a class",
                "A type of variable",
                "A function that returns data"
              ],
              "correctAnswer": 1,
              "explanation": "An object is a specific instance created from a class, like an actual cookie made from a cookie cutter."
            },
            {
              "type": "TRUE_FALSE",
              "id": "3.1.q3",
              "title": "Properties are variables that belong to a class.",
              "description": "Properties are variables that belong to a class.",
              "question": "Properties are variables that belong to a class.",
              "correctAnswer": true,
              "explanation": "True. Properties are variables defined within a class that store data for each object."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "3.1.q4",
              "title": "What keyword is used to create a new object?",
              "description": "What keyword is used to create a new object?",
              "options": [
                "create",
                "new",
                "object",
                "No keyword needed - just call the class like a function"
              ],
              "correctAnswer": 3,
              "explanation": "In Kotlin, you don't use 'new'. You create objects by calling the class constructor like a function."
            }
          ]
        },
        {
          "id": "part3-quiz-3.2",
          "title": "Null Safety Quiz",
          "description": "Knowledge check for Null Safety Quiz",
          "moduleId": "module-03",
          "passingScore": 70,
          "estimatedMinutes": 10,
          "questions": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "3.2.q1",
              "title": "What does 'null' represent?",
              "description": "What does 'null' represent?",
              "options": [
                "Zero",
                "Empty string",
                "The absence of a value",
                "False"
              ],
              "correctAnswer": 2,
              "explanation": "null represents the absence of a value - 'nothing' or 'no data'."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "3.2.q2",
              "title": "How do you declare a nullable type?",
              "description": "How do you declare a nullable type?",
              "options": [
                "String null",
                "String?",
                "nullable String",
                "String!"
              ],
              "correctAnswer": 1,
              "explanation": "Add a question mark (?) after the type to make it nullable: String?"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "3.2.q3",
              "title": "What does the safe call operator (?.) do?",
              "description": "What does the safe call operator (?.) do?",
              "options": [
                "Forces unwrapping",
                "Only calls the method if the object is not null",
                "Throws an exception",
                "Converts null to zero"
              ],
              "correctAnswer": 1,
              "explanation": "The safe call operator (?.) only calls the method/property if the object is not null. If null, it returns null."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "3.2.q4",
              "title": "What does the Elvis operator (?:) do?",
              "description": "What does the Elvis operator (?:) do?",
              "options": [
                "Plays music",
                "Provides a default value if the left side is null",
                "Checks if two values are equal",
                "Throws an exception"
              ],
              "correctAnswer": 1,
              "explanation": "The Elvis operator (?:) returns the left value if not null, otherwise returns the right value (default)."
            },
            {
              "type": "TRUE_FALSE",
              "id": "3.2.q5",
              "title": "The !! operator should be used frequently in production code.",
              "description": "The !! operator should be used frequently in production code.",
              "question": "The !! operator should be used frequently in production code.",
              "correctAnswer": false,
              "explanation": "False. The !! operator forces unwrapping and can cause NullPointerException. Use it sparingly and only when you're certain."
            }
          ]
        },
        {
          "id": "part3-quiz-3.3",
          "title": "Inheritance and Polymorphism Quiz",
          "description": "Knowledge check for Inheritance and Polymorphism Quiz",
          "moduleId": "module-03",
          "passingScore": 70,
          "estimatedMinutes": 10,
          "questions": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "3.3.q1",
              "title": "What is inheritance?",
              "description": "What is inheritance?",
              "options": [
                "Creating multiple objects",
                "A class inheriting properties and methods from another class",
                "Passing parameters to functions",
                "Creating nullable types"
              ],
              "correctAnswer": 1,
              "explanation": "Inheritance allows a class to inherit properties and methods from another class, promoting code reuse."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "3.3.q2",
              "title": "What keyword makes a class inheritable?",
              "description": "What keyword makes a class inheritable?",
              "options": [
                "inheritable",
                "open",
                "public",
                "extend"
              ],
              "correctAnswer": 1,
              "explanation": "The 'open' keyword allows a class to be inherited. By default, Kotlin classes are final."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "3.3.q3",
              "title": "What keyword is used to inherit from a class?",
              "description": "What keyword is used to inherit from a class?",
              "options": [
                "extends",
                "inherits",
                ": (colon)",
                "from"
              ],
              "correctAnswer": 2,
              "explanation": "In Kotlin, you use a colon (:) to inherit from a class: class Dog : Animal()"
            },
            {
              "type": "TRUE_FALSE",
              "id": "3.3.q4",
              "title": "An abstract class can be instantiated directly.",
              "description": "An abstract class can be instantiated directly.",
              "question": "An abstract class can be instantiated directly.",
              "correctAnswer": false,
              "explanation": "False. Abstract classes cannot be instantiated. They're meant to be inherited by other classes."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "3.3.q5",
              "title": "What is an interface?",
              "description": "What is an interface?",
              "options": [
                "A concrete class",
                "A contract that defines what methods a class must implement",
                "A type of variable",
                "A loop structure"
              ],
              "correctAnswer": 1,
              "explanation": "An interface is a contract that defines methods a class must implement, without providing implementation details."
            }
          ]
        },
        {
          "id": "part3-quiz-3.4",
          "title": "Data Classes Quiz",
          "description": "Knowledge check for Data Classes Quiz",
          "moduleId": "module-03",
          "passingScore": 70,
          "estimatedMinutes": 8,
          "questions": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "3.4.q1",
              "title": "What does the 'data' keyword do?",
              "description": "What does the 'data' keyword do?",
              "options": [
                "Makes the class store data",
                "Automatically generates useful methods like equals(), hashCode(), toString()",
                "Creates a database",
                "Makes properties nullable"
              ],
              "correctAnswer": 1,
              "explanation": "Data classes automatically generate equals(), hashCode(), toString(), copy(), and component functions."
            },
            {
              "type": "TRUE_FALSE",
              "id": "3.4.q2",
              "title": "Two data class instances with the same property values are considered equal.",
              "description": "Two data class instances with the same property values are considered equal.",
              "question": "Two data class instances with the same property values are considered equal.",
              "correctAnswer": true,
              "explanation": "True. Data classes implement structural equality - instances with same values are equal."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "3.4.q3",
              "title": "What does the copy() method do in data classes?",
              "description": "What does the copy() method do in data classes?",
              "options": [
                "Duplicates the class definition",
                "Creates a new instance with optionally modified properties",
                "Copies to clipboard",
                "Makes a backup"
              ],
              "correctAnswer": 1,
              "explanation": "copy() creates a new instance of the data class, allowing you to change specific properties while keeping others the same."
            },
            {
              "type": "TRUE_FALSE",
              "id": "3.4.q4",
              "title": "Data classes can have properties defined outside the primary constructor.",
              "description": "Data classes can have properties defined outside the primary constructor.",
              "question": "Data classes can have properties defined outside the primary constructor.",
              "correctAnswer": true,
              "explanation": "True, but only properties in the primary constructor are used in equals(), hashCode(), etc."
            }
          ]
        }
      ]
    },
    {
      "id": "module-04",
      "title": "Part 4: Kotlin Fundamentals",
      "description": "Learn Kotlin programming - Part 4",
      "difficulty": "intermediate",
      "estimatedHours": 15,
      "lessons": [
        {
          "id": "4.1",
          "title": "Lesson 3.1: Introduction to Functional Programming",
          "moduleId": "module-04",
          "order": 1,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 60 minutes\n**Difficulty**: Intermediate\n**Prerequisites**: Parts 1-2 (Kotlin fundamentals, OOP)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Topic Introduction",
              "content": "\nWelcome to Part 3: Functional Programming! You've mastered Kotlin basics and object-oriented programming. Now it's time to explore a powerful programming paradigm that will transform how you write code.\n\nFunctional programming (FP) is not just about using functions‚Äîit's a different way of thinking about problems. Instead of telling the computer **what to do** step-by-step (imperative), you describe **what you want** (declarative). The result? Code that's shorter, clearer, and easier to test.\n\nIn this lesson, you'll learn:\n- What functional programming really means\n- First-class and higher-order functions\n- Lambda expressions basics\n- Function types in Kotlin\n- How to pass functions as parameters\n\nBy the end, you'll write elegant, functional code that reads like English!\n\n---\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "The Concept: What Is Functional Programming?",
              "content": "\n### The Assembly Line Analogy\n\nImagine two approaches to making a pizza:\n\n**Imperative Approach** (Traditional Programming):\n\n**Functional Approach**:\n\nThe functional approach:\n- Chains operations together\n- Each step transforms data and passes it forward\n- Reads more naturally\n- Easier to understand at a glance\n\n### Core Principles of Functional Programming\n\n**1. Functions Are First-Class Citizens**\n\nIn FP, functions are values just like numbers or strings. You can:\n- Store them in variables\n- Pass them to other functions\n- Return them from functions\n- Create them on the fly\n\n\n**2. Higher-Order Functions**\n\nFunctions that take other functions as parameters or return functions:\n\n\n**3. Immutability**\n\nPrefer values that don't change (immutable data):\n\n\n**4. Pure Functions**\n\nFunctions with no side effects‚Äîsame input always gives same output:\n\n\n---\n\n",
              "code": "// ‚úÖ Pure function\nfun add(a: Int, b: Int): Int = a + b\n\n// ‚ùå Impure function (depends on external state)\nvar discount = 0.1\nfun applyDiscount(price: Double): Double = price * (1 - discount)",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "First-Class Functions",
              "content": "\nIn Kotlin, functions are **first-class citizens**‚Äîthey're treated like any other value.\n\n### Assigning Functions to Variables\n\n\n### Anonymous Functions\n\nFunctions without names:\n\n\n### Lambda Expressions (Preview)\n\nShorter syntax for anonymous functions:\n\n\n### Why This Matters\n\n\n---\n\n",
              "code": "// Store different math operations\nval add = { a: Int, b: Int -> a + b }\nval subtract = { a: Int, b: Int -> a - b }\nval multiply = { a: Int, b: Int -> a * b }\n\n// Use them interchangeably\nfun calculate(a: Int, b: Int, operation: (Int, Int) -> Int): Int {\n    return operation(a, b)\n}\n\nprintln(calculate(10, 5, add))       // 15\nprintln(calculate(10, 5, subtract))  // 5\nprintln(calculate(10, 5, multiply))  // 50",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Higher-Order Functions",
              "content": "\nFunctions that work with other functions.\n\n### Taking Functions as Parameters\n\n\n### Real-World Example: Custom List Processing\n\n\n### Returning Functions\n\n\n---\n\n",
              "code": "fun createMultiplier(factor: Int): (Int) -> Int {\n    return { number -> number * factor }\n}\n\nval double = createMultiplier(2)\nval triple = createMultiplier(3)\nval tenfold = createMultiplier(10)\n\nprintln(double(5))    // 10\nprintln(triple(5))    // 15\nprintln(tenfold(5))   // 50",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Lambda Expressions Basics",
              "content": "\nLambdas are concise anonymous functions.\n\n### Basic Lambda Syntax\n\n\n### Lambda Structure\n\n\nExamples:\n\n\n### Type Inference\n\nKotlin often infers lambda parameter types:\n\n\n---\n\n",
              "code": "// Explicit type\nval numbers = listOf(1, 2, 3, 4, 5)\nval doubled = numbers.map({ x: Int -> x * 2 })\n\n// Type inferred (cleaner!)\nval tripled = numbers.map({ x -> x * 3 })\n\n// Even shorter with 'it' (single parameter)\nval quadrupled = numbers.map({ it * 4 })\n\n// Trailing lambda (move outside parentheses)\nval quintupled = numbers.map { it * 5 }\n\nprintln(quintupled)  // [5, 10, 15, 20, 25]",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Function Types",
              "content": "\nEvery function has a type, just like variables.\n\n### Basic Function Type Syntax\n\n\n### Function Type Components\n\n\n### Using Function Types in Declarations\n\n\n### Nullable Function Types\n\n\n---\n\n",
              "code": "var operation: ((Int, Int) -> Int)? = null\n\noperation = { a, b -> a + b }\n\n// Safe call with nullable function\nval result = operation?.invoke(5, 3)  // 8\n\noperation = null\nval result2 = operation?.invoke(5, 3)  // null",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Passing Functions as Parameters",
              "content": "\nOne of the most powerful FP techniques.\n\n### Example 1: Retry Logic\n\n\n### Example 2: Timing Function Execution\n\n\n### Example 3: List Transformation\n\n\n---\n\n",
              "code": "fun List<Int>.customMap(transform: (Int) -> Int): List<Int> {\n    val result = mutableListOf<Int>()\n    for (item in this) {\n        result.add(transform(item))\n    }\n    return result\n}\n\nval numbers = listOf(1, 2, 3, 4, 5)\n\nval doubled = numbers.customMap { it * 2 }\nprintln(doubled)  // [2, 4, 6, 8, 10]\n\nval squared = numbers.customMap { it * it }\nprintln(squared)  // [1, 4, 9, 16, 25]",
              "language": "kotlin"
            },
            {
              "type": "EXAMPLE",
              "title": "Practical Examples: Real-World Use Cases",
              "content": "\n### Example 1: Form Validation\n\n\n### Example 2: Event Handling\n\n\n### Example 3: Strategy Pattern with Functions\n\n\n---\n\n",
              "code": "class PriceCalculator {\n    fun calculatePrice(\n        basePrice: Double,\n        quantity: Int,\n        discountStrategy: (Double, Int) -> Double\n    ): Double {\n        return discountStrategy(basePrice, quantity)\n    }\n}\n\n// Different discount strategies\nval noDiscount = { price: Double, qty: Int -> price * qty }\nval bulkDiscount = { price: Double, qty: Int ->\n    if (qty >= 10) price * qty * 0.9 else price * qty\n}\nval loyaltyDiscount = { price: Double, qty: Int -> price * qty * 0.85 }\n\nval calculator = PriceCalculator()\n\nprintln(calculator.calculatePrice(100.0, 5, noDiscount))        // 500.0\nprintln(calculator.calculatePrice(100.0, 15, bulkDiscount))     // 1350.0\nprintln(calculator.calculatePrice(100.0, 5, loyaltyDiscount))   // 425.0",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 1: Function Calculator",
              "content": "\n**Goal**: Create a calculator that uses functions for operations.\n\n**Requirements**:\n1. Create a function `calculate` that takes two numbers and an operation function\n2. Define operation functions for: add, subtract, multiply, divide\n3. Use the calculator with different operations\n\n**Starter Code**:\n\n---\n\n",
              "code": "fun calculate(a: Int, b: Int, operation: (Int, Int) -> Int): Int {\n    // TODO: Implement\n}\n\nfun main() {\n    // TODO: Define operations and use calculator\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Solution 1: Function Calculator",
              "content": "\n\n**Explanation**:\n- We define operation functions as lambda expressions\n- Each lambda takes two Ints and returns an Int\n- The `calculate` function is generic‚Äîit works with any operation\n- We can pass pre-defined operations or create them inline\n\n---\n\n",
              "code": "fun calculate(a: Int, b: Int, operation: (Int, Int) -> Int): Int {\n    return operation(a, b)\n}\n\nfun main() {\n    // Define operations as lambdas\n    val add = { a: Int, b: Int -> a + b }\n    val subtract = { a: Int, b: Int -> a - b }\n    val multiply = { a: Int, b: Int -> a * b }\n    val divide = { a: Int, b: Int -> if (b != 0) a / b else 0 }\n\n    val x = 20\n    val y = 4\n\n    println(\"$x + $y = ${calculate(x, y, add)}\")         // 24\n    println(\"$x - $y = ${calculate(x, y, subtract)}\")    // 16\n    println(\"$x * $y = ${calculate(x, y, multiply)}\")    // 80\n    println(\"$x / $y = ${calculate(x, y, divide)}\")      // 5\n\n    // Can also use lambdas directly\n    println(\"$x % $y = ${calculate(x, y) { a, b -> a % b }}\")  // 0\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 2: Custom List Filter",
              "content": "\n**Goal**: Build a reusable filter function for lists.\n\n**Requirements**:\n1. Create a function `filterList` that takes a list and a predicate function\n2. The predicate determines which elements to keep\n3. Test with different predicates (even numbers, > 10, etc.)\n\n**Starter Code**:\n\n---\n\n",
              "code": "fun filterList(list: List<Int>, predicate: (Int) -> Boolean): List<Int> {\n    // TODO: Implement\n}\n\nfun main() {\n    val numbers = listOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n    // TODO: Filter with different predicates\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Solution 2: Custom List Filter",
              "content": "\n\n**Explanation**:\n- `filterList` iterates through the list\n- For each item, it calls the predicate function\n- If predicate returns true, item is included in result\n- Different predicates give different filtered results\n\n---\n\n",
              "code": "fun filterList(list: List<Int>, predicate: (Int) -> Boolean): List<Int> {\n    val result = mutableListOf<Int>()\n    for (item in list) {\n        if (predicate(item)) {\n            result.add(item)\n        }\n    }\n    return result\n}\n\nfun main() {\n    val numbers = listOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20, 25)\n\n    // Filter even numbers\n    val evens = filterList(numbers) { it % 2 == 0 }\n    println(\"Even numbers: $evens\")  // [2, 4, 6, 8, 10, 20]\n\n    // Filter numbers greater than 10\n    val bigNumbers = filterList(numbers) { it > 10 }\n    println(\"Numbers > 10: $bigNumbers\")  // [15, 20, 25]\n\n    // Filter numbers divisible by 5\n    val divisibleBy5 = filterList(numbers) { it % 5 == 0 }\n    println(\"Divisible by 5: $divisibleBy5\")  // [5, 10, 15, 20, 25]\n\n    // Filter numbers in range 3..7\n    val inRange = filterList(numbers) { it in 3..7 }\n    println(\"In range 3-7: $inRange\")  // [3, 4, 5, 6, 7]\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 3: Function Builder",
              "content": "\n**Goal**: Create a function that returns different functions based on input.\n\n**Requirements**:\n1. Create `createGreeter` that takes a greeting style\n2. Return appropriate greeting function\n3. Styles: \"formal\", \"casual\", \"enthusiastic\"\n\n**Starter Code**:\n\n---\n\n",
              "code": "fun createGreeter(style: String): (String) -> String {\n    // TODO: Return different greeting functions based on style\n}\n\nfun main() {\n    // TODO: Test different greeting styles\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Solution 3: Function Builder",
              "content": "\n\n**Explanation**:\n- `createGreeter` is a factory function that returns functions\n- Based on style parameter, it returns different greeting implementations\n- Each returned function has the same signature: `(String) -> String`\n- This demonstrates functions returning functions‚Äîpowerful abstraction!\n\n---\n\n",
              "code": "fun createGreeter(style: String): (String) -> String {\n    return when (style) {\n        \"formal\" -> { name -> \"Good day, $name. How may I assist you?\" }\n        \"casual\" -> { name -> \"Hey $name! What's up?\" }\n        \"enthusiastic\" -> { name -> \"OH WOW! Hi $name!!! So great to see you!!!\" }\n        else -> { name -> \"Hello, $name.\" }\n    }\n}\n\nfun main() {\n    val formalGreeter = createGreeter(\"formal\")\n    val casualGreeter = createGreeter(\"casual\")\n    val enthusiasticGreeter = createGreeter(\"enthusiastic\")\n\n    val person = \"Alice\"\n\n    println(formalGreeter(person))\n    // Output: Good day, Alice. How may I assist you?\n\n    println(casualGreeter(person))\n    // Output: Hey Alice! What's up?\n\n    println(enthusiasticGreeter(person))\n    // Output: OH WOW! Hi Alice!!! So great to see you!!!\n\n    // Can also create and use immediately\n    println(createGreeter(\"unknown\")(person))\n    // Output: Hello, Alice.\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Checkpoint Quiz",
              "content": "\nTest your understanding of functional programming concepts!\n\n### Question 1\nWhat does it mean that functions are \"first-class citizens\" in Kotlin?\n\nA) Functions must be declared before variables\nB) Functions can be treated as values‚Äîstored in variables, passed as parameters, and returned from functions\nC) Functions are more important than other code elements\nD) Functions always execute first in a program\n\n### Question 2\nWhat is a higher-order function?\n\nA) A function declared at the top of a file\nB) A function with more parameters than usual\nC) A function that takes another function as a parameter or returns a function\nD) A function that runs faster than normal functions\n\n### Question 3\nWhat is the correct syntax for a lambda expression that doubles a number?\n\nA) `lambda x -> x * 2`\nB) `{ x -> x * 2 }`\nC) `func(x) { x * 2 }`\nD) `double(x) = x * 2`\n\n### Question 4\nWhat is the function type of: `{ a: Int, b: Int -> a + b }`?\n\nA) `(Int) -> Int`\nB) `(Int, Int) -> Unit`\nC) `(Int, Int) -> Int`\nD) `() -> Int`\n\n### Question 5\nWhat does the `it` keyword represent in a lambda?\n\nA) The function itself\nB) The single parameter when a lambda has exactly one parameter\nC) The return value\nD) The iteration count in a loop\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Answers",
              "content": "\n**Question 1: B) Functions can be treated as values‚Äîstored in variables, passed as parameters, and returned from functions**\n\nFirst-class functions mean functions are treated like any other value in the language:\n\n\nThis is fundamental to functional programming and enables powerful abstractions.\n\n---\n\n**Question 2: C) A function that takes another function as a parameter or returns a function**\n\nHigher-order functions work with other functions:\n\n\nThis enables generic, reusable code patterns.\n\n---\n\n**Question 3: B) `{ x -> x * 2 }`**\n\nLambda syntax in Kotlin:\n\n\nCurly braces delimit the lambda, arrow separates parameters from body.\n\n---\n\n**Question 4: C) `(Int, Int) -> Int`**\n\nFunction type syntax: `(ParameterTypes) -> ReturnType`\n\n\nThis describes a function taking two Ints and returning an Int.\n\n---\n\n**Question 5: B) The single parameter when a lambda has exactly one parameter**\n\n`it` is shorthand for the single parameter:\n\n\nOnly works with single-parameter lambdas.\n\n---\n\n",
              "code": "// Explicit parameter\nnumbers.map({ x -> x * 2 })\n\n// Using 'it'\nnumbers.map({ it * 2 })\n\n// Even shorter\nnumbers.map { it * 2 }\n\n// But with multiple parameters, must use names:\nnumbers.fold(0) { acc, n -> acc + n }  // Can't use 'it' here",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "What You've Learned",
              "content": "\n‚úÖ Core principles of functional programming (first-class functions, immutability, pure functions)\n‚úÖ First-class functions‚Äîtreating functions as values\n‚úÖ Higher-order functions‚Äîfunctions that work with other functions\n‚úÖ Lambda expression syntax and usage\n‚úÖ Function types and type signatures\n‚úÖ Passing functions as parameters\n‚úÖ Returning functions from functions\n‚úÖ Practical applications: validation, event handling, strategy pattern\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Next Steps",
              "content": "\nIn **Lesson 3.2: Lambda Expressions and Anonymous Functions**, you'll master:\n- Advanced lambda syntax variations\n- The `it` keyword and trailing lambda syntax\n- Anonymous functions vs lambdas\n- Function references and member references\n- When to use each approach\n\nGet ready to write even more elegant functional code!\n\n---\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "\n**Functional Programming Benefits**:\n- More concise code\n- Easier to test (pure functions)\n- Better composability\n- Natural parallelization\n- Reduced bugs from mutable state\n\n**When to Use Functional Style**:\n- ‚úÖ Data transformations (map, filter, reduce)\n- ‚úÖ Event handling\n- ‚úÖ Configuration and customization\n- ‚úÖ Collections processing\n- ‚ùå Performance-critical tight loops (sometimes)\n- ‚ùå State machines with complex mutable state\n\n**Remember**:\n- Functions are values‚Äîtreat them as such\n- Higher-order functions enable powerful abstractions\n- Lambdas make functional code concise\n- Start thinking \"what\" instead of \"how\"\n\n---\n\n**Congratulations on completing Lesson 3.1!** üéâ\n\nYou've taken your first steps into functional programming. This paradigm will make your code more elegant and expressive. Keep practicing‚Äîfunctional thinking becomes natural with use!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "4.1.1",
              "title": "Simple Lambda",
              "description": "Create a lambda that takes two integers and returns their sum. Store it in a variable and call it.",
              "instructions": "Create a lambda that takes two integers and returns their sum. Store it in a variable and call it.",
              "starterCode": "fun main() {\n    // Create a lambda that adds two numbers\n    val add = \n    \n    println(add(5, 3))  // Should print 8\n}",
              "solution": "fun main() {\n    val add = { a: Int, b: Int -> a + b }\n    \n    println(add(5, 3))  // Should print 8\n}",
              "language": "kotlin",
              "testCases": [
                {
                  "description": "Lambda should add 5 and 3",
                  "expectedOutput": "8",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Lambda syntax: { parameters -> body }"
                },
                {
                  "level": 2,
                  "text": "Specify parameter types: a: Int, b: Int"
                },
                {
                  "level": 3,
                  "text": "Return value is the last expression"
                },
                {
                  "level": 4,
                  "text": "Store lambda in a variable"
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "4.1.2",
              "title": "Higher-Order Function",
              "description": "Create a function `applyOperation` that takes two integers and a lambda operation, then returns the result of applying the operation.",
              "instructions": "Create a function `applyOperation` that takes two integers and a lambda operation, then returns the result of applying the operation.",
              "starterCode": "fun applyOperation(a: Int, b: Int, operation: (Int, Int) -> Int): Int {\n    // Apply the operation to a and b\n}\n\nfun main() {\n    val result1 = applyOperation(10, 5) { x, y -> x + y }\n    val result2 = applyOperation(10, 5) { x, y -> x * y }\n    println(\"Addition: $result1\")\n    println(\"Multiplication: $result2\")\n}",
              "solution": "fun applyOperation(a: Int, b: Int, operation: (Int, Int) -> Int): Int {\n    return operation(a, b)\n}\n\nfun main() {\n    val result1 = applyOperation(10, 5) { x, y -> x + y }\n    val result2 = applyOperation(10, 5) { x, y -> x * y }\n    println(\"Addition: $result1\")\n    println(\"Multiplication: $result2\")\n}",
              "language": "kotlin",
              "testCases": [
                {
                  "description": "Addition should work",
                  "expectedOutput": "Addition: 15",
                  "isVisible": true
                },
                {
                  "description": "Multiplication should work",
                  "expectedOutput": "Multiplication: 50",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Function parameter type: (Int, Int) -> Int"
                },
                {
                  "level": 2,
                  "text": "Call the lambda like a function: operation(a, b)"
                },
                {
                  "level": 3,
                  "text": "Lambda can be passed as the last parameter outside parentheses"
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "4.1.3",
              "title": "Filter and Map",
              "description": "Given a list of numbers, filter out even numbers, then multiply each by 2 using map.",
              "instructions": "Given a list of numbers, filter out even numbers, then multiply each by 2 using map.",
              "starterCode": "fun main() {\n    val numbers = listOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n    \n    // Filter odd numbers and multiply by 2\n    val result = \n    \n    println(result)\n}",
              "solution": "fun main() {\n    val numbers = listOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n    \n    val result = numbers\n        .filter { it % 2 != 0 }\n        .map { it * 2 }\n    \n    println(result)\n}",
              "language": "kotlin",
              "testCases": [
                {
                  "description": "Should filter odd numbers and double them",
                  "expectedOutput": "[2, 6, 10, 14, 18]",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use filter to keep only odd numbers (it % 2 != 0)"
                },
                {
                  "level": 2,
                  "text": "Use map to transform each element"
                },
                {
                  "level": 3,
                  "text": "Chain operations with ."
                },
                {
                  "level": 4,
                  "text": "Use 'it' for single parameter lambdas"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "4.10",
          "title": "Lesson 4.4: Delegation and Lazy Initialization",
          "moduleId": "module-04",
          "order": 2,
          "estimatedMinutes": 65,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 65 minutes\n**Difficulty**: Advanced\n**Prerequisites**: Parts 1-3\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Topic Introduction",
              "content": "\nIn software development, you often want to reuse behavior from other classes or defer expensive operations until they're needed. Kotlin provides powerful delegation mechanisms that make these patterns simple and type-safe.\n\nDelegation is the design pattern where an object handles a request by delegating to a helper object (delegate). Instead of inheritance, you compose objects and delegate behavior. Kotlin provides first-class language support for this pattern.\n\nIn this lesson, you'll learn:\n- Class delegation with the `by` keyword\n- Property delegation patterns\n- Lazy initialization with `lazy`\n- Observable properties\n- Custom delegates\n- Standard delegates: `notNull`, `vetoable`, `observable`\n\nBy the end, you'll write cleaner, more maintainable code using delegation!\n\n---\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "The Concept: Why Delegation Matters",
              "content": "\n### The Problem: Code Duplication\n\nWithout delegation:\n\n\n### The Solution: Class Delegation\n\n\n**Benefits**:\n- No boilerplate forwarding code\n- Composition over inheritance\n- Clear separation of concerns\n\n---\n\n",
              "code": "class Logger(printer: Printer) : Printer by printer {\n    fun log(message: String) {\n        print(\"[LOG] $message\")\n    }\n}\n\nfun main() {\n    val logger = Logger(ConsolePrinter())\n    logger.print(\"Hello\")     // Delegated to ConsolePrinter\n    logger.log(\"Important\")   // [LOG] Important\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Class Delegation",
              "content": "\nThe `by` keyword delegates interface implementation to another object.\n\n### Basic Class Delegation\n\n\n### Multiple Interface Delegation\n\n\n### Real-World Example: Window Decoration\n\n\n---\n\n",
              "code": "interface Window {\n    fun draw()\n    fun getDescription(): String\n}\n\nclass SimpleWindow : Window {\n    override fun draw() {\n        println(\"Drawing window\")\n    }\n\n    override fun getDescription(): String = \"Simple window\"\n}\n\nclass ScrollableWindow(window: Window) : Window by window {\n    override fun draw() {\n        window.draw()\n        println(\"Adding scrollbars\")\n    }\n\n    override fun getDescription(): String = \"${window.getDescription()} with scrollbars\"\n}\n\nclass BorderedWindow(window: Window) : Window by window {\n    override fun draw() {\n        window.draw()\n        println(\"Adding border\")\n    }\n\n    override fun getDescription(): String = \"${window.getDescription()} with border\"\n}\n\nfun main() {\n    val window = BorderedWindow(ScrollableWindow(SimpleWindow()))\n    window.draw()\n    println(window.getDescription())\n}\n// Output:\n// Drawing window\n// Adding scrollbars\n// Adding border\n// Simple window with scrollbars with border",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Property Delegation",
              "content": "\nProperty delegation allows you to delegate the implementation of property accessors.\n\n### Syntax\n\n\nThe delegate must provide `getValue` and `setValue` operators:\n\n\n---\n\n",
              "code": "class DelegateClass {\n    operator fun getValue(thisRef: Any?, property: KProperty<*>): String {\n        return \"Value of ${property.name}\"\n    }\n\n    operator fun setValue(thisRef: Any?, property: KProperty<*>, value: String) {\n        println(\"Setting ${property.name} to $value\")\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Lazy Initialization",
              "content": "\n`lazy` creates a property that's initialized only when first accessed.\n\n### Basic Lazy\n\n\n### Lazy Thread Safety\n\n\n### Practical Example: Database Connection\n\n\n---\n\n",
              "code": "class DatabaseConnection {\n    init {\n        println(\"Connecting to database...\")\n        Thread.sleep(1000)\n        println(\"Connected!\")\n    }\n\n    fun query(sql: String): String {\n        return \"Result for: $sql\"\n    }\n}\n\nclass Repository {\n    private val db: DatabaseConnection by lazy {\n        println(\"Lazy initialization triggered\")\n        DatabaseConnection()\n    }\n\n    fun getData(): String {\n        return db.query(\"SELECT * FROM users\")\n    }\n}\n\nfun main() {\n    println(\"Creating repository\")\n    val repo = Repository()\n\n    println(\"Repository created (DB not connected yet)\")\n\n    println(\"\\nFetching data...\")\n    println(repo.getData())\n}\n// Output:\n// Creating repository\n// Repository created (DB not connected yet)\n//\n// Fetching data...\n// Lazy initialization triggered\n// Connecting to database...\n// Connected!\n// Result for: SELECT * FROM users",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Observable Properties",
              "content": "\nObservable delegates notify you when a property changes.\n\n### Delegates.observable\n\n\n### Delegates.vetoable\n\nVeto (reject) property changes based on a condition:\n\n\n---\n\n",
              "code": "class Account {\n    var balance: Double by Delegates.vetoable(0.0) { _, oldValue, newValue ->\n        println(\"Attempting to change balance from $oldValue to $newValue\")\n\n        // Veto negative balances\n        if (newValue < 0) {\n            println(\"‚ùå Rejected: balance cannot be negative\")\n            false  // Reject change\n        } else {\n            println(\"‚úÖ Accepted\")\n            true  // Accept change\n        }\n    }\n}\n\nfun main() {\n    val account = Account()\n\n    account.balance = 100.0  // ‚úÖ Accepted\n    println(\"Balance: ${account.balance}\")\n\n    account.balance = -50.0  // ‚ùå Rejected\n    println(\"Balance: ${account.balance}\")  // Still 100.0\n\n    account.balance = 200.0  // ‚úÖ Accepted\n    println(\"Balance: ${account.balance}\")\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Delegates.notNull",
              "content": "\nFor non-null properties that can't be initialized immediately:\n\n\n---\n\n",
              "code": "import kotlin.properties.Delegates\n\nclass Configuration {\n    var apiKey: String by Delegates.notNull()\n    var apiSecret: String by Delegates.notNull()\n\n    fun initialize(key: String, secret: String) {\n        apiKey = key\n        apiSecret = secret\n    }\n}\n\nfun main() {\n    val config = Configuration()\n\n    // println(config.apiKey)  // ‚ùå Throws IllegalStateException\n\n    config.initialize(\"key123\", \"secret456\")\n\n    println(config.apiKey)     // ‚úÖ Works: key123\n    println(config.apiSecret)  // ‚úÖ Works: secret456\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Custom Delegates",
              "content": "\nCreate your own property delegates by implementing `getValue` and `setValue`.\n\n### Read-Only Delegate\n\n\n### Logged Property Delegate\n\n\n### Range-Validated Delegate\n\n\n---\n\n",
              "code": "class RangeValidator<T : Comparable<T>>(\n    private var value: T,\n    private val range: ClosedRange<T>\n) {\n    operator fun getValue(thisRef: Any?, property: KProperty<*>): T {\n        return value\n    }\n\n    operator fun setValue(thisRef: Any?, property: KProperty<*>, newValue: T) {\n        if (newValue in range) {\n            value = newValue\n        } else {\n            throw IllegalArgumentException(\n                \"${property.name} must be in $range, got $newValue\"\n            )\n        }\n    }\n}\n\nfun <T : Comparable<T>> rangeValidator(initial: T, range: ClosedRange<T>) =\n    RangeValidator(initial, range)\n\nclass Temperature {\n    var celsius: Double by rangeValidator(0.0, -273.15..1000.0)\n}\n\nfun main() {\n    val temp = Temperature()\n\n    temp.celsius = 25.0\n    println(temp.celsius)  // 25.0\n\n    temp.celsius = 100.0\n    println(temp.celsius)  // 100.0\n\n    // temp.celsius = -300.0  // ‚ùå Throws exception\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Map-Based Delegation",
              "content": "\nDelegate properties to a map:\n\n\n### Mutable Map Delegation\n\n\n### Practical Example: JSON-like Configuration\n\n\n---\n\n",
              "code": "class Config(private val properties: MutableMap<String, Any?> = mutableMapOf()) {\n    var serverUrl: String by properties\n    var port: Int by properties\n    var timeout: Long by properties\n    var enableLogging: Boolean by properties\n\n    fun toMap(): Map<String, Any?> = properties.toMap()\n}\n\nfun main() {\n    val config = Config()\n\n    config.serverUrl = \"https://api.example.com\"\n    config.port = 8080\n    config.timeout = 5000L\n    config.enableLogging = true\n\n    println(config.toMap())\n    // {serverUrl=https://api.example.com, port=8080, timeout=5000, enableLogging=true}\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Providing Delegates",
              "content": "\nCreate delegate providers that can initialize delegates with custom logic:\n\n\n---\n\n",
              "code": "import kotlin.properties.ReadWriteProperty\nimport kotlin.reflect.KProperty\n\nclass ResourceDelegate<T>(private val resource: T) : ReadWriteProperty<Any?, T> {\n    private var value: T = resource\n\n    override fun getValue(thisRef: Any?, property: KProperty<*>): T {\n        println(\"Accessing resource: ${property.name}\")\n        return value\n    }\n\n    override fun setValue(thisRef: Any?, property: KProperty<*>, value: T) {\n        println(\"Updating resource: ${property.name}\")\n        this.value = value\n    }\n}\n\nclass ResourceProvider<T>(private val resource: T) {\n    operator fun provideDelegate(thisRef: Any?, property: KProperty<*>): ResourceDelegate<T> {\n        println(\"Providing delegate for ${property.name}\")\n        return ResourceDelegate(resource)\n    }\n}\n\nclass Example {\n    var resource: String by ResourceProvider(\"Initial\")\n}\n\nfun main() {\n    val example = Example()\n    // Output: Providing delegate for resource\n\n    example.resource = \"Updated\"\n    // Output: Updating resource: resource\n\n    println(example.resource)\n    // Output: Accessing resource: resource\n    // Updated\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercises",
              "content": "\n### Exercise 1: Thread-Safe Cache (Medium)\n\nCreate a thread-safe caching delegate.\n\n**Requirements**:\n- Cache computed values\n- Thread-safe access\n- Optional expiration time\n- Lazy computation\n\n**Solution**:\n\n\n### Exercise 2: Change Tracking (Medium)\n\nCreate a delegate that tracks all changes to a property.\n\n**Requirements**:\n- Track value changes with timestamps\n- Get change history\n- Support any type\n\n**Solution**:\n\n\n### Exercise 3: Smart Configuration (Hard)\n\nCreate a configuration system with validation, defaults, and environment variables.\n\n**Requirements**:\n- Type-safe configuration properties\n- Default values\n- Environment variable override\n- Validation\n\n**Solution**:\n\n\n---\n\n",
              "code": "import kotlin.properties.ReadWriteProperty\nimport kotlin.reflect.KProperty\n\nclass ConfigProperty<T>(\n    private val default: T,\n    private val envVar: String? = null,\n    private val validator: (T) -> Boolean = { true }\n) : ReadWriteProperty<Any?, T> {\n    private var value: T? = null\n\n    override fun getValue(thisRef: Any?, property: KProperty<*>): T {\n        if (value == null) {\n            // Try environment variable\n            value = envVar?.let { getEnvValue(it, default) } ?: default\n        }\n        return value!!\n    }\n\n    override fun setValue(thisRef: Any?, property: KProperty<*>, value: T) {\n        if (!validator(value)) {\n            throw IllegalArgumentException(\"Invalid value for ${property.name}: $value\")\n        }\n        this.value = value\n    }\n\n    @Suppress(\"UNCHECKED_CAST\")\n    private fun getEnvValue(name: String, default: T): T {\n        val envValue = System.getenv(name) ?: return default\n\n        return when (default) {\n            is String -> envValue as T\n            is Int -> envValue.toIntOrNull() as? T ?: default\n            is Boolean -> envValue.toBoolean() as T\n            is Double -> envValue.toDoubleOrNull() as? T ?: default\n            else -> default\n        }\n    }\n}\n\nfun <T> config(\n    default: T,\n    envVar: String? = null,\n    validator: (T) -> Boolean = { true }\n) = ConfigProperty(default, envVar, validator)\n\nclass AppConfig {\n    var host: String by config(\n        default = \"localhost\",\n        envVar = \"APP_HOST\"\n    )\n\n    var port: Int by config(\n        default = 8080,\n        envVar = \"APP_PORT\",\n        validator = { it in 1..65535 }\n    )\n\n    var maxConnections: Int by config(\n        default = 100,\n        validator = { it > 0 }\n    )\n\n    var debugMode: Boolean by config(\n        default = false,\n        envVar = \"DEBUG\"\n    )\n\n    override fun toString(): String {\n        return \"\"\"\n            AppConfig(\n              host=$host,\n              port=$port,\n              maxConnections=$maxConnections,\n              debugMode=$debugMode\n            )\n        \"\"\".trimIndent()\n    }\n}\n\nfun main() {\n    val config = AppConfig()\n\n    println(\"Default configuration:\")\n    println(config)\n\n    // Modify configuration\n    config.host = \"0.0.0.0\"\n    config.port = 3000\n    config.maxConnections = 500\n\n    println(\"\\nModified configuration:\")\n    println(config)\n\n    // Validation\n    try {\n        config.port = 99999  // Invalid\n    } catch (e: IllegalArgumentException) {\n        println(\"\\n‚ùå Error: ${e.message}\")\n    }\n\n    try {\n        config.maxConnections = -10  // Invalid\n    } catch (e: IllegalArgumentException) {\n        println(\"‚ùå Error: ${e.message}\")\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Checkpoint Quiz",
              "content": "\n### Question 1: Class Delegation\n\nWhat does the `by` keyword do in class delegation?\n\n**A)** Creates a subclass\n**B)** Forwards interface implementation to another object\n**C)** Copies all methods from another class\n**D)** Creates a singleton\n\n**Answer**: **B** - The `by` keyword automatically forwards interface implementation to the specified delegate object.\n\n---\n\n### Question 2: Lazy Initialization\n\nWhen is a lazy property initialized?\n\n**A)** When the class is created\n**B)** At compile time\n**C)** On first access\n**D)** Never\n\n**Answer**: **C** - Lazy properties are initialized on first access, not when the class is created.\n\n---\n\n### Question 3: Observable\n\nWhat does `Delegates.observable` do?\n\n**A)** Validates property values\n**B)** Notifies when property changes\n**C)** Makes property thread-safe\n**D)** Caches property values\n\n**Answer**: **B** - `Delegates.observable` calls a lambda whenever the property value changes, allowing you to observe changes.\n\n---\n\n### Question 4: Vetoable\n\nHow does `Delegates.vetoable` work?\n\n**A)** It logs all changes\n**B)** It returns true/false to accept/reject changes\n**C)** It automatically validates types\n**D)** It prevents all changes\n\n**Answer**: **B** - `Delegates.vetoable` calls a lambda that returns true to accept or false to reject the property change.\n\n---\n\n### Question 5: Custom Delegates\n\nWhat must a custom property delegate implement?\n\n**A)** `get()` and `set()`\n**B)** `getValue()` and `setValue()` operators\n**C)** `read()` and `write()`\n**D)** `load()` and `store()`\n\n**Answer**: **B** - Custom delegates must implement `getValue()` operator (and `setValue()` for mutable properties).\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Summary",
              "content": "\nCongratulations! You've mastered delegation in Kotlin. Here's what you learned:\n\n‚úÖ **Class Delegation** - Composing objects with `by` keyword\n‚úÖ **Property Delegation** - Delegating property accessors\n‚úÖ **Lazy Initialization** - Deferring expensive computations\n‚úÖ **Observable Properties** - Tracking property changes\n‚úÖ **Standard Delegates** - `notNull`, `vetoable`, `observable`\n‚úÖ **Custom Delegates** - Creating your own delegation logic\n\n### Key Takeaways\n\n1. **Class delegation** promotes composition over inheritance\n2. **`lazy`** initializes properties only on first access\n3. **`observable`** notifies on changes, **`vetoable`** can reject changes\n4. **Custom delegates** implement `getValue`/`setValue` operators\n5. **Map delegation** is great for dynamic property storage\n\n### Next Steps\n\nIn the next lesson, we'll explore **Annotations and Reflection** - powerful metaprogramming features that let you inspect and modify code at runtime!\n\n---\n\n**Practice Challenge**: Create a preferences system that saves properties to a file automatically when they change, using custom delegates and observable patterns.\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "4.11",
          "title": "Lesson 4.5: Annotations and Reflection",
          "moduleId": "module-04",
          "order": 3,
          "estimatedMinutes": 70,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 70 minutes\n**Difficulty**: Advanced\n**Prerequisites**: Parts 1-3, Lesson 4.1 (Generics)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Topic Introduction",
              "content": "\nAnnotations and reflection are powerful metaprogramming tools that allow you to write code that examines and modifies other code at runtime. Annotations provide metadata about your code, while reflection lets you inspect and manipulate classes, functions, and properties dynamically.\n\nThese features are essential for building frameworks, libraries, serialization systems, dependency injection containers, and testing frameworks.\n\nIn this lesson, you'll learn:\n- Built-in annotations (`@JvmName`, `@JvmStatic`, `@Deprecated`, etc.)\n- Creating custom annotations\n- Annotation targets and retention\n- Reflection basics with `KClass`, `KFunction`, `KProperty`\n- Inspecting classes and members at runtime\n- Practical use cases and patterns\n\nBy the end, you'll build systems that adapt dynamically at runtime!\n\n---\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "The Concept: Metadata and Introspection",
              "content": "\n### Why Annotations?\n\nAnnotations attach metadata to code elements:\n\n\n### Why Reflection?\n\nReflection lets you inspect code structure at runtime:\n\n\n---\n\n",
              "code": "data class User(val name: String, val age: Int)\n\nfun main() {\n    val user = User(\"Alice\", 25)\n    val kClass = user::class\n\n    println(\"Class: ${kClass.simpleName}\")\n    println(\"Properties:\")\n    kClass.memberProperties.forEach { prop ->\n        println(\"  ${prop.name} = ${prop.get(user)}\")\n    }\n}\n// Output:\n// Class: User\n// Properties:\n//   age = 25\n//   name = Alice",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Built-in Annotations",
              "content": "\nKotlin provides several useful annotations.\n\n### @Deprecated\n\nMark code as deprecated with migration hints:\n\n\n**Deprecation Levels**:\n- `WARNING` - shows warning (default)\n- `ERROR` - compilation error\n- `HIDDEN` - not visible to code\n\n### @Suppress\n\nSuppress compiler warnings:\n\n\n### JVM Interoperability Annotations\n\n#### @JvmName\n\nChange the JVM name of a function:\n\n\n#### @JvmStatic\n\nGenerate static method for companion object:\n\n\n#### @JvmField\n\nExpose property as public field (no getter/setter):\n\n\n#### @JvmOverloads\n\nGenerate overloaded methods for default parameters:\n\n\n### @Throws\n\nDeclare checked exceptions (for Java interop):\n\n\n---\n\n",
              "code": "import java.io.IOException\n\n@Throws(IOException::class)\nfun readFile(path: String): String {\n    throw IOException(\"File not found\")\n}\n\n// In Java, this is a checked exception",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Creating Custom Annotations",
              "content": "\n### Basic Annotation\n\n\n### Annotations with Parameters\n\n\n### Annotation with Multiple Parameters\n\n\n---\n\n",
              "code": "annotation class Route(\n    val path: String,\n    val method: String = \"GET\",\n    val requiresAuth: Boolean = false\n)\n\n@Route(\"/users\", method = \"GET\", requiresAuth = true)\nfun getUsers() {\n    println(\"Fetching users\")\n}\n\n@Route(\"/users\", method = \"POST\")\nfun createUser() {\n    println(\"Creating user\")\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Annotation Targets",
              "content": "\nSpecify where an annotation can be used:\n\n\n**Common Targets**:\n- `CLASS` - classes, interfaces, objects\n- `FUNCTION` - functions\n- `PROPERTY` - properties\n- `FIELD` - backing fields\n- `VALUE_PARAMETER` - function parameters\n- `CONSTRUCTOR` - constructors\n- `EXPRESSION` - expressions\n- `FILE` - file\n\n### Use-Site Targets\n\nSpecify exactly which part to annotate:\n\n\n---\n\n",
              "code": "class Example(\n    @field:Required val name: String,  // Annotate the backing field\n    @get:Required val age: Int,        // Annotate the getter\n    @param:NotBlank val email: String  // Annotate constructor parameter\n)",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Annotation Retention",
              "content": "\nControl when annotations are available:\n\n\n**Retention Policies**:\n- `SOURCE` - discarded after compilation (e.g., `@Suppress`)\n- `BINARY` - stored in binary but not available via reflection\n- `RUNTIME` - available at runtime via reflection (default)\n\n---\n\n",
              "code": "@Retention(AnnotationRetention.SOURCE)\nannotation class CompileTimeOnly\n\n@Retention(AnnotationRetention.BINARY)\nannotation class InBinary\n\n@Retention(AnnotationRetention.RUNTIME)\nannotation class InRuntime",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Reflection Basics",
              "content": "\nReflection allows inspecting and manipulating code at runtime.\n\n### Getting Class References\n\n\n### KClass - Class Metadata\n\n\n### KProperty - Property Reflection\n\n\n### KFunction - Function Reflection\n\n\n---\n\n",
              "code": "import kotlin.reflect.full.*\n\nclass Calculator {\n    fun add(a: Int, b: Int): Int = a + b\n\n    fun multiply(a: Int, b: Int, c: Int = 1): Int = a * b * c\n}\n\nfun main() {\n    val calc = Calculator()\n    val kClass = Calculator::class\n\n    val addFunction = kClass.memberFunctions.find { it.name == \"add\" }!!\n\n    println(\"Function: ${addFunction.name}\")\n    println(\"Parameters: ${addFunction.parameters.map { it.name }}\")\n    println(\"Return type: ${addFunction.returnType}\")\n\n    // Call function\n    val result = addFunction.call(calc, 5, 3)\n    println(\"Result: $result\")  // 8\n\n    // Call with named parameters\n    val multiplyFunction = kClass.memberFunctions.find { it.name == \"multiply\" }!!\n    val result2 = multiplyFunction.callBy(\n        mapOf(\n            multiplyFunction.parameters[0] to calc,  // instance\n            multiplyFunction.parameters[1] to 2,      // a\n            multiplyFunction.parameters[2] to 3       // b (c uses default)\n        )\n    )\n    println(\"Multiply result: $result2\")  // 6\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Reading Annotations at Runtime",
              "content": "\n\n### Finding Annotated Members\n\n\n---\n\n",
              "code": "import kotlin.reflect.full.*\n\n@Target(AnnotationTarget.FUNCTION)\n@Retention(AnnotationRetention.RUNTIME)\nannotation class Test\n\nclass TestSuite {\n    @Test\n    fun test1() = println(\"Running test 1\")\n\n    @Test\n    fun test2() = println(\"Running test 2\")\n\n    fun helper() = println(\"Helper function\")\n}\n\nfun main() {\n    val testSuite = TestSuite()\n    val kClass = TestSuite::class\n\n    val testFunctions = kClass.memberFunctions.filter { function ->\n        function.annotations.any { it is Test }\n    }\n\n    println(\"Running ${testFunctions.size} tests:\")\n    testFunctions.forEach { function ->\n        function.call(testSuite)\n    }\n}\n// Output:\n// Running 2 tests:\n// Running test 1\n// Running test 2",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Practical Use Cases",
              "content": "\n### Use Case 1: Simple Validation Framework\n\n\n### Use Case 2: Simple Serialization\n\n\n### Use Case 3: Dependency Injection Container\n\n\n---\n\n",
              "code": "import kotlin.reflect.full.*\n\n@Target(AnnotationTarget.PROPERTY)\n@Retention(AnnotationRetention.RUNTIME)\nannotation class Inject\n\nclass Database {\n    fun query(sql: String) = \"Result for: $sql\"\n}\n\nclass UserRepository {\n    @Inject\n    lateinit var database: Database\n\n    fun findUser(id: Int): String {\n        return database.query(\"SELECT * FROM users WHERE id = $id\")\n    }\n}\n\nclass Container {\n    private val instances = mutableMapOf<kotlin.reflect.KClass<*>, Any>()\n\n    fun <T : Any> register(kClass: kotlin.reflect.KClass<T>, instance: T) {\n        instances[kClass] = instance\n    }\n\n    fun <T : Any> get(kClass: kotlin.reflect.KClass<T>): T {\n        @Suppress(\"UNCHECKED_CAST\")\n        return instances[kClass] as T\n    }\n\n    fun <T : Any> inject(obj: T) {\n        val kClass = obj::class\n\n        kClass.memberProperties.forEach { prop ->\n            if (prop.annotations.any { it is Inject }) {\n                if (prop is kotlin.reflect.KMutableProperty<*>) {\n                    val dependency = instances[prop.returnType.classifier as kotlin.reflect.KClass<*>]\n                    if (dependency != null) {\n                        prop.setter.call(obj, dependency)\n                    }\n                }\n            }\n        }\n    }\n}\n\nfun main() {\n    val container = Container()\n    container.register(Database::class, Database())\n\n    val repository = UserRepository()\n    container.inject(repository)\n\n    println(repository.findUser(1))\n    // Result for: SELECT * FROM users WHERE id = 1\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercises",
              "content": "\n### Exercise 1: Test Runner (Medium)\n\nCreate a simple test runner using annotations.\n\n**Requirements**:\n- `@Test` for test methods\n- `@BeforeEach` for setup\n- `@AfterEach` for cleanup\n- Run all tests and report results\n\n**Solution**:\n\n\n### Exercise 2: Query Builder (Hard)\n\nCreate a query builder using annotations and reflection.\n\n**Requirements**:\n- `@Table` for table name\n- `@Column` for column mapping\n- Generate SELECT, INSERT queries\n\n**Solution**:\n\n\n### Exercise 3: Object Mapper (Hard)\n\nCreate an object mapper that converts between objects and maps.\n\n**Requirements**:\n- Convert object to Map<String, Any?>\n- Convert Map<String, Any?> to object\n- Support custom field names\n- Handle nested objects\n\n**Solution**:\n\n\n---\n\n",
              "code": "import kotlin.reflect.full.*\nimport kotlin.reflect.KClass\n\n@Target(AnnotationTarget.PROPERTY)\n@Retention(AnnotationRetention.RUNTIME)\nannotation class Field(val name: String = \"\")\n\ndata class Address(\n    @Field(\"street_name\")\n    val street: String,\n\n    val city: String\n)\n\ndata class Person(\n    @Field(\"full_name\")\n    val name: String,\n\n    val age: Int,\n\n    val address: Address\n)\n\nobject ObjectMapper {\n    fun toMap(obj: Any): Map<String, Any?> {\n        val kClass = obj::class\n        val map = mutableMapOf<String, Any?>()\n\n        kClass.memberProperties.forEach { prop ->\n            val fieldName = prop.annotations.filterIsInstance<Field>().firstOrNull()?.name?.takeIf { it.isNotEmpty() }\n                ?: prop.name\n\n            val value = prop.get(obj)\n\n            map[fieldName] = when {\n                value == null -> null\n                isPrimitive(value) -> value\n                else -> toMap(value)  // Nested object\n            }\n        }\n\n        return map\n    }\n\n    fun <T : Any> fromMap(map: Map<String, Any?>, kClass: KClass<T>): T {\n        val constructor = kClass.constructors.first()\n        val args = constructor.parameters.associateWith { param ->\n            val prop = kClass.memberProperties.find { it.name == param.name }\n\n            val fieldName = prop?.annotations?.filterIsInstance<Field>()?.firstOrNull()?.name?.takeIf { it.isNotEmpty() }\n                ?: param.name\n\n            val value = map[fieldName]\n\n            when {\n                value == null -> null\n                param.type.classifier == String::class -> value.toString()\n                param.type.classifier == Int::class -> (value as? Number)?.toInt()\n                else -> {\n                    // Nested object\n                    @Suppress(\"UNCHECKED_CAST\")\n                    fromMap(value as Map<String, Any?>, param.type.classifier as KClass<Any>)\n                }\n            }\n        }\n\n        return constructor.callBy(args)\n    }\n\n    private fun isPrimitive(value: Any): Boolean {\n        return value is String || value is Number || value is Boolean\n    }\n}\n\nfun main() {\n    val person = Person(\n        name = \"Alice\",\n        age = 30,\n        address = Address(\"123 Main St\", \"Springfield\")\n    )\n\n    val map = ObjectMapper.toMap(person)\n    println(\"To Map:\")\n    println(map)\n    // {full_name=Alice, age=30, address={street_name=123 Main St, city=Springfield}}\n\n    val restored = ObjectMapper.fromMap(map, Person::class)\n    println(\"\\nFrom Map:\")\n    println(restored)\n    // Person(name=Alice, age=30, address=Address(street=123 Main St, city=Springfield))\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Checkpoint Quiz",
              "content": "\n### Question 1: Annotation Retention\n\nWhat does `@Retention(AnnotationRetention.RUNTIME)` mean?\n\n**A)** Annotation is discarded after compilation\n**B)** Annotation is available at runtime via reflection\n**C)** Annotation only works at compile time\n**D)** Annotation is stored in source code only\n\n**Answer**: **B** - `RUNTIME` retention makes annotations available at runtime for reflection.\n\n---\n\n### Question 2: KClass\n\nHow do you get a KClass reference from an instance?\n\n**A)** `instance.class`\n**B)** `instance::class`\n**C)** `instance.getClass()`\n**D)** `classOf(instance)`\n\n**Answer**: **B** - Use `instance::class` to get KClass from an instance.\n\n---\n\n### Question 3: @JvmStatic\n\nWhat does `@JvmStatic` do?\n\n**A)** Makes a property immutable\n**B)** Generates a static method for Java interop\n**C)** Prevents inheritance\n**D)** Makes a class final\n\n**Answer**: **B** - `@JvmStatic` generates a static method in the companion object for Java interoperability.\n\n---\n\n### Question 4: Reflection Performance\n\nWhat's a disadvantage of reflection?\n\n**A)** It's type-safe\n**B)** It's slower than direct access\n**C)** It can't access private members\n**D)** It only works with data classes\n\n**Answer**: **B** - Reflection is slower than direct access because it involves runtime type checking and dynamic invocation.\n\n---\n\n### Question 5: Annotation Targets\n\nWhich target allows annotating a property's backing field?\n\n**A)** `@field:`\n**B)** `@property:`\n**C)** `@get:`\n**D)** `@param:`\n\n**Answer**: **A** - Use `@field:` to annotate the backing field of a property.\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Summary",
              "content": "\nCongratulations! You've mastered annotations and reflection in Kotlin. Here's what you learned:\n\n‚úÖ **Built-in Annotations** - `@Deprecated`, `@JvmStatic`, `@JvmOverloads`, etc.\n‚úÖ **Custom Annotations** - Creating annotations with parameters\n‚úÖ **Annotation Targets** - Controlling where annotations can be used\n‚úÖ **Retention Policies** - SOURCE, BINARY, RUNTIME\n‚úÖ **Reflection** - `KClass`, `KFunction`, `KProperty`\n‚úÖ **Practical Uses** - Validation, serialization, dependency injection\n\n### Key Takeaways\n\n1. **Annotations** provide metadata for code elements\n2. **`@Retention(RUNTIME)`** needed for reflection access\n3. **`@Target`** controls where annotations apply\n4. **Reflection** enables dynamic code inspection\n5. **Use sparingly** - reflection has performance overhead\n\n### Next Steps\n\nIn the next lesson, we'll explore **DSLs and Type-Safe Builders** - creating beautiful, type-safe domain-specific languages in Kotlin!\n\n---\n\n**Practice Challenge**: Build a configuration validator that reads annotations and validates configuration objects, generating detailed error reports with field names and constraints.\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "4.12",
          "title": "Lesson 4.6: DSLs and Type-Safe Builders",
          "moduleId": "module-04",
          "order": 4,
          "estimatedMinutes": 70,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 70 minutes\n**Difficulty**: Advanced\n**Prerequisites**: Parts 1-3, Functional Programming basics\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Topic Introduction",
              "content": "\nDomain-Specific Languages (DSLs) are specialized mini-languages designed for specific problem domains. Kotlin's features‚Äîespecially lambda with receiver‚Äîmake it perfect for creating beautiful, type-safe DSLs that feel like natural language.\n\nYou've already used DSLs if you've worked with Gradle build scripts, Ktor routing, or HTML builders. These aren't magic‚Äîthey're well-designed Kotlin code that you can create yourself!\n\nIn this lesson, you'll learn:\n- What DSLs are and when to use them\n- Lambda with receiver syntax\n- Type-safe builders pattern\n- Creating HTML DSL\n- Creating configuration DSL\n- `@DslMarker` annotation for scope control\n\nBy the end, you'll build expressive APIs that feel like custom languages!\n\n---\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "The Concept: What Are DSLs?",
              "content": "\n### Internal vs External DSLs\n\n**External DSL**: A separate language with its own parser (like SQL, regex)\n\n\n**Internal DSL**: Built within the host language (Kotlin)\n\n\n### Why DSLs in Kotlin?\n\nKotlin DSLs are readable, type-safe, and have IDE support:\n\n\n---\n\n",
              "code": "// Without DSL\nval table = Table()\ntable.setWidth(\"100%\")\nval row = Row()\nval cell = Cell()\ncell.setText(\"Hello\")\nrow.addCell(cell)\ntable.addRow(row)\n\n// With DSL\ntable {\n    width = \"100%\"\n    row {\n        cell { text = \"Hello\" }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Lambda with Receiver",
              "content": "\nThe foundation of Kotlin DSLs is **lambda with receiver**.\n\n### Regular Lambda\n\n\n### Lambda with Receiver\n\n\n**Key Difference**: `StringBuilder.() -> Unit` means `this` inside the lambda is `StringBuilder`.\n\n### Visualizing the Difference\n\n\n### Standard Library Examples\n\nKotlin's standard library uses lambdas with receiver:\n\n\n---\n\n",
              "code": "// apply\nval person = Person().apply {\n    name = \"Alice\"  // this.name\n    age = 25        // this.age\n}\n\n// with\nval result = with(person) {\n    println(name)   // this.name\n    println(age)    // this.age\n}\n\n// buildString (actually uses lambda with receiver)\nval text = buildString {\n    append(\"Line 1\")\n    appendLine()\n    append(\"Line 2\")\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Type-Safe Builders",
              "content": "\nType-safe builders use lambdas with receiver to create hierarchical structures.\n\n### Simple Example: List Builder\n\n\n### Nested Builders\n\n\n---\n\n",
              "code": "class Item(val name: String)\n\nclass ItemList {\n    private val items = mutableListOf<Item>()\n\n    fun item(name: String) {\n        items.add(Item(name))\n    }\n\n    fun getItems(): List<Item> = items\n}\n\nclass ShoppingList {\n    private val lists = mutableListOf<ItemList>()\n\n    fun category(name: String, action: ItemList.() -> Unit) {\n        println(\"Category: $name\")\n        val list = ItemList()\n        list.action()\n        lists.add(list)\n    }\n\n    fun getAllItems(): List<Item> = lists.flatMap { it.getItems() }\n}\n\nfun shoppingList(action: ShoppingList.() -> Unit): ShoppingList {\n    val list = ShoppingList()\n    list.action()\n    return list\n}\n\nfun main() {\n    val list = shoppingList {\n        category(\"Fruits\") {\n            item(\"Apple\")\n            item(\"Banana\")\n            item(\"Orange\")\n        }\n\n        category(\"Vegetables\") {\n            item(\"Carrot\")\n            item(\"Broccoli\")\n        }\n    }\n\n    println(\"\\nAll items:\")\n    list.getAllItems().forEach { println(\"  - ${it.name}\") }\n}",
              "language": "kotlin"
            },
            {
              "type": "EXAMPLE",
              "title": "HTML DSL Example",
              "content": "\nLet's build a complete HTML DSL!\n\n### Basic Structure\n\n\n### Using the HTML DSL\n\n\n### Enhanced HTML with Attributes\n\n\n---\n\n",
              "code": "class EnhancedDiv : Tag(\"div\") {\n    var id: String\n        get() = \"\"\n        set(value) { attribute(\"id\", value) }\n\n    var cssClass: String\n        get() = \"\"\n        set(value) { attribute(\"class\", value) }\n\n    fun p(action: EnhancedP.() -> Unit) = initTag(EnhancedP(), action)\n}\n\nclass EnhancedP : Tag(\"p\") {\n    var style: String\n        get() = \"\"\n        set(value) { attribute(\"style\", value) }\n\n    fun text(content: String) = initTag(Text(content)) {}\n}\n\nfun enhancedHtml(action: EnhancedHTML.() -> Unit): EnhancedHTML {\n    val html = EnhancedHTML()\n    html.action()\n    return html\n}\n\nclass EnhancedHTML : Tag(\"html\") {\n    fun body(action: EnhancedBody.() -> Unit) = initTag(EnhancedBody(), action)\n}\n\nclass EnhancedBody : Tag(\"body\") {\n    fun div(action: EnhancedDiv.() -> Unit) = initTag(EnhancedDiv(), action)\n}\n\nfun main() {\n    val page = enhancedHtml {\n        body {\n            div {\n                id = \"main\"\n                cssClass = \"container\"\n\n                p {\n                    style = \"color: blue;\"\n                    text(\"Styled paragraph\")\n                }\n            }\n        }\n    }\n\n    println(page)\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Configuration DSL",
              "content": "\nCreate a type-safe configuration DSL:\n\n\n---\n\n",
              "code": "class Server {\n    var host: String = \"localhost\"\n    var port: Int = 8080\n    var ssl: Boolean = false\n}\n\nclass Database {\n    var url: String = \"\"\n    var username: String = \"\"\n    var password: String = \"\"\n    var maxConnections: Int = 10\n}\n\nclass AppConfig {\n    private var serverConfig: Server? = null\n    private var databaseConfig: Database? = null\n\n    fun server(action: Server.() -> Unit) {\n        serverConfig = Server().apply(action)\n    }\n\n    fun database(action: Database.() -> Unit) {\n        databaseConfig = Database().apply(action)\n    }\n\n    fun getServer(): Server = serverConfig ?: Server()\n    fun getDatabase(): Database = databaseConfig ?: Database()\n\n    override fun toString(): String {\n        return \"\"\"\n            Server: ${getServer().host}:${getServer().port} (SSL: ${getServer().ssl})\n            Database: ${getDatabase().url} (Max connections: ${getDatabase().maxConnections})\n        \"\"\".trimIndent()\n    }\n}\n\nfun config(action: AppConfig.() -> Unit): AppConfig {\n    return AppConfig().apply(action)\n}\n\nfun main() {\n    val appConfig = config {\n        server {\n            host = \"0.0.0.0\"\n            port = 3000\n            ssl = true\n        }\n\n        database {\n            url = \"jdbc:postgresql://localhost:5432/mydb\"\n            username = \"admin\"\n            password = \"secret\"\n            maxConnections = 20\n        }\n    }\n\n    println(appConfig)\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "@DslMarker - Scope Control",
              "content": "\n`@DslMarker` prevents implicit receiver mixing in nested DSLs.\n\n### The Problem Without @DslMarker\n\n\n### Solution with @DslMarker\n\n\n**Benefits**:\n- Prevents calling outer scope functions\n- Makes DSL structure clearer\n- Reduces errors\n\n---\n\n",
              "code": "@DslMarker\nannotation class HtmlTagMarker\n\n@HtmlTagMarker\nabstract class MarkedTag(val name: String) {\n    private val children = mutableListOf<MarkedTag>()\n\n    protected fun <T : MarkedTag> initTag(tag: T, action: T.() -> Unit): T {\n        tag.action()\n        children.add(tag)\n        return tag\n    }\n\n    fun render(): String {\n        val childrenHtml = children.joinToString(\"\") { it.render() }\n        return if (children.isEmpty()) {\n            \"<$name />\"\n        } else {\n            \"<$name>$childrenHtml</$name>\"\n        }\n    }\n}\n\n@HtmlTagMarker\nclass MarkedHTML : MarkedTag(\"html\") {\n    fun body(action: MarkedBody.() -> Unit) = initTag(MarkedBody(), action)\n}\n\n@HtmlTagMarker\nclass MarkedBody : MarkedTag(\"body\") {\n    fun div(action: MarkedDiv.() -> Unit) = initTag(MarkedDiv(), action)\n}\n\n@HtmlTagMarker\nclass MarkedDiv : MarkedTag(\"div\") {\n    fun p(action: MarkedP.() -> Unit) = initTag(MarkedP(), action)\n}\n\n@HtmlTagMarker\nclass MarkedP : MarkedTag(\"p\")\n\nfun main() {\n    val page = MarkedHTML().apply {\n        body {\n            div {\n                p { }\n                // body { }  // ‚ùå Error: can't call body from here\n            }\n        }\n    }\n\n    println(page.render())\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Advanced DSL Pattern: Builder with Validation",
              "content": "\n\n---\n\n",
              "code": "class ValidationException(message: String) : Exception(message)\n\n@DslMarker\nannotation class FormMarker\n\n@FormMarker\nclass Form {\n    private val fields = mutableListOf<Field>()\n    var submitUrl: String = \"\"\n\n    fun textField(action: TextField.() -> Unit) {\n        fields.add(TextField().apply(action))\n    }\n\n    fun emailField(action: EmailField.() -> Unit) {\n        fields.add(EmailField().apply(action))\n    }\n\n    fun numberField(action: NumberField.() -> Unit) {\n        fields.add(NumberField().apply(action))\n    }\n\n    fun validate() {\n        if (submitUrl.isBlank()) {\n            throw ValidationException(\"Submit URL is required\")\n        }\n\n        fields.forEach { it.validate() }\n    }\n\n    fun render(): String {\n        return \"\"\"\n            Form (submit to: $submitUrl)\n            Fields:\n            ${fields.joinToString(\"\\n\") { \"  - ${it.render()}\" }}\n        \"\"\".trimIndent()\n    }\n}\n\n@FormMarker\nabstract class Field {\n    var name: String = \"\"\n    var label: String = \"\"\n    var required: Boolean = false\n\n    abstract fun validate()\n    abstract fun render(): String\n\n    protected fun baseValidation() {\n        if (name.isBlank()) {\n            throw ValidationException(\"Field name is required\")\n        }\n    }\n}\n\n@FormMarker\nclass TextField : Field() {\n    var minLength: Int = 0\n    var maxLength: Int = Int.MAX_VALUE\n\n    override fun validate() {\n        baseValidation()\n        if (minLength < 0) {\n            throw ValidationException(\"$name: minLength cannot be negative\")\n        }\n        if (maxLength < minLength) {\n            throw ValidationException(\"$name: maxLength must be >= minLength\")\n        }\n    }\n\n    override fun render() = \"TextField('$name', label='$label', required=$required, length=$minLength..$maxLength)\"\n}\n\n@FormMarker\nclass EmailField : Field() {\n    override fun validate() {\n        baseValidation()\n    }\n\n    override fun render() = \"EmailField('$name', label='$label', required=$required)\"\n}\n\n@FormMarker\nclass NumberField : Field() {\n    var min: Int = Int.MIN_VALUE\n    var max: Int = Int.MAX_VALUE\n\n    override fun validate() {\n        baseValidation()\n        if (max < min) {\n            throw ValidationException(\"$name: max must be >= min\")\n        }\n    }\n\n    override fun render() = \"NumberField('$name', label='$label', required=$required, range=$min..$max)\"\n}\n\nfun form(action: Form.() -> Unit): Form {\n    val form = Form()\n    form.action()\n    form.validate()\n    return form\n}\n\nfun main() {\n    val contactForm = form {\n        submitUrl = \"/contact\"\n\n        textField {\n            name = \"fullName\"\n            label = \"Full Name\"\n            required = true\n            minLength = 3\n            maxLength = 100\n        }\n\n        emailField {\n            name = \"email\"\n            label = \"Email Address\"\n            required = true\n        }\n\n        numberField {\n            name = \"age\"\n            label = \"Age\"\n            min = 18\n            max = 120\n        }\n    }\n\n    println(contactForm.render())\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercises",
              "content": "\n### Exercise 1: JSON Builder (Medium)\n\nCreate a type-safe JSON builder DSL.\n\n**Requirements**:\n- Support objects and arrays\n- Support primitives (string, number, boolean, null)\n- Nested structures\n- Pretty-print output\n\n**Solution**:\n\n\n### Exercise 2: SQL Query Builder (Hard)\n\nCreate a type-safe SQL query builder.\n\n**Requirements**:\n- SELECT with columns\n- FROM with table\n- WHERE with conditions\n- ORDER BY\n- LIMIT\n\n**Solution**:\n\n\n### Exercise 3: Test DSL (Hard)\n\nCreate a test framework DSL similar to Kotest or Spek.\n\n**Requirements**:\n- describe/it blocks\n- Nested contexts\n- Assertions\n- Setup/teardown hooks\n\n**Solution**:\n\n\n---\n\n",
              "code": "@DslMarker\nannotation class TestMarker\n\n@TestMarker\nclass TestSuite(val name: String) {\n    private val specs = mutableListOf<Spec>()\n    private var beforeEach: (() -> Unit)? = null\n    private var afterEach: (() -> Unit)? = null\n\n    fun describe(description: String, action: Context.() -> Unit) {\n        specs.add(Context(description).apply(action))\n    }\n\n    fun beforeEach(action: () -> Unit) {\n        beforeEach = action\n    }\n\n    fun afterEach(action: () -> Unit) {\n        afterEach = action\n    }\n\n    fun run() {\n        println(\"Test Suite: $name\\n\")\n        var passed = 0\n        var failed = 0\n\n        specs.forEach { spec ->\n            val results = spec.run(beforeEach, afterEach)\n            passed += results.first\n            failed += results.second\n        }\n\n        println(\"\\n${passed} passed, $failed failed\")\n    }\n}\n\n@TestMarker\nsealed class Spec {\n    abstract fun run(beforeEach: (() -> Unit)?, afterEach: (() -> Unit)?): Pair<Int, Int>\n}\n\n@TestMarker\nclass Context(private val description: String) : Spec() {\n    private val tests = mutableListOf<Test>()\n    private val subContexts = mutableListOf<Context>()\n\n    fun it(description: String, action: () -> Unit) {\n        tests.add(Test(description, action))\n    }\n\n    fun describe(description: String, action: Context.() -> Unit) {\n        subContexts.add(Context(description).apply(action))\n    }\n\n    override fun run(beforeEach: (() -> Unit)?, afterEach: (() -> Unit)?): Pair<Int, Int> {\n        println(\"  $description\")\n        var passed = 0\n        var failed = 0\n\n        tests.forEach { test ->\n            val result = test.run(beforeEach, afterEach)\n            if (result.first == 1) passed++ else failed++\n        }\n\n        subContexts.forEach { context ->\n            val results = context.run(beforeEach, afterEach)\n            passed += results.first\n            failed += results.second\n        }\n\n        return Pair(passed, failed)\n    }\n}\n\n@TestMarker\nclass Test(private val description: String, private val action: () -> Unit) : Spec() {\n    override fun run(beforeEach: (() -> Unit)?, afterEach: (() -> Unit)?): Pair<Int, Int> {\n        return try {\n            beforeEach?.invoke()\n            action()\n            afterEach?.invoke()\n\n            println(\"    ‚úÖ $description\")\n            Pair(1, 0)\n        } catch (e: AssertionError) {\n            println(\"    ‚ùå $description: ${e.message}\")\n            Pair(0, 1)\n        }\n    }\n}\n\nfun testSuite(name: String, action: TestSuite.() -> Unit): TestSuite {\n    return TestSuite(name).apply(action)\n}\n\nfun assertEquals(expected: Any?, actual: Any?) {\n    if (expected != actual) {\n        throw AssertionError(\"Expected $expected but got $actual\")\n    }\n}\n\nfun main() {\n    val suite = testSuite(\"Calculator Tests\") {\n        beforeEach {\n            println(\"      [Setup]\")\n        }\n\n        afterEach {\n            println(\"      [Teardown]\")\n        }\n\n        describe(\"Addition\") {\n            it(\"should add positive numbers\") {\n                assertEquals(5, 2 + 3)\n            }\n\n            it(\"should add negative numbers\") {\n                assertEquals(-5, -2 + -3)\n            }\n        }\n\n        describe(\"Multiplication\") {\n            it(\"should multiply numbers\") {\n                assertEquals(6, 2 * 3)\n            }\n\n            it(\"should fail example\") {\n                assertEquals(10, 2 * 3)  // This will fail\n            }\n\n            describe(\"Edge cases\") {\n                it(\"should handle zero\") {\n                    assertEquals(0, 0 * 100)\n                }\n            }\n        }\n    }\n\n    suite.run()\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Checkpoint Quiz",
              "content": "\n### Question 1: Lambda with Receiver\n\nWhat's the difference between `(T) -> Unit` and `T.() -> Unit`?\n\n**A)** They're identical\n**B)** First takes T as parameter, second has T as receiver (this)\n**C)** Second is faster\n**D)** First is type-safe, second isn't\n\n**Answer**: **B** - `(T) -> Unit` takes T as a parameter, while `T.() -> Unit` has T as the receiver, accessible as `this`.\n\n---\n\n### Question 2: DSL Marker\n\nWhat does `@DslMarker` do?\n\n**A)** Makes DSLs faster\n**B)** Prevents implicit receiver mixing in nested scopes\n**C)** Enables reflection on DSLs\n**D)** Makes DSLs type-safe\n\n**Answer**: **B** - `@DslMarker` prevents accidentally calling outer scope functions from inner scopes in nested DSLs.\n\n---\n\n### Question 3: Type-Safe Builders\n\nWhat makes a builder \"type-safe\"?\n\n**A)** It's written in Kotlin\n**B)** Compiler checks types at compile time\n**C)** It uses strings\n**D)** It throws exceptions\n\n**Answer**: **B** - Type-safe builders leverage Kotlin's type system so the compiler catches errors at compile time.\n\n---\n\n### Question 4: When to Use DSLs\n\nWhen should you create a DSL?\n\n**A)** For every class\n**B)** When you have complex, hierarchical configurations\n**C)** Only for HTML\n**D)** Never, they're too complex\n\n**Answer**: **B** - DSLs are best for complex, hierarchical configurations where a fluent API improves readability.\n\n---\n\n### Question 5: initTag Pattern\n\nIn HTML DSL, what does `initTag` typically do?\n\n**A)** Deletes a tag\n**B)** Creates, configures, and adds a child tag\n**C)** Validates HTML\n**D)** Converts to string\n\n**Answer**: **B** - `initTag` creates a tag, runs its configuration lambda, adds it to children, and returns it.\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Summary",
              "content": "\nCongratulations! You've mastered DSLs and type-safe builders in Kotlin. Here's what you learned:\n\n‚úÖ **DSLs** - Creating domain-specific languages in Kotlin\n‚úÖ **Lambda with Receiver** - Foundation of DSL syntax\n‚úÖ **Type-Safe Builders** - Hierarchical structure creation\n‚úÖ **HTML DSL** - Practical builder pattern example\n‚úÖ **Configuration DSL** - Type-safe configuration\n‚úÖ **@DslMarker** - Scope control in nested DSLs\n\n### Key Takeaways\n\n1. **Lambda with receiver** makes `this` implicit\n2. **Type-safe builders** catch errors at compile time\n3. **@DslMarker** prevents scope confusion\n4. **DSLs improve readability** for complex configurations\n5. **Use judiciously** - don't over-engineer simple cases\n\n### Next Steps\n\nIn the next lesson, we'll bring everything together in the **Part 4 Capstone Project** - building a complete task scheduler that uses generics, coroutines, delegation, reflection, and DSLs!\n\n---\n\n**Practice Challenge**: Create a routing DSL for a web framework with GET/POST/PUT/DELETE methods, path parameters, middleware, and type-safe request handlers.\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "4.13",
          "title": "Lesson 4.7: Part 4 Capstone - Task Scheduler with Coroutines",
          "moduleId": "module-04",
          "order": 5,
          "estimatedMinutes": 30,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 4-5 hours\n**Difficulty**: Advanced\n**Prerequisites**: All Part 4 lessons\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Project Overview",
              "content": "\nCongratulations on completing all the lessons in Part 4! You've learned the most advanced features of Kotlin:\n\n- ‚úÖ Generics and type parameters\n- ‚úÖ Coroutines fundamentals\n- ‚úÖ Advanced coroutines (Flows, Channels, StateFlow)\n- ‚úÖ Delegation and lazy initialization\n- ‚úÖ Annotations and reflection\n- ‚úÖ DSLs and type-safe builders\n\nNow it's time to put it all together in a **comprehensive capstone project**: a **Task Scheduler with Coroutines**.\n\nThis project will challenge you to apply all advanced concepts in a real-world scenario where you build a sophisticated task scheduling system with async execution, monitoring, and configuration.\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "The Project: TaskFlow",
              "content": "\n**TaskFlow** is a complete task scheduling and execution system that allows:\n- Generic task definitions with type-safe results\n- Coroutine-based async execution\n- Task dependencies and workflows\n- Progress monitoring with StateFlow\n- Custom property delegates for task configuration\n- Reflection-based task discovery and execution\n- DSL for task and workflow configuration\n- Scheduled and recurring tasks\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Requirements",
              "content": "\n### 1. Generic Task System\n\n**Generic Task Interface**:\n- Type parameter for result type\n- Async execution with suspend functions\n- Task metadata (name, priority, retries)\n- Result handling (Success, Failure, Cancelled)\n\n**Task Types**:\n- `SimpleTask<T>` - single operation\n- `WorkflowTask<T>` - composite of multiple tasks\n- `ScheduledTask<T>` - runs at specific times\n- `RecurringTask<T>` - runs periodically\n\n### 2. Coroutine-Based Execution\n\n**Task Executor**:\n- Concurrent task execution\n- Dispatcher management\n- Cancellation support\n- Retry logic with exponential backoff\n- Timeout handling\n\n**Progress Monitoring**:\n- StateFlow for task status\n- SharedFlow for events\n- Real-time progress updates\n\n### 3. Custom Delegates\n\n**Task Properties**:\n- Lazy resource initialization\n- Observable task state\n- Validated configuration\n- Cached results\n\n### 4. Reflection-Based Discovery\n\n**Task Registry**:\n- Discover tasks annotated with `@Task`\n- Auto-register tasks\n- Inspect task metadata\n- Dynamic task instantiation\n\n### 5. Configuration DSL\n\n**Type-Safe Builder**:\n- Task definition DSL\n- Workflow composition\n- Scheduler configuration\n- Execution policies\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Phase 1: Core Task System (60 minutes)",
              "content": "\nLet's start by building the core task system with generics.\n\n### Task Result Types\n\n\n### Task Metadata\n\n\n### Base Task Interface\n\n\n### Simple Task Implementation\n\n\nWait, let me fix this implementation:\n\n\n---\n\n",
              "code": "abstract class SimpleTask<T>(override val metadata: TaskMetadata) : Task<T> {\n    private val _status = MutableStateFlow(TaskStatus.PENDING)\n    override val status: StateFlow<TaskStatus> = _status\n\n    private var job: Job? = null\n\n    protected abstract suspend fun run(): T\n\n    override suspend fun execute(): TaskResult<T> {\n        _status.value = TaskStatus.RUNNING\n\n        return try {\n            val result = if (metadata.timeout > 0) {\n                withTimeout(metadata.timeout) { run() }\n            } else {\n                run()\n            }\n\n            _status.value = TaskStatus.COMPLETED\n            TaskResult.Success(result)\n        } catch (e: CancellationException) {\n            _status.value = TaskStatus.CANCELLED\n            TaskResult.Cancelled\n        } catch (e: Exception) {\n            _status.value = TaskStatus.FAILED\n            TaskResult.Failure(e)\n        }\n    }\n\n    override fun cancel() {\n        job?.cancel()\n        _status.value = TaskStatus.CANCELLED\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Phase 2: Task Executor with Coroutines (60 minutes)",
              "content": "\n### Task Executor\n\n\n---\n\n",
              "code": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nclass TaskExecutor(\n    private val dispatcher: CoroutineDispatcher = Dispatchers.Default,\n    private val maxConcurrentTasks: Int = 4\n) {\n    private val scope = CoroutineScope(dispatcher + SupervisorJob())\n    private val _events = MutableSharedFlow<TaskEvent>()\n    val events: SharedFlow<TaskEvent> = _events\n\n    private val activeTasks = MutableStateFlow(0)\n\n    suspend fun <T> execute(task: Task<T>): TaskResult<T> {\n        return withContext(dispatcher) {\n            // Wait if max concurrent tasks reached\n            while (activeTasks.value >= maxConcurrentTasks) {\n                delay(100)\n            }\n\n            activeTasks.value++\n            _events.emit(TaskEvent.Started(task.metadata.name))\n\n            try {\n                val result = executeWithRetry(task)\n\n                when (result) {\n                    is TaskResult.Success -> _events.emit(TaskEvent.Completed(task.metadata.name))\n                    is TaskResult.Failure -> _events.emit(TaskEvent.Failed(task.metadata.name, result.error))\n                    is TaskResult.Cancelled -> _events.emit(TaskEvent.Cancelled(task.metadata.name))\n                }\n\n                result\n            } finally {\n                activeTasks.value--\n            }\n        }\n    }\n\n    private suspend fun <T> executeWithRetry(task: Task<T>): TaskResult<T> {\n        var lastError: Throwable? = null\n        var attempt = 0\n        val maxAttempts = task.metadata.retries + 1\n\n        while (attempt < maxAttempts) {\n            val result = task.execute()\n\n            when (result) {\n                is TaskResult.Success -> return result\n                is TaskResult.Cancelled -> return result\n                is TaskResult.Failure -> {\n                    lastError = result.error\n                    attempt++\n\n                    if (attempt < maxAttempts) {\n                        val delayMs = (100 * (1 shl attempt)).toLong()\n                        _events.emit(TaskEvent.Retrying(task.metadata.name, attempt, delayMs))\n                        delay(delayMs)\n                    }\n                }\n            }\n        }\n\n        return TaskResult.Failure(lastError ?: Exception(\"Unknown error\"))\n    }\n\n    fun shutdown() {\n        scope.cancel()\n    }\n}\n\nsealed class TaskEvent {\n    data class Started(val taskName: String) : TaskEvent()\n    data class Completed(val taskName: String) : TaskEvent()\n    data class Failed(val taskName: String, val error: Throwable) : TaskEvent()\n    data class Cancelled(val taskName: String) : TaskEvent()\n    data class Retrying(val taskName: String, val attempt: Int, val delayMs: Long) : TaskEvent()\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Phase 3: Delegation Patterns (45 minutes)",
              "content": "\n### Lazy Task Resource\n\n\n### Observable Task State\n\n\n### Validated Configuration\n\n\n---\n\n",
              "code": "class ValidatedProperty<T>(\n    private var value: T,\n    private val validator: (T) -> Boolean,\n    private val errorMessage: (T) -> String\n) {\n    operator fun getValue(thisRef: Any?, property: KProperty<*>): T {\n        return value\n    }\n\n    operator fun setValue(thisRef: Any?, property: KProperty<*>, newValue: T) {\n        if (!validator(newValue)) {\n            throw IllegalArgumentException(errorMessage(newValue))\n        }\n        value = newValue\n    }\n}\n\nfun <T> validated(\n    initialValue: T,\n    validator: (T) -> Boolean,\n    errorMessage: (T) -> String = { \"Invalid value: $it\" }\n) = ValidatedProperty(initialValue, validator, errorMessage)",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Phase 4: Annotations and Reflection (45 minutes)",
              "content": "\n### Task Annotations\n\n\n### Task Registry with Reflection\n\n\n---\n\n",
              "code": "import kotlin.reflect.KClass\nimport kotlin.reflect.full.*\n\nobject TaskRegistry {\n    private val tasks = mutableMapOf<String, KClass<out Task<*>>>()\n\n    fun register(taskClass: KClass<out Task<*>>) {\n        val annotation = taskClass.annotations.filterIsInstance<RegisteredTask>().firstOrNull()\n            ?: throw IllegalArgumentException(\"Task must be annotated with @RegisteredTask\")\n\n        tasks[annotation.name] = taskClass\n    }\n\n    fun <T> create(name: String): Task<T>? {\n        val taskClass = tasks[name] ?: return null\n\n        // Find primary constructor\n        val constructor = taskClass.constructors.firstOrNull() ?: return null\n\n        // Create metadata from annotation\n        val annotation = taskClass.annotations.filterIsInstance<RegisteredTask>().first()\n        val metadata = TaskMetadata(\n            name = annotation.name,\n            priority = annotation.priority,\n            retries = annotation.retries\n        )\n\n        // Call constructor with metadata\n        val instance = if (constructor.parameters.isEmpty()) {\n            constructor.call()\n        } else {\n            constructor.call(metadata)\n        }\n\n        @Suppress(\"UNCHECKED_CAST\")\n        return instance as? Task<T>\n    }\n\n    fun listTasks(): List<String> = tasks.keys.toList()\n\n    fun getTaskInfo(name: String): TaskMetadata? {\n        val taskClass = tasks[name] ?: return null\n        val annotation = taskClass.annotations.filterIsInstance<RegisteredTask>().first()\n\n        return TaskMetadata(\n            name = annotation.name,\n            priority = annotation.priority,\n            retries = annotation.retries\n        )\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Phase 5: DSL Configuration (60 minutes)",
              "content": "\n### Task DSL\n\n\n### Workflow DSL\n\n\n---\n\n",
              "code": "@TaskFlowDsl\nclass WorkflowBuilder<T> {\n    var name: String = \"\"\n    var description: String = \"\"\n\n    private val tasks = mutableListOf<Task<*>>()\n    private var finalTask: (suspend (List<Any?>) -> T)? = null\n\n    fun <R> task(name: String, action: suspend () -> R) {\n        val task = task<R> {\n            this.name = name\n            action(action)\n        }\n        tasks.add(task)\n    }\n\n    fun finalize(action: suspend (List<Any?>) -> T) {\n        finalTask = action\n    }\n\n    fun build(): WorkflowTask<T> {\n        val metadata = TaskMetadata(name, description)\n        return WorkflowTask(metadata, tasks, finalTask!!)\n    }\n}\n\nclass WorkflowTask<T>(\n    override val metadata: TaskMetadata,\n    private val tasks: List<Task<*>>,\n    private val finalizer: suspend (List<Any?>) -> T\n) : Task<T> {\n    private val _status = MutableStateFlow(TaskStatus.PENDING)\n    override val status: StateFlow<TaskStatus> = _status\n\n    override suspend fun execute(): TaskResult<T> {\n        _status.value = TaskStatus.RUNNING\n\n        return try {\n            val results = tasks.map { task ->\n                when (val result = task.execute()) {\n                    is TaskResult.Success -> result.value\n                    is TaskResult.Failure -> throw result.error\n                    is TaskResult.Cancelled -> throw CancellationException(\"Subtask cancelled\")\n                }\n            }\n\n            val finalResult = finalizer(results)\n            _status.value = TaskStatus.COMPLETED\n            TaskResult.Success(finalResult)\n        } catch (e: CancellationException) {\n            _status.value = TaskStatus.CANCELLED\n            TaskResult.Cancelled\n        } catch (e: Exception) {\n            _status.value = TaskStatus.FAILED\n            TaskResult.Failure(e)\n        }\n    }\n\n    override fun cancel() {\n        tasks.forEach { it.cancel() }\n        _status.value = TaskStatus.CANCELLED\n    }\n}\n\nfun <T> workflow(block: WorkflowBuilder<T>.() -> Unit): WorkflowTask<T> {\n    return WorkflowBuilder<T>().apply(block).build()\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Complete Solution: TaskFlow System",
              "content": "\nHere's the complete integrated solution:\n\n\n---\n\n",
              "code": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlin.reflect.KClass\nimport kotlin.reflect.full.*\n\n// ========== Core Types ==========\n\nsealed class TaskResult<out T> {\n    data class Success<T>(val value: T) : TaskResult<T>()\n    data class Failure(val error: Throwable) : TaskResult<Nothing>()\n    object Cancelled : TaskResult<Nothing>()\n\n    fun <R> map(transform: (T) -> R): TaskResult<R> = when (this) {\n        is Success -> Success(transform(value))\n        is Failure -> this\n        is Cancelled -> this\n    }\n\n    fun getOrNull(): T? = (this as? Success)?.value\n}\n\ndata class TaskMetadata(\n    val name: String,\n    val description: String = \"\",\n    val priority: TaskPriority = TaskPriority.NORMAL,\n    val retries: Int = 0,\n    val timeout: Long = 0\n)\n\nenum class TaskPriority { LOW, NORMAL, HIGH, CRITICAL }\nenum class TaskStatus { PENDING, RUNNING, COMPLETED, FAILED, CANCELLED }\n\n// ========== Task Interface ==========\n\ninterface Task<T> {\n    val metadata: TaskMetadata\n    val status: StateFlow<TaskStatus>\n    suspend fun execute(): TaskResult<T>\n    fun cancel()\n}\n\n// ========== Example Tasks ==========\n\n@RegisteredTask(name = \"DataFetch\", priority = TaskPriority.HIGH, retries = 3)\nclass DataFetchTask(override val metadata: TaskMetadata) : SimpleTask<String>(metadata) {\n    override suspend fun run(): String {\n        delay(1000)\n        return \"Fetched data at ${System.currentTimeMillis()}\"\n    }\n}\n\n@RegisteredTask(name = \"DataProcess\", priority = TaskPriority.NORMAL, retries = 2)\nclass DataProcessTask(override val metadata: TaskMetadata) : SimpleTask<String>(metadata) {\n    override suspend fun run(): String {\n        delay(500)\n        return \"Processed data\"\n    }\n}\n\n// ========== Main Demo ==========\n\nfun main() = runBlocking {\n    println(\"=== TaskFlow Demo ===\\n\")\n\n    // 1. Simple Task with DSL\n    println(\"1. Creating task with DSL:\")\n    val simpleTask = task<String> {\n        name = \"GreetingTask\"\n        description = \"Generates a greeting\"\n        timeout = 5000\n\n        action {\n            delay(500)\n            \"Hello from TaskFlow!\"\n        }\n    }\n\n    val result1 = simpleTask.execute()\n    println(\"Result: ${result1.getOrNull()}\\n\")\n\n    // 2. Workflow Task\n    println(\"2. Creating workflow:\")\n    val workflowTask = workflow<String> {\n        name = \"DataPipeline\"\n        description = \"Fetch and process data\"\n\n        task(\"fetch\") {\n            delay(1000)\n            \"Raw Data\"\n        }\n\n        task(\"transform\") {\n            delay(500)\n            \"Transformed\"\n        }\n\n        finalize { results ->\n            \"Pipeline completed: $results\"\n        }\n    }\n\n    val result2 = workflowTask.execute()\n    println(\"Workflow result: ${result2.getOrNull()}\\n\")\n\n    // 3. Task Executor with monitoring\n    println(\"3. Task Executor with monitoring:\")\n    val executor = TaskExecutor(maxConcurrentTasks = 2)\n\n    launch {\n        executor.events.collect { event ->\n            when (event) {\n                is TaskEvent.Started -> println(\"  ‚ñ∂ Started: ${event.taskName}\")\n                is TaskEvent.Completed -> println(\"  ‚úÖ Completed: ${event.taskName}\")\n                is TaskEvent.Failed -> println(\"  ‚ùå Failed: ${event.taskName}\")\n                is TaskEvent.Retrying -> println(\"  üîÑ Retrying: ${event.taskName} (attempt ${event.attempt})\")\n                is TaskEvent.Cancelled -> println(\"  ‚õî Cancelled: ${event.taskName}\")\n            }\n        }\n    }\n\n    val tasks = (1..5).map { i ->\n        task<Int> {\n            name = \"Task-$i\"\n            retries = 2\n            action {\n                delay((500..1500).random().toLong())\n                if (i == 3) throw Exception(\"Simulated failure\")\n                i * 10\n            }\n        }\n    }\n\n    val results = tasks.map { async { executor.execute(it) } }.awaitAll()\n\n    println(\"\\nResults:\")\n    results.forEach { result ->\n        println(\"  ${result.getOrNull() ?: \"Failed\"}\")\n    }\n\n    // 4. Task Registry with Reflection\n    println(\"\\n4. Task Registry:\")\n    TaskRegistry.register(DataFetchTask::class)\n    TaskRegistry.register(DataProcessTask::class)\n\n    println(\"Registered tasks: ${TaskRegistry.listTasks()}\")\n\n    val fetchTask = TaskRegistry.create<String>(\"DataFetch\")\n    if (fetchTask != null) {\n        val result = executor.execute(fetchTask)\n        println(\"Registry task result: ${result.getOrNull()}\")\n    }\n\n    delay(1000)\n    executor.shutdown()\n\n    println(\"\\n=== Demo Complete ===\")\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Extension Challenges",
              "content": "\nReady for more? Try these advanced challenges:\n\n### Challenge 1: Dependency Management\n\nAdd task dependencies so tasks only run after their dependencies complete:\n\n\n### Challenge 2: Task Scheduler\n\nImplement scheduled and recurring tasks:\n\n\n### Challenge 3: Persistence\n\nSave and restore task state:\n\n\n### Challenge 4: Priority Queue\n\nImplement priority-based task execution:\n\n\n### Challenge 5: Error Recovery\n\nAdd sophisticated error recovery strategies:\n\n\n---\n\n",
              "code": "sealed class RecoveryStrategy {\n    object Retry : RecoveryStrategy()\n    data class Fallback(val alternativeTask: Task<*>) : RecoveryStrategy()\n    data class Circuit(val threshold: Int, val resetTime: Duration) : RecoveryStrategy()\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Testing Your Implementation",
              "content": "\n\n---\n\n",
              "code": "import kotlinx.coroutines.test.*\nimport kotlin.test.*\n\nclass TaskFlowTests {\n    @Test\n    fun testSimpleTaskSuccess() = runTest {\n        val task = task<Int> {\n            name = \"Test\"\n            action { 42 }\n        }\n\n        val result = task.execute()\n        assertTrue(result is TaskResult.Success)\n        assertEquals(42, result.getOrNull())\n    }\n\n    @Test\n    fun testTaskRetry() = runTest {\n        var attempts = 0\n        val task = task<Int> {\n            name = \"RetryTest\"\n            retries = 2\n            action {\n                attempts++\n                if (attempts < 3) throw Exception(\"Fail\")\n                42\n            }\n        }\n\n        val executor = TaskExecutor()\n        val result = executor.execute(task)\n\n        assertEquals(3, attempts)\n        assertTrue(result is TaskResult.Success)\n    }\n\n    @Test\n    fun testWorkflow() = runTest {\n        val workflow = workflow<Int> {\n            name = \"TestWorkflow\"\n\n            task(\"step1\") { 10 }\n            task(\"step2\") { 20 }\n\n            finalize { results ->\n                (results[0] as Int) + (results[1] as Int)\n            }\n        }\n\n        val result = workflow.execute()\n        assertEquals(30, result.getOrNull())\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "What You've Built",
              "content": "\nCongratulations! You've built a production-quality task scheduling system that demonstrates:\n\n‚úÖ **Generics** - Type-safe task system with generic results\n‚úÖ **Coroutines** - Async task execution with proper concurrency\n‚úÖ **Flows** - Real-time status monitoring and events\n‚úÖ **Delegation** - Lazy resources, observable state, validated config\n‚úÖ **Reflection** - Dynamic task discovery and registration\n‚úÖ **DSLs** - Beautiful, type-safe configuration API\n‚úÖ **Error Handling** - Retry logic, timeouts, cancellation\n‚úÖ **Structured Concurrency** - Proper lifecycle management\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Summary",
              "content": "\nYou've completed Part 4: Advanced Kotlin Features! Here's everything you learned:\n\n### Lesson 4.1: Generics\n- Generic classes and functions\n- Type constraints and variance\n- Reified type parameters\n\n### Lesson 4.2: Coroutines Fundamentals\n- Suspend functions\n- launch, async, runBlocking\n- Scopes and contexts\n\n### Lesson 4.3: Advanced Coroutines\n- Structured concurrency\n- Flows and Channels\n- StateFlow and SharedFlow\n\n### Lesson 4.4: Delegation\n- Class delegation\n- Property delegation\n- Lazy initialization\n\n### Lesson 4.5: Annotations and Reflection\n- Custom annotations\n- Runtime reflection\n- Metadata inspection\n\n### Lesson 4.6: DSLs\n- Lambda with receiver\n- Type-safe builders\n- @DslMarker\n\n### Lesson 4.7: Capstone Project\n- Real-world integration\n- Production patterns\n- Advanced architectures\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Next Steps",
              "content": "\nYou're now ready for **Part 5: Backend Development with Ktor**! You'll learn to:\n- Build RESTful APIs\n- Handle HTTP requests and responses\n- Implement authentication and authorization\n- Work with databases\n- Deploy production applications\n\nKeep this capstone project as a reference‚Äîmany patterns you built here apply to backend development!\n\n---\n\n**Final Challenge**: Extend TaskFlow with a web dashboard using Ktor. Create REST endpoints to submit tasks, monitor progress, view history, and manage the scheduler. Combine everything you've learned in Parts 1-5!\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "4.2",
          "title": "Lesson 3.2: Lambda Expressions and Anonymous Functions",
          "moduleId": "module-04",
          "order": 6,
          "estimatedMinutes": 65,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 65 minutes\n**Difficulty**: Intermediate\n**Prerequisites**: Lesson 3.1 (Introduction to Functional Programming)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Topic Introduction",
              "content": "\nIn the previous lesson, you learned the basics of lambda expressions. Now it's time to master them completely!\n\nLambda expressions are everywhere in modern Kotlin code. They power collection operations, make Android development cleaner, and enable elegant APIs. Understanding lambdas deeply will make you a more effective Kotlin developer.\n\nIn this lesson, you'll learn:\n- All lambda syntax variations\n- The `it` keyword and when to use it\n- Trailing lambda syntax\n- Anonymous functions\n- Function references (::)\n- Member references\n- When to use each approach\n\nBy the end, you'll write idiomatic Kotlin code like a pro!\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Lambda Syntax Variations",
              "content": "\nKotlin offers multiple ways to write lambdas, from verbose to ultra-concise.\n\n### The Full Syntax Journey\n\nLet's trace the evolution from most explicit to most concise:\n\n\n### Syntax Breakdown\n\n\n### Multi-Line Lambdas\n\n\n**Key Rule**: The last expression in a lambda is automatically returned (no `return` keyword needed).\n\n---\n\n",
              "code": "val complexOperation = numbers.map { number ->\n    println(\"Processing: $number\")\n    val doubled = number * 2\n    val squared = doubled * doubled\n    squared  // Last expression is the return value\n}\n\nprintln(complexOperation)  // [4, 16, 36, 64, 100]",
              "language": "kotlin"
            },
            {
              "type": "KEY_POINT",
              "title": "The `it` Keyword",
              "content": "\n`it` is a shorthand for the single parameter in a lambda.\n\n### When `it` Is Available\n\n\n### `it` vs Named Parameters\n\n\n### When to Use `it`\n\n**‚úÖ Use `it` when**:\n- The operation is simple and obvious\n- The lambda is short (1-2 lines)\n- Context makes the parameter clear\n\n\n**‚ùå Avoid `it` when**:\n- The lambda is complex\n- Multiple nested lambdas\n- Parameter type isn't obvious\n\n\n### Nested Lambdas and `it`\n\n\n---\n\n",
              "code": "data class Order(val id: Int, val items: List<Item>)\ndata class Item(val name: String, val price: Double)\n\nval orders = listOf(\n    Order(1, listOf(Item(\"Book\", 15.0), Item(\"Laptop\", 1200.0))),\n    Order(2, listOf(Item(\"Phone\", 800.0), Item(\"Case\", 25.0)))\n)\n\n// ‚ùå Confusing: nested 'it'\nval expensive = orders.map {\n    it.items.filter { it.price > 100 }  // Both 'it'?!\n}\n\n// ‚úÖ Clear: name parameters\nval expensiveItems = orders.map { order ->\n    order.items.filter { item -> item.price > 100 }\n}\n\nprintln(expensiveItems)\n// [[Item(name=Laptop, price=1200.0)], [Item(name=Phone, price=800.0)]]",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Trailing Lambda Syntax",
              "content": "\nOne of Kotlin's most elegant features!\n\n### The Rule\n\n**If a lambda is the last parameter, move it outside the parentheses.**\n\n\n### Real-World Examples\n\n\n### Multiple Parameters with Trailing Lambda\n\n\n---\n\n",
              "code": "// Function with multiple parameters, lambda is last\nfun processData(\n    prefix: String,\n    suffix: String,\n    transform: (String) -> String\n): String {\n    return prefix + transform(\"data\") + suffix\n}\n\n// Usage with trailing lambda\nval result = processData(\"[\", \"]\") { it.uppercase() }\nprintln(result)  // [DATA]\n\n// Without trailing lambda (less readable)\nval result2 = processData(\"[\", \"]\", { it.uppercase() })",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Anonymous Functions",
              "content": "\nAn alternative to lambda expressions with different semantics.\n\n### Anonymous Function Syntax\n\n\n### Difference: Return Behavior\n\n**The key difference**: `return` in lambdas vs anonymous functions.\n\n\n### Labeled Returns in Lambdas\n\nAlternative to anonymous functions:\n\n\n### When to Use Anonymous Functions\n\n**Use anonymous functions when**:\n- You need explicit return statements\n- You want different return behavior\n- The function body is complex with multiple returns\n\n\n**Use lambdas when**:\n- Simple, single-expression operations\n- Following common Kotlin idioms\n- Working with collection operations\n\n---\n\n",
              "code": "val numbers = listOf(1, 2, 3, 4, 5)\n\n// Complex validation with multiple returns\nval isValid = numbers.any(fun(number: Int): Boolean {\n    if (number < 0) return false\n    if (number > 100) return false\n    if (number % 2 != 0) return false\n    return true\n})",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Function References",
              "content": "\nReferring to existing functions instead of creating new lambdas.\n\n### Function Reference Syntax\n\nUse `::` to reference a function:\n\n\n### Top-Level Function References\n\n\n### Built-In Function References\n\n\n---\n\n",
              "code": "val strings = listOf(\"  hello  \", \"  world  \", \"  kotlin  \")\n\n// Method reference\nval trimmed = strings.map(String::trim)\nprintln(trimmed)  // [hello, world, kotlin]\n\n// Property reference\nval lengths = strings.map(String::length)\nprintln(lengths)  // [9, 9, 10]",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Member References",
              "content": "\nReferences to class members (properties and methods).\n\n### Instance Method References\n\n\n### Property References\n\n\n### Constructor References\n\n\n### Extension Function References\n\n\n---\n\n",
              "code": "fun String.addExclamation(): String = \"$this!\"\n\nfun Int.isEven(): Boolean = this % 2 == 0\n\nval words = listOf(\"hello\", \"world\", \"kotlin\")\nval excited = words.map(String::addExclamation)\nprintln(excited)  // [hello!, world!, kotlin!]\n\nval numbers = listOf(1, 2, 3, 4, 5, 6)\nval evens = numbers.filter(Int::isEven)\nprintln(evens)  // [2, 4, 6]",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Choosing the Right Approach",
              "content": "\nWhen should you use each style?\n\n### Decision Matrix\n\n| Scenario | Best Choice | Example |\n|----------|-------------|---------|\n| Simple operation on single parameter | Lambda with `it` | `numbers.map { it * 2 }` |\n| Complex operation or nested lambdas | Lambda with named parameter | `orders.map { order -> order.calculate() }` |\n| Existing function matches signature | Function reference | `numbers.filter(::isEven)` |\n| Need explicit returns | Anonymous function | `fun(x) { if(x < 0) return false; return true }` |\n| Calling method on each element | Member reference | `people.map(Person::name)` |\n\n### Examples of Each\n\n\n---\n\n",
              "code": "// Lambda with 'it': simple operations\nval doubled = numbers.map { it * 2 }\nval filtered = numbers.filter { it > 10 }\n\n// Lambda with named parameter: complex or nested\nval processed = orders.map { order ->\n    order.items.filter { item -> item.price > 100 }\n}\n\n// Function reference: existing function\nfun isValid(s: String) = s.isNotEmpty() && s.length > 3\nval valid = strings.filter(::isValid)\n\n// Member reference: calling methods/properties\nval names = people.map(Person::name)\nval adults = people.filter(Person::isAdult)\n\n// Anonymous function: explicit returns\nval result = numbers.firstOrNull(fun(n): Boolean {\n    if (n < 0) return false\n    return n % 2 == 0\n})",
              "language": "kotlin"
            },
            {
              "type": "EXAMPLE",
              "title": "Practical Examples",
              "content": "\n### Example 1: Data Processing Pipeline\n\n\n### Example 2: Validation Framework\n\n\n### Example 3: Event System\n\n\n---\n\n",
              "code": "class EventBus {\n    private val handlers = mutableMapOf<String, MutableList<(Any) -> Unit>>()\n\n    fun on(event: String, handler: (Any) -> Unit) {\n        handlers.getOrPut(event) { mutableListOf() }.add(handler)\n    }\n\n    fun emit(event: String, data: Any) {\n        handlers[event]?.forEach { it(data) }\n    }\n}\n\n// Usage\nval bus = EventBus()\n\n// Lambda with named parameter\nbus.on(\"user_login\") { data ->\n    val user = data as String\n    println(\"User logged in: $user\")\n}\n\n// Lambda with 'it'\nbus.on(\"user_logout\") {\n    println(\"User logged out: $it\")\n}\n\n// Function reference\nfun handleError(error: Any) {\n    println(\"Error occurred: $error\")\n}\nbus.on(\"error\", ::handleError)\n\n// Emit events\nbus.emit(\"user_login\", \"Alice\")\nbus.emit(\"user_logout\", \"Bob\")\nbus.emit(\"error\", \"Connection failed\")",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 1: Lambda Style Converter",
              "content": "\n**Goal**: Convert between different lambda styles.\n\n**Task**: Rewrite the following code using:\n1. Function references where possible\n2. Member references where possible\n3. Simplified lambda syntax\n\n\n---\n\n",
              "code": "data class Book(val title: String, val author: String, val pages: Int, val rating: Double)\n\nfun isHighlyRated(book: Book): Boolean = book.rating >= 4.0\n\nfun main() {\n    val books = listOf(\n        Book(\"1984\", \"George Orwell\", 328, 4.5),\n        Book(\"Brave New World\", \"Aldous Huxley\", 268, 4.2),\n        Book(\"The Hobbit\", \"J.R.R. Tolkien\", 310, 4.7)\n    )\n\n    // TODO: Rewrite with better lambda styles\n    val titles = books.map({ book -> book.title })\n    val longBooks = books.filter({ book -> book.pages > 300 })\n    val highlyRated = books.filter({ book -> isHighlyRated(book) })\n    val authors = books.map({ book -> book.author })\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Solution 1: Lambda Style Converter",
              "content": "\n\n**Explanation**:\n- Property references (`Book::title`) are cleanest for simple property access\n- Function references (`::isHighlyRated`) work when calling existing functions\n- Lambda with `it` is fine for simple operations like `it.pages > 300`\n\n---\n\n",
              "code": "data class Book(val title: String, val author: String, val pages: Int, val rating: Double)\n\nfun isHighlyRated(book: Book): Boolean = book.rating >= 4.0\n\nfun main() {\n    val books = listOf(\n        Book(\"1984\", \"George Orwell\", 328, 4.5),\n        Book(\"Brave New World\", \"Aldous Huxley\", 268, 4.2),\n        Book(\"The Hobbit\", \"J.R.R. Tolkien\", 310, 4.7)\n    )\n\n    // Original: books.map({ book -> book.title })\n    // Improved: Property reference\n    val titles = books.map(Book::title)\n    println(\"Titles: $titles\")\n    // [1984, Brave New World, The Hobbit]\n\n    // Original: books.filter({ book -> book.pages > 300 })\n    // Improved: Lambda with 'it'\n    val longBooks = books.filter { it.pages > 300 }\n    println(\"Long books: ${longBooks.map { it.title }}\")\n    // [1984, The Hobbit]\n\n    // Original: books.filter({ book -> isHighlyRated(book) })\n    // Improved: Function reference\n    val highlyRated = books.filter(::isHighlyRated)\n    println(\"Highly rated: ${highlyRated.map { it.title }}\")\n    // [1984, Brave New World, The Hobbit]\n\n    // Original: books.map({ book -> book.author })\n    // Improved: Property reference\n    val authors = books.map(Book::author)\n    println(\"Authors: $authors\")\n    // [George Orwell, Aldous Huxley, J.R.R. Tolkien]\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 2: Nested Lambda Clarity",
              "content": "\n**Goal**: Improve nested lambda readability by using named parameters.\n\n**Task**: Rewrite with clear, named parameters:\n\n\n---\n\n",
              "code": "data class Order(val id: Int, val items: List<Item>)\ndata class Item(val name: String, val price: Double, val quantity: Int)\n\nfun main() {\n    val orders = listOf(\n        Order(1, listOf(\n            Item(\"Laptop\", 1200.0, 1),\n            Item(\"Mouse\", 25.0, 2)\n        )),\n        Order(2, listOf(\n            Item(\"Monitor\", 300.0, 1),\n            Item(\"Keyboard\", 75.0, 1)\n        ))\n    )\n\n    // TODO: Make this more readable\n    val result = orders.map {\n        it.items.filter { it.price > 50 }.map { it.name }\n    }\n\n    println(result)\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Solution 2: Nested Lambda Clarity",
              "content": "\n\n**Explanation**:\n- Named parameters (`order`, `item`) eliminate confusion\n- Breaking onto multiple lines improves readability\n- Extracting helper functions can simplify complex chains\n- Member references work great after extraction\n\n---\n\n",
              "code": "data class Order(val id: Int, val items: List<Item>)\ndata class Item(val name: String, val price: Double, val quantity: Int)\n\nfun main() {\n    val orders = listOf(\n        Order(1, listOf(\n            Item(\"Laptop\", 1200.0, 1),\n            Item(\"Mouse\", 25.0, 2)\n        )),\n        Order(2, listOf(\n            Item(\"Monitor\", 300.0, 1),\n            Item(\"Keyboard\", 75.0, 1)\n        ))\n    )\n\n    // Original (confusing):\n    // val result = orders.map { it.items.filter { it.price > 50 }.map { it.name } }\n\n    // Improved: Named parameters for clarity\n    val expensiveItemNames = orders.map { order ->\n        order.items\n            .filter { item -> item.price > 50 }\n            .map { item -> item.name }\n    }\n\n    println(\"Expensive items per order: $expensiveItemNames\")\n    // [[Laptop], [Monitor, Keyboard]]\n\n    // Alternative: Extract helper function\n    fun Order.getExpensiveItemNames(): List<String> {\n        return items\n            .filter { it.price > 50 }\n            .map { it.name }\n    }\n\n    val expensiveItems2 = orders.map { it.getExpensiveItemNames() }\n    println(\"Alternative result: $expensiveItems2\")\n    // [[Laptop], [Monitor, Keyboard]]\n\n    // Or with extension and member reference\n    val expensiveItems3 = orders.map(Order::getExpensiveItemNames)\n    println(\"With member reference: $expensiveItems3\")\n    // [[Laptop], [Monitor, Keyboard]]\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 3: Return Behavior",
              "content": "\n**Goal**: Understand the difference between lambda and anonymous function returns.\n\n**Task**: Fix this code so it prints all numbers except 3:\n\n\n**Goal**: Fix it using:\n1. Labeled return\n2. Anonymous function\n\n---\n\n",
              "code": "fun printNumbersSkippingThree() {\n    val numbers = listOf(1, 2, 3, 4, 5)\n\n    numbers.forEach {\n        if (it == 3) return  // Problem: this exits the entire function!\n        println(it)\n    }\n\n    println(\"Done!\")  // This never prints!\n}\n\nfun main() {\n    printNumbersSkippingThree()\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Solution 3: Return Behavior",
              "content": "\n\n**Explanation**:\n- **Labeled return** (`return@forEach`): Returns from the lambda only\n- **Anonymous function**: `return` naturally exits only that function\n- **Filter approach**: Often the most idiomatic‚Äîavoid returns altogether\n- Understanding return behavior prevents subtle bugs in functional code\n\n---\n\n",
              "code": "// Approach 1: Labeled return\nfun printNumbersSkippingThreeLabeledReturn() {\n    val numbers = listOf(1, 2, 3, 4, 5)\n\n    numbers.forEach {\n        if (it == 3) return@forEach  // Return from lambda only\n        println(it)\n    }\n\n    println(\"Done!\")  // This DOES print!\n}\n\n// Approach 2: Anonymous function\nfun printNumbersSkippingThreeAnonymousFunction() {\n    val numbers = listOf(1, 2, 3, 4, 5)\n\n    numbers.forEach(fun(number) {\n        if (number == 3) return  // Return from anonymous function only\n        println(number)\n    })\n\n    println(\"Done!\")  // This DOES print!\n}\n\n// Approach 3: Continue with different logic\nfun printNumbersSkippingThreeFilter() {\n    val numbers = listOf(1, 2, 3, 4, 5)\n\n    numbers\n        .filter { it != 3 }\n        .forEach { println(it) }\n\n    println(\"Done!\")\n}\n\nfun main() {\n    println(\"=== Labeled Return ===\")\n    printNumbersSkippingThreeLabeledReturn()\n    // Output: 1, 2, 4, 5, Done!\n\n    println(\"\\n=== Anonymous Function ===\")\n    printNumbersSkippingThreeAnonymousFunction()\n    // Output: 1, 2, 4, 5, Done!\n\n    println(\"\\n=== Filter Approach ===\")\n    printNumbersSkippingThreeFilter()\n    // Output: 1, 2, 4, 5, Done!\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Checkpoint Quiz",
              "content": "\n### Question 1\nWhat does the `it` keyword represent in a lambda expression?\n\nA) The return value of the lambda\nB) The single parameter when the lambda has exactly one parameter\nC) The iterator in a loop\nD) The lambda function itself\n\n### Question 2\nWhat is trailing lambda syntax?\n\nA) A lambda that comes at the end of a file\nB) Moving the lambda parameter outside parentheses when it's the last parameter\nC) A lambda with multiple return statements\nD) A deprecated lambda syntax\n\n### Question 3\nWhat's the key difference between lambda and anonymous function returns?\n\nA) Lambdas can't use return\nB) Anonymous functions are faster\nC) `return` in lambda exits enclosing function; in anonymous function exits only that function\nD) There is no difference\n\n### Question 4\nWhat does `String::length` represent?\n\nA) A function that returns the length of \"String\"\nB) A property reference to the length property of String\nC) A way to create strings\nD) An error‚Äîinvalid syntax\n\n### Question 5\nWhen should you use named parameters instead of `it` in lambdas?\n\nA) Always‚Äînamed parameters are always better\nB) Never‚Äî`it` is always clearer\nC) When the lambda is complex, nested, or the parameter type isn't obvious\nD) Only in anonymous functions\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Answers",
              "content": "\n**Question 1: B) The single parameter when the lambda has exactly one parameter**\n\n\n`it` is shorthand provided by Kotlin for single-parameter lambdas.\n\n---\n\n**Question 2: B) Moving the lambda parameter outside parentheses when it's the last parameter**\n\n\nThis makes code more readable and is idiomatic Kotlin.\n\n---\n\n**Question 3: C) `return` in lambda exits enclosing function; in anonymous function exits only that function**\n\n\nUnderstanding this prevents subtle bugs.\n\n---\n\n**Question 4: B) A property reference to the length property of String**\n\n\n`::` creates a reference to an existing member (property or function).\n\n---\n\n**Question 5: C) When the lambda is complex, nested, or the parameter type isn't obvious**\n\n\nChoose readability over brevity in complex scenarios.\n\n---\n\n",
              "code": "// ‚úÖ Simple: 'it' is fine\nnumbers.filter { it > 10 }\n\n// ‚ùå Complex: named parameter is clearer\nusers.filter { it.age > 18 && it.isActive && it.hasRole(\"admin\") }\n// Better:\nusers.filter { user -> user.age > 18 && user.isActive && user.hasRole(\"admin\") }\n\n// ‚ùå Nested: named parameters prevent confusion\norders.map { it.items.filter { it.price > 100 } }  // Which 'it'?\n// Better:\norders.map { order -> order.items.filter { item -> item.price > 100 } }",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "What You've Learned",
              "content": "\n‚úÖ All lambda syntax variations (verbose to concise)\n‚úÖ The `it` keyword and when to use it\n‚úÖ Trailing lambda syntax for cleaner code\n‚úÖ Anonymous functions and return behavior\n‚úÖ Function references with `::`\n‚úÖ Member references (properties and methods)\n‚úÖ Labeled returns in lambdas\n‚úÖ How to choose the right approach for each situation\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Next Steps",
              "content": "\nIn **Lesson 3.3: Collection Operations**, you'll master:\n- Essential operations: map, filter, reduce\n- Finding elements: find, first, last, any, all\n- Grouping and partitioning data\n- flatMap and flatten for nested structures\n- Sequences for efficient lazy evaluation\n\nGet ready to transform how you work with data!\n\n---\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "\n**Lambda Mastery**:\n- Use `it` for simple operations\n- Name parameters for clarity in complex cases\n- Trailing lambda syntax is idiomatic Kotlin\n- Understand return behavior to avoid bugs\n\n**References**:\n- Function references (`::functionName`) for existing functions\n- Property references (`Class::property`) for property access\n- Member references for methods and properties\n\n**Best Practices**:\n- Prioritize readability over brevity\n- Use the simplest syntax that's still clear\n- Extract complex lambdas to named functions\n- Be consistent within your codebase\n\n---\n\n**Congratulations on completing Lesson 3.2!** üéâ\n\nYou now have deep knowledge of lambda expressions and anonymous functions. This mastery will serve you well throughout your Kotlin journey‚Äîlambdas are everywhere in modern Kotlin code!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "4.2.1",
              "title": "Extension Function",
              "description": "Create an extension function on String called `isPalindrome()` that returns true if the string reads the same forwards and backwards.",
              "instructions": "Create an extension function on String called `isPalindrome()` that returns true if the string reads the same forwards and backwards.",
              "starterCode": "// Create extension function here\n\nfun main() {\n    println(\"racecar\".isPalindrome())  // Should be true\n    println(\"hello\".isPalindrome())    // Should be false\n    println(\"madam\".isPalindrome())    // Should be true\n}",
              "solution": "fun String.isPalindrome(): Boolean {\n    return this == this.reversed()\n}\n\nfun main() {\n    println(\"racecar\".isPalindrome())  // Should be true\n    println(\"hello\".isPalindrome())    // Should be false\n    println(\"madam\".isPalindrome())    // Should be true\n}",
              "language": "kotlin",
              "testCases": [
                {
                  "description": "racecar should be palindrome",
                  "expectedOutput": "true",
                  "isVisible": true
                },
                {
                  "description": "hello should not be palindrome",
                  "expectedOutput": "false",
                  "isVisible": true
                },
                {
                  "description": "madam should be palindrome",
                  "expectedOutput": "true",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Extension function syntax: fun Type.functionName()"
                },
                {
                  "level": 2,
                  "text": "Use 'this' to refer to the receiver object"
                },
                {
                  "level": 3,
                  "text": "Use reversed() method on String"
                },
                {
                  "level": 4,
                  "text": "Compare original with reversed using =="
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "4.2.2",
              "title": "Extension Function on List",
              "description": "Create an extension function on List<Int> called `secondLargest()` that returns the second largest number or null if list has fewer than 2 elements.",
              "instructions": "Create an extension function on List<Int> called `secondLargest()` that returns the second largest number or null if list has fewer than 2 elements.",
              "starterCode": "fun List<Int>.secondLargest(): Int? {\n    // Your implementation\n}\n\nfun main() {\n    println(listOf(5, 2, 8, 1, 9).secondLargest())  // Should be 8\n    println(listOf(10).secondLargest())              // Should be null\n}",
              "solution": "fun List<Int>.secondLargest(): Int? {\n    if (this.size < 2) return null\n    val sorted = this.sortedDescending()\n    return sorted[1]\n}\n\nfun main() {\n    println(listOf(5, 2, 8, 1, 9).secondLargest())  // Should be 8\n    println(listOf(10).secondLargest())              // Should be null\n}",
              "language": "kotlin",
              "testCases": [
                {
                  "description": "Should find second largest",
                  "expectedOutput": "8",
                  "isVisible": true
                },
                {
                  "description": "Should return null for small lists",
                  "expectedOutput": "null",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Check list size first"
                },
                {
                  "level": 2,
                  "text": "Use sortedDescending() to sort in descending order"
                },
                {
                  "level": 3,
                  "text": "Second largest is at index 1 after sorting"
                },
                {
                  "level": 4,
                  "text": "Return null for lists with < 2 elements"
                }
              ],
              "difficulty": "advanced"
            }
          ]
        },
        {
          "id": "4.3",
          "title": "Lesson 3.3: Collection Operations",
          "moduleId": "module-04",
          "order": 7,
          "estimatedMinutes": 70,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 70 minutes\n**Difficulty**: Intermediate\n**Prerequisites**: Lessons 3.1-3.2 (Functional programming basics, lambdas)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Topic Introduction",
              "content": "\nCollections are everywhere in programming. Lists of users, sets of products, maps of configurations‚Äîthey're fundamental to real applications. The way you work with collections defines your code quality.\n\nKotlin's collection operations transform data manipulation from verbose loops into expressive, declarative pipelines. Instead of writing \"how\" to process data step-by-step, you declare \"what\" you want.\n\nIn this lesson, you'll master:\n- Essential operations: map, filter, reduce\n- Finding elements: find, first, last, any, all, none\n- Advanced grouping: groupBy, partition, associate\n- Flattening nested structures: flatMap, flatten\n- Sequences for lazy evaluation and performance\n\nBy the end, you'll process data with elegance and efficiency!\n\n---\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "The Concept: Transforming vs Iterating",
              "content": "\n### The Traditional Way (Imperative)\n\n\n### The Functional Way (Declarative)\n\n\n**Benefits**:\n- Clearer intent (filter, then sum)\n- No mutable state (`var total`)\n- Chainable operations\n- Less error-prone\n- Easier to test and reason about\n\n---\n\n",
              "code": "val items = listOf(50.0, 120.0, 75.0, 200.0, 95.0)\nval total = items\n    .filter { it > 100 }\n    .sum()\nprintln(total)  // 320.0",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Map: Transforming Elements",
              "content": "\n`map` transforms each element using a function.\n\n### Basic Map\n\n\n### Map with Objects\n\n\n### MapIndexed: Transform with Index\n\n\n### MapNotNull: Transform and Filter Nulls\n\n\n---\n\n",
              "code": "val input = listOf(\"1\", \"2\", \"abc\", \"3\", \"xyz\")\n\nval numbers = input.mapNotNull { it.toIntOrNull() }\nprintln(numbers)  // [1, 2, 3]",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Filter: Selecting Elements",
              "content": "\n`filter` keeps only elements matching a predicate.\n\n### Basic Filter\n\n\n### Filter with Objects\n\n\n### FilterNot: Opposite of Filter\n\n\n### FilterIsInstance: Filter by Type\n\n\n---\n\n",
              "code": "val mixed: List<Any> = listOf(1, \"hello\", 2, \"world\", 3.14, true)\n\nval strings = mixed.filterIsInstance<String>()\nprintln(strings)  // [hello, world]\n\nval numbers = mixed.filterIsInstance<Int>()\nprintln(numbers)  // [1, 2]",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Reduce and Fold: Accumulating Values",
              "content": "\nReduce/fold combine all elements into a single value.\n\n### Reduce\n\n\n### Fold: Reduce with Initial Value\n\n\n### Practical Example: Complex Accumulation\n\n\n---\n\n",
              "code": "data class Transaction(val amount: Double, val type: String)\n\nval transactions = listOf(\n    Transaction(100.0, \"income\"),\n    Transaction(50.0, \"expense\"),\n    Transaction(200.0, \"income\"),\n    Transaction(30.0, \"expense\"),\n    Transaction(150.0, \"income\")\n)\n\n// Calculate net balance\nval balance = transactions.fold(0.0) { acc, transaction ->\n    when (transaction.type) {\n        \"income\" -> acc + transaction.amount\n        \"expense\" -> acc - transaction.amount\n        else -> acc\n    }\n}\nprintln(\"Balance: $$balance\")  // Balance: $370.0",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Finding Elements",
              "content": "\n### find: First Match or Null\n\n\n### findLast: Last Match or Null\n\n\n### first and last\n\n\n### any, all, none: Boolean Checks\n\n\n### Practical Example: Validation\n\n\n---\n\n",
              "code": "data class User(val name: String, val age: Int, val email: String)\n\nval users = listOf(\n    User(\"Alice\", 25, \"alice@example.com\"),\n    User(\"Bob\", 17, \"bob@example.com\"),\n    User(\"Charlie\", 30, \"charlie@example.com\")\n)\n\n// Check if any user is underage\nval hasMinors = users.any { it.age < 18 }\nprintln(\"Has minors: $hasMinors\")  // true\n\n// Check if all have valid emails\nval allValidEmails = users.all { it.email.contains(\"@\") }\nprintln(\"All valid emails: $allValidEmails\")  // true\n\n// Check if no user has empty name\nval noEmptyNames = users.none { it.name.isEmpty() }\nprintln(\"No empty names: $noEmptyNames\")  // true",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Grouping and Partitioning",
              "content": "\n### groupBy: Group into Map\n\n\n### partition: Split into Two Groups\n\n\n### associate: Create Map\n\n\n---\n\n",
              "code": "val people = listOf(\"Alice\", \"Bob\", \"Charlie\")\n\n// Create map from list\nval ages = people.associateWith { it.length }\nprintln(ages)  // {Alice=5, Bob=3, Charlie=7}\n\n// Associate with key\nval byFirstLetter = people.associateBy { it.first() }\nprintln(byFirstLetter)  // {A=Alice, B=Bob, C=Charlie}\n\n// Full control\nval custom = people.associate { name ->\n    name.uppercase() to name.length\n}\nprintln(custom)  // {ALICE=5, BOB=3, CHARLIE=7}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "FlatMap and Flatten",
              "content": "\n### flatten: Flatten Nested Collections\n\n\n### flatMap: Map Then Flatten\n\n\n### Practical Example: Hierarchical Data\n\n\n---\n\n",
              "code": "data class Department(val name: String, val employees: List<Employee>)\ndata class Employee(val name: String, val skills: List<String>)\n\nval departments = listOf(\n    Department(\"Engineering\", listOf(\n        Employee(\"Alice\", listOf(\"Kotlin\", \"Java\", \"Python\")),\n        Employee(\"Bob\", listOf(\"JavaScript\", \"TypeScript\"))\n    )),\n    Department(\"Design\", listOf(\n        Employee(\"Charlie\", listOf(\"Figma\", \"Photoshop\")),\n        Employee(\"Diana\", listOf(\"Illustrator\", \"Sketch\"))\n    ))\n)\n\n// All employees across departments\nval allEmployees = departments.flatMap { it.employees }\nprintln(\"Total employees: ${allEmployees.size}\")  // 4\n\n// All unique skills across company\nval allSkills = departments\n    .flatMap { it.employees }\n    .flatMap { it.skills }\n    .toSet()\nprintln(\"All skills: $allSkills\")\n// [Kotlin, Java, Python, JavaScript, TypeScript, Figma, Photoshop, Illustrator, Sketch]",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Sequences: Lazy Evaluation",
              "content": "\nCollections process eagerly (all at once). Sequences process lazily (on demand).\n\n### The Problem with Eager Evaluation\n\n\n### Sequences to the Rescue\n\n\n### How Sequences Work\n\n\n### When to Use Sequences\n\n**Use sequences when**:\n- ‚úÖ Large collections (1000+ elements)\n- ‚úÖ Multiple chained operations\n- ‚úÖ Only need part of result (take, first)\n- ‚úÖ Infinite data streams\n\n**Use regular collections when**:\n- ‚úÖ Small collections (< 100 elements)\n- ‚úÖ Single operation\n- ‚úÖ Need the entire result anyway\n\n### Performance Comparison\n\n\n---\n\n",
              "code": "fun measureTime(label: String, block: () -> Unit) {\n    val start = System.currentTimeMillis()\n    block()\n    val elapsed = System.currentTimeMillis() - start\n    println(\"$label: ${elapsed}ms\")\n}\n\nval largeList = (1..10_000_000).toList()\n\nmeasureTime(\"List\") {\n    val result = largeList\n        .map { it * 2 }\n        .filter { it > 1000 }\n        .take(100)\n        .sum()\n}\n\nmeasureTime(\"Sequence\") {\n    val result = largeList.asSequence()\n        .map { it * 2 }\n        .filter { it > 1000 }\n        .take(100)\n        .sum()\n}\n\n// Typical output:\n// List: 450ms\n// Sequence: 0ms (processes only ~51 elements!)",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Chaining Operations",
              "content": "\nThe real power comes from combining operations.\n\n### Example 1: E-Commerce Analysis\n\n\n### Example 2: Student Grade Analysis\n\n\n---\n\n",
              "code": "data class Student(val name: String, val grades: List<Int>, val major: String)\n\nval students = listOf(\n    Student(\"Alice\", listOf(85, 90, 92), \"CS\"),\n    Student(\"Bob\", listOf(78, 82, 80), \"Math\"),\n    Student(\"Charlie\", listOf(95, 98, 96), \"CS\"),\n    Student(\"Diana\", listOf(88, 85, 90), \"Math\"),\n    Student(\"Eve\", listOf(70, 75, 72), \"CS\")\n)\n\n// CS students with average > 85\nval topCSStudents = students\n    .filter { it.major == \"CS\" }\n    .map { student ->\n        student.name to student.grades.average()\n    }\n    .filter { (_, avg) -> avg > 85 }\n    .sortedByDescending { (_, avg) -> avg }\n\nprintln(\"Top CS students:\")\ntopCSStudents.forEach { (name, avg) ->\n    println(\"  $name: ${\"%.1f\".format(avg)}\")\n}\n// Top CS students:\n//   Charlie: 96.3\n//   Alice: 89.0\n\n// All grades flattened and analyzed\nval allGrades = students.flatMap { it.grades }\nprintln(\"Total grades: ${allGrades.size}\")  // 15\nprintln(\"Highest grade: ${allGrades.maxOrNull()}\")  // 98\nprintln(\"Average: ${\"%.1f\".format(allGrades.average())}\")  // 84.7",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 1: Sales Data Analysis",
              "content": "\n**Goal**: Analyze sales data using collection operations.\n\n**Task**: Given sales data, calculate:\n1. Total revenue\n2. Number of sales over $100\n3. Average sale amount\n4. Best-selling product\n\n\n---\n\n",
              "code": "data class Sale(val product: String, val amount: Double, val quantity: Int)\n\nfun main() {\n    val sales = listOf(\n        Sale(\"Laptop\", 1200.0, 2),\n        Sale(\"Mouse\", 25.0, 10),\n        Sale(\"Keyboard\", 75.0, 5),\n        Sale(\"Monitor\", 300.0, 3),\n        Sale(\"Laptop\", 1200.0, 1),\n        Sale(\"Mouse\", 25.0, 15)\n    )\n\n    // TODO: Implement analysis\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Solution 1: Sales Data Analysis",
              "content": "\n\n**Explanation**:\n- `sumOf` calculates total with transformation\n- `count` with predicate counts matches\n- `groupBy` + `mapValues` aggregates by key\n- `maxByOrNull` finds maximum based on criteria\n\n---\n\n",
              "code": "data class Sale(val product: String, val amount: Double, val quantity: Int)\n\nfun main() {\n    val sales = listOf(\n        Sale(\"Laptop\", 1200.0, 2),\n        Sale(\"Mouse\", 25.0, 10),\n        Sale(\"Keyboard\", 75.0, 5),\n        Sale(\"Monitor\", 300.0, 3),\n        Sale(\"Laptop\", 1200.0, 1),\n        Sale(\"Mouse\", 25.0, 15)\n    )\n\n    // 1. Total revenue\n    val totalRevenue = sales.sumOf { it.amount * it.quantity }\n    println(\"Total revenue: $${\"%.2f\".format(totalRevenue)}\")\n    // Total revenue: $5500.00\n\n    // 2. Number of sales over $100 total\n    val bigSales = sales.count { it.amount * it.quantity > 100 }\n    println(\"Sales over $100: $bigSales\")\n    // Sales over $100: 5\n\n    // 3. Average sale amount\n    val avgSale = sales.map { it.amount * it.quantity }.average()\n    println(\"Average sale: $${\"%.2f\".format(avgSale)}\")\n    // Average sale: $916.67\n\n    // 4. Best-selling product (by quantity)\n    val bestSeller = sales\n        .groupBy { it.product }\n        .mapValues { (_, sales) -> sales.sumOf { it.quantity } }\n        .maxByOrNull { it.value }\n\n    println(\"Best seller: ${bestSeller?.key} (${bestSeller?.value} units)\")\n    // Best seller: Mouse (25 units)\n\n    // Bonus: Revenue by product\n    val revenueByProduct = sales\n        .groupBy { it.product }\n        .mapValues { (_, sales) ->\n            sales.sumOf { it.amount * it.quantity }\n        }\n        .toList()\n        .sortedByDescending { it.second }\n\n    println(\"\\nRevenue by product:\")\n    revenueByProduct.forEach { (product, revenue) ->\n        println(\"  $product: $${\"%.2f\".format(revenue)}\")\n    }\n    // Laptop: $3600.00\n    // Monitor: $900.00\n    // Mouse: $625.00\n    // Keyboard: $375.00\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 2: Text Processing",
              "content": "\n**Goal**: Process log files using collection operations.\n\n**Task**: Parse log entries and:\n1. Count errors\n2. Find unique users\n3. Group by log level\n4. Get most recent error\n\n\n---\n\n",
              "code": "data class LogEntry(\n    val timestamp: Long,\n    val level: String,\n    val user: String,\n    val message: String\n)\n\nfun main() {\n    val logs = listOf(\n        LogEntry(1000, \"INFO\", \"alice\", \"User logged in\"),\n        LogEntry(2000, \"ERROR\", \"bob\", \"Connection failed\"),\n        LogEntry(3000, \"INFO\", \"alice\", \"Data saved\"),\n        LogEntry(4000, \"WARN\", \"charlie\", \"Slow query\"),\n        LogEntry(5000, \"ERROR\", \"alice\", \"Timeout\"),\n        LogEntry(6000, \"INFO\", \"bob\", \"Request completed\")\n    )\n\n    // TODO: Process logs\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Solution 2: Text Processing",
              "content": "\n\n**Explanation**:\n- `count` with predicate for conditional counting\n- `map` + `toSet` for unique values\n- `groupBy` organizes by key\n- `filter` + `maxByOrNull` finds specific maximum\n- Chaining operations creates powerful pipelines\n\n---\n\n",
              "code": "data class LogEntry(\n    val timestamp: Long,\n    val level: String,\n    val user: String,\n    val message: String\n)\n\nfun main() {\n    val logs = listOf(\n        LogEntry(1000, \"INFO\", \"alice\", \"User logged in\"),\n        LogEntry(2000, \"ERROR\", \"bob\", \"Connection failed\"),\n        LogEntry(3000, \"INFO\", \"alice\", \"Data saved\"),\n        LogEntry(4000, \"WARN\", \"charlie\", \"Slow query\"),\n        LogEntry(5000, \"ERROR\", \"alice\", \"Timeout\"),\n        LogEntry(6000, \"INFO\", \"bob\", \"Request completed\")\n    )\n\n    // 1. Count errors\n    val errorCount = logs.count { it.level == \"ERROR\" }\n    println(\"Error count: $errorCount\")  // 2\n\n    // 2. Unique users\n    val uniqueUsers = logs.map { it.user }.toSet()\n    println(\"Unique users: $uniqueUsers\")  // [alice, bob, charlie]\n\n    // 3. Group by log level\n    val byLevel = logs.groupBy { it.level }\n    println(\"\\nLogs by level:\")\n    byLevel.forEach { (level, entries) ->\n        println(\"  $level: ${entries.size}\")\n    }\n    // INFO: 3\n    // ERROR: 2\n    // WARN: 1\n\n    // 4. Most recent error\n    val recentError = logs\n        .filter { it.level == \"ERROR\" }\n        .maxByOrNull { it.timestamp }\n\n    println(\"\\nMost recent error:\")\n    println(\"  User: ${recentError?.user}\")\n    println(\"  Message: ${recentError?.message}\")\n    // User: alice\n    // Message: Timeout\n\n    // Bonus: Activity by user\n    val activityByUser = logs\n        .groupBy { it.user }\n        .mapValues { (_, entries) -> entries.size }\n        .toList()\n        .sortedByDescending { it.second }\n\n    println(\"\\nActivity by user:\")\n    activityByUser.forEach { (user, count) ->\n        println(\"  $user: $count actions\")\n    }\n    // alice: 3 actions\n    // bob: 2 actions\n    // charlie: 1 actions\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 3: Sequence Performance",
              "content": "\n**Goal**: Compare list vs sequence performance.\n\n**Task**: Process large dataset and measure time difference.\n\n\n---\n\n",
              "code": "fun main() {\n    val largeList = (1..1_000_000).toList()\n\n    // TODO: Compare list vs sequence for:\n    // - Map to double\n    // - Filter > 1000\n    // - Take first 100\n    // - Sum\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Solution 3: Sequence Performance",
              "content": "\n\n**Explanation**:\n- Lists create intermediate collections at each step\n- Sequences process elements one at a time\n- With `take(100)`, sequence stops after 100 matches\n- Sequences excel when you don't need all results\n- The performance difference grows with data size\n\n---\n\n",
              "code": "fun measureTime(label: String, block: () -> Any): Any {\n    val start = System.currentTimeMillis()\n    val result = block()\n    val elapsed = System.currentTimeMillis() - start\n    println(\"$label: ${elapsed}ms\")\n    return result\n}\n\nfun main() {\n    val largeList = (1..1_000_000).toList()\n\n    // Using List (eager evaluation)\n    val listResult = measureTime(\"List processing\") {\n        largeList\n            .map { it * 2 }        // Processes all 1M\n            .filter { it > 1000 }  // Processes all results\n            .take(100)             // Finally takes 100\n            .sum()\n    }\n    println(\"Result: $listResult\\n\")\n\n    // Using Sequence (lazy evaluation)\n    val sequenceResult = measureTime(\"Sequence processing\") {\n        largeList.asSequence()\n            .map { it * 2 }        // Lazy\n            .filter { it > 1000 }  // Lazy\n            .take(100)             // Lazy\n            .sum()                 // Triggers evaluation\n    }\n    println(\"Result: $sequenceResult\\n\")\n\n    // Demonstrate step-by-step processing\n    println(\"=== Sequence Element-by-Element ===\")\n    (1..5).asSequence()\n        .map {\n            println(\"  Map: $it -> ${it * 2}\")\n            it * 2\n        }\n        .filter {\n            println(\"  Filter: $it > 4? ${it > 4}\")\n            it > 4\n        }\n        .take(2)\n        .forEach { println(\"  Result: $it\") }\n\n    // Typical output:\n    // List processing: 180ms\n    // Result: 130100\n    //\n    // Sequence processing: 0ms\n    // Result: 130100\n    //\n    // === Sequence Element-by-Element ===\n    //   Map: 1 -> 2\n    //   Filter: 2 > 4? false\n    //   Map: 2 -> 4\n    //   Filter: 4 > 4? false\n    //   Map: 3 -> 6\n    //   Filter: 6 > 4? true\n    //   Result: 6\n    //   Map: 4 -> 8\n    //   Filter: 8 > 4? true\n    //   Result: 8\n\n    // Explanation\n    println(\"\\n=== Why Sequence is Faster ===\")\n    println(\"List: Processes all 1M elements through each operation\")\n    println(\"Sequence: Processes elements one-by-one, stops after finding 100\")\n    println(\"For this example, sequence processes ~501 elements vs 1M\")\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Checkpoint Quiz",
              "content": "\n### Question 1\nWhat's the difference between `map` and `flatMap`?\n\nA) They do the same thing\nB) `map` transforms each element; `flatMap` transforms and flattens nested structures\nC) `flatMap` is faster than `map`\nD) `map` only works with numbers\n\n### Question 2\nWhat does `filter` return?\n\nA) A single element\nB) A Boolean\nC) A new collection with only elements matching the predicate\nD) The count of matching elements\n\n### Question 3\nWhat's the difference between `reduce` and `fold`?\n\nA) No difference\nB) `fold` requires an initial value; `reduce` uses the first element as initial value\nC) `reduce` is deprecated\nD) `fold` only works with numbers\n\n### Question 4\nWhen should you use sequences instead of regular collections?\n\nA) Always\nB) Never\nC) For large collections with multiple operations, especially when you don't need all results\nD) Only for strings\n\n### Question 5\nWhat does `partition` do?\n\nA) Splits a collection into N equal parts\nB) Splits a collection into two groups based on a predicate\nC) Removes duplicate elements\nD) Sorts the collection\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Answers",
              "content": "\n**Question 1: B) `map` transforms each element; `flatMap` transforms and flattens nested structures**\n\n\n`flatMap` = `map` + `flatten`\n\n---\n\n**Question 2: C) A new collection with only elements matching the predicate**\n\n\n`filter` returns a new list; the original is unchanged (immutability).\n\n---\n\n**Question 3: B) `fold` requires an initial value; `reduce` uses the first element as initial value**\n\n\n`fold` is safer and more flexible.\n\n---\n\n**Question 4: C) For large collections with multiple operations, especially when you don't need all results**\n\n\nSequences have overhead; only beneficial for specific scenarios.\n\n---\n\n**Question 5: B) Splits a collection into two groups based on a predicate**\n\n\nReturns a `Pair` of lists: (matching, not-matching).\n\n---\n\n",
              "code": "val numbers = listOf(1, 2, 3, 4, 5, 6)\n\nval (evens, odds) = numbers.partition { it % 2 == 0 }\nprintln(evens)  // [2, 4, 6]\nprintln(odds)   // [1, 3, 5]",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "What You've Learned",
              "content": "\n‚úÖ Essential operations: map, filter, reduce, fold\n‚úÖ Finding elements: find, first, last, any, all, none\n‚úÖ Grouping and partitioning: groupBy, partition, associate\n‚úÖ Flattening nested structures: flatMap, flatten\n‚úÖ Sequences for lazy evaluation and performance\n‚úÖ Chaining operations into powerful pipelines\n‚úÖ When to use each operation\n‚úÖ Performance considerations\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Next Steps",
              "content": "\nIn **Lesson 3.4: Scope Functions**, you'll master:\n- let, run, with, apply, also\n- When to use each scope function\n- `this` vs `it` context\n- Return value differences\n- Chaining scope functions\n\nGet ready for Kotlin's most elegant features!\n\n---\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "\n**Collection Operations Transform Code**:\n- Replace loops with declarative operations\n- Chain operations for readability\n- Immutable transformations prevent bugs\n\n**Choose the Right Tool**:\n- `map`: Transform each element\n- `filter`: Select elements\n- `reduce/fold`: Combine into single value\n- `flatMap`: Transform and flatten\n- `groupBy`: Organize by key\n\n**Performance Matters**:\n- Regular collections: Small data, simple operations\n- Sequences: Large data, multiple operations, partial results\n- Measure when performance is critical\n\n---\n\n**Congratulations on completing Lesson 3.3!** üéâ\n\nYou now wield the power of functional collection operations. This knowledge will make your data processing code elegant and efficient. Practice chaining operations‚Äîit becomes second nature quickly!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "4.3.1",
              "title": "Partition a List",
              "description": "Use the partition function to split a list of numbers into even and odd numbers.",
              "instructions": "Use the partition function to split a list of numbers into even and odd numbers.",
              "starterCode": "fun main() {\n    val numbers = listOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n    \n    // Use partition to split into even and odd\n    val (even, odd) = \n    \n    println(\"Even: $even\")\n    println(\"Odd: $odd\")\n}",
              "solution": "fun main() {\n    val numbers = listOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n    \n    val (even, odd) = numbers.partition { it % 2 == 0 }\n    \n    println(\"Even: $even\")\n    println(\"Odd: $odd\")\n}",
              "language": "kotlin",
              "testCases": [
                {
                  "description": "Even numbers should be extracted",
                  "expectedOutput": "Even: [2, 4, 6, 8, 10]",
                  "isVisible": true
                },
                {
                  "description": "Odd numbers should be extracted",
                  "expectedOutput": "Odd: [1, 3, 5, 7, 9]",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "partition returns a Pair of two lists"
                },
                {
                  "level": 2,
                  "text": "Use destructuring: val (first, second) = pair"
                },
                {
                  "level": 3,
                  "text": "Predicate for even: it % 2 == 0"
                },
                {
                  "level": 4,
                  "text": "True values go to first list, false to second"
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "4.3.2",
              "title": "Sequence for Large Data",
              "description": "Create a sequence that generates the first 10 squares of numbers, but only compute when needed.",
              "instructions": "Create a sequence that generates the first 10 squares of numbers, but only compute when needed.",
              "starterCode": "fun main() {\n    // Create a sequence of squares\n    val squares = \n    \n    // Take first 5\n    println(squares.take(5).toList())\n}",
              "solution": "fun main() {\n    val squares = generateSequence(1) { it + 1 }\n        .map { it * it }\n    \n    println(squares.take(5).toList())\n}",
              "language": "kotlin",
              "testCases": [
                {
                  "description": "Should generate first 5 squares",
                  "expectedOutput": "[1, 4, 9, 16, 25]",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use generateSequence to create infinite sequence"
                },
                {
                  "level": 2,
                  "text": "First parameter is the initial value"
                },
                {
                  "level": 3,
                  "text": "Second parameter is lambda that generates next value"
                },
                {
                  "level": 4,
                  "text": "Use map to compute squares"
                },
                {
                  "level": 5,
                  "text": "Use take() to limit results"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "4.4",
          "title": "Lesson 3.4: Scope Functions",
          "moduleId": "module-04",
          "order": 8,
          "estimatedMinutes": 65,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 65 minutes\n**Difficulty**: Intermediate\n**Prerequisites**: Lessons 3.1-3.3 (Functional programming, lambdas, collections)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Topic Introduction",
              "content": "\nScope functions are one of Kotlin's most distinctive features. They're small but incredibly powerful‚Äîenabling you to write cleaner, more expressive code.\n\nAt first glance, `let`, `run`, `with`, `apply`, and `also` might seem similar. But each has a specific purpose, and mastering them will make your code more idiomatic and elegant.\n\nIn this lesson, you'll learn:\n- What scope functions are and why they exist\n- The five scope functions: let, run, with, apply, also\n- When to use each one\n- The difference between `this` and `it` context\n- Return value differences\n- Chaining scope functions\n- Real-world use cases\n\nBy the end, you'll write fluent, readable Kotlin code!\n\n---\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "The Concept: What Are Scope Functions?",
              "content": "\nScope functions execute a block of code within the context of an object. They temporarily change the scope to work on that object.\n\n### The Problem They Solve\n\n**Without scope functions**:\n\n\n**With scope functions**:\n\n\nEven better:\n\n\n**Benefits**:\n- Less repetition (no `person.` everywhere)\n- Clearer intent\n- Chainable operations\n- Scoped changes (visible what's being modified)\n\n---\n\n",
              "code": "Person(\"Alice\", 25)\n    .apply {\n        name = name.uppercase()\n        age += 1\n    }\n    .also { println(it) }\n    .name\n    .length",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "The Five Scope Functions: Overview",
              "content": "\n| Function | Context | Return | Common Use |\n|----------|---------|--------|------------|\n| `let` | `it` | Lambda result | Null safety, transformations |\n| `run` | `this` | Lambda result | Object configuration & compute result |\n| `with` | `this` | Lambda result | Multiple operations on object |\n| `apply` | `this` | Object itself | Object configuration |\n| `also` | `it` | Object itself | Side effects (logging, validation) |\n\n### Key Differences\n\n**Context**: How you refer to the object\n- `this`: Receiver (implicit, can omit)\n- `it`: Parameter (explicit, must use `it`)\n\n**Return value**:\n- Lambda result: Returns what the block returns\n- Object itself: Returns the original object (chainable)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "let: Transform or Process",
              "content": "\n`let` takes the object as `it` and returns the lambda result.\n\n### Basic Usage\n\n\n### Primary Use Case: Null Safety\n\n\n### Transforming Nullable Values\n\n\n### Chaining Transformations\n\n\n### Real-World Example: API Response Processing\n\n\n---\n\n",
              "code": "data class ApiResponse(val data: String?, val error: String?)\n\nfun processResponse(response: ApiResponse): String {\n    return response.data?.let { data ->\n        // Process successful response\n        data.uppercase()\n    } ?: response.error?.let { error ->\n        // Handle error\n        \"Error: $error\"\n    } ?: \"Unknown error\"\n}\n\nval success = ApiResponse(\"hello\", null)\nprintln(processResponse(success))  // HELLO\n\nval failure = ApiResponse(null, \"Not found\")\nprintln(processResponse(failure))  // Error: Not found",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "run: Execute and Return Result",
              "content": "\n`run` uses `this` as context and returns the lambda result.\n\n### Basic Usage\n\n\n### Object Configuration + Computation\n\n\n### Multiple Operations, Single Result\n\n\n### Real-World Example: Complex Calculation\n\n\n---\n\n",
              "code": "data class Order(\n    val items: List<Item>,\n    val discount: Double,\n    val taxRate: Double\n)\n\ndata class Item(val price: Double, val quantity: Int)\n\nfun Order.calculateTotal() = run {\n    val subtotal = items.sumOf { it.price * it.quantity }\n    val afterDiscount = subtotal * (1 - discount)\n    val withTax = afterDiscount * (1 + taxRate)\n    withTax\n}\n\nval order = Order(\n    items = listOf(\n        Item(10.0, 2),\n        Item(5.0, 3)\n    ),\n    discount = 0.1,\n    taxRate = 0.08\n)\n\nprintln(\"Total: ${\"%.2f\".format(order.calculateTotal())}\")\n// Total: 30.02",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "with: Non-Extension Version",
              "content": "\n`with` is not an extension function; you pass the object as parameter. Uses `this` context.\n\n### Basic Usage\n\n\n### Multiple Operations on Object\n\n\n### When to Use with vs run\n\n\n### Real-World Example: Configuration\n\n\n---\n\n",
              "code": "data class DatabaseConfig(\n    var host: String = \"\",\n    var port: Int = 0,\n    var username: String = \"\",\n    var password: String = \"\",\n    var database: String = \"\"\n) {\n    fun validate() = host.isNotEmpty() && username.isNotEmpty()\n}\n\nval config = DatabaseConfig()\n\nval isValid = with(config) {\n    host = \"localhost\"\n    port = 5432\n    username = \"admin\"\n    password = \"secret\"\n    database = \"myapp\"\n    validate()\n}\n\nprintln(\"Config valid: $isValid\")  // true",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "apply: Configure and Return Object",
              "content": "\n`apply` uses `this` context and returns the object itself (great for chaining!).\n\n### Basic Usage\n\n\n### Object Initialization\n\n\n### Builder Pattern\n\n\n### Real-World Example: Android View Configuration\n\n\n---\n\n",
              "code": "// Simulated Android view\nclass TextView {\n    var text: String = \"\"\n    var textSize: Float = 14f\n    var textColor: String = \"black\"\n\n    override fun toString() = \"TextView(text=$text, size=$textSize, color=$textColor)\"\n}\n\nfun createTitleView() = TextView().apply {\n    text = \"Welcome!\"\n    textSize = 24f\n    textColor = \"blue\"\n}\n\nval view = createTitleView()\nprintln(view)\n// TextView(text=Welcome!, size=24.0, color=blue)",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "also: Side Effects, Return Object",
              "content": "\n`also` uses `it` context and returns the object itself.\n\n### Basic Usage\n\n\n### Debugging and Logging\n\n\n### Validation with Side Effects\n\n\n### Real-World Example: File Operations\n\n\n---\n\n",
              "code": "import java.io.File\n\nfun processFile(path: String): List<String> {\n    return File(path)\n        .also { println(\"Reading file: ${it.absolutePath}\") }\n        .also { require(it.exists()) { \"File not found\" } }\n        .readLines()\n        .also { println(\"Read ${it.size} lines\") }\n        .filter { it.isNotEmpty() }\n        .also { println(\"After filtering: ${it.size} non-empty lines\") }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "this vs it: Context Objects",
              "content": "\n### Comparison\n\n**`this` (receiver)**:\n- Used by: `run`, `with`, `apply`\n- Can be omitted (implicit)\n- Feels like you \"are\" the object\n\n**`it` (parameter)**:\n- Used by: `let`, `also`\n- Must be explicit\n- Clearer distinction between outer and inner scope\n\n### Examples\n\n\n### When to Use Which\n\n\n---\n\n",
              "code": "// Use 'this' when configuring object\nval user = User().apply {\n    name = \"Alice\"  // Clean, no 'this.' needed\n    email = \"alice@example.com\"\n    age = 25\n}\n\n// Use 'it' when object needs clear reference\nval processed = user.let {\n    saveToDatabase(it)  // Clear what's being passed\n    sendEmail(it)\n    it\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Return Values: Lambda Result vs Object",
              "content": "\n### Lambda Result Functions: let, run, with\n\n\n### Object Functions: apply, also\n\n\n### Why It Matters for Chaining\n\n\n---\n\n",
              "code": "// apply and also return object - chainable!\nval person = Person(\"Alice\", 25)\n    .apply { age += 1 }\n    .also { println(\"Created: $it\") }\n    .apply { name = name.uppercase() }\n\n// let, run, with return result - chains break\nval result = Person(\"Alice\", 25)\n    .run { age + 1 }  // Returns Int, can't call Person methods anymore\n    // .apply { ... }  // ERROR: Int doesn't have apply with Person context",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Chaining Scope Functions",
              "content": "\nCombining scope functions creates fluent APIs.\n\n### Example 1: Data Processing Pipeline\n\n\n### Example 2: Building Complex Objects\n\n\n### Example 3: Conditional Processing\n\n\n---\n\n",
              "code": "fun processOrder(orderId: Int): String {\n    return fetchOrder(orderId)\n        ?.let { order ->\n            // Transform order\n            order.apply {\n                items = items.filter { it.inStock }\n            }\n        }\n        ?.takeIf { it.items.isNotEmpty() }\n        ?.also { validateOrder(it) }\n        ?.run { \"Order ${this.id} processed successfully\" }\n        ?: \"Order not found or invalid\"\n}\n\ndata class Order(val id: Int, var items: List<Item>)\ndata class Item(val name: String, val inStock: Boolean)\n\nfun fetchOrder(id: Int): Order? = Order(id, listOf(\n    Item(\"Book\", true),\n    Item(\"Pen\", false),\n    Item(\"Notebook\", true)\n))\n\nfun validateOrder(order: Order) {\n    println(\"Validating order ${order.id}\")\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Decision Matrix: Which Scope Function to Use?",
              "content": "\n### Flowchart\n\n\n### Quick Reference\n\n| Want to... | Use | Example |\n|------------|-----|---------|\n| Transform nullable value | `let` | `name?.let { it.uppercase() }` |\n| Configure object | `apply` | `Person().apply { name = \"Alice\" }` |\n| Log/debug without breaking chain | `also` | `.also { println(it) }` |\n| Group operations, compute result | `run` / `with` | `person.run { age + 1 }` |\n| Multiple calls on existing object | `with` | `with(config) { ... }` |\n\n---\n\n",
              "code": "Need to transform/compute result?\n‚îú‚îÄ Yes ‚Üí Returns lambda result\n‚îÇ  ‚îú‚îÄ Have object already? ‚Üí with\n‚îÇ  ‚îú‚îÄ Need null safety? ‚Üí let\n‚îÇ  ‚îî‚îÄ Creating/chaining? ‚Üí run\n‚îÇ\n‚îî‚îÄ No ‚Üí Returns object (chainable)\n   ‚îú‚îÄ Need configuration? ‚Üí apply (this)\n   ‚îî‚îÄ Need side effect? ‚Üí also (it)",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 1: Refactor with Scope Functions",
              "content": "\n**Goal**: Refactor imperative code using scope functions.\n\n**Task**: Rewrite this code using appropriate scope functions:\n\n\n---\n\n",
              "code": "data class Email(\n    var to: String = \"\",\n    var subject: String = \"\",\n    var body: String = \"\",\n    var sent: Boolean = false\n)\n\nfun sendEmail() {\n    val email = Email()\n    email.to = \"user@example.com\"\n    email.subject = \"Welcome\"\n    email.body = \"Welcome to our service!\"\n\n    println(\"Sending email to: ${email.to}\")\n\n    if (email.to.isNotEmpty() && email.subject.isNotEmpty()) {\n        email.sent = true\n        println(\"Email sent successfully\")\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Solution 1: Refactor with Scope Functions",
              "content": "\n\n**Explanation**:\n- `apply`: Configure the email object\n- `also`: Log without breaking the chain\n- `takeIf`: Conditional processing\n- Chainable, readable, and expressive!\n\n---\n\n",
              "code": "data class Email(\n    var to: String = \"\",\n    var subject: String = \"\",\n    var body: String = \"\",\n    var sent: Boolean = false\n)\n\nfun sendEmailRefactored() {\n    Email()\n        .apply {\n            // Configure email\n            to = \"user@example.com\"\n            subject = \"Welcome\"\n            body = \"Welcome to our service!\"\n        }\n        .also {\n            // Side effect: log\n            println(\"Sending email to: ${it.to}\")\n        }\n        .takeIf { it.to.isNotEmpty() && it.subject.isNotEmpty() }\n        ?.apply {\n            // Mark as sent\n            sent = true\n        }\n        ?.also {\n            // Side effect: confirm\n            println(\"Email sent successfully\")\n        }\n        ?: println(\"Email validation failed\")\n}\n\nfun main() {\n    sendEmailRefactored()\n    // Sending email to: user@example.com\n    // Email sent successfully\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 2: Null Safety with let",
              "content": "\n**Goal**: Use `let` for safe null handling.\n\n**Task**: Process nullable user input safely:\n\n\n---\n\n",
              "code": "fun processUserInput(input: String?): String {\n    // TODO: Use let to safely process input\n    // 1. Trim whitespace\n    // 2. Convert to uppercase\n    // 3. Return processed string or \"NO INPUT\" if null/empty\n}\n\nfun main() {\n    println(processUserInput(\"  hello  \"))  // Should print: HELLO\n    println(processUserInput(null))         // Should print: NO INPUT\n    println(processUserInput(\"   \"))        // Should print: NO INPUT\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Solution 2: Null Safety with let",
              "content": "\n\n**Explanation**:\n- `?.` safe call operator works with `let`\n- `takeIf` filters out empty strings\n- `let` chains transformations safely\n- Elvis operator (`?:`) provides default\n\n---\n\n",
              "code": "fun processUserInput(input: String?): String {\n    return input\n        ?.trim()\n        ?.takeIf { it.isNotEmpty() }\n        ?.let { it.uppercase() }\n        ?: \"NO INPUT\"\n}\n\n// Alternative with more explicit let\nfun processUserInputAlt(input: String?): String {\n    return input?.let { rawInput ->\n        rawInput.trim()\n    }?.let { trimmed ->\n        trimmed.takeIf { it.isNotEmpty() }\n    }?.let { validated ->\n        validated.uppercase()\n    } ?: \"NO INPUT\"\n}\n\nfun main() {\n    println(processUserInput(\"  hello  \"))  // HELLO\n    println(processUserInput(null))         // NO INPUT\n    println(processUserInput(\"   \"))        // NO INPUT\n\n    println(\"\\nAlternative version:\")\n    println(processUserInputAlt(\"  world  \"))  // WORLD\n    println(processUserInputAlt(null))         // NO INPUT\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 3: Builder Pattern with apply",
              "content": "\n**Goal**: Create a fluent builder using `apply`.\n\n**Task**: Build an HTTP request configuration:\n\n\n---\n\n",
              "code": "class HttpRequest {\n    var url: String = \"\"\n    var method: String = \"GET\"\n    var headers: MutableMap<String, String> = mutableMapOf()\n    var body: String? = null\n\n    fun addHeader(key: String, value: String) {\n        headers[key] = value\n    }\n\n    override fun toString(): String {\n        return \"HttpRequest(url=$url, method=$method, headers=$headers, body=$body)\"\n    }\n}\n\nfun main() {\n    // TODO: Create POST request with headers using apply\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Solution 3: Builder Pattern with apply",
              "content": "\n\n**Explanation**:\n- `apply` configures the object and returns it\n- Making `addHeader` return `this` with `apply` enables chaining\n- `also` adds logging without breaking the chain\n- Fluent, readable builder pattern\n\n---\n\n",
              "code": "class HttpRequest {\n    var url: String = \"\"\n    var method: String = \"GET\"\n    var headers: MutableMap<String, String> = mutableMapOf()\n    var body: String? = null\n\n    fun addHeader(key: String, value: String) = apply {\n        headers[key] = value\n    }\n\n    override fun toString(): String {\n        return \"HttpRequest(url=$url, method=$method, headers=$headers, body=$body)\"\n    }\n}\n\nfun main() {\n    // Using apply for configuration\n    val request = HttpRequest().apply {\n        url = \"https://api.example.com/users\"\n        method = \"POST\"\n        body = \"\"\"{\"name\": \"Alice\", \"email\": \"alice@example.com\"}\"\"\"\n    }.apply {\n        addHeader(\"Content-Type\", \"application/json\")\n        addHeader(\"Authorization\", \"Bearer token123\")\n    }\n\n    println(request)\n    // HttpRequest(url=https://api.example.com/users, method=POST,\n    // headers={Content-Type=application/json, Authorization=Bearer token123},\n    // body={\"name\": \"Alice\", \"email\": \"alice@example.com\"})\n\n    // Alternative: chaining with fluent API\n    val request2 = HttpRequest()\n        .apply {\n            url = \"https://api.example.com/products\"\n            method = \"PUT\"\n            body = \"\"\"{\"id\": 1, \"price\": 99.99}\"\"\"\n        }\n        .addHeader(\"Content-Type\", \"application/json\")\n        .addHeader(\"Accept\", \"application/json\")\n        .also {\n            println(\"\\nCreated request: ${it.method} ${it.url}\")\n        }\n\n    println(request2)\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Checkpoint Quiz",
              "content": "\n### Question 1\nWhat's the main difference between `apply` and `also`?\n\nA) They're the same\nB) `apply` uses `this` context; `also` uses `it` context\nC) `apply` is faster\nD) `also` can't be chained\n\n### Question 2\nWhich scope function should you use for null-safe transformations?\n\nA) `apply`\nB) `also`\nC) `let`\nD) `with`\n\n### Question 3\nWhat does `apply` return?\n\nA) The lambda result\nB) Unit\nC) The object itself\nD) A boolean\n\n### Question 4\nWhen should you use `with` vs `run`?\n\nA) They're identical\nB) `with` when you have an object; `run` for chaining or inline creation\nC) `with` is deprecated\nD) `run` only works with strings\n\n### Question 5\nWhat's the primary use case for `also`?\n\nA) Configuration\nB) Transformation\nC) Side effects (logging, validation) without breaking the chain\nD) Null safety\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Answers",
              "content": "\n**Question 1: B) `apply` uses `this` context; `also` uses `it` context**\n\n\nBoth return the object, but context differs.\n\n---\n\n**Question 2: C) `let`**\n\n\n`let` is perfect for nullable chains.\n\n---\n\n**Question 3: C) The object itself**\n\n\nReturning the object enables chaining.\n\n---\n\n**Question 4: B) `with` when you have an object; `run` for chaining or inline creation**\n\n\nFunctionally similar, but usage context differs.\n\n---\n\n**Question 5: C) Side effects (logging, validation) without breaking the chain**\n\n\nPerfect for debugging and logging in chains.\n\n---\n\n",
              "code": "val result = processData()\n    .also { println(\"Step 1: $it\") }\n    .transform()\n    .also { println(\"Step 2: $it\") }\n    .finalize()\n\n// 'also' logs without changing the return value",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "What You've Learned",
              "content": "\n‚úÖ Five scope functions: let, run, with, apply, also\n‚úÖ Context differences: `this` vs `it`\n‚úÖ Return value differences: lambda result vs object\n‚úÖ When to use each scope function\n‚úÖ Chaining scope functions for fluent APIs\n‚úÖ Real-world use cases: null safety, configuration, logging\n‚úÖ Builder pattern with `apply`\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Next Steps",
              "content": "\nIn **Lesson 3.5: Function Composition and Currying**, you'll explore:\n- Composing functions to build complex operations\n- Currying and partial application\n- Extension functions as functional tools\n- Infix functions for readable DSLs\n- Operator overloading\n- Building domain-specific languages (DSLs)\n\nGet ready to take functional programming to the next level!\n\n---\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "\n**Scope Functions Summary**:\n\n\n**Decision Tree**:\n1. Need result from operation? ‚Üí let, run, with\n2. Need object for chaining? ‚Üí apply, also\n3. Null safety? ‚Üí let\n4. Configuration? ‚Üí apply\n5. Logging/side effects? ‚Üí also\n\n**Best Practices**:\n- Don't overuse‚Äîsometimes simple code is clearer\n- Choose based on intent, not just brevity\n- Use meaningful names when using `it` isn't clear\n- Chain thoughtfully‚Äîtoo many levels hurt readability\n\n---\n\n**Congratulations on completing Lesson 3.4!** üéâ\n\nScope functions are a hallmark of idiomatic Kotlin. Mastering them will make your code more elegant and expressive. Practice using them in your daily coding‚Äîthey quickly become second nature!\n\n",
              "code": "// let: nullable handling, transformation\nname?.let { it.uppercase() }\n\n// run: configure + compute result\nperson.run { age + 1 }\n\n// with: multiple ops on existing object\nwith(config) { host = \"localhost\"; port = 8080 }\n\n// apply: object configuration\nPerson().apply { name = \"Alice\"; age = 25 }\n\n// also: side effects, logging\ndata.also { println(it) }",
              "language": "kotlin"
            }
          ],
          "challenges": []
        },
        {
          "id": "4.5",
          "title": "Lesson 3.5: Function Composition and Currying",
          "moduleId": "module-04",
          "order": 9,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 60 minutes\n**Difficulty**: Advanced\n**Prerequisites**: Lessons 3.1-3.4 (Functional programming fundamentals)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Topic Introduction",
              "content": "\nYou've learned functional programming basics, lambdas, collections, and scope functions. Now it's time to explore advanced functional techniques that enable powerful abstractions.\n\nFunction composition and currying are techniques that let you build complex functionality from simple building blocks. They're the foundation of elegant, reusable code.\n\nIn this lesson, you'll learn:\n- Function composition (combining functions)\n- Currying and partial application\n- Extension functions as functional tools\n- Infix functions for readable code\n- Operator overloading\n- Building domain-specific languages (DSLs)\n\nBy the end, you'll create expressive, composable APIs!\n\n---\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "The Concept: Building with Functions",
              "content": "\n### The LEGO Analogy\n\nImagine building with LEGO:\n- **Small pieces**: Individual functions (single responsibility)\n- **Combining pieces**: Function composition (build complex structures)\n- **Specialized tools**: Extension functions, operators\n\n\n**Better with composition**:\n\n\n---\n\n",
              "code": "val process = ::trim then ::uppercase then ::addExclamation\nval result = process(\"  hello  \")\nprintln(result)  // HELLO!",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Function Composition",
              "content": "\nCombining functions to create new functions.\n\n### Mathematical Foundation\n\nIn math: `(f ‚àò g)(x) = f(g(x))`\n\n\n### Generic Composition\n\n\n### Infix Composition Operator\n\nMake composition more readable with `infix`:\n\n\n### Practical Example: Data Transformation Pipeline\n\n\n---\n\n",
              "code": "// Individual transformations\nval validateEmail: (String) -> String? = { email ->\n    if (email.contains(\"@\")) email else null\n}\n\nval normalizeEmail: (String) -> String = { email ->\n    email.trim().lowercase()\n}\n\nval extractDomain: (String) -> String = { email ->\n    email.substringAfter(\"@\")\n}\n\n// Composition\ninfix fun <A, B, C> ((A) -> B?).thenIfNotNull(other: (B) -> C): (A) -> C? {\n    return { x -> this(x)?.let(other) }\n}\n\nval processPipeline = validateEmail thenIfNotNull normalizeEmail\n\nval email1 = processPipeline(\"  USER@EXAMPLE.COM  \")\nprintln(email1)  // user@example.com\n\nval email2 = processPipeline(\"invalid\")\nprintln(email2)  // null",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Currying",
              "content": "\nTransforming a function with multiple parameters into a sequence of functions, each taking a single parameter.\n\n### Basic Currying\n\n\n### Generic Currying Helper\n\n\n### Three-Parameter Currying\n\n\n### Practical Example: Configuration Builder\n\n\n---\n\n",
              "code": "// Regular function with many parameters\nfun sendEmail(\n    to: String,\n    subject: String,\n    body: String,\n    priority: String,\n    attachments: List<String>\n) {\n    println(\"Sending email:\")\n    println(\"  To: $to\")\n    println(\"  Subject: $subject\")\n    println(\"  Body: $body\")\n    println(\"  Priority: $priority\")\n    println(\"  Attachments: $attachments\")\n}\n\n// Curried version for reusability\nfun emailSender(to: String) = { subject: String ->\n    { body: String ->\n        { priority: String ->\n            { attachments: List<String> ->\n                sendEmail(to, subject, body, priority, attachments)\n            }\n        }\n    }\n}\n\n// Create specialized senders\nval sendToAdmin = emailSender(\"admin@example.com\")\nval sendAlertToAdmin = sendToAdmin(\"ALERT\")\n\n// Use it\nsendAlertToAdmin(\"System down\")(\"HIGH\")(emptyList())\n\n// Or create even more specialized versions\nval sendHighPriorityAlert = sendToAdmin(\"ALERT\")(\"System issue\")(\"HIGH\")\nsendHighPriorityAlert(listOf(\"log.txt\"))",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Partial Application",
              "content": "\nFixing some arguments of a function, creating a new function.\n\n### Manual Partial Application\n\n\n### Generic Partial Application Helper\n\n\n### Practical Example: Database Queries\n\n\n---\n\n",
              "code": "// Generic query function\nfun query(\n    database: String,\n    table: String,\n    columns: List<String>,\n    where: String\n): String {\n    return \"SELECT ${columns.joinToString()} FROM $database.$table WHERE $where\"\n}\n\n// Partially apply database\nfun queriesFor(database: String) = { table: String, columns: List<String>, where: String ->\n    query(database, table, columns, where)\n}\n\n// Partially apply database and table\nfun tableQueries(database: String, table: String) = { columns: List<String>, where: String ->\n    query(database, table, columns, where)\n}\n\n// Usage\nval prodQueries = queriesFor(\"production\")\nval userQuery = prodQueries(\"users\", listOf(\"id\", \"name\", \"email\"), \"active = true\")\nprintln(userQuery)\n// SELECT id, name, email FROM production.users WHERE active = true\n\nval userTableQueries = tableQueries(\"production\", \"users\")\nval activeUsers = userTableQueries(listOf(\"*\"), \"active = true\")\nprintln(activeUsers)\n// SELECT * FROM production.users WHERE active = true",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Extension Functions as Functional Tools",
              "content": "\nExtension functions enable functional-style APIs.\n\n### Pipeline Operations\n\n\n### Collection Extensions\n\n\n### Higher-Order Extension Functions\n\n\n---\n\n",
              "code": "// Retry logic as extension\nfun <T> (() -> T).retry(times: Int): T? {\n    repeat(times) { attempt ->\n        try {\n            return this()\n        } catch (e: Exception) {\n            if (attempt == times - 1) throw e\n            println(\"Attempt ${attempt + 1} failed, retrying...\")\n        }\n    }\n    return null\n}\n\n// Measure execution time\nfun <T> (() -> T).measureTimeMillis(): Pair<T, Long> {\n    val start = System.currentTimeMillis()\n    val result = this()\n    val elapsed = System.currentTimeMillis() - start\n    return result to elapsed\n}\n\n// Usage\nval (result, time) = {\n    Thread.sleep(100)\n    \"Done\"\n}.measureTimeMillis()\n\nprintln(\"Result: $result, Time: ${time}ms\")",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Infix Functions",
              "content": "\nMake function calls read like natural language.\n\n### Basic Infix\n\n\n### Building Readable DSLs\n\n\n### Practical Example: Query DSL\n\n\n---\n\n",
              "code": "data class Query(val table: String, val conditions: List<String> = emptyList())\n\ninfix fun String.from(table: String) = Query(table)\n\ninfix fun Query.where(condition: String) = this.copy(\n    conditions = this.conditions + condition\n)\n\ninfix fun Query.and(condition: String) = this.copy(\n    conditions = this.conditions + condition\n)\n\nfun Query.build(): String {\n    val whereCl= if (conditions.isNotEmpty()) {\n        \" WHERE ${conditions.joinToString(\" AND \")}\"\n    } else \"\"\n    return \"SELECT $table FROM $table$whereClause\"\n}\n\n// Usage: reads like SQL!\nval query = \"users\" from \"users_table\" where \"age > 18\" and \"active = true\"\nprintln(query.build())\n// SELECT users FROM users_table WHERE age > 18 AND active = true",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Operator Overloading",
              "content": "\nDefine how operators work with custom types.\n\n### Arithmetic Operators\n\n\n### Comparison Operators\n\n\n### Invoke Operator (Callable Objects)\n\n\n### Index Access Operator\n\n\n---\n\n",
              "code": "class Grid(val width: Int, val height: Int) {\n    private val data = Array(width * height) { 0 }\n\n    operator fun get(x: Int, y: Int): Int {\n        return data[y * width + x]\n    }\n\n    operator fun set(x: Int, y: Int, value: Int) {\n        data[y * width + x] = value\n    }\n}\n\nval grid = Grid(3, 3)\ngrid[1, 2] = 42\nprintln(grid[1, 2])  // 42",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Building a Simple DSL",
              "content": "\nCombine everything to create a domain-specific language.\n\n### HTML Builder DSL\n\n\n---\n\n",
              "code": "@DslMarker\nannotation class HtmlTagMarker\n\n@HtmlTagMarker\nabstract class Tag(val name: String) {\n    val children = mutableListOf<Tag>()\n    val attributes = mutableMapOf<String, String>()\n\n    protected fun <T : Tag> initTag(tag: T, init: T.() -> Unit): T {\n        tag.init()\n        children.add(tag)\n        return tag\n    }\n\n    fun render(): String {\n        val attrs = if (attributes.isEmpty()) \"\" else {\n            attributes.entries.joinToString(\" \", \" \") { \"${it.key}=\\\"${it.value}\\\"\" }\n        }\n        val content = children.joinToString(\"\") { it.render() }\n        return \"<$name$attrs>$content</$name>\"\n    }\n}\n\nclass HTML : Tag(\"html\") {\n    fun head(init: Head.() -> Unit) = initTag(Head(), init)\n    fun body(init: Body.() -> Unit) = initTag(Body(), init)\n}\n\nclass Head : Tag(\"head\") {\n    fun title(init: Title.() -> Unit) = initTag(Title(), init)\n}\n\nclass Title : Tag(\"title\") {\n    operator fun String.unaryPlus() {\n        children.add(Text(this))\n    }\n}\n\nclass Body : Tag(\"body\") {\n    fun h1(init: H1.() -> Unit) = initTag(H1(), init)\n    fun p(init: P.() -> Unit) = initTag(P(), init)\n}\n\nclass H1 : Tag(\"h1\") {\n    operator fun String.unaryPlus() {\n        children.add(Text(this))\n    }\n}\n\nclass P : Tag(\"p\") {\n    operator fun String.unaryPlus() {\n        children.add(Text(this))\n    }\n}\n\nclass Text(val content: String) : Tag(\"\") {\n    override fun render() = content\n}\n\nfun html(init: HTML.() -> Unit): HTML {\n    val html = HTML()\n    html.init()\n    return html\n}\n\n// Usage: beautiful DSL!\nval page = html {\n    head {\n        title { +\"My Page\" }\n    }\n    body {\n        h1 { +\"Welcome!\" }\n        p { +\"This is a paragraph.\" }\n        p { +\"Another paragraph.\" }\n    }\n}\n\nprintln(page.render())\n// <html><head><title>My Page</title></head><body><h1>Welcome!</h1><p>This is a paragraph.</p><p>Another paragraph.</p></body></html>",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 1: Function Composition",
              "content": "\n**Goal**: Implement function composition operators.\n\n**Task**: Create `andThen` and `compose` operators for functions.\n\n\n---\n\n",
              "code": "// TODO: Implement these\ninfix fun <A, B, C> ((A) -> B).andThen(other: (B) -> C): (A) -> C {\n    // Your code here\n}\n\ninfix fun <A, B, C> ((B) -> C).compose(other: (A) -> B): (A) -> C {\n    // Your code here\n}\n\nfun main() {\n    val trim: (String) -> String = { it.trim() }\n    val uppercase: (String) -> String = { it.uppercase() }\n    val addExclamation: (String) -> String = { \"$it!\" }\n\n    // TODO: Test both operators\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Solution 1: Function Composition",
              "content": "\n\n**Explanation**:\n- `andThen`: Read left-to-right (intuitive)\n- `compose`: Mathematical notation (right-to-left)\n- Both achieve the same result, different reading order\n\n---\n\n",
              "code": "infix fun <A, B, C> ((A) -> B).andThen(other: (B) -> C): (A) -> C {\n    return { x -> other(this(x)) }\n}\n\ninfix fun <A, B, C> ((B) -> C).compose(other: (A) -> B): (A) -> C {\n    return { x -> this(other(x)) }\n}\n\nfun main() {\n    val trim: (String) -> String = { it.trim() }\n    val uppercase: (String) -> String = { it.uppercase() }\n    val addExclamation: (String) -> String = { \"$it!\" }\n\n    // andThen: left to right\n    val process1 = trim andThen uppercase andThen addExclamation\n    println(process1(\"  hello  \"))  // HELLO!\n\n    // compose: right to left\n    val process2 = addExclamation compose uppercase compose trim\n    println(process2(\"  world  \"))  // WORLD!\n\n    // Practical example: data processing\n    val validate: (String) -> String? = { if (it.isNotEmpty()) it else null }\n    val normalize: (String) -> String = { it.trim().lowercase() }\n    val hash: (String) -> Int = { it.hashCode() }\n\n    val pipeline = normalize andThen hash\n    println(\"Hash: ${pipeline(\"  HELLO  \")}\")  // Hash of \"hello\"\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 2: Currying Implementation",
              "content": "\n**Goal**: Implement a curry function for 2-parameter functions.\n\n**Task**:\n\n\n---\n\n",
              "code": "fun <A, B, C> curry(f: (A, B) -> C): (A) -> (B) -> C {\n    // TODO: Implement\n}\n\nfun main() {\n    val add = { a: Int, b: Int -> a + b }\n    val multiply = { a: Int, b: Int -> a * b }\n\n    // TODO: Test currying\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Solution 2: Currying Implementation",
              "content": "\n\n**Explanation**:\n- Currying transforms multi-parameter functions into chains\n- Creates specialized versions by fixing parameters\n- Useful for configuration and creating function families\n\n---\n\n",
              "code": "fun <A, B, C> curry(f: (A, B) -> C): (A) -> (B) -> C {\n    return { a -> { b -> f(a, b) } }\n}\n\n// Bonus: Uncurry\nfun <A, B, C> uncurry(f: (A) -> (B) -> C): (A, B) -> C {\n    return { a, b -> f(a)(b) }\n}\n\nfun main() {\n    val add = { a: Int, b: Int -> a + b }\n    val multiply = { a: Int, b: Int -> a * b }\n\n    // Curry add\n    val curriedAdd = curry(add)\n    val add10 = curriedAdd(10)\n    println(add10(5))   // 15\n    println(add10(20))  // 30\n\n    // Curry multiply\n    val curriedMultiply = curry(multiply)\n    val double = curriedMultiply(2)\n    val triple = curriedMultiply(3)\n    println(double(7))  // 14\n    println(triple(7))  // 21\n\n    // Practical: Specialized formatters\n    val format = { prefix: String, value: String -> \"$prefix: $value\" }\n    val curriedFormat = curry(format)\n\n    val errorFormatter = curriedFormat(\"ERROR\")\n    val infoFormatter = curriedFormat(\"INFO\")\n\n    println(errorFormatter(\"Something went wrong\"))  // ERROR: Something went wrong\n    println(infoFormatter(\"Process started\"))        // INFO: Process started\n\n    // Uncurry example\n    val uncurriedAdd = uncurry(curriedAdd)\n    println(uncurriedAdd(5, 3))  // 8\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 3: DSL Builder",
              "content": "\n**Goal**: Create a simple DSL for building configurations.\n\n**Task**:\n\n\n---\n\n",
              "code": "// TODO: Implement a configuration DSL\nclass ServerConfig {\n    var host: String = \"\"\n    var port: Int = 0\n    val routes = mutableListOf<Route>()\n\n    fun route(path: String, init: Route.() -> Unit) {\n        // TODO\n    }\n}\n\nclass Route(val path: String) {\n    var method: String = \"GET\"\n    var handler: String = \"\"\n}\n\nfun server(init: ServerConfig.() -> Unit): ServerConfig {\n    // TODO\n}\n\nfun main() {\n    // Should work like this:\n    val config = server {\n        host = \"localhost\"\n        port = 8080\n        route(\"/users\") {\n            method = \"GET\"\n            handler = \"listUsers\"\n        }\n        route(\"/users\") {\n            method = \"POST\"\n            handler = \"createUser\"\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Solution 3: DSL Builder",
              "content": "\n\n**Explanation**:\n- DSL provides type-safe configuration\n- Lambda with receiver (`init: ServerConfig.() -> Unit`) enables clean syntax\n- Nested structures through builder pattern\n- Reads almost like a configuration file!\n\n---\n\n",
              "code": "class ServerConfig {\n    var host: String = \"\"\n    var port: Int = 0\n    val routes = mutableListOf<Route>()\n\n    fun route(path: String, init: Route.() -> Unit) {\n        val route = Route(path)\n        route.init()\n        routes.add(route)\n    }\n\n    override fun toString(): String {\n        return \"\"\"\n            Server Configuration:\n              Host: $host\n              Port: $port\n              Routes:\n                ${routes.joinToString(\"\\n    \") { it.toString() }}\n        \"\"\".trimIndent()\n    }\n}\n\nclass Route(val path: String) {\n    var method: String = \"GET\"\n    var handler: String = \"\"\n\n    override fun toString() = \"$method $path -> $handler\"\n}\n\nfun server(init: ServerConfig.() -> Unit): ServerConfig {\n    val config = ServerConfig()\n    config.init()\n    return config\n}\n\nfun main() {\n    val config = server {\n        host = \"localhost\"\n        port = 8080\n\n        route(\"/users\") {\n            method = \"GET\"\n            handler = \"listUsers\"\n        }\n\n        route(\"/users\") {\n            method = \"POST\"\n            handler = \"createUser\"\n        }\n\n        route(\"/users/{id}\") {\n            method = \"GET\"\n            handler = \"getUser\"\n        }\n\n        route(\"/users/{id}\") {\n            method = \"PUT\"\n            handler = \"updateUser\"\n        }\n\n        route(\"/users/{id}\") {\n            method = \"DELETE\"\n            handler = \"deleteUser\"\n        }\n    }\n\n    println(config)\n    /*\n    Server Configuration:\n      Host: localhost\n      Port: 8080\n      Routes:\n        GET /users -> listUsers\n        POST /users -> createUser\n        GET /users/{id} -> getUser\n        PUT /users/{id} -> updateUser\n        DELETE /users/{id} -> deleteUser\n    */\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Checkpoint Quiz",
              "content": "\n### Question 1\nWhat is function composition?\n\nA) Writing functions inside other functions\nB) Combining functions to create new functions where output of one becomes input of another\nC) Making functions larger\nD) Commenting functions\n\n### Question 2\nWhat is currying?\n\nA) Converting a multi-parameter function into a sequence of single-parameter functions\nB) Making functions run faster\nC) A cooking technique\nD) Error handling\n\n### Question 3\nWhat does the `infix` keyword do?\n\nA) Makes functions run in the background\nB) Allows calling functions without dot notation and parentheses (binary operation style)\nC) Makes functions faster\nD) Prevents function calls\n\n### Question 4\nWhat is operator overloading?\n\nA) Using too many operators\nB) Defining custom behavior for operators like +, -, *, / on custom types\nC) A performance optimization\nD) A deprecated feature\n\n### Question 5\nWhat is a DSL (Domain-Specific Language)?\n\nA) A new programming language\nB) An API designed to read like natural language for a specific domain\nC) A debugging tool\nD) A database query language\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Answers",
              "content": "\n**Question 1: B) Combining functions to create new functions where output of one becomes input of another**\n\n\nComposition builds complex operations from simple parts.\n\n---\n\n**Question 2: A) Converting a multi-parameter function into a sequence of single-parameter functions**\n\n\nCurrying enables partial application and function specialization.\n\n---\n\n**Question 3: B) Allows calling functions without dot notation and parentheses (binary operation style)**\n\n\nMakes code read more naturally.\n\n---\n\n**Question 4: B) Defining custom behavior for operators like +, -, *, / on custom types**\n\n\nEnables intuitive syntax for custom types.\n\n---\n\n**Question 5: B) An API designed to read like natural language for a specific domain**\n\n\nDSLs make code expressive and domain-specific.\n\n---\n\n",
              "code": "// DSL for HTML\nhtml {\n    head {\n        title { +\"My Page\" }\n    }\n    body {\n        h1 { +\"Welcome\" }\n    }\n}\n\n// Reads like HTML structure!",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "What You've Learned",
              "content": "\n‚úÖ Function composition (combining functions)\n‚úÖ Currying (transforming multi-parameter functions)\n‚úÖ Partial application (fixing some parameters)\n‚úÖ Extension functions as functional tools\n‚úÖ Infix functions for readable code\n‚úÖ Operator overloading for custom types\n‚úÖ Building domain-specific languages (DSLs)\n‚úÖ Advanced functional programming techniques\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Next Steps",
              "content": "\nIn **Lesson 3.6: Part 3 Capstone - Data Processing Pipeline**, you'll:\n- Build a complete functional programming project\n- Process CSV data with functional operations\n- Create reusable pipeline components\n- Apply everything you've learned\n- Build statistics and reporting features\n\nTime to put it all together!\n\n---\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "\n**Function Composition**:\nBuild complex operations from simple building blocks.\n\n**Currying**:\nCreate specialized functions from general ones.\n\n**Infix & Operators**:\nMake code read naturally.\n\n**DSLs**:\nType-safe, readable configuration.\n\n---\n\n**Congratulations on completing Lesson 3.5!** üéâ\n\nYou've mastered advanced functional programming techniques! These concepts enable powerful abstractions and elegant APIs. Now you're ready to build real-world functional applications in the capstone project!\n\n",
              "code": "server {\n    host = \"localhost\"\n    port = 8080\n    route(\"/api\") { ... }\n}",
              "language": "kotlin"
            }
          ],
          "challenges": []
        },
        {
          "id": "4.6",
          "title": "Lesson 3.6: Part 3 Capstone - Data Processing Pipeline",
          "moduleId": "module-04",
          "order": 10,
          "estimatedMinutes": 90,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 90 minutes\n**Difficulty**: Advanced\n**Prerequisites**: Lessons 3.1-3.5 (All functional programming concepts)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Project Introduction",
              "content": "\nCongratulations on reaching the capstone project! You've learned functional programming from the ground up‚Äîlambdas, higher-order functions, collection operations, scope functions, composition, and currying.\n\nNow it's time to apply everything to a real-world project: a **Data Processing Pipeline** that analyzes sales data.\n\n### What You'll Build\n\nA complete functional data processing system that:\n- Reads and parses CSV data\n- Cleans and validates data\n- Transforms and enriches data\n- Aggregates statistics\n- Generates reports\n- Uses functional programming throughout\n\n### Skills You'll Practice\n\n‚úÖ Collection operations (map, filter, groupBy, etc.)\n‚úÖ Higher-order functions\n‚úÖ Function composition\n‚úÖ Scope functions\n‚úÖ Extension functions\n‚úÖ Sequences for performance\n‚úÖ Functional pipelines\n‚úÖ Error handling functionally\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Project Requirements",
              "content": "\n### Dataset: Sales Data\n\nYou'll process sales data with these fields:\n- Order ID\n- Date\n- Customer Name\n- Product\n- Category\n- Quantity\n- Price\n- Region\n\n### Features to Implement\n\n**Core Features**:\n1. Data parsing from CSV\n2. Data validation and cleaning\n3. Revenue calculation\n4. Category-based analysis\n5. Regional analysis\n6. Top products/customers\n7. Time-based trends\n8. Report generation\n\n**Functional Requirements**:\n- Use functional pipelines (no imperative loops)\n- Create reusable transformation functions\n- Compose operations for complex analysis\n- Use sequences for large datasets\n- Apply scope functions appropriately\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Sample Data",
              "content": "\n\n---\n\n",
              "code": "OrderID,Date,Customer,Product,Category,Quantity,Price,Region\n1001,2024-01-15,Alice Johnson,Laptop,Electronics,1,1200.00,North\n1002,2024-01-16,Bob Smith,Mouse,Electronics,2,25.00,South\n1003,2024-01-17,Alice Johnson,Keyboard,Electronics,1,75.00,North\n1004,2024-01-18,Charlie Brown,Desk,Furniture,1,300.00,East\n1005,2024-01-19,Diana Prince,Chair,Furniture,2,150.00,West\n1006,2024-01-20,Bob Smith,Monitor,Electronics,1,400.00,South\n1007,2024-01-21,Alice Johnson,Lamp,Furniture,3,50.00,North\n1008,2024-01-22,Eve Davis,Laptop,Electronics,1,1200.00,East\n1009,2024-01-23,Frank Miller,Mouse,Electronics,5,25.00,West\n1010,2024-01-24,Charlie Brown,Desk,Furniture,1,300.00,East\n1011,2024-01-25,Alice Johnson,Monitor,Electronics,1,400.00,North\n1012,2024-01-26,Bob Smith,Keyboard,Electronics,2,75.00,South\n1013,2024-01-27,Diana Prince,Laptop,Electronics,1,1200.00,West\n1014,2024-01-28,Eve Davis,Chair,Furniture,2,150.00,East\n1015,2024-01-29,Frank Miller,Lamp,Furniture,1,50.00,West",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Step 1: Data Model",
              "content": "\nFirst, define your data structures.\n\n\n---\n\n",
              "code": "data class SalesRecord(\n    val orderId: Int,\n    val date: String,\n    val customer: String,\n    val product: String,\n    val category: String,\n    val quantity: Int,\n    val price: Double,\n    val region: String\n) {\n    val revenue: Double\n        get() = quantity * price\n}\n\n// Result types for functional error handling\nsealed class ParseResult {\n    data class Success(val records: List<SalesRecord>) : ParseResult()\n    data class Error(val message: String, val lineNumber: Int) : ParseResult()\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Step 2: CSV Parser",
              "content": "\nCreate a functional CSV parser.\n\n\n---\n\n",
              "code": "object CsvParser {\n    fun parseLine(line: String, lineNumber: Int): SalesRecord? {\n        return try {\n            val parts = line.split(\",\")\n            if (parts.size != 8) return null\n\n            SalesRecord(\n                orderId = parts[0].toInt(),\n                date = parts[1],\n                customer = parts[2],\n                product = parts[3],\n                category = parts[4],\n                quantity = parts[5].toInt(),\n                price = parts[6].toDouble(),\n                region = parts[7]\n            )\n        } catch (e: Exception) {\n            println(\"Error parsing line $lineNumber: ${e.message}\")\n            null\n        }\n    }\n\n    fun parseCSV(csvData: String): List<SalesRecord> {\n        return csvData\n            .lines()\n            .drop(1)  // Skip header\n            .filter { it.isNotBlank() }\n            .mapIndexedNotNull { index, line -> parseLine(line, index + 2) }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Step 3: Validation Pipeline",
              "content": "\nCreate data validation functions.\n\n\n---\n\n",
              "code": "// Validation functions\ntypealias Validator<T> = (T) -> Boolean\n\nobject Validators {\n    val validQuantity: Validator<SalesRecord> = { it.quantity > 0 }\n    val validPrice: Validator<SalesRecord> = { it.price > 0 }\n    val validCustomer: Validator<SalesRecord> = { it.customer.isNotBlank() }\n    val validProduct: Validator<SalesRecord> = { it.product.isNotBlank() }\n\n    fun validateRecord(record: SalesRecord): Boolean {\n        return listOf(\n            validQuantity,\n            validPrice,\n            validCustomer,\n            validProduct\n        ).all { it(record) }\n    }\n}\n\n// Extension function for validation\nfun List<SalesRecord>.validated(): List<SalesRecord> {\n    return this.filter(Validators::validateRecord)\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Step 4: Data Transformation Pipeline",
              "content": "\nCreate transformation and enrichment functions.\n\n\n---\n\n",
              "code": "// Extension functions for transformations\nfun SalesRecord.normalize() = this.copy(\n    customer = customer.trim(),\n    product = product.trim(),\n    category = category.trim(),\n    region = region.trim().uppercase()\n)\n\nfun List<SalesRecord>.normalized() = this.map { it.normalize() }\n\n// Revenue calculations\nfun List<SalesRecord>.totalRevenue() = this.sumOf { it.revenue }\n\nfun List<SalesRecord>.averageOrderValue() =\n    if (this.isEmpty()) 0.0 else this.totalRevenue() / this.size",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Step 5: Analysis Functions",
              "content": "\nCreate analysis functions using functional operations.\n\n\n---\n\n",
              "code": "object Analytics {\n    // Category analysis\n    fun categoryBreakdown(records: List<SalesRecord>): Map<String, Double> {\n        return records\n            .groupBy { it.category }\n            .mapValues { (_, sales) -> sales.totalRevenue() }\n    }\n\n    // Regional analysis\n    fun regionalBreakdown(records: List<SalesRecord>): Map<String, Double> {\n        return records\n            .groupBy { it.region }\n            .mapValues { (_, sales) -> sales.totalRevenue() }\n    }\n\n    // Top products\n    fun topProducts(records: List<SalesRecord>, limit: Int = 5): List<Pair<String, Double>> {\n        return records\n            .groupBy { it.product }\n            .mapValues { (_, sales) -> sales.totalRevenue() }\n            .toList()\n            .sortedByDescending { it.second }\n            .take(limit)\n    }\n\n    // Top customers\n    fun topCustomers(records: List<SalesRecord>, limit: Int = 5): List<Pair<String, Double>> {\n        return records\n            .groupBy { it.customer }\n            .mapValues { (_, sales) -> sales.totalRevenue() }\n            .toList()\n            .sortedByDescending { it.second }\n            .take(limit)\n    }\n\n    // Product statistics\n    data class ProductStats(\n        val totalOrders: Int,\n        val totalQuantity: Int,\n        val totalRevenue: Double,\n        val averagePrice: Double\n    )\n\n    fun productStatistics(records: List<SalesRecord>): Map<String, ProductStats> {\n        return records\n            .groupBy { it.product }\n            .mapValues { (_, sales) ->\n                ProductStats(\n                    totalOrders = sales.size,\n                    totalQuantity = sales.sumOf { it.quantity },\n                    totalRevenue = sales.totalRevenue(),\n                    averagePrice = sales.map { it.price }.average()\n                )\n            }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Step 6: Report Generator",
              "content": "\nCreate a report generator using functional composition.\n\n\n---\n\n",
              "code": "object ReportGenerator {\n    fun generateSummary(records: List<SalesRecord>): String {\n        return buildString {\n            appendLine(\"=\" .repeat(60))\n            appendLine(\"SALES REPORT SUMMARY\")\n            appendLine(\"=\".repeat(60))\n            appendLine()\n\n            appendLine(\"üìä Overall Statistics\")\n            appendLine(\"-\".repeat(60))\n            appendLine(\"Total Orders: ${records.size}\")\n            appendLine(\"Total Revenue: ${\"$%.2f\".format(records.totalRevenue())}\")\n            appendLine(\"Average Order Value: ${\"$%.2f\".format(records.averageOrderValue())}\")\n            appendLine()\n\n            val categoryData = Analytics.categoryBreakdown(records)\n            appendLine(\"üì¶ Category Breakdown\")\n            appendLine(\"-\".repeat(60))\n            categoryData\n                .toList()\n                .sortedByDescending { it.second }\n                .forEach { (category, revenue) ->\n                    appendLine(\"  $category: ${\"$%.2f\".format(revenue)}\")\n                }\n            appendLine()\n\n            val regionalData = Analytics.regionalBreakdown(records)\n            appendLine(\"üåç Regional Breakdown\")\n            appendLine(\"-\".repeat(60))\n            regionalData\n                .toList()\n                .sortedByDescending { it.second }\n                .forEach { (region, revenue) ->\n                    appendLine(\"  $region: ${\"$%.2f\".format(revenue)}\")\n                }\n            appendLine()\n\n            appendLine(\"üèÜ Top 5 Products\")\n            appendLine(\"-\".repeat(60))\n            Analytics.topProducts(records, 5)\n                .forEachIndexed { index, (product, revenue) ->\n                    appendLine(\"  ${index + 1}. $product: ${\"$%.2f\".format(revenue)}\")\n                }\n            appendLine()\n\n            appendLine(\"üë• Top 5 Customers\")\n            appendLine(\"-\".repeat(60))\n            Analytics.topCustomers(records, 5)\n                .forEachIndexed { index, (customer, revenue) ->\n                    appendLine(\"  ${index + 1}. $customer: ${\"$%.2f\".format(revenue)}\")\n                }\n            appendLine()\n\n            appendLine(\"=\".repeat(60))\n        }\n    }\n\n    fun generateDetailedReport(records: List<SalesRecord>): String {\n        return buildString {\n            appendLine(generateSummary(records))\n            appendLine()\n            appendLine(\"üìä DETAILED PRODUCT STATISTICS\")\n            appendLine(\"=\".repeat(60))\n\n            Analytics.productStatistics(records)\n                .toList()\n                .sortedByDescending { it.second.totalRevenue }\n                .forEach { (product, stats) ->\n                    appendLine()\n                    appendLine(\"Product: $product\")\n                    appendLine(\"  Orders: ${stats.totalOrders}\")\n                    appendLine(\"  Quantity Sold: ${stats.totalQuantity}\")\n                    appendLine(\"  Total Revenue: ${\"$%.2f\".format(stats.totalRevenue)}\")\n                    appendLine(\"  Average Price: ${\"$%.2f\".format(stats.averagePrice)}\")\n                }\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Step 7: Complete Pipeline",
              "content": "\nPut it all together in a functional pipeline.\n\n\n---\n\n",
              "code": "class SalesDataPipeline {\n    private val transformations = mutableListOf<(List<SalesRecord>) -> List<SalesRecord>>()\n\n    fun addTransformation(transform: (List<SalesRecord>) -> List<SalesRecord>) = apply {\n        transformations.add(transform)\n    }\n\n    fun process(csvData: String): List<SalesRecord> {\n        var records = CsvParser.parseCSV(csvData)\n\n        // Apply all transformations in sequence\n        transformations.forEach { transform ->\n            records = transform(records)\n        }\n\n        return records\n    }\n}\n\n// Create pipeline\nfun createPipeline() = SalesDataPipeline()\n    .addTransformation { it.validated() }\n    .addTransformation { it.normalized() }\n\n// Infix function for readable filtering\ninfix fun List<SalesRecord>.inCategory(category: String) =\n    this.filter { it.category.equals(category, ignoreCase = true) }\n\ninfix fun List<SalesRecord>.inRegion(region: String) =\n    this.filter { it.region.equals(region, ignoreCase = true) }\n\nfun List<SalesRecord>.withRevenueAbove(amount: Double) =\n    this.filter { it.revenue > amount }",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Complete Solution",
              "content": "\nHere's the full working solution:\n\n\n---\n\n",
              "code": "// Data Model\ndata class SalesRecord(\n    val orderId: Int,\n    val date: String,\n    val customer: String,\n    val product: String,\n    val category: String,\n    val quantity: Int,\n    val price: Double,\n    val region: String\n) {\n    val revenue: Double get() = quantity * price\n}\n\n// CSV Parser\nobject CsvParser {\n    fun parseLine(line: String): SalesRecord? {\n        return try {\n            val parts = line.split(\",\")\n            if (parts.size != 8) return null\n            SalesRecord(\n                orderId = parts[0].toInt(),\n                date = parts[1],\n                customer = parts[2],\n                product = parts[3],\n                category = parts[4],\n                quantity = parts[5].toInt(),\n                price = parts[6].toDouble(),\n                region = parts[7]\n            )\n        } catch (e: Exception) {\n            null\n        }\n    }\n\n    fun parseCSV(csvData: String): List<SalesRecord> {\n        return csvData.lines()\n            .drop(1)\n            .filter { it.isNotBlank() }\n            .mapNotNull { parseLine(it) }\n    }\n}\n\n// Validators\nobject Validators {\n    val validQuantity: (SalesRecord) -> Boolean = { it.quantity > 0 }\n    val validPrice: (SalesRecord) -> Boolean = { it.price > 0 }\n    val validCustomer: (SalesRecord) -> Boolean = { it.customer.isNotBlank() }\n\n    fun validateRecord(record: SalesRecord): Boolean =\n        listOf(validQuantity, validPrice, validCustomer).all { it(record) }\n}\n\n// Extensions\nfun SalesRecord.normalize() = copy(\n    customer = customer.trim(),\n    product = product.trim(),\n    category = category.trim(),\n    region = region.trim().uppercase()\n)\n\nfun List<SalesRecord>.validated() = filter(Validators::validateRecord)\nfun List<SalesRecord>.normalized() = map { it.normalize() }\nfun List<SalesRecord>.totalRevenue() = sumOf { it.revenue }\nfun List<SalesRecord>.averageOrderValue() =\n    if (isEmpty()) 0.0 else totalRevenue() / size\n\ninfix fun List<SalesRecord>.inCategory(category: String) =\n    filter { it.category.equals(category, ignoreCase = true) }\n\ninfix fun List<SalesRecord>.inRegion(region: String) =\n    filter { it.region.equals(region, ignoreCase = true) }\n\n// Analytics\nobject Analytics {\n    fun categoryBreakdown(records: List<SalesRecord>) =\n        records.groupBy { it.category }\n            .mapValues { (_, sales) -> sales.totalRevenue() }\n\n    fun regionalBreakdown(records: List<SalesRecord>) =\n        records.groupBy { it.region }\n            .mapValues { (_, sales) -> sales.totalRevenue() }\n\n    fun topProducts(records: List<SalesRecord>, limit: Int = 5) =\n        records.groupBy { it.product }\n            .mapValues { (_, sales) -> sales.totalRevenue() }\n            .toList()\n            .sortedByDescending { it.second }\n            .take(limit)\n\n    fun topCustomers(records: List<SalesRecord>, limit: Int = 5) =\n        records.groupBy { it.customer }\n            .mapValues { (_, sales) -> sales.totalRevenue() }\n            .toList()\n            .sortedByDescending { it.second }\n            .take(limit)\n}\n\n// Report Generator\nobject ReportGenerator {\n    fun generate(records: List<SalesRecord>): String = buildString {\n        appendLine(\"=\" .repeat(60))\n        appendLine(\"SALES REPORT\")\n        appendLine(\"=\".repeat(60))\n        appendLine()\n\n        appendLine(\"üìä Overall Statistics\")\n        appendLine(\"Total Orders: ${records.size}\")\n        appendLine(\"Total Revenue: ${\"$%.2f\".format(records.totalRevenue())}\")\n        appendLine(\"Average Order: ${\"$%.2f\".format(records.averageOrderValue())}\")\n        appendLine()\n\n        appendLine(\"üì¶ Category Breakdown\")\n        Analytics.categoryBreakdown(records)\n            .toList()\n            .sortedByDescending { it.second }\n            .forEach { (cat, rev) ->\n                appendLine(\"  $cat: ${\"$%.2f\".format(rev)}\")\n            }\n        appendLine()\n\n        appendLine(\"üåç Regional Breakdown\")\n        Analytics.regionalBreakdown(records)\n            .toList()\n            .sortedByDescending { it.second }\n            .forEach { (reg, rev) ->\n                appendLine(\"  $reg: ${\"$%.2f\".format(rev)}\")\n            }\n        appendLine()\n\n        appendLine(\"üèÜ Top 5 Products\")\n        Analytics.topProducts(records, 5)\n            .forEachIndexed { i, (prod, rev) ->\n                appendLine(\"  ${i + 1}. $prod: ${\"$%.2f\".format(rev)}\")\n            }\n        appendLine()\n\n        appendLine(\"üë• Top 5 Customers\")\n        Analytics.topCustomers(records, 5)\n            .forEachIndexed { i, (cust, rev) ->\n                appendLine(\"  ${i + 1}. $cust: ${\"$%.2f\".format(rev)}\")\n            }\n    }\n}\n\n// Main Application\nfun main() {\n    val csvData = \"\"\"\nOrderID,Date,Customer,Product,Category,Quantity,Price,Region\n1001,2024-01-15,Alice Johnson,Laptop,Electronics,1,1200.00,North\n1002,2024-01-16,Bob Smith,Mouse,Electronics,2,25.00,South\n1003,2024-01-17,Alice Johnson,Keyboard,Electronics,1,75.00,North\n1004,2024-01-18,Charlie Brown,Desk,Furniture,1,300.00,East\n1005,2024-01-19,Diana Prince,Chair,Furniture,2,150.00,West\n1006,2024-01-20,Bob Smith,Monitor,Electronics,1,400.00,South\n1007,2024-01-21,Alice Johnson,Lamp,Furniture,3,50.00,North\n1008,2024-01-22,Eve Davis,Laptop,Electronics,1,1200.00,East\n1009,2024-01-23,Frank Miller,Mouse,Electronics,5,25.00,West\n1010,2024-01-24,Charlie Brown,Desk,Furniture,1,300.00,East\n1011,2024-01-25,Alice Johnson,Monitor,Electronics,1,400.00,North\n1012,2024-01-26,Bob Smith,Keyboard,Electronics,2,75.00,South\n1013,2024-01-27,Diana Prince,Laptop,Electronics,1,1200.00,West\n1014,2024-01-28,Eve Davis,Chair,Furniture,2,150.00,East\n1015,2024-01-29,Frank Miller,Lamp,Furniture,1,50.00,West\n    \"\"\".trimIndent()\n\n    // Process data through functional pipeline\n    val allRecords = CsvParser.parseCSV(csvData)\n        .validated()\n        .normalized()\n\n    println(\"Processed ${allRecords.size} records\\n\")\n\n    // Generate full report\n    println(ReportGenerator.generate(allRecords))\n\n    // Demonstrate functional filtering\n    println(\"\\n\" + \"=\".repeat(60))\n    println(\"CUSTOM ANALYSIS EXAMPLES\")\n    println(\"=\".repeat(60))\n\n    // Electronics in North region\n    val northElectronics = allRecords inCategory \"Electronics\" inRegion \"NORTH\"\n    println(\"\\nElectronics in North Region:\")\n    println(\"  Orders: ${northElectronics.size}\")\n    println(\"  Revenue: ${\"$%.2f\".format(northElectronics.totalRevenue())}\")\n\n    // Furniture analysis\n    val furniture = allRecords inCategory \"Furniture\"\n    println(\"\\nFurniture Sales:\")\n    println(\"  Orders: ${furniture.size}\")\n    println(\"  Revenue: ${\"$%.2f\".format(furniture.totalRevenue())}\")\n    println(\"  Average Order: ${\"$%.2f\".format(furniture.averageOrderValue())}\")\n\n    // High-value orders\n    val highValue = allRecords.filter { it.revenue > 500 }\n    println(\"\\nHigh-Value Orders (>$500):\")\n    println(\"  Count: ${highValue.size}\")\n    println(\"  Total: ${\"$%.2f\".format(highValue.totalRevenue())}\")\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Extension Challenges",
              "content": "\nTake the project further with these challenges!\n\n### Challenge 1: Date-Based Analysis\n\nAdd time-series analysis:\n\n\n### Challenge 2: Customer Segmentation\n\nClassify customers by spending:\n\n\n### Challenge 3: Product Recommendations\n\nFind frequently bought together items:\n\n\n### Challenge 4: Export to Different Formats\n\nAdd JSON/CSV export:\n\n\n### Challenge 5: Sequence Optimization\n\nUse sequences for large datasets:\n\n\n---\n\n",
              "code": "fun processLargeDataset(csvData: String): List<SalesRecord> {\n    return csvData.lineSequence()  // Sequence instead of lines()\n        .drop(1)\n        .filter { it.isNotBlank() }\n        .mapNotNull { CsvParser.parseLine(it) }\n        .filter(Validators::validateRecord)\n        .map { it.normalize() }\n        .toList()\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Testing Your Pipeline",
              "content": "\nCreate test functions to verify your implementation:\n\n\n---\n\n",
              "code": "fun testPipeline() {\n    val testData = \"\"\"\nOrderID,Date,Customer,Product,Category,Quantity,Price,Region\n1,2024-01-01,Test User,Test Product,Test,1,100.00,North\n2,2024-01-02,Test User,Test Product,Test,2,50.00,South\n    \"\"\".trimIndent()\n\n    val records = CsvParser.parseCSV(testData).validated().normalized()\n\n    // Test parsing\n    assert(records.size == 2) { \"Should parse 2 records\" }\n\n    // Test revenue calculation\n    val total = records.totalRevenue()\n    assert(total == 200.0) { \"Total revenue should be 200\" }\n\n    // Test filtering\n    val north = records inRegion \"NORTH\"\n    assert(north.size == 1) { \"Should find 1 North region record\" }\n\n    println(\"‚úÖ All tests passed!\")\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "What You've Accomplished",
              "content": "\n**Functional Programming Techniques Used**:\n- ‚úÖ Higher-order functions (map, filter, groupBy)\n- ‚úÖ Function composition and pipelines\n- ‚úÖ Extension functions for fluent APIs\n- ‚úÖ Scope functions (apply, let, also)\n- ‚úÖ Infix functions for readability\n- ‚úÖ Sequences for performance\n- ‚úÖ Functional error handling\n- ‚úÖ Type-safe transformations\n- ‚úÖ Immutable data structures\n- ‚úÖ Declarative data processing\n\n**Real-World Skills**:\n- CSV parsing and data import\n- Data validation and cleaning\n- Statistical analysis\n- Report generation\n- Modular, reusable code design\n- Performance optimization\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Checkpoint Quiz",
              "content": "\n### Question 1\nWhy use sequences instead of lists for large datasets?\n\nA) Sequences are faster for all operations\nB) Sequences use lazy evaluation, processing elements only as needed\nC) Sequences use less memory for small datasets\nD) Sequences can't be used with collection operations\n\n### Question 2\nWhat's the benefit of extension functions in the pipeline?\n\nA) They make code run faster\nB) They create fluent, chainable APIs that read naturally\nC) They're required for functional programming\nD) They reduce memory usage\n\n### Question 3\nWhy use `mapNotNull` instead of `map`?\n\nA) It's faster\nB) It filters out null values automatically while mapping\nC) It handles exceptions better\nD) There's no difference\n\n### Question 4\nWhat does the `infix` keyword enable in `inCategory`?\n\nA) Faster execution\nB) Calling the function without dot notation: `records inCategory \"Electronics\"`\nC) Making the function private\nD) Type safety\n\n### Question 5\nWhy separate validation, transformation, and analysis into different objects/functions?\n\nA) It's required by Kotlin\nB) Separation of concerns: easier to test, reuse, and maintain\nC) It makes code slower but safer\nD) It uses less memory\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Answers",
              "content": "\n**Question 1: B) Sequences use lazy evaluation, processing elements only as needed**\n\n\nSequences excel with large data and partial results.\n\n---\n\n**Question 2: B) They create fluent, chainable APIs that read naturally**\n\n\nReads left-to-right, naturally chains operations.\n\n---\n\n**Question 3: B) It filters out null values automatically while mapping**\n\n\nMore concise and expresses intent clearly.\n\n---\n\n**Question 4: B) Calling the function without dot notation: `records inCategory \"Electronics\"`**\n\n\nReads more naturally, like English.\n\n---\n\n**Question 5: B) Separation of concerns: easier to test, reuse, and maintain**\n\n\nModular design is a core programming principle.\n\n---\n\n",
              "code": "// Separated: easy to test each part\nval parsed = CsvParser.parseCSV(data)\nval validated = Validators.validate(parsed)\nval analyzed = Analytics.analyze(validated)\n\n// Each component can be:\n// - Tested independently\n// - Reused in different contexts\n// - Modified without affecting others\n// - Understood in isolation",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Final Thoughts",
              "content": "\n**You've Built a Complete Functional Application!**\n\nThis capstone project demonstrates that functional programming isn't just academic‚Äîit's practical and powerful for real-world applications.\n\n**Key Lessons**:\n1. **Composition**: Small functions ‚Üí Complex operations\n2. **Immutability**: Safer, easier to reason about\n3. **Declarative**: Expresses *what*, not *how*\n4. **Reusability**: Functions as building blocks\n5. **Testability**: Pure functions are easy to test\n\n**Next Steps**:\n- Add features from the extension challenges\n- Apply FP principles to your own projects\n- Explore Arrow library for advanced FP in Kotlin\n- Practice composing functions daily\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Additional Resources",
              "content": "\n**Libraries for Functional Kotlin**:\n- **Arrow**: Functional programming library (types, patterns)\n- **Kotlinx.coroutines**: Asynchronous functional patterns\n- **Exposed**: Functional SQL DSL\n\n**Further Reading**:\n- \"Functional Programming in Kotlin\" by Marco Vermeulen\n- \"Kotlin in Action\" by Dmitry Jemerov\n- Arrow documentation: arrow-kt.io\n\n**Practice Projects**:\n- Log analyzer with functional pipelines\n- JSON/XML transformer\n- Stream processing system\n- Configuration validator\n\n---\n\n**Congratulations on completing Part 3: Functional Programming!** üéâ\n\nYou've mastered:\n- Functional programming fundamentals\n- Lambda expressions and higher-order functions\n- Collection operations and sequences\n- Scope functions\n- Function composition and currying\n- Building real-world functional applications\n\nThese skills will make you a better programmer in any language. Functional thinking transcends Kotlin‚Äîit's a way of approaching problems that leads to elegant, maintainable solutions.\n\nKeep practicing, keep building, and enjoy the functional journey ahead!\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "4.7",
          "title": "Lesson 4.1: Generics and Type Parameters",
          "moduleId": "module-04",
          "order": 11,
          "estimatedMinutes": 70,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 70 minutes\n**Difficulty**: Advanced\n**Prerequisites**: Parts 1-3 (Kotlin fundamentals, OOP, Functional Programming)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Topic Introduction",
              "content": "\nWelcome to Part 4: Advanced Kotlin Features! You've mastered the fundamentals, object-oriented programming, and functional programming. Now it's time to explore the powerful features that make Kotlin a truly modern language.\n\nGenerics are one of the most important features in Kotlin. They allow you to write flexible, reusable code that works with different types while maintaining type safety. Without generics, you'd need to write the same code multiple times for different types or lose type safety by using `Any`.\n\nIn this lesson, you'll learn:\n- Generic classes and functions\n- Type parameters and constraints\n- Variance: `in`, `out`, and invariant types\n- Reified type parameters\n- Star projections\n- Generic constraints with `where`\n\nBy the end, you'll write type-safe, reusable code that works with any type!\n\n---\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "The Concept: Why Generics Matter",
              "content": "\n### The Problem Without Generics\n\nImagine you need to create a box that can hold different types of items:\n\n\n### The Solution: Generics\n\n\nGenerics let you write code once and use it with many types, while the compiler ensures everything is type-safe.\n\n---\n\n",
              "code": "// ‚úÖ With generics - one class, full type safety\nclass Box<T>(val value: T)\n\nval intBox = Box(42)           // Box<Int>\nval stringBox = Box(\"Hello\")   // Box<String>\nval personBox = Box(Person())  // Box<Person>\n\nval str: String = stringBox.value  // Type-safe!",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Generic Classes",
              "content": "\n### Basic Generic Class\n\nA generic class has type parameters in angle brackets:\n\n\n### Multiple Type Parameters\n\nClasses can have multiple type parameters:\n\n\n### Generic Collections\n\nKotlin's standard collections are generic:\n\n\n---\n\n",
              "code": "fun main() {\n    // List<T>\n    val numbers: List<Int> = listOf(1, 2, 3)\n    val words: List<String> = listOf(\"a\", \"b\", \"c\")\n\n    // Map<K, V>\n    val ages: Map<String, Int> = mapOf(\n        \"Alice\" to 25,\n        \"Bob\" to 30\n    )\n\n    // Set<T>\n    val uniqueNumbers: Set<Int> = setOf(1, 2, 2, 3)  // [1, 2, 3]\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Generic Functions",
              "content": "\nFunctions can also be generic:\n\n### Basic Generic Function\n\n\n### Generic Function with Type Inference\n\n\n### Generic Extension Functions\n\n\n---\n\n",
              "code": "fun <T> T.toSingletonList(): List<T> {\n    return listOf(this)\n}\n\nfun <T> List<T>.secondOrNull(): T? {\n    return if (size >= 2) this[1] else null\n}\n\nfun main() {\n    println(42.toSingletonList())  // [42]\n    println(\"Hello\".toSingletonList())  // [Hello]\n\n    println(listOf(1, 2, 3).secondOrNull())  // 2\n    println(listOf(\"a\").secondOrNull())       // null\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Type Constraints",
              "content": "\nType constraints restrict which types can be used with generics:\n\n### Upper Bound Constraints\n\nUse `:` to specify an upper bound:\n\n\n### Comparable Constraint\n\n\n### Multiple Constraints with `where`\n\nWhen you need multiple constraints, use `where`:\n\n\n---\n\n",
              "code": "interface Drawable {\n    fun draw()\n}\n\nclass Shape(val name: String) : Drawable, Comparable<Shape> {\n    override fun draw() {\n        println(\"Drawing $name\")\n    }\n\n    override fun compareTo(other: Shape): Int {\n        return name.compareTo(other.name)\n    }\n}\n\nfun <T> displayAndCompare(a: T, b: T) where T : Drawable, T : Comparable<T> {\n    a.draw()\n    b.draw()\n    println(\"${if (a > b) \"First\" else \"Second\"} is greater\")\n}\n\nfun main() {\n    val circle = Shape(\"Circle\")\n    val square = Shape(\"Square\")\n    displayAndCompare(circle, square)\n    // Drawing Circle\n    // Drawing Square\n    // Second is greater\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Variance: In, Out, and Invariant",
              "content": "\nVariance controls how generic types relate to each other based on their type parameters.\n\n### The Problem: Invariance\n\nBy default, generic types are **invariant**:\n\n\n### Covariance: `out` Keyword\n\nUse `out` when a type is only produced (output), never consumed:\n\n\n**Rule**: If a generic class only returns `T` (never accepts it), mark it `out T`.\n\n### Contravariance: `in` Keyword\n\nUse `in` when a type is only consumed (input), never produced:\n\n\n**Rule**: If a generic class only accepts `T` (never returns it), mark it `in T`.\n\n### Real-World Example: List vs MutableList\n\n\n### Variance Summary\n\n| Variance | Keyword | Usage | Example |\n|----------|---------|-------|---------|\n| **Covariant** | `out T` | Type is only produced | `List<out T>`, `Producer<out T>` |\n| **Contravariant** | `in T` | Type is only consumed | `Comparable<in T>`, `Consumer<in T>` |\n| **Invariant** | `T` | Type is both produced and consumed | `MutableList<T>`, `Box<T>` |\n\n---\n\n",
              "code": "fun main() {\n    // List<T> is covariant (out T)\n    val dogs: List<Dog> = listOf(Dog(), Dog())\n    val animals: List<Animal> = dogs  // ‚úÖ Works!\n\n    // MutableList<T> is invariant (can't be covariant or contravariant)\n    val mutableDogs: MutableList<Dog> = mutableListOf(Dog())\n    // val mutableAnimals: MutableList<Animal> = mutableDogs  // ‚ùå Error!\n    // Why? Because MutableList both produces and consumes\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Use-Site Variance: Type Projections",
              "content": "\nYou can specify variance at the use site instead of the declaration site:\n\n\n---\n\n",
              "code": "class Box<T>(var item: T)\n\nfun copyFrom(from: Box<out Animal>, to: Box<Animal>) {\n    to.item = from.item  // ‚úÖ Can read from 'from'\n}\n\nfun copyTo(from: Box<Animal>, to: Box<in Animal>) {\n    to.item = from.item  // ‚úÖ Can write to 'to'\n}\n\nfun main() {\n    val dogBox = Box(Dog())\n    val animalBox = Box<Animal>(Cat())\n\n    copyFrom(dogBox, animalBox)  // ‚úÖ Works with out projection\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Star Projections",
              "content": "\nStar projection `*` is used when you don't know or care about the type argument:\n\n\n**Rules for `List<*>`**:\n- Equivalent to `List<out Any?>`\n- You can read items (as `Any?`)\n- For `MutableList<*>`: can't add items, can only read\n\n---\n\n",
              "code": "fun printList(list: List<*>) {\n    for (item in list) {\n        println(item)  // item is Any?\n    }\n}\n\nfun main() {\n    printList(listOf(1, 2, 3))\n    printList(listOf(\"a\", \"b\", \"c\"))\n\n    // Star projection on mutable types\n    val anyList: MutableList<*> = mutableListOf(1, 2, 3)\n    // anyList.add(4)  // ‚ùå Error: can't add to MutableList<*>\n    val item = anyList[0]  // ‚úÖ Can read (as Any?)\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Reified Type Parameters",
              "content": "\nNormally, type information is erased at runtime. `reified` preserves it:\n\n### The Problem: Type Erasure\n\n\n### The Solution: Reified\n\n\n### Reified with Class Checking\n\n\n### Reified with JSON Parsing (Practical Example)\n\n\n**Requirements for `reified`**:\n- Function must be `inline`\n- Can use `is`, `as`, `::class` with type parameter\n- Cannot be used in non-inline functions\n\n---\n\n",
              "code": "import kotlin.reflect.KClass\n\n// Simulated JSON parser\ninline fun <reified T : Any> parseJson(json: String): T {\n    println(\"Parsing JSON to ${T::class.simpleName}\")\n    // In real code, you'd use a JSON library\n    return when (T::class) {\n        String::class -> json as T\n        Int::class -> json.toInt() as T\n        else -> throw IllegalArgumentException(\"Unsupported type\")\n    }\n}\n\nfun main() {\n    val str = parseJson<String>(\"\\\"Hello\\\"\")\n    val num = parseJson<Int>(\"42\")\n\n    println(\"String: $str\")  // String: \"Hello\"\n    println(\"Int: $num\")     // Int: 42\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Generic Constraints with Where",
              "content": "\nComplex constraints often need the `where` clause:\n\n\n### Multiple Constraints Example\n\n\n---\n\n",
              "code": "fun <T> findMax(items: List<T>) where T : Comparable<T>, T : Number {\n    val max = items.maxOrNull()\n    max?.let {\n        println(\"Max value: $it, Double value: ${it.toDouble()}\")\n    }\n}\n\nfun main() {\n    findMax(listOf(1, 5, 3, 9, 2))\n    // Max value: 9, Double value: 9.0\n\n    findMax(listOf(1.5, 2.8, 0.9))\n    // Max value: 2.8, Double value: 2.8\n}",
              "language": "kotlin"
            },
            {
              "type": "EXAMPLE",
              "title": "Practical Examples",
              "content": "\n### Generic Repository Pattern\n\n\n### Generic Result Type\n\n\n---\n\n",
              "code": "sealed class Result<out T> {\n    data class Success<T>(val data: T) : Result<T>()\n    data class Error(val message: String) : Result<Nothing>()\n    object Loading : Result<Nothing>()\n\n    fun <R> map(transform: (T) -> R): Result<R> = when (this) {\n        is Success -> Success(transform(data))\n        is Error -> this\n        is Loading -> this\n    }\n\n    fun getOrNull(): T? = when (this) {\n        is Success -> data\n        else -> null\n    }\n}\n\nfun fetchUser(id: Int): Result<String> {\n    return if (id > 0) {\n        Result.Success(\"User $id\")\n    } else {\n        Result.Error(\"Invalid user ID\")\n    }\n}\n\nfun main() {\n    val result1 = fetchUser(42)\n    println(result1.getOrNull())  // User 42\n\n    val result2 = fetchUser(-1)\n    println(result2.getOrNull())  // null\n\n    val mapped = result1.map { it.uppercase() }\n    println(mapped.getOrNull())  // USER 42\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercises",
              "content": "\n### Exercise 1: Generic Stack (Medium)\n\nCreate a generic `Stack<T>` class with push, pop, and peek operations.\n\n**Requirements**:\n- `push(item: T)` - add item to top\n- `pop(): T?` - remove and return top item\n- `peek(): T?` - return top item without removing\n- `isEmpty(): Boolean` - check if stack is empty\n- `size: Int` - number of items in stack\n\n**Solution**:\n\n\n### Exercise 2: Generic Tree with Comparable (Hard)\n\nCreate a generic binary search tree that stores comparable items.\n\n**Requirements**:\n- `insert(value: T)` - add value to tree\n- `contains(value: T): Boolean` - check if value exists\n- `toSortedList(): List<T>` - return sorted list of all values\n\n**Solution**:\n\n\n### Exercise 3: Generic Cache with Constraints (Hard)\n\nCreate a generic cache that stores serializable items with expiration.\n\n**Requirements**:\n- Type must be serializable (toString/equals)\n- `put(key: String, value: T, ttlSeconds: Int)` - store with expiration\n- `get(key: String): T?` - retrieve if not expired\n- `clear()` - remove all entries\n- `size: Int` - number of valid entries\n\n**Solution**:\n\n\n---\n\n",
              "code": "import java.time.Instant\n\nclass Cache<T : Any> {\n    private data class CacheEntry<T>(\n        val value: T,\n        val expiresAt: Long\n    ) {\n        fun isExpired(): Boolean {\n            return System.currentTimeMillis() > expiresAt\n        }\n    }\n\n    private val storage = mutableMapOf<String, CacheEntry<T>>()\n\n    fun put(key: String, value: T, ttlSeconds: Int = 60) {\n        val expiresAt = System.currentTimeMillis() + (ttlSeconds * 1000)\n        storage[key] = CacheEntry(value, expiresAt)\n        cleanupExpired()\n    }\n\n    fun get(key: String): T? {\n        val entry = storage[key] ?: return null\n\n        return if (entry.isExpired()) {\n            storage.remove(key)\n            null\n        } else {\n            entry.value\n        }\n    }\n\n    fun clear() {\n        storage.clear()\n    }\n\n    val size: Int\n        get() {\n            cleanupExpired()\n            return storage.size\n        }\n\n    private fun cleanupExpired() {\n        storage.entries.removeIf { it.value.isExpired() }\n    }\n\n    fun getAllKeys(): Set<String> {\n        cleanupExpired()\n        return storage.keys.toSet()\n    }\n}\n\nfun main() {\n    val cache = Cache<String>()\n\n    cache.put(\"user1\", \"Alice\", 2)\n    cache.put(\"user2\", \"Bob\", 5)\n\n    println(\"Get user1: ${cache.get(\"user1\")}\")  // Alice\n    println(\"Size: ${cache.size}\")                // 2\n\n    // Wait for expiration (in real code)\n    Thread.sleep(2100)\n\n    println(\"Get user1 after expiration: ${cache.get(\"user1\")}\")  // null\n    println(\"Get user2: ${cache.get(\"user2\")}\")   // Bob\n    println(\"Size: ${cache.size}\")                // 1\n\n    // Works with any type\n    val numberCache = Cache<Int>()\n    numberCache.put(\"count\", 42, 10)\n    println(\"Count: ${numberCache.get(\"count\")}\")  // 42\n\n    cache.clear()\n    println(\"Size after clear: ${cache.size}\")  // 0\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Checkpoint Quiz",
              "content": "\nTest your understanding of generics!\n\n### Question 1: Type Parameter Syntax\n\nWhat does this function signature mean?\n\n**A)** T can be any type\n**B)** T must be Number or its subtype\n**C)** T must be exactly Number\n**D)** T can be Number or Any\n\n**Answer**: **B** - The `: Number` constraint means T must be Number or any of its subtypes (Int, Double, Float, etc.)\n\n---\n\n### Question 2: Variance\n\nWhich statement is correct about variance?\n\n**A)** `out` is used when a type is only consumed\n**B)** `in` is used when a type is only produced\n**C)** `out` makes a type covariant (producer)\n**D)** Invariant types can be used as both covariant and contravariant\n\n**Answer**: **C** - `out` makes a type covariant, meaning it can only be produced/returned, not consumed. `in` makes it contravariant (consumer).\n\n---\n\n### Question 3: Reified Type Parameters\n\nWhat is required to use reified type parameters?\n\n**A)** The function must be suspend\n**B)** The function must be inline\n**C)** The class must be open\n**D)** The type must be nullable\n\n**Answer**: **B** - Reified type parameters require the function to be `inline` so the compiler can substitute the actual type at call sites.\n\n---\n\n### Question 4: Star Projection\n\nWhat can you do with a `MutableList<*>`?\n\n**A)** Add and remove elements\n**B)** Only add elements\n**C)** Only read elements\n**D)** Nothing at all\n\n**Answer**: **C** - `MutableList<*>` can only read elements (as `Any?`). You cannot add elements because the compiler doesn't know the actual type.\n\n---\n\n### Question 5: Multiple Constraints\n\nHow do you specify multiple type constraints?\n\n\n**A)** Separate with commas inside angle brackets\n**B)** Use `where` clause with commas\n**C)** Use multiple angle brackets\n**D)** Not possible in Kotlin\n\n**Answer**: **B** - Multiple constraints use the `where` clause: `fun <T> process(item: T) where T : Constraint1, T : Constraint2`\n\n---\n\n",
              "code": "fun <T> process(item: T) where T : _____, T : _____",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Summary",
              "content": "\nCongratulations! You've mastered Kotlin generics. Here's what you learned:\n\n‚úÖ **Generic Classes and Functions** - Write reusable code for any type\n‚úÖ **Type Constraints** - Restrict types with upper bounds\n‚úÖ **Variance** - Understand `out` (covariant), `in` (contravariant), and invariant\n‚úÖ **Reified Type Parameters** - Preserve type information at runtime\n‚úÖ **Star Projections** - Work with unknown types safely\n‚úÖ **Generic Constraints** - Use `where` for multiple bounds\n\n### Key Takeaways\n\n1. **Generics provide type safety** without code duplication\n2. **Use `out`** when you only return a type (producer)\n3. **Use `in`** when you only accept a type (consumer)\n4. **`reified` requires `inline`** but gives runtime type access\n5. **Star projection `*`** is useful when the exact type doesn't matter\n\n### Next Steps\n\nIn the next lesson, we'll dive into **Coroutines Fundamentals** - Kotlin's powerful approach to asynchronous programming. You'll learn how to write concurrent code that's easy to read and maintain!\n\n---\n\n**Practice Challenge**: Create a generic `Pool<T>` class that manages reusable objects (like database connections). Implement `acquire()` to get an object and `release(obj: T)` to return it to the pool.\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "4.8",
          "title": "Lesson 4.2: Coroutines Fundamentals",
          "moduleId": "module-04",
          "order": 12,
          "estimatedMinutes": 75,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 75 minutes\n**Difficulty**: Advanced\n**Prerequisites**: Parts 1-3, Lesson 4.1 (Generics)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Topic Introduction",
              "content": "\nTraditional programming is synchronous - your code waits for each operation to complete before moving to the next one. When dealing with slow operations like network requests, file I/O, or database queries, this leads to blocked threads and poor performance.\n\nCoroutines are Kotlin's solution to asynchronous programming. They allow you to write asynchronous code that looks and behaves like synchronous code, making it much easier to understand and maintain.\n\nIn this lesson, you'll learn:\n- What coroutines are and why they matter\n- Suspend functions - the building blocks of coroutines\n- Launching coroutines with `launch`, `async`, and `runBlocking`\n- Coroutine scopes and contexts\n- Job and Deferred for managing coroutines\n- Basic patterns for async operations\n\nBy the end, you'll write efficient concurrent code that's as easy to read as sequential code!\n\n---\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "The Concept: Why Coroutines Matter",
              "content": "\n### The Problem: Blocking Code\n\n\n### Traditional Solution: Threads\n\n\n### The Coroutine Solution\n\n\n**Key Differences**:\n- Coroutines are lightweight (thousands can run on one thread)\n- `delay()` doesn't block the thread\n- Code looks sequential but runs concurrently\n- Easy to manage and cancel\n\n---\n\n",
              "code": "import kotlinx.coroutines.*\n\nsuspend fun fetchUser(userId: Int): String {\n    delay(1000)  // Non-blocking delay\n    return \"User $userId\"\n}\n\nfun main() = runBlocking {\n    println(\"Fetching users...\")\n\n    val user1 = async { fetchUser(1) }\n    val user2 = async { fetchUser(2) }\n\n    println(\"Got ${user1.await()}\")\n    println(\"Got ${user2.await()}\")\n\n    // Total time: ~1 second (concurrent)\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Setting Up Coroutines",
              "content": "\nTo use coroutines, add the dependency to your `build.gradle.kts`:\n\n\nImport the coroutines package:\n\n\n---\n\n",
              "code": "import kotlinx.coroutines.*",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Suspend Functions",
              "content": "\nSuspend functions are the foundation of coroutines. They can be paused and resumed without blocking a thread.\n\n### Basic Suspend Function\n\n\n### Suspend Functions Can Call Other Suspend Functions\n\n\n### Why Suspend?\n\nThe `suspend` keyword tells the compiler:\n- This function may take time\n- It can be paused and resumed\n- It doesn't block the thread\n- It can only be called from a coroutine or another suspend function\n\n\n---\n\n",
              "code": "suspend fun example() {\n    // Can call:\n    delay(1000)           // ‚úÖ Suspend function\n    fetchData()           // ‚úÖ Suspend function\n    println(\"Hello\")      // ‚úÖ Regular function\n    val x = 1 + 2         // ‚úÖ Regular code\n\n    // Thread.sleep(1000) // ‚ö†Ô∏è Works but blocks thread (avoid!)\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Coroutine Builders",
              "content": "\nCoroutine builders create and launch coroutines.\n\n### `runBlocking` - Bridge to the Blocking World\n\n`runBlocking` starts a coroutine and blocks the current thread until it completes:\n\n\n**When to use**: Main functions, tests. Avoid in production code (blocks thread).\n\n### `launch` - Fire and Forget\n\n`launch` starts a coroutine that runs in the background:\n\n\n**Returns**: `Job` - handle to manage the coroutine\n\n\n### `async` - Return a Result\n\n`async` is like `launch` but returns a result:\n\n\n**Returns**: `Deferred<T>` - a future result\n\n### Concurrent Execution with `async`\n\n\n---\n\n",
              "code": "suspend fun fetchUser(id: Int): String {\n    delay(1000)\n    return \"User $id\"\n}\n\nsuspend fun fetchPosts(userId: Int): List<String> {\n    delay(1000)\n    return listOf(\"Post 1\", \"Post 2\")\n}\n\nfun main() = runBlocking {\n    val startTime = System.currentTimeMillis()\n\n    // Sequential (slow)\n    val user = fetchUser(1)\n    val posts = fetchPosts(1)\n    println(\"Sequential time: ${System.currentTimeMillis() - startTime}ms\")\n    // ~2000ms\n\n    // Concurrent (fast)\n    val startTime2 = System.currentTimeMillis()\n    val userDeferred = async { fetchUser(1) }\n    val postsDeferred = async { fetchPosts(1) }\n\n    val user2 = userDeferred.await()\n    val posts2 = postsDeferred.await()\n    println(\"Concurrent time: ${System.currentTimeMillis() - startTime2}ms\")\n    // ~1000ms\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Coroutine Scope",
              "content": "\nEvery coroutine runs inside a scope. Scopes define lifecycle and context.\n\n### What is a Scope?\n\n\n### Creating Custom Scopes\n\n\n### Structured Concurrency\n\nChild coroutines are automatically cancelled when parent scope is cancelled:\n\n\n---\n\n",
              "code": "fun main() = runBlocking {\n    val parentJob = launch {\n        launch {\n            repeat(10) {\n                delay(500)\n                println(\"Child 1: $it\")\n            }\n        }\n\n        launch {\n            repeat(10) {\n                delay(500)\n                println(\"Child 2: $it\")\n            }\n        }\n    }\n\n    delay(1500)\n    println(\"Cancelling parent\")\n    parentJob.cancel()  // Cancels all children too\n    delay(1000)\n}\n// Output:\n// Child 1: 0\n// Child 2: 0\n// Child 1: 1\n// Child 2: 1\n// Cancelling parent",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Coroutine Context",
              "content": "\nEvery coroutine has a context that includes:\n- **Job** - manages lifecycle\n- **Dispatcher** - determines which thread(s) to use\n- **CoroutineName** - for debugging\n- **Exception handler** - handles errors\n\n### Dispatchers\n\nDispatchers determine which thread pool a coroutine runs on:\n\n\n**Common Dispatchers**:\n- `Dispatchers.Default` - CPU-intensive tasks (sorting, calculations)\n- `Dispatchers.IO` - I/O operations (network, database, files)\n- `Dispatchers.Main` - UI updates (Android, JavaFX)\n- `Dispatchers.Unconfined` - not confined to specific thread\n\n### Switching Contexts with `withContext`\n\n\n---\n\n",
              "code": "suspend fun fetchAndProcess() = withContext(Dispatchers.IO) {\n    // Fetch data on IO dispatcher\n    val data = fetchDataFromNetwork()\n\n    withContext(Dispatchers.Default) {\n        // Process on Default dispatcher\n        processData(data)\n    }\n}\n\nsuspend fun fetchDataFromNetwork(): String {\n    delay(1000)\n    return \"Network data\"\n}\n\nsuspend fun processData(data: String): String {\n    delay(500)\n    return \"Processed: $data\"\n}\n\nfun main() = runBlocking {\n    val result = fetchAndProcess()\n    println(result)\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Job - Managing Coroutine Lifecycle",
              "content": "\nA `Job` represents a coroutine and allows you to manage its lifecycle.\n\n### Job Basics\n\n\n### Job States\n\n\n### Cancellation is Cooperative\n\nCoroutines must cooperate to be cancellable:\n\n\n### Making Code Cancellable\n\n\n---\n\n",
              "code": "import kotlinx.coroutines.isActive\n\nfun main() = runBlocking {\n    val job = launch {\n        var i = 0\n        while (isActive) {  // ‚úÖ Check if still active\n            println(\"Job: $i\")\n            Thread.sleep(500)\n            i++\n        }\n        println(\"Cleaning up...\")\n    }\n\n    delay(1200)\n    job.cancel()\n    job.join()\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Deferred - Async Results",
              "content": "\n`Deferred<T>` is a `Job` that returns a result.\n\n### Basic Usage\n\n\n### Multiple Async Operations\n\n\n### Error Handling with Deferred\n\n\n---\n\n",
              "code": "fun main() = runBlocking {\n    val deferred = async {\n        delay(500)\n        throw RuntimeException(\"Error!\")\n    }\n\n    try {\n        deferred.await()  // Exception thrown here\n    } catch (e: Exception) {\n        println(\"Caught: ${e.message}\")\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Common Patterns",
              "content": "\n### Pattern 1: Parallel Decomposition\n\nExecute multiple independent tasks concurrently:\n\n\n### Pattern 2: Sequential with Suspending\n\n\n### Pattern 3: Timeout\n\n\n### Pattern 4: Lazy Async\n\n\n---\n\n",
              "code": "fun main() = runBlocking {\n    val deferred = async(start = CoroutineStart.LAZY) {\n        println(\"Computing...\")\n        delay(1000)\n        42\n    }\n\n    println(\"Created async\")\n    delay(2000)\n    println(\"Starting computation\")\n    val result = deferred.await()  // Starts computation here\n    println(\"Result: $result\")\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercises",
              "content": "\n### Exercise 1: Concurrent API Calls (Medium)\n\nSimulate fetching data from multiple APIs concurrently.\n\n**Requirements**:\n- Create 3 suspend functions that simulate API calls (1-2 second delays)\n- Fetch all data concurrently\n- Print total time taken\n- Handle potential errors\n\n**Solution**:\n\n\n### Exercise 2: Progress Reporter (Medium)\n\nCreate a progress reporter that runs while a long task executes.\n\n**Requirements**:\n- Long-running task (5 seconds)\n- Progress reporter updates every 500ms\n- Stop progress when task completes\n- Show final result\n\n**Solution**:\n\n\n### Exercise 3: Retry Logic (Hard)\n\nImplement retry logic for a failing operation.\n\n**Requirements**:\n- Suspend function that may fail\n- Retry up to 3 times with exponential backoff\n- Return result on success or throw after max retries\n- Log each attempt\n\n**Solution**:\n\n\n---\n\n",
              "code": "import kotlinx.coroutines.*\nimport kotlin.random.Random\n\nclass RetryException(message: String) : Exception(message)\n\nsuspend fun unreliableOperation(): String {\n    delay(500)\n\n    // 70% chance of failure\n    if (Random.nextInt(100) < 70) {\n        throw RetryException(\"Operation failed\")\n    }\n\n    return \"Success!\"\n}\n\nsuspend fun <T> retryWithBackoff(\n    maxRetries: Int = 3,\n    initialDelay: Long = 100,\n    maxDelay: Long = 2000,\n    factor: Double = 2.0,\n    operation: suspend () -> T\n): T {\n    var currentDelay = initialDelay\n\n    repeat(maxRetries) { attempt ->\n        try {\n            println(\"Attempt ${attempt + 1}...\")\n            return operation()\n        } catch (e: Exception) {\n            println(\"Failed: ${e.message}\")\n\n            if (attempt == maxRetries - 1) {\n                throw e\n            }\n\n            println(\"Retrying in ${currentDelay}ms...\")\n            delay(currentDelay)\n\n            currentDelay = (currentDelay * factor).toLong().coerceAtMost(maxDelay)\n        }\n    }\n\n    throw RetryException(\"Max retries exceeded\")\n}\n\nfun main() = runBlocking {\n    try {\n        val result = retryWithBackoff {\n            unreliableOperation()\n        }\n        println(\"\\n$result\")\n    } catch (e: Exception) {\n        println(\"\\nGave up after max retries: ${e.message}\")\n    }\n}\n\n// Possible output:\n// Attempt 1...\n// Failed: Operation failed\n// Retrying in 100ms...\n// Attempt 2...\n// Failed: Operation failed\n// Retrying in 200ms...\n// Attempt 3...\n// Success!",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Checkpoint Quiz",
              "content": "\n### Question 1: Suspend Functions\n\nWhat is true about suspend functions?\n\n**A)** They always run on a background thread\n**B)** They can only be called from coroutines or other suspend functions\n**C)** They block the calling thread\n**D)** They must always use delay()\n\n**Answer**: **B** - Suspend functions can only be called from coroutines or other suspend functions. They don't necessarily run on background threads and don't block threads.\n\n---\n\n### Question 2: Coroutine Builders\n\nWhat's the difference between `launch` and `async`?\n\n**A)** `launch` returns a result, `async` doesn't\n**B)** `launch` is for sequential code, `async` for concurrent\n**C)** `launch` returns Job (no result), `async` returns Deferred (with result)\n**D)** They are identical\n\n**Answer**: **C** - `launch` returns a `Job` for fire-and-forget tasks, while `async` returns a `Deferred<T>` that can provide a result via `await()`.\n\n---\n\n### Question 3: Dispatchers\n\nWhich dispatcher should you use for network requests?\n\n**A)** Dispatchers.Default\n**B)** Dispatchers.Main\n**C)** Dispatchers.IO\n**D)** Dispatchers.Unconfined\n\n**Answer**: **C** - `Dispatchers.IO` is optimized for I/O operations like network requests, file operations, and database queries.\n\n---\n\n### Question 4: Cancellation\n\nWhy doesn't this coroutine cancel properly?\n\n\n**A)** Missing job.join()\n**B)** Thread.sleep doesn't check for cancellation\n**C)** while(true) prevents cancellation\n**D)** launch doesn't support cancellation\n\n**Answer**: **B** - `Thread.sleep()` doesn't check for cancellation. Use `delay()` or check `isActive` in the loop.\n\n---\n\n### Question 5: Structured Concurrency\n\nWhat happens when a parent coroutine is cancelled?\n\n**A)** Child coroutines continue running\n**B)** Only the parent is cancelled\n**C)** All child coroutines are automatically cancelled\n**D)** An exception is thrown\n\n**Answer**: **C** - Structured concurrency ensures that when a parent coroutine is cancelled, all its children are automatically cancelled too.\n\n---\n\n",
              "code": "val job = launch {\n    while (true) {\n        Thread.sleep(500)\n        println(\"Working\")\n    }\n}\njob.cancel()",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Summary",
              "content": "\nCongratulations! You've learned the fundamentals of Kotlin coroutines. Here's what you covered:\n\n‚úÖ **Suspend Functions** - Building blocks of coroutines\n‚úÖ **Coroutine Builders** - `launch`, `async`, `runBlocking`\n‚úÖ **Coroutine Scope** - Lifecycle and structured concurrency\n‚úÖ **Coroutine Context** - Jobs, dispatchers, and configuration\n‚úÖ **Job & Deferred** - Managing coroutines and results\n‚úÖ **Common Patterns** - Parallel execution, timeouts, retries\n\n### Key Takeaways\n\n1. **Suspend functions** don't block threads - they suspend and resume\n2. **Use `launch`** for fire-and-forget tasks\n3. **Use `async`** when you need a result\n4. **`Dispatchers.IO`** for I/O, `Dispatchers.Default` for CPU work\n5. **Cancellation is cooperative** - use `delay()` or check `isActive`\n6. **Structured concurrency** automatically manages child coroutines\n\n### Next Steps\n\nIn the next lesson, we'll dive into **Advanced Coroutines** - exploring Flows for reactive streams, channels for communication, exception handling, and advanced patterns!\n\n---\n\n**Practice Challenge**: Build a download manager that downloads multiple files concurrently, shows progress for each file, and allows cancelling individual downloads or all downloads at once.\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "4.9",
          "title": "Lesson 4.3: Advanced Coroutines",
          "moduleId": "module-04",
          "order": 13,
          "estimatedMinutes": 75,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 75 minutes\n**Difficulty**: Advanced\n**Prerequisites**: Lesson 4.2 (Coroutines Fundamentals)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Topic Introduction",
              "content": "\nNow that you understand coroutine basics, it's time to explore the advanced features that make coroutines truly powerful. These features enable you to build reactive systems, handle streams of data, communicate between coroutines, and gracefully handle errors in concurrent code.\n\nIn this lesson, you'll learn:\n- Structured concurrency patterns\n- Exception handling in coroutines\n- Flows for reactive streams\n- Channels for coroutine communication\n- StateFlow and SharedFlow for state management\n- `withContext` for context switching\n- Advanced dispatchers and supervisors\n\nBy the end, you'll build production-ready concurrent applications!\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Structured Concurrency",
              "content": "\nStructured concurrency ensures coroutines have a clear lifecycle and don't leak.\n\n### The Principle\n\nCoroutines should:\n1. Have a clear parent-child relationship\n2. Be automatically cancelled when parent is cancelled\n3. Complete or fail together as a unit\n\n\n### `coroutineScope` - Structured Concurrency Builder\n\n`coroutineScope` creates a scope that completes only when all children complete:\n\n\nIf any child fails, all siblings are cancelled:\n\n\n### `supervisorScope` - Independent Children\n\n`supervisorScope` allows children to fail independently:\n\n\n---\n\n",
              "code": "suspend fun fetchWithSupervision() = supervisorScope {\n    launch {\n        delay(500)\n        println(\"Task 1 completed\")\n    }\n\n    launch {\n        delay(300)\n        throw RuntimeException(\"Task 2 failed!\")\n    }\n\n    launch {\n        delay(700)\n        println(\"Task 3 completed\")  // Still executes\n    }\n}\n\nfun main() = runBlocking {\n    try {\n        fetchWithSupervision()\n        delay(1000)\n    } catch (e: Exception) {\n        println(\"Caught: ${e.message}\")\n    }\n}\n// Output:\n// Task 1 completed\n// Task 3 completed",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exception Handling in Coroutines",
              "content": "\nException handling in coroutines has special rules.\n\n### Try-Catch in Coroutines\n\n\n### Try-Catch Outside Launch (Doesn't Work!)\n\n\n### Exception Handling with Async\n\n\n### CoroutineExceptionHandler\n\nGlobal exception handler for coroutines:\n\n\n### SupervisorJob for Independent Failures\n\n\n---\n\n",
              "code": "fun main() = runBlocking {\n    val supervisor = SupervisorJob()\n    val scope = CoroutineScope(Dispatchers.Default + supervisor)\n\n    val job1 = scope.launch {\n        delay(500)\n        println(\"Job 1 completed\")\n    }\n\n    val job2 = scope.launch {\n        delay(300)\n        throw RuntimeException(\"Job 2 failed!\")\n    }\n\n    val job3 = scope.launch {\n        delay(700)\n        println(\"Job 3 completed\")\n    }\n\n    joinAll(job1, job2, job3)\n    supervisor.cancel()\n}\n// Output:\n// Job 1 completed\n// Job 3 completed",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Flows - Reactive Streams",
              "content": "\nFlows represent asynchronous streams of values.\n\n### Basic Flow\n\n\n### Flow Builders\n\n\n### Flow Operators\n\n\n### Flow Context\n\nFlows preserve the context of the collector:\n\n\n### `flowOn` - Change Flow Context\n\n\n### Buffer and Conflate\n\n\n### Combining Flows\n\n\n### Flow Completion\n\n\n---\n\n",
              "code": "fun main() = runBlocking {\n    (1..3).asFlow()\n        .onEach { println(\"Emitting $it\") }\n        .onCompletion { println(\"Flow completed\") }\n        .collect { println(\"Collected $it\") }\n\n    // With exception handling\n    flow {\n        emit(1)\n        throw RuntimeException(\"Error!\")\n    }\n        .onCompletion { cause ->\n            if (cause != null) {\n                println(\"Completed with error: ${cause.message}\")\n            }\n        }\n        .catch { println(\"Caught: ${it.message}\") }\n        .collect()\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Channels - Communication Between Coroutines",
              "content": "\nChannels are hot streams for sending data between coroutines.\n\n### Basic Channel\n\n\n### Producer-Consumer Pattern\n\n\n### Channel Buffering\n\n\n### Fan-out and Fan-in\n\n\n---\n\n",
              "code": "// Fan-out - multiple consumers\nfun CoroutineScope.produceNumbers() = produce<Int> {\n    var x = 1\n    while (true) {\n        send(x++)\n        delay(100)\n    }\n}\n\nfun CoroutineScope.consumeNumbers(id: Int, channel: ReceiveChannel<Int>) = launch {\n    for (msg in channel) {\n        println(\"Consumer $id received $msg\")\n    }\n}\n\nfun main() = runBlocking {\n    val producer = produceNumbers()\n\n    repeat(3) {\n        consumeNumbers(it + 1, producer)\n    }\n\n    delay(1000)\n    producer.cancel()\n}\n\n// Fan-in - multiple producers\nsuspend fun sendString(channel: SendChannel<String>, s: String, time: Long) {\n    while (true) {\n        delay(time)\n        channel.send(s)\n    }\n}\n\nfun main2() = runBlocking {\n    val channel = Channel<String>()\n\n    launch { sendString(channel, \"foo\", 200) }\n    launch { sendString(channel, \"bar\", 500) }\n\n    repeat(10) {\n        println(channel.receive())\n    }\n\n    coroutineContext.cancelChildren()\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "StateFlow and SharedFlow",
              "content": "\nHot flows that maintain state or broadcast values.\n\n### StateFlow - State Holder\n\n\n### StateFlow Features\n\n\n### SharedFlow - Event Broadcaster\n\n\n### SharedFlow with Replay\n\n\n---\n\n",
              "code": "fun main() = runBlocking {\n    val sharedFlow = MutableSharedFlow<Int>(replay = 2)\n\n    sharedFlow.emit(1)\n    sharedFlow.emit(2)\n    sharedFlow.emit(3)\n\n    // New collector gets last 2 values\n    sharedFlow.collect {\n        println(\"Received: $it\")\n    }\n}\n// Output:\n// Received: 2\n// Received: 3",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Advanced Context Switching",
              "content": "\n### `withContext` - Temporary Context Switch\n\n\n### Context Elements\n\n\n---\n\n",
              "code": "fun main() = runBlocking {\n    val context = CoroutineName(\"MyCoroutine\") + Dispatchers.Default\n\n    launch(context) {\n        println(\"Running in: ${coroutineContext[CoroutineName]?.name}\")\n        println(\"On thread: ${Thread.currentThread().name}\")\n    }\n\n    delay(100)\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercises",
              "content": "\n### Exercise 1: Temperature Monitor with Flow (Medium)\n\nCreate a temperature monitoring system using Flow.\n\n**Requirements**:\n- Generate random temperatures every second\n- Filter temperatures above 30¬∞C\n- Calculate running average\n- Emit alerts for high temperatures\n\n**Solution**:\n\n\n### Exercise 2: Download Manager with Channels (Hard)\n\nBuild a concurrent download manager using channels.\n\n**Requirements**:\n- Multiple download workers\n- Task queue with channel\n- Progress reporting\n- Completion notification\n\n**Solution**:\n\n\n### Exercise 3: Real-Time Chat with StateFlow (Hard)\n\nCreate a simple chat system with StateFlow for state management.\n\n**Requirements**:\n- User state (online/offline)\n- Message history\n- Real-time updates\n- Multiple observers\n\n**Solution**:\n\n\n---\n\n",
              "code": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\ndata class Message(val user: String, val text: String, val timestamp: Long)\ndata class ChatState(\n    val users: Set<String>,\n    val messages: List<Message>\n)\n\nclass ChatRoom {\n    private val _state = MutableStateFlow(ChatState(emptySet(), emptyList()))\n    val state: StateFlow<ChatState> = _state\n\n    fun userJoin(username: String) {\n        _state.value = _state.value.copy(\n            users = _state.value.users + username,\n            messages = _state.value.messages + Message(\n                \"System\",\n                \"$username joined\",\n                System.currentTimeMillis()\n            )\n        )\n    }\n\n    fun userLeave(username: String) {\n        _state.value = _state.value.copy(\n            users = _state.value.users - username,\n            messages = _state.value.messages + Message(\n                \"System\",\n                \"$username left\",\n                System.currentTimeMillis()\n            )\n        )\n    }\n\n    fun sendMessage(username: String, text: String) {\n        _state.value = _state.value.copy(\n            messages = _state.value.messages + Message(\n                username,\n                text,\n                System.currentTimeMillis()\n            )\n        )\n    }\n}\n\nfun main() = runBlocking {\n    val chatRoom = ChatRoom()\n\n    // Observer 1\n    launch {\n        chatRoom.state\n            .map { it.users.size }\n            .distinctUntilChanged()\n            .collect { count ->\n                println(\"üë• Users online: $count\")\n            }\n    }\n\n    // Observer 2\n    launch {\n        chatRoom.state\n            .map { it.messages.lastOrNull() }\n            .filterNotNull()\n            .collect { msg ->\n                println(\"üí¨ [${msg.user}]: ${msg.text}\")\n            }\n    }\n\n    delay(100)\n\n    chatRoom.userJoin(\"Alice\")\n    delay(100)\n    chatRoom.userJoin(\"Bob\")\n    delay(100)\n    chatRoom.sendMessage(\"Alice\", \"Hello, Bob!\")\n    delay(100)\n    chatRoom.sendMessage(\"Bob\", \"Hi, Alice!\")\n    delay(100)\n    chatRoom.userLeave(\"Alice\")\n\n    delay(500)\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Checkpoint Quiz",
              "content": "\n### Question 1: Structured Concurrency\n\nWhat happens in `coroutineScope` if one child fails?\n\n**A)** Only that child is cancelled\n**B)** All children are cancelled and exception is propagated\n**C)** The exception is ignored\n**D)** Other children continue running\n\n**Answer**: **B** - In `coroutineScope`, if one child fails, all siblings are cancelled and the exception is propagated to the parent.\n\n---\n\n### Question 2: Flow vs Channel\n\nWhat's the main difference between Flow and Channel?\n\n**A)** Flow is hot, Channel is cold\n**B)** Flow is cold (lazy), Channel is hot (active)\n**C)** They are the same\n**D)** Channel can't be cancelled\n\n**Answer**: **B** - Flow is cold (starts on collection), while Channel is hot (actively sends/receives regardless of consumers).\n\n---\n\n### Question 3: StateFlow\n\nWhat makes StateFlow special?\n\n**A)** It's the fastest flow type\n**B)** It always has a current value and conflates duplicates\n**C)** It can only emit once\n**D)** It doesn't support multiple collectors\n\n**Answer**: **B** - StateFlow always has a current value (accessible via `.value`) and automatically conflates duplicate consecutive values.\n\n---\n\n### Question 4: Exception Handling\n\nWhy doesn't this catch the exception?\n\n\n**A)** launch is not a suspend function\n**B)** launch is fire-and-forget, exception happens async\n**C)** Exception handling doesn't work in coroutines\n**D)** Missing await()\n\n**Answer**: **B** - `launch` returns immediately (fire-and-forget), so the exception happens asynchronously after the try-catch block.\n\n---\n\n### Question 5: flowOn\n\nWhat does `flowOn` do?\n\n**A)** Changes the dispatcher for downstream operators\n**B)** Changes the dispatcher for upstream operators\n**C)** Stops the flow\n**D)** Buffers the flow\n\n**Answer**: **B** - `flowOn` changes the dispatcher for upstream operators (everything before it in the chain).\n\n---\n\n",
              "code": "try {\n    launch {\n        throw Exception(\"Error\")\n    }\n} catch (e: Exception) {\n    println(\"Caught\")\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Summary",
              "content": "\nCongratulations! You've mastered advanced coroutines. Here's what you learned:\n\n‚úÖ **Structured Concurrency** - `coroutineScope` and `supervisorScope`\n‚úÖ **Exception Handling** - Try-catch patterns and exception handlers\n‚úÖ **Flows** - Reactive streams with operators and transformations\n‚úÖ **Channels** - Communication between coroutines\n‚úÖ **StateFlow/SharedFlow** - State management and event broadcasting\n‚úÖ **Context Switching** - `withContext` for dispatcher changes\n\n### Key Takeaways\n\n1. **Use `coroutineScope`** for related tasks that should fail together\n2. **Use `supervisorScope`** for independent tasks\n3. **Flows are cold** (start on collection), **Channels are hot**\n4. **StateFlow** for state, **SharedFlow** for events\n5. **Exception handling** in `launch` requires `CoroutineExceptionHandler`\n6. **`flowOn`** changes dispatcher for upstream operators\n\n### Next Steps\n\nIn the next lesson, we'll explore **Delegation and Lazy Initialization** - powerful patterns for delegating behavior and optimizing resource usage!\n\n---\n\n**Practice Challenge**: Build a stock price monitoring system that fetches prices from multiple sources using Flows, combines them, and alerts when prices cross thresholds using StateFlow.\n\n"
            }
          ],
          "challenges": []
        }
      ],
      "quizzes": [
        {
          "id": "part4-quiz-4.1",
          "title": "Lambda Expressions Quiz",
          "description": "Knowledge check for Lambda Expressions Quiz",
          "moduleId": "module-04",
          "passingScore": 70,
          "estimatedMinutes": 8,
          "questions": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "4.1.q1",
              "title": "What is a lambda expression?",
              "description": "What is a lambda expression?",
              "options": [
                "A type of loop",
                "An anonymous function that can be treated as a value",
                "A class definition",
                "A variable type"
              ],
              "correctAnswer": 1,
              "explanation": "A lambda is an anonymous function (function without a name) that can be passed around as a value."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "4.1.q2",
              "title": "What is the syntax for a simple lambda?",
              "description": "What is the syntax for a simple lambda?",
              "options": [
                "lambda(x) -> x * 2",
                "{ x -> x * 2 }",
                "fun(x) { x * 2 }",
                "(x) => x * 2"
              ],
              "correctAnswer": 1,
              "explanation": "Lambda syntax in Kotlin: { parameters -> body }. Example: { x -> x * 2 }"
            },
            {
              "type": "TRUE_FALSE",
              "id": "4.1.q3",
              "title": "When a lambda has a single parameter, you can use 'it' instead of naming the parameter.",
              "description": "When a lambda has a single parameter, you can use 'it' instead of naming the parameter.",
              "question": "When a lambda has a single parameter, you can use 'it' instead of naming the parameter.",
              "correctAnswer": true,
              "explanation": "True. 'it' is the implicit name of a single parameter: { it * 2 } instead of { x -> x * 2 }"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "4.1.q4",
              "title": "What is a higher-order function?",
              "description": "What is a higher-order function?",
              "options": [
                "A function that returns a number",
                "A function that takes another function as parameter or returns a function",
                "A function at the top of the file",
                "A very complex function"
              ],
              "correctAnswer": 1,
              "explanation": "Higher-order functions either take functions as parameters or return functions."
            }
          ]
        },
        {
          "id": "part4-quiz-4.2",
          "title": "Extension Functions Quiz",
          "description": "Knowledge check for Extension Functions Quiz",
          "moduleId": "module-04",
          "passingScore": 70,
          "estimatedMinutes": 6,
          "questions": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "4.2.q1",
              "title": "What do extension functions allow you to do?",
              "description": "What do extension functions allow you to do?",
              "options": [
                "Make functions longer",
                "Add new functionality to existing classes without modifying them",
                "Extend the program runtime",
                "Create longer variable names"
              ],
              "correctAnswer": 1,
              "explanation": "Extension functions let you add methods to existing classes without modifying their source code."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "4.2.q2",
              "title": "How do you define an extension function on String?",
              "description": "How do you define an extension function on String?",
              "options": [
                "fun String.myFunction()",
                "fun myFunction(String)",
                "extend String.myFunction()",
                "String fun myFunction()"
              ],
              "correctAnswer": 0,
              "explanation": "Extension function syntax: fun TypeName.functionName(). The type comes before the dot."
            },
            {
              "type": "TRUE_FALSE",
              "id": "4.2.q3",
              "title": "Inside an extension function, 'this' refers to the receiver object.",
              "description": "Inside an extension function, 'this' refers to the receiver object.",
              "question": "Inside an extension function, 'this' refers to the receiver object.",
              "correctAnswer": true,
              "explanation": "True. 'this' refers to the instance of the class you're extending."
            }
          ]
        },
        {
          "id": "part4-quiz-4.3",
          "title": "Collections and Sequences Quiz",
          "description": "Knowledge check for Collections and Sequences Quiz",
          "moduleId": "module-04",
          "passingScore": 70,
          "estimatedMinutes": 8,
          "questions": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "4.3.q1",
              "title": "What does the filter() function do?",
              "description": "What does the filter() function do?",
              "options": [
                "Removes all elements",
                "Keeps only elements that match a condition",
                "Sorts elements",
                "Counts elements"
              ],
              "correctAnswer": 1,
              "explanation": "filter() returns a new collection containing only elements that match the given predicate."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "4.3.q2",
              "title": "What does the map() function do?",
              "description": "What does the map() function do?",
              "options": [
                "Creates a map collection",
                "Transforms each element to a new value",
                "Filters elements",
                "Finds the largest element"
              ],
              "correctAnswer": 1,
              "explanation": "map() transforms each element in a collection to a new value using the provided function."
            },
            {
              "type": "TRUE_FALSE",
              "id": "4.3.q3",
              "title": "Sequences are evaluated lazily, while lists are evaluated eagerly.",
              "description": "Sequences are evaluated lazily, while lists are evaluated eagerly.",
              "question": "Sequences are evaluated lazily, while lists are evaluated eagerly.",
              "correctAnswer": true,
              "explanation": "True. Sequences compute values on-demand (lazy), while lists compute everything immediately (eager)."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "4.3.q4",
              "title": "What advantage do sequences have over lists for large datasets?",
              "description": "What advantage do sequences have over lists for large datasets?",
              "options": [
                "They're faster to create",
                "They use less memory by computing values on-demand",
                "They're easier to read",
                "They support more operations"
              ],
              "correctAnswer": 1,
              "explanation": "Sequences are memory-efficient for large datasets because they compute values lazily, only when needed."
            }
          ]
        }
      ]
    },
    {
      "id": "module-05",
      "title": "Part 5: Kotlin Fundamentals",
      "description": "Learn Kotlin programming - Part 5",
      "difficulty": "intermediate",
      "estimatedHours": 13,
      "lessons": [
        {
          "id": "5.1",
          "title": "Lesson 5.1: Introduction to Backend Development & HTTP Fundamentals",
          "moduleId": "module-05",
          "order": 1,
          "estimatedMinutes": 30,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 30 minutes\n**Difficulty**: Beginner\n**Prerequisites**: Parts 1-4 (Kotlin fundamentals, OOP, functions)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "üìñ Topic Introduction",
              "content": "\nWelcome to Part 5! You've mastered Kotlin fundamentals, object-oriented programming, and functional concepts. Now it's time to build something that runs on the internet: a **backend server**.\n\nIn this lesson, you'll learn what backend development actually means, how computers talk to each other over the internet, and the fundamental protocol (HTTP) that powers the web.\n\n---\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "üí° The Concept: What Is a Backend?",
              "content": "\n### The Restaurant Analogy\n\nImagine you're at a restaurant:\n\n**Frontend** = The dining room, menu, and waitstaff\n- This is what you see and interact with\n- Beautiful presentation\n- Easy to understand and navigate\n\n**Backend** = The kitchen\n- Hidden from customers\n- Where the real work happens\n- Processes orders, prepares food, manages inventory\n- Follows strict recipes and procedures\n\nWhen you order food (make a request), the waiter takes your order to the kitchen (sends it to the backend). The kitchen prepares it (processes the request), and the waiter brings it back to you (returns the response).\n\n### What Does a Backend Actually Do?\n\nA backend server is a program running on a computer (usually in a data center) that:\n\n1. **Listens** for requests from clients (web browsers, mobile apps, etc.)\n2. **Processes** those requests (validates data, performs calculations, queries databases)\n3. **Responds** with data or confirmation\n4. **Stores** data in databases for long-term persistence\n5. **Enforces** business rules and security\n\n### Client-Server Architecture\n\n\n- **Client**: Your web browser, mobile app, or any program that makes requests\n- **Server**: The backend program that handles requests and sends responses\n\n---\n\n",
              "code": "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ   Client    ‚îÇ  ---- Request ---> ‚îÇ   Server    ‚îÇ\n‚îÇ (Frontend)  ‚îÇ                    ‚îÇ  (Backend)  ‚îÇ\n‚îÇ             ‚îÇ <--- Response ---- ‚îÇ             ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "üåê HTTP: The Language of the Web",
              "content": "\n### What Is HTTP?\n\n**HTTP** stands for **Hypertext Transfer Protocol**. It's the standard way computers communicate on the web.\n\nThink of HTTP as the \"language rules\" for how a customer (client) and a waiter (server) communicate:\n\n- **Customer**: \"I'd like a coffee, please.\" (GET request)\n- **Waiter**: \"Here's your coffee.\" (200 OK response)\n\n### HTTP Request Structure\n\nWhen a client makes a request, it includes:\n\n\n**Components**:\n1. **Method**: What action to perform (GET, POST, PUT, DELETE)\n2. **Path**: Which resource you want (`/api/books`)\n3. **Headers**: Metadata about the request\n4. **Body**: Data sent with the request (optional)\n\n### HTTP Methods: The \"Verbs\" of the Web\n\n| Method   | Purpose           | Restaurant Analogy          | Example              |\n|----------|-------------------|-----------------------------|----------------------|\n| **GET**  | Retrieve data     | \"What's on the menu?\"       | Get list of books    |\n| **POST** | Create new data   | \"I'd like to order this\"    | Create a new book    |\n| **PUT**  | Update/replace    | \"Change my entire order\"    | Update book details  |\n| **DELETE** | Remove data     | \"Cancel my order\"           | Delete a book        |\n\n### HTTP Status Codes: The \"Results\" of Requests\n\nStatus codes tell you what happened with your request:\n\n#### **2xx Success** ‚úÖ\n- **200 OK**: Request succeeded, here's your data\n- **201 Created**: New resource created successfully\n- **204 No Content**: Success, but no data to return\n\n#### **4xx Client Errors** ‚ùå (You made a mistake)\n- **400 Bad Request**: Your request doesn't make sense\n- **401 Unauthorized**: You need to log in first\n- **403 Forbidden**: You're logged in, but not allowed to do this\n- **404 Not Found**: This resource doesn't exist\n\n#### **5xx Server Errors** üí• (Server made a mistake)\n- **500 Internal Server Error**: Something broke on the server\n- **503 Service Unavailable**: Server is temporarily down\n\n### Real-World Example\n\nWhen you visit `https://example.com/books`:\n\n\n---\n\n",
              "code": "1. Your browser sends:\n   GET /books HTTP/1.1\n   Host: example.com\n\n2. Server processes the request\n\n3. Server responds:\n   HTTP/1.1 200 OK\n   Content-Type: application/json\n\n   [\n     {\"id\": 1, \"title\": \"1984\"},\n     {\"id\": 2, \"title\": \"Brave New World\"}\n   ]",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "üîß Understanding URLs and Endpoints",
              "content": "\n### URL Structure\n\n\n- **Scheme**: `https://` (secure) or `http://` (insecure)\n- **Domain**: The server address\n- **Port**: Usually 80 (HTTP) or 443 (HTTPS), often hidden\n- **Path**: The route to the resource\n- **Query Parameters**: Additional filters or options\n- **Fragment**: Specific section (rarely used in APIs)\n\n### RESTful API Design Principles\n\n**REST** = Representational State Transfer (don't worry about the name, focus on the pattern)\n\nGood API endpoint design:\n\n\n**Key Principles**:\n1. Use **nouns** for resources (books, users, orders)\n2. Use **HTTP methods** for actions (GET, POST, DELETE)\n3. Use **plural** names (`/books`, not `/book`)\n4. Be **consistent** throughout your API\n\n---\n\n",
              "code": "‚úÖ GET    /books           - Get all books\n‚úÖ GET    /books/123       - Get book with ID 123\n‚úÖ POST   /books           - Create a new book\n‚úÖ PUT    /books/123       - Update book 123 (replace entirely)\n‚úÖ PATCH  /books/123       - Update book 123 (partial update)\n‚úÖ DELETE /books/123       - Delete book 123\n\n‚ùå GET    /getAllBooks     - Don't use verbs in URLs\n‚ùå POST   /books/delete    - Use DELETE method instead\n‚ùå GET    /book             - Use plural nouns",
              "language": "kotlin"
            },
            {
              "type": "EXAMPLE",
              "title": "üìù Practical Example: Library API Design",
              "content": "\nLet's design an API for a library system on paper:\n\n### Resources\n- Books\n- Users\n- Loans (when someone borrows a book)\n\n### Endpoints\n\n\n---\n\n",
              "code": "Books:\nGET    /api/books              - List all books\nGET    /api/books/42           - Get specific book\nPOST   /api/books              - Add new book (admin only)\nPUT    /api/books/42           - Update book details\nDELETE /api/books/42           - Remove book\n\nUsers:\nGET    /api/users              - List all users\nGET    /api/users/alice        - Get user profile\nPOST   /api/users              - Register new user\nPUT    /api/users/alice        - Update user info\n\nLoans:\nGET    /api/loans              - List all current loans\nPOST   /api/loans              - Check out a book\nDELETE /api/loans/5            - Return a book\n\nSearch:\nGET    /api/books?author=Orwell           - Search by author\nGET    /api/books?available=true          - Find available books\nGET    /api/books?category=scifi&year=2020 - Multiple filters",
              "language": "kotlin"
            },
            {
              "type": "ANALOGY",
              "title": "üíª Code Example: Understanding HTTP Requests (Conceptual)",
              "content": "\nWhile we haven't built a server yet, let's understand what requests and responses look like:\n\n\n### Understanding the Flow\n\n\n**Output:**\n\n---\n\n",
              "code": "Status: 200 OK\nBody: {\"id\": 1, \"title\": \"1984\", \"author\": \"George Orwell\"}",
              "language": "kotlin"
            },
            {
              "type": "EXAMPLE",
              "title": "üîç Code Breakdown",
              "content": "\nLet's analyze the key concepts:\n\n### 1. Request Structure\n\n- **method**: Tells the server what you want to do\n- **path**: Identifies which resource you're targeting\n- **headers**: Additional information (authentication, content type, etc.)\n- **body**: The actual data (for POST/PUT requests)\n\n### 2. Response Structure\n\n- **statusCode**: Numerical code (200 = success, 404 = not found)\n- **statusMessage**: Description of the status\n- **body**: The data you requested (or error information)\n\n### 3. Request Handling Logic\n\n\nThis pattern will be the foundation of every backend you build.\n\n---\n\n",
              "code": "when {\n    request.method != \"GET\" -> // Wrong HTTP method\n    id == null -> // Invalid input\n    id !in books -> // Resource doesn't exist\n    else -> // Success!\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "üéØ Exercise: Design Your Own API",
              "content": "\nDesign a simple API for a **To-Do List Application** on paper. You don't need to write code yet!\n\n**Requirements:**\n1. Users can view all their tasks\n2. Users can view a single task by ID\n3. Users can create a new task\n4. Users can mark a task as complete\n5. Users can delete a task\n6. Users can filter tasks by status (completed/pending)\n\n**Your task:**\n- List all the endpoints you would need\n- Specify the HTTP method for each\n- Include example URLs with query parameters where needed\n- Think about what status codes you'd return for each endpoint\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "‚úÖ Solution & Explanation",
              "content": "\nHere's a well-designed API for the To-Do List application:\n\n### Endpoints\n\n\n### Example Request/Response Flow\n\n**Creating a Task:**\n\n\n**Marking Task Complete:**\n\n\n### Key Design Decisions\n\n1. **Consistent naming**: All endpoints use `/api/tasks` (plural noun)\n2. **Proper HTTP methods**: GET for reading, POST for creating, PUT for updating, DELETE for removing\n3. **Meaningful status codes**: 201 for creation, 204 for deletion, 404 when not found\n4. **Query parameters for filtering**: `?status=completed` instead of `/tasks/completed`\n5. **Resource IDs in the path**: `/tasks/{id}` for specific tasks\n\n---\n\n",
              "code": "Request:\nPUT /api/tasks/42 HTTP/1.1\nContent-Type: application/json\nAuthorization: Bearer user_token_123\n\n{\n    \"completed\": true\n}\n\nResponse:\nHTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n    \"id\": 42,\n    \"title\": \"Buy groceries\",\n    \"description\": \"Milk, eggs, bread\",\n    \"dueDate\": \"2024-12-01\",\n    \"completed\": true,\n    \"completedAt\": \"2024-11-13T15:45:00Z\"\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "üìù Lesson Checkpoint Quiz",
              "content": "\nTest your understanding of HTTP fundamentals:\n\n### Question 1\nWhich HTTP method should you use to retrieve a list of books from a server?\n\nA) POST\nB) GET\nC) PUT\nD) DELETE\n\n---\n\n### Question 2\nYou try to access `/api/users/42` but that user doesn't exist. What status code should the server return?\n\nA) 200 OK\nB) 400 Bad Request\nC) 404 Not Found\nD) 500 Internal Server Error\n\n---\n\n### Question 3\nWhich of the following is the BEST RESTful API endpoint design for updating a user's profile?\n\nA) `POST /updateUserProfile/123`\nB) `GET /users/123/update`\nC) `PUT /users/123`\nD) `UPDATE /user/123`\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "üéØ Why This Matters",
              "content": "\nUnderstanding HTTP is like learning the alphabet before writing essays. **Every** backend you ever build‚Äîwhether with Ktor, Spring Boot, Express.js, Django, or any other framework‚Äîuses these exact same concepts:\n\n- **HTTP methods** are universal across all web frameworks\n- **Status codes** are standardized (200 always means success, 404 always means not found)\n- **RESTful design** makes your API intuitive for other developers\n\nIn the next lesson, we'll set up our first Ktor project and turn these concepts into actual working code. But first, you needed to understand *what* you're building and *why* it's designed this way.\n\nWhen you build your first API endpoint, you'll think: \"GET request to `/api/books` returns 200 with a JSON array.\" You now speak the language of backend development!\n\n---\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "üìö Key Takeaways",
              "content": "\n‚úÖ **Backend** = The server-side logic, database, and business rules\n‚úÖ **HTTP** = The protocol that defines how clients and servers communicate\n‚úÖ **GET** = Retrieve data, **POST** = Create, **PUT** = Update, **DELETE** = Remove\n‚úÖ **Status Codes**: 2xx = Success, 4xx = Client error, 5xx = Server error\n‚úÖ **REST API** = Use nouns for resources, HTTP methods for actions\n‚úÖ **Endpoints** = URLs that point to specific resources\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "üîú Next Steps",
              "content": "\nIn **Lesson 5.2**, you'll:\n- Install Ktor and create your first project\n- Set up a development environment\n- Run your first server that responds to HTTP requests\n- Test your API with a web browser and Postman\n\n---\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "‚úèÔ∏è Quiz Answer Key",
              "content": "\n**Question 1**: **B) GET**\nGET is used to retrieve/read data without modifying anything on the server.\n\n**Question 2**: **C) 404 Not Found**\n404 means the resource (user 42) doesn't exist at that URL.\n\n**Question 3**: **C) PUT /users/123**\nThis follows REST principles: plural noun (`users`), resource ID in path (`123`), and proper HTTP method (`PUT` for updates).\n\n---\n\n**Congratulations!** You now understand the foundational concepts of backend development. In the next lesson, we'll start writing real code!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "5.1.1",
              "title": "Create a Simple Route",
              "description": "Create a Ktor route that responds to GET /hello with 'Hello, Ktor!' (Conceptual - print the route definition)",
              "instructions": "Create a Ktor route that responds to GET /hello with 'Hello, Ktor!' (Conceptual - print the route definition)",
              "starterCode": "// Simulate Ktor routing structure\nfun main() {\n    // Print what a GET /hello route would look like\n    println(\"Route: GET /hello\")\n    // Print the response\n}",
              "solution": "fun main() {\n    println(\"Route: GET /hello\")\n    println(\"Response: Hello, Ktor!\")\n}",
              "language": "kotlin",
              "testCases": [
                {
                  "description": "Should define the route",
                  "expectedOutput": "Route: GET /hello",
                  "isVisible": true
                },
                {
                  "description": "Should show the response",
                  "expectedOutput": "Response: Hello, Ktor!",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "This is a conceptual exercise"
                },
                {
                  "level": 2,
                  "text": "Print the route method and path"
                },
                {
                  "level": 3,
                  "text": "Print the response text"
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "5.1.2",
              "title": "Data Class for API Response",
              "description": "Create a data class `ApiResponse` with status (Int) and message (String). Create an instance representing a successful response.",
              "instructions": "Create a data class `ApiResponse` with status (Int) and message (String). Create an instance representing a successful response.",
              "starterCode": "// Create ApiResponse data class\n\nfun main() {\n    val response = ApiResponse(200, \"Success\")\n    println(\"Status: ${response.status}\")\n    println(\"Message: ${response.message}\")\n}",
              "solution": "data class ApiResponse(val status: Int, val message: String)\n\nfun main() {\n    val response = ApiResponse(200, \"Success\")\n    println(\"Status: ${response.status}\")\n    println(\"Message: ${response.message}\")\n}",
              "language": "kotlin",
              "testCases": [
                {
                  "description": "Should have status 200",
                  "expectedOutput": "Status: 200",
                  "isVisible": true
                },
                {
                  "description": "Should have success message",
                  "expectedOutput": "Message: Success",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use data class for API models"
                },
                {
                  "level": 2,
                  "text": "Include status code (Int) and message (String)"
                },
                {
                  "level": 3,
                  "text": "200 is the HTTP status for success"
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "5.1.3",
              "title": "URL Path Parameters",
              "description": "Simulate extracting a user ID from a URL path like '/users/123'. Parse and print the ID.",
              "instructions": "Simulate extracting a user ID from a URL path like '/users/123'. Parse and print the ID.",
              "starterCode": "fun main() {\n    val url = \"/users/123\"\n    // Extract the user ID from the URL\n    val userId = \n    \n    println(\"User ID: $userId\")\n}",
              "solution": "fun main() {\n    val url = \"/users/123\"\n    val userId = url.substringAfterLast(\"/\")\n    \n    println(\"User ID: $userId\")\n}",
              "language": "kotlin",
              "testCases": [
                {
                  "description": "Should extract user ID 123",
                  "expectedOutput": "User ID: 123",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use substringAfterLast to get text after last /"
                },
                {
                  "level": 2,
                  "text": "The path is /users/{id}"
                },
                {
                  "level": 3,
                  "text": "Extract the numeric ID"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "5.10",
          "title": "Lesson 5.10: Authentication - User Registration & Password Hashing",
          "moduleId": "module-05",
          "order": 2,
          "estimatedMinutes": 65,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 65 minutes\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Topic Introduction",
              "content": "\nYou've built APIs that create, read, update, and delete data. But what if you need to know *who* is making the request? What if some users should have access to certain data while others shouldn't?\n\nThat's where authentication comes in. In this lesson, you'll learn how to securely register users and protect their passwords using industry-standard hashing techniques. This is the first step in building a complete authentication system.\n\n**Warning**: Password security is critical. Done wrong, you expose your users to identity theft and your company to lawsuits. We'll learn how to do it right.\n\n---\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "The Concept",
              "content": "\n### The Bank Vault Analogy\n\nThink of password hashing like a bank vault combination:\n\n**Bad Approach (Storing Plaintext Passwords)**:\n- Writing the combination on a sticky note\n- Anyone who sees it (hackers, rogue employees, backups) can open the vault\n- If the note is stolen, every vault using that combination is compromised\n- üíÄ Catastrophic security failure\n\n**Good Approach (Hashing Passwords)**:\n- The combination goes through a one-way machine\n- Machine outputs a unique fingerprint of the combination\n- You store the fingerprint, not the combination\n- To verify: run their attempt through the same machine, compare fingerprints\n- Even if the fingerprint is stolen, it can't be reversed back to the combination\n- ‚úÖ Secure!\n\n### Hashing vs Encryption: Critical Difference\n\n| Aspect | Hashing | Encryption |\n|--------|---------|------------|\n| **Direction** | One-way (irreversible) | Two-way (reversible) |\n| **Purpose** | Verify data without storing it | Protect data in transit/storage |\n| **Can be decoded?** | ‚ùå No (by design!) | ‚úÖ Yes (with key) |\n| **Use for passwords?** | ‚úÖ Always | ‚ùå Never |\n| **Example** | bcrypt, argon2 | AES, RSA |\n\n**Why hashing for passwords?**\n\nIf you encrypt passwords, the decryption key must exist somewhere in your system. If hackers get that key, they decrypt every password. With hashing, there's nothing to steal‚Äîthe original passwords simply don't exist in your system.\n\n### The Rainbow Table Problem\n\nEarly password systems used simple hashing (like MD5):\n\n\nHackers created \"rainbow tables\"‚Äîmassive databases mapping common passwords to their hashes:\n\n\nIf your database is breached, they instantly crack every password by looking up hashes in the table.\n\n**Solution: Salting**\n\nA \"salt\" is random data added to each password before hashing:\n\n\nSame password, different salts = different hashes! Rainbow tables are useless.\n\n### Why bcrypt?\n\nModern password hashing needs three properties:\n\n1. **Slow**: Takes time to compute (makes brute-force attacks impractical)\n2. **Adaptive**: Can increase cost as computers get faster\n3. **Salted**: Built-in random salt for each password\n\n**bcrypt** provides all three:\n\n\nAs computers improve, just increase the cost factor. Your password system stays secure for years.\n\n---\n\n",
              "code": "bcrypt(password, cost=12)\n        ‚Üì\nCost factor: 2^12 = 4,096 rounds\n(Adjustable: 10=fast, 12=default, 14=very secure but slower)",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Setting Up User Registration",
              "content": "\n### Step 1: Add bcrypt Dependency\n\nAdd bcrypt to your `build.gradle.kts`:\n\n\nSync your Gradle project to download the dependency.\n\n### Step 2: Create User Model and Table\n\n\n**Key Security Principle**: The `User` model exposed to clients NEVER includes the password hash. That stays in the database layer only.\n\n### Step 3: Create Password Hashing Utility\n\n\n### Step 4: Create Password Validator\n\nStrong passwords are essential. Let's enforce requirements:\n\n\n### Step 5: Create User Validator\n\n\n### Step 6: Create User Repository\n\n\n### Step 7: Create User Service with Registration Logic\n\n\n### Step 8: Create Registration Route\n\n\n### Step 9: Update Database Factory\n\nAdd the Users table to schema creation:\n\n\n### Step 10: Wire Everything Together\n\n\n---\n\n",
              "code": "// src/main/kotlin/com/example/Application.kt\npackage com.example\n\nimport com.example.database.DatabaseFactory\nimport com.example.plugins.configureErrorHandling\nimport com.example.repositories.UserRepositoryImpl\nimport com.example.routes.authRoutes\nimport com.example.services.UserService\nimport io.ktor.serialization.kotlinx.json.*\nimport io.ktor.server.application.*\nimport io.ktor.server.cio.*\nimport io.ktor.server.engine.*\nimport io.ktor.server.plugins.contentnegotiation.*\nimport io.ktor.server.routing.*\nimport kotlinx.serialization.json.Json\n\nfun main() {\n    embeddedServer(CIO, port = 8080, module = Application::module).start(wait = true)\n}\n\nfun Application.module() {\n    // Install plugins\n    install(ContentNegotiation) {\n        json(Json {\n            prettyPrint = true\n            ignoreUnknownKeys = true\n        })\n    }\n\n    // Install error handling\n    configureErrorHandling()\n\n    // Initialize database\n    DatabaseFactory.init()\n\n    // Create dependencies\n    val userRepository = UserRepositoryImpl()\n    val userService = UserService(userRepository)\n\n    // Configure routes\n    routing {\n        authRoutes(userService)\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Breakdown",
              "content": "\n### The Registration Flow\n\n\n### Security Highlights\n\n**1. Password Never Stored in Plaintext**:\n\n**2. Password Hash Never Exposed**:\n\n**3. Separate Method for Password Retrieval**:\n\n**4. Email Case-Insensitivity**:\n\n---\n\n",
              "code": "// \"Alice@Example.COM\" and \"alice@example.com\" are the same user\nit[Users.email] = email.lowercase().trim()",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Testing User Registration",
              "content": "\n### Test 1: Successful Registration\n\n\nResponse (201 Created):\n\n### Test 2: Weak Password\n\n\nResponse (400 Bad Request):\n\n### Test 3: Duplicate Email\n\n\nResponse (409 Conflict):\n\n### Test 4: Invalid Email Format\n\n\nResponse (400 Bad Request):\n\n---\n\n",
              "code": "{\n  \"success\": false,\n  \"message\": \"Validation failed\",\n  \"errors\": {\n    \"email\": [\"email must be a valid email address\"]\n  },\n  \"timestamp\": \"2025-01-15T10:33:45.012\"\n}",
              "language": "json"
            },
            {
              "type": "THEORY",
              "title": "Exercise: Enhanced User Profile",
              "content": "\nExtend the user registration system with additional features.\n\n### Requirements\n\n1. **Add Profile Fields**:\n   - Username (required, unique, 3-20 chars, alphanumeric + underscore only)\n   - Bio (optional, max 500 chars)\n   - Date of birth (required, must be 13+ years old)\n   - Phone number (optional, if provided must match pattern: +1-XXX-XXX-XXXX)\n\n2. **Update User Model**:\n   - Include new fields in User and RegisterRequest\n   - Add database columns\n\n3. **Create Username Validator**:\n   - Length: 3-20 characters\n   - Pattern: Only letters, numbers, underscore\n   - Must not start with underscore or number\n   - Check uniqueness\n\n4. **Create Age Validator**:\n   - Parse date of birth\n   - Calculate age\n   - Ensure user is at least 13 years old (COPPA compliance)\n\n5. **Create Phone Validator**:\n   - Optional but must match pattern if provided\n   - Format: +1-XXX-XXX-XXXX (US phone numbers)\n\n### Starter Code\n\n\n---\n\n",
              "code": "@Serializable\ndata class User(\n    val id: Int,\n    val email: String,\n    val username: String,\n    val fullName: String,\n    val bio: String?,\n    val dateOfBirth: String,\n    val phoneNumber: String?,\n    val createdAt: String\n)\n\n@Serializable\ndata class RegisterRequest(\n    val email: String,\n    val username: String,\n    val password: String,\n    val fullName: String,\n    val bio: String? = null,\n    val dateOfBirth: String,  // Format: YYYY-MM-DD\n    val phoneNumber: String? = null\n)\n\n// TODO: Update Users table definition\n// TODO: Implement enhanced UserValidator\n// TODO: Update UserRepository\n// TODO: Test all validation rules",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Solution",
              "content": "\n### Enhanced User System\n\n\n\n\n\n### Test Cases\n\n**Valid Registration**:\n\n**Invalid Username (starts with number)**:\nError: \"Username must start with a letter...\"\n\n**Underage User**:\nError: \"You must be at least 13 years old to register\"\n\n**Invalid Phone Format**:\nError: \"Phone number must be in format: +1-XXX-XXX-XXXX\"\n\n---\n\n",
              "code": "{\n  \"phoneNumber\": \"555-1234\",\n  // ... other fields\n}",
              "language": "json"
            },
            {
              "type": "THEORY",
              "title": "Solution Explanation",
              "content": "\n### Key Enhancements\n\n**1. Username Uniqueness**:\nBoth email AND username must be unique. We check both before creating the user.\n\n**2. Age Validation with LocalDate**:\nProperly calculates age accounting for leap years and time zones.\n\n**3. Optional but Validated Fields**:\nBio and phone are optional, but if provided they must meet format requirements.\n\n**4. COPPA Compliance**:\nThe 13+ age requirement ensures compliance with US Children's Online Privacy Protection Act.\n\n---\n\n",
              "code": "value.phoneNumber?.let { phone ->\n    if (phone.isNotBlank()) {\n        validatePattern(...)  // Only validate if provided\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n### Real-World Security\n\n**Password Breach Statistics** (2024 data):\n- 81% of data breaches involve stolen/weak passwords\n- Average cost of a data breach: $4.45 million\n- Companies that store plaintext passwords face massive fines and lawsuits\n\n**Your Responsibility as a Developer**:\nWhen you store user passwords, you're responsible for protecting them. Using bcrypt with proper salting and cost factors is not optional‚Äîit's a legal and ethical requirement.\n\n### Industry Standards\n\n**OWASP Top 10 (2023)**:\n- #2: Cryptographic Failures (storing passwords insecurely)\n- #7: Identification and Authentication Failures\n\nImplementing what you learned today directly addresses two of the top security vulnerabilities.\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Checkpoint Quiz",
              "content": "\n### Question 1\nWhat's the critical difference between hashing and encryption?\n\nA) Hashing is faster than encryption\nB) Hashing is one-way (irreversible), encryption is two-way (reversible)\nC) Hashing uses more CPU than encryption\nD) They're the same thing\n\n### Question 2\nWhat is a \"salt\" in password hashing?\n\nA) Random data added to each password before hashing\nB) A type of encryption algorithm\nC) The cost factor in bcrypt\nD) The password strength requirement\n\n### Question 3\nWhy should you NEVER expose password hashes in API responses?\n\nA) They take up too much bandwidth\nB) They're ugly and users don't need them\nC) Attackers can use them for offline brute-force attacks\nD) It violates JSON formatting standards\n\n### Question 4\nWhat is the recommended bcrypt cost factor for 2025?\n\nA) 4 (fast)\nB) 8 (balanced)\nC) 12 (secure, recommended default)\nD) 20 (maximum security)\n\n### Question 5\nWhy do we check email uniqueness BEFORE hashing the password?\n\nA) It's required by the database\nB) It saves CPU cycles (hashing is expensive, no point if email is duplicate)\nC) It makes the code run faster\nD) bcrypt doesn't work with duplicate emails\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Answers",
              "content": "\n**Question 1: B) Hashing is one-way (irreversible), encryption is two-way (reversible)**\n\nThis is the fundamental difference:\n- **Hashing**: password ‚Üí hash (no reverse operation possible)\n- **Encryption**: password ‚Üí encrypted ‚Üí decrypt ‚Üí password\n\nFor passwords, you want one-way hashing so even you can't retrieve the original password.\n\n---\n\n**Question 2: A) Random data added to each password before hashing**\n\nSalt prevents rainbow table attacks:\n\n\nbcrypt generates and stores the salt automatically in the hash output.\n\n---\n\n**Question 3: C) Attackers can use them for offline brute-force attacks**\n\nIf an attacker gets the hash, they can:\n1. Try millions of passwords offline\n2. Hash each attempt with bcrypt\n3. Compare to the stolen hash\n4. Eventually crack weak passwords\n\nThis is why strong passwords and high cost factors matter‚Äîthey make this attack impractically slow.\n\n---\n\n**Question 4: C) 12 (secure, recommended default)**\n\nCost factor guidelines:\n- **10**: Fast but less secure, ok for low-security applications\n- **12**: Recommended default (takes ~250-350ms per hash)\n- **14**: Very secure but slower (~1-1.5s per hash)\n- **16+**: Overkill for most applications, may hurt UX\n\nCost=12 balances security with user experience.\n\n---\n\n**Question 5: B) It saves CPU cycles (hashing is expensive, no point if email is duplicate)**\n\nOrder of operations matters:\n\n\nFail fast on cheap operations before expensive ones.\n\n---\n\n",
              "code": "// ‚úÖ Efficient: Check uniqueness first\nif (userRepository.emailExists(request.email)) {\n    throw ConflictException(...)  // Fast database lookup\n}\nval hash = PasswordHasher.hashPassword(request.password)  // Expensive bcrypt\n\n// ‚ùå Wasteful: Hash first, then check\nval hash = PasswordHasher.hashPassword(request.password)  // Wasted CPU if email is duplicate\nif (userRepository.emailExists(request.email)) {\n    throw ConflictException(...)\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "What You've Learned",
              "content": "\n‚úÖ Why password security is critical and the consequences of doing it wrong\n‚úÖ The difference between hashing and encryption (one-way vs two-way)\n‚úÖ How salting protects against rainbow table attacks\n‚úÖ Why bcrypt is the industry standard for password hashing\n‚úÖ How to implement secure user registration with password hashing\n‚úÖ How to validate password strength with multiple requirements\n‚úÖ How to properly structure user models to never expose password hashes\n‚úÖ Best practices for email uniqueness and case-insensitivity\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Next Steps",
              "content": "\nIn **Lesson 5.11**, you'll implement the login system using the hashed passwords you just created. You'll learn:\n- How to verify passwords against bcrypt hashes\n- How to generate JWT (JSON Web Tokens) for authenticated sessions\n- How to handle login errors securely (without revealing whether email exists)\n- Token expiration and refresh strategies\n\nThe foundation you built today makes authentication possible!\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "5.11",
          "title": "Lesson 5.11: Authentication - Login & JWT Tokens",
          "moduleId": "module-05",
          "order": 3,
          "estimatedMinutes": 70,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 70 minutes\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Topic Introduction",
              "content": "\nYou've built secure user registration with bcrypt-hashed passwords. Now users can sign up‚Äîbut how do they prove their identity on subsequent requests?\n\nTraditional web applications use server-side sessions (cookies stored in server memory). But modern APIs need something more scalable and stateless: **JSON Web Tokens (JWT)**.\n\nIn this lesson, you'll implement a complete login system that verifies passwords and issues JWTs, allowing users to authenticate with your API without storing session state on the server.\n\n---\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "The Concept",
              "content": "\n### The Concert Ticket Analogy\n\nThink of JWT authentication like getting into a concert:\n\n**Old Way (Sessions)**:\n- You show your ID at the door\n- Bouncer writes your name on a clipboard (server memory)\n- Every time you leave and return, bouncer checks the clipboard\n- Problem: Bouncer must remember thousands of people\n- If bouncer forgets (server restarts), you're locked out\n\n**New Way (JWT)**:\n- You show your ID at the door once\n- Bouncer gives you a wristband with your info and a tamper-proof seal\n- Every time you return, you just show the wristband\n- Anyone can verify the wristband is authentic (check the seal)\n- No need to remember who you are‚Äîthe wristband proves everything\n- ‚úÖ Scalable!\n\nJWTs are like tamper-proof wristbands for your API.\n\n### What is a JWT?\n\nA JWT (JSON Web Token) is a compact, self-contained token that securely transmits information between parties.\n\n**Structure**: Three parts separated by dots (`.`)\n\n\n#### Part 1: Header\nBase64URL encoded ‚Üí `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9`\n\n#### Part 2: Payload (Claims)\nBase64URL encoded ‚Üí `eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4g...`\n\n#### Part 3: Signature\n\nThe signature ensures:\n- Token hasn't been tampered with\n- Token was issued by your server (only you know the secret)\n\n### JWT vs Sessions\n\n| Aspect | JWT (Stateless) | Sessions (Stateful) |\n|--------|-----------------|---------------------|\n| **Storage** | Client-side (sent with each request) | Server-side memory/database |\n| **Scalability** | ‚úÖ Excellent (no server state) | ‚ùå Requires shared session store |\n| **Performance** | ‚úÖ Fast (no DB lookup) | ‚ùå DB/cache lookup each request |\n| **Revocation** | ‚ùå Hard (token valid until expiration) | ‚úÖ Easy (delete session) |\n| **Size** | ‚ùå Larger (entire token sent) | ‚úÖ Small (just session ID) |\n| **Best For** | Distributed systems, microservices | Traditional monolithic apps |\n\n**When to use JWT**:\n- RESTful APIs\n- Mobile apps\n- Microservices architecture\n- Cross-domain authentication\n\n---\n\n",
              "code": "HMACSHA256(\n  base64UrlEncode(header) + \".\" + base64UrlEncode(payload),\n  secret\n)",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Implementing Login with JWT",
              "content": "\n### Step 1: Add JWT Dependencies\n\nUpdate your `build.gradle.kts`:\n\n\n### Step 2: Create JWT Configuration\n\n\n**Security Note**: The secret should be:\n- At least 256 bits (32 characters) long\n- Randomly generated\n- Loaded from environment variables, not hardcoded\n- Different for each environment (dev, staging, production)\n\n### Step 3: Create Login Models\n\n\n### Step 4: Create Authentication Service\n\n\n### Step 5: Create Login Route\n\n\n### Step 6: Wire Everything Together\n\nUpdate your Application.kt:\n\n\n---\n\n",
              "code": "// src/main/kotlin/com/example/Application.kt\npackage com.example\n\nimport com.example.database.DatabaseFactory\nimport com.example.plugins.configureErrorHandling\nimport com.example.repositories.UserRepositoryImpl\nimport com.example.routes.authRoutes\nimport com.example.services.AuthService\nimport com.example.services.UserService\nimport io.ktor.serialization.kotlinx.json.*\nimport io.ktor.server.application.*\nimport io.ktor.server.cio.*\nimport io.ktor.server.engine.*\nimport io.ktor.server.plugins.contentnegotiation.*\nimport io.ktor.server.routing.*\nimport kotlinx.serialization.json.Json\n\nfun main() {\n    embeddedServer(CIO, port = 8080, module = Application::module).start(wait = true)\n}\n\nfun Application.module() {\n    // Install plugins\n    install(ContentNegotiation) {\n        json(Json {\n            prettyPrint = true\n            ignoreUnknownKeys = true\n        })\n    }\n\n    // Install error handling\n    configureErrorHandling()\n\n    // Initialize database\n    DatabaseFactory.init()\n\n    // Create dependencies\n    val userRepository = UserRepositoryImpl()\n    val userService = UserService(userRepository)\n    val authService = AuthService(userRepository)\n\n    // Configure routes\n    routing {\n        authRoutes(userService, authService)\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Breakdown",
              "content": "\n### The Login Flow\n\n\n### Security Highlights\n\n**1. Generic Error Messages**:\n\nThis prevents attackers from enumerating valid email addresses.\n\n**2. Password Verification Timing**:\nEven if email doesn't exist, we should still verify the password (against a dummy hash) to prevent timing attacks:\n\n\nThis ensures the function always takes the same time, whether email exists or not.\n\n**3. Token Claims**:\n\nThese claims are used to validate the token and identify the user.\n\n---\n\n",
              "code": ".withSubject(userId.toString())     // Standard claim: user identifier\n.withClaim(\"email\", email)          // Custom claim: user email\n.withIssuedAt(Date())               // When token was created\n.withExpiresAt(Date(...))           // When token expires\n.withIssuer(ISSUER)                 // Who issued the token\n.withAudience(AUDIENCE)             // Who token is intended for",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Testing Login",
              "content": "\n### Test 1: Successful Login\n\nFirst, register a user:\n\nNow login:\n\nResponse (200 OK):\n\n### Test 2: Wrong Password\n\n\nResponse (401 Unauthorized):\n\n### Test 3: Non-existent Email\n\n\nResponse (401 Unauthorized):\n\nNotice: **Same error message** as wrong password! Security best practice.\n\n### Test 4: Decode the JWT Token\n\nCopy the token from the login response and decode it at [jwt.io](https://jwt.io):\n\n**Header**:\n\n**Payload**:\n\n**Verify Signature**: Paste the secret `your-256-bit-secret-change-this-in-production` to verify the signature is valid.\n\n---\n\n",
              "code": "{\n  \"iss\": \"http://localhost:8080\",\n  \"aud\": \"http://localhost:8080/api\",\n  \"sub\": \"1\",\n  \"email\": \"alice@example.com\",\n  \"iat\": 1705315200,\n  \"exp\": 1705318800\n}",
              "language": "json"
            },
            {
              "type": "THEORY",
              "title": "Exercise: Refresh Token System",
              "content": "\nImplement a refresh token mechanism for better security and UX.\n\n### Background\n\nCurrent system has a problem:\n- Tokens expire after 1 hour\n- User must login again every hour (poor UX)\n- Longer expiration times are less secure\n\n**Solution**: Two-token system:\n- **Access Token**: Short-lived (15 minutes), used for API requests\n- **Refresh Token**: Long-lived (7 days), used to get new access tokens\n\n### Requirements\n\n1. **Update Login Response**:\n   - Return both `accessToken` and `refreshToken`\n   - Access token expires in 15 minutes\n   - Refresh token expires in 7 days\n\n2. **Create Refresh Endpoint**:\n   - `POST /api/auth/refresh`\n   - Accepts: `{ \"refreshToken\": \"...\" }`\n   - Returns: New access token (and optionally new refresh token)\n\n3. **Store Refresh Tokens**:\n   - Create `RefreshTokens` table\n   - Fields: id, userId, token, expiresAt, createdAt\n   - Each user can have multiple refresh tokens (different devices)\n\n4. **Revocation Support**:\n   - `POST /api/auth/logout` - Delete refresh token\n   - `POST /api/auth/logout-all` - Delete all user's refresh tokens\n\n5. **Security Requirements**:\n   - Refresh tokens must be stored hashed (like passwords)\n   - Each refresh token can be used only once (rotation)\n   - Expired tokens are automatically invalid\n\n### Starter Code\n\n\n---\n\n",
              "code": "@Serializable\ndata class LoginResponse(\n    val accessToken: String,\n    val refreshToken: String,\n    val user: User,\n    val accessTokenExpiresIn: Long,   // 15 minutes\n    val refreshTokenExpiresIn: Long,  // 7 days\n    val message: String = \"Login successful\"\n)\n\n@Serializable\ndata class RefreshRequest(\n    val refreshToken: String\n)\n\n@Serializable\ndata class RefreshResponse(\n    val accessToken: String,\n    val refreshToken: String,\n    val accessTokenExpiresIn: Long\n)\n\n// TODO: Create RefreshTokens table\n// TODO: Implement refresh token generation and validation\n// TODO: Implement refresh endpoint\n// TODO: Implement logout endpoints",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Solution",
              "content": "\n### Complete Refresh Token System\n\n\n\n\n\n\n### Test the Refresh Flow\n\n**1. Login**:\n\nResponse includes both tokens:\n\n**2. Use Access Token** (we'll implement this in next lesson)\n\n**3. When Access Token Expires, Refresh**:\n\nResponse: New tokens!\n\n**4. Logout**:\n\n---\n\n",
              "code": "curl -X POST http://localhost:8080/api/auth/logout \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"refreshToken\": \"x9y8z7...\"}'",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Solution Explanation",
              "content": "\n### Key Security Features\n\n**1. Refresh Token Rotation**:\nEach time you use a refresh token, it's deleted and a new one is issued. This limits the impact of stolen tokens.\n\n**2. Hashed Storage**:\nRefresh tokens are hashed before storage (like passwords). If the database is breached, tokens can't be used.\n\n**3. Automatic Cleanup**:\nExpired tokens are deleted, preventing database bloat and reducing attack surface.\n\n**4. Per-Device Tokens**:\nUsers can have multiple refresh tokens (web, mobile, tablet). Logging out one device doesn't affect others.\n\n**5. Short Access Tokens**:\nAccess tokens expire quickly (15 min), limiting damage if stolen. Refresh tokens handle long-term sessions.\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n### Real-World Impact\n\n**Why JWT is Industry Standard**:\n- **Scalability**: No server-side session storage needed\n- **Microservices**: Token can be validated by any service\n- **Mobile Apps**: Perfect for native apps (no cookies needed)\n- **Cross-Domain**: Works across different domains and subdomains\n\n**Production Considerations**:\n1. **Secret Management**: Use environment variables, AWS Secrets Manager, or HashiCorp Vault\n2. **Token Revocation**: Implement refresh token blacklisting for compromised accounts\n3. **Monitoring**: Log failed authentication attempts (detect brute-force attacks)\n4. **Rate Limiting**: Limit login attempts (5 per hour, for example)\n5. **HTTPS Only**: NEVER send JWTs over HTTP (easily intercepted)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Checkpoint Quiz",
              "content": "\n### Question 1\nWhat are the three parts of a JWT?\n\nA) Username, Password, Signature\nB) Header, Body, Footer\nC) Header, Payload, Signature\nD) Key, Value, Hash\n\n### Question 2\nWhy use refresh tokens instead of just making access tokens long-lived?\n\nA) Refresh tokens look cooler\nB) Short access tokens limit exposure if stolen; refresh tokens enable revocation\nC) It's required by OAuth 2.0 specification\nD) Refresh tokens are faster to verify\n\n### Question 3\nWhy should error messages for \"wrong password\" and \"email not found\" be identical?\n\nA) It's easier to code\nB) It prevents attackers from enumerating valid email addresses\nC) It confuses users\nD) It's required by GDPR\n\n### Question 4\nWhat claim in a JWT identifies the user?\n\nA) `uid`\nB) `user`\nC) `sub` (subject)\nD) `id`\n\n### Question 5\nWhy hash refresh tokens before storing them in the database?\n\nA) To make them look random\nB) To save database space\nC) To protect users if database is breached (like password hashing)\nD) It's not necessary, just a best practice\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Answers",
              "content": "\n**Question 1: C) Header, Payload, Signature**\n\nJWT structure:\n\nEach part is Base64URL encoded (except signature which is encrypted).\n\n---\n\n**Question 2: B) Short access tokens limit exposure if stolen; refresh tokens enable revocation**\n\nThe two-token system provides:\n- **Security**: Access tokens expire quickly (15 min) limiting damage if stolen\n- **UX**: Users don't have to login every 15 minutes (refresh tokens last 7 days)\n- **Control**: You can revoke refresh tokens but can't revoke JWTs (they're stateless)\n\n---\n\n**Question 3: B) It prevents attackers from enumerating valid email addresses**\n\nDifferent messages leak information:\n\n\n---\n\n**Question 4: C) `sub` (subject)**\n\nStandard JWT claims:\n- `sub`: Subject (user identifier)\n- `iss`: Issuer (who created token)\n- `aud`: Audience (who token is for)\n- `exp`: Expiration timestamp\n- `iat`: Issued at timestamp\n\n---\n\n**Question 5: C) To protect users if database is breached (like password hashing)**\n\nIf refresh tokens are stored in plaintext:\n\nIf refresh tokens are hashed:\n\n---\n\n",
              "code": "Database breached ‚Üí Attacker gets hashes ‚Üí\nCan't use them (one-way hashing) ‚Üí Users are safe!",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "What You've Learned",
              "content": "\n‚úÖ What JWTs are and how they enable stateless authentication\n‚úÖ JWT structure (header, payload, signature) and how signing works\n‚úÖ How to implement login with password verification and JWT generation\n‚úÖ Security best practices (generic error messages, timing attack prevention)\n‚úÖ How to create refresh token systems for better security and UX\n‚úÖ Token rotation and revocation strategies\n‚úÖ Why short-lived access tokens + long-lived refresh tokens are industry standard\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Next Steps",
              "content": "\nIn **Lesson 5.12**, you'll learn how to **protect routes with JWT authentication**. You'll discover:\n- How to configure Ktor's JWT authentication plugin\n- How to create authenticated routes that require valid tokens\n- How to extract user information from tokens in route handlers\n- How to implement role-based access control (admin vs regular users)\n\nThe foundation you built today makes all of this possible!\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "5.12",
          "title": "Lesson 5.12: Authentication - Protecting Routes with JWT",
          "moduleId": "module-05",
          "order": 4,
          "estimatedMinutes": 70,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 70 minutes\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Topic Introduction",
              "content": "\nYou've implemented user registration, password hashing, and JWT token generation. But right now, any user can access any endpoint‚Äîthere's no protection!\n\nIn this lesson, you'll learn how to configure Ktor's authentication system to protect routes, requiring valid JWT tokens for access. You'll also implement role-based access control to differentiate between regular users and administrators.\n\n---\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "The Concept",
              "content": "\n### The VIP Club Analogy\n\nThink of protected routes like different areas in a nightclub:\n\n**Public Areas (No Authentication)**:\n- Lobby: Anyone can enter (`GET /api/health`, `POST /api/auth/register`)\n- No wristband needed\n\n**Members Area (Authentication Required)**:\n- Main floor: Must show wristband (`GET /api/profile`, `PUT /api/profile`)\n- Bouncer checks: \"Is this wristband valid? Not expired?\"\n\n**VIP Section (Role-Based Access)**:\n- VIP lounge: Must show wristband AND have VIP status\n- Bouncer checks: \"Valid wristband? ‚úÖ VIP status? ‚ùå Sorry, no entry!\"\n- Only admins can access (`GET /api/admin/users`, `DELETE /api/admin/users/:id`)\n\nYour API needs the same layered access control.\n\n### Authentication vs Authorization\n\n| Term | Meaning | Question Answered |\n|------|---------|-------------------|\n| **Authentication** | Verifying identity | \"Who are you?\" |\n| **Authorization** | Verifying permissions | \"Are you allowed to do this?\" |\n\n**Example**:\n- **Authentication**: Alice proves she's Alice (with JWT token)\n- **Authorization**: Check if Alice has admin role before allowing her to delete users\n\nBoth are essential for secure APIs.\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Configuring JWT Authentication",
              "content": "\n### Step 1: Update User Model with Roles\n\nFirst, add role support to your user system:\n\n\nUpdate UserRepository to include role:\n\n\n### Step 2: Update JWT to Include Role\n\n\n### Step 3: Install Ktor Authentication Plugin\n\nCreate a configuration file for authentication:\n\n\n### Step 4: Apply Authentication to Routes\n\nNow protect your routes with the `authenticate` function:\n\n\n### Step 5: Create Admin-Only Routes\n\n\n### Step 6: Update Application Configuration\n\n\n---\n\n",
              "code": "// src/main/kotlin/com/example/Application.kt\npackage com.example\n\nimport com.example.database.DatabaseFactory\nimport com.example.plugins.configureAuthentication\nimport com.example.plugins.configureErrorHandling\nimport com.example.repositories.UserRepositoryImpl\nimport com.example.routes.adminRoutes\nimport com.example.routes.authRoutes\nimport com.example.routes.userRoutes\nimport com.example.services.AuthService\nimport com.example.services.UserService\nimport io.ktor.serialization.kotlinx.json.*\nimport io.ktor.server.application.*\nimport io.ktor.server.cio.*\nimport io.ktor.server.engine.*\nimport io.ktor.server.plugins.contentnegotiation.*\nimport io.ktor.server.routing.*\nimport kotlinx.serialization.json.Json\n\nfun main() {\n    embeddedServer(CIO, port = 8080, module = Application::module).start(wait = true)\n}\n\nfun Application.module() {\n    // Install plugins\n    install(ContentNegotiation) {\n        json(Json {\n            prettyPrint = true\n            ignoreUnknownKeys = true\n        })\n    }\n\n    // Install error handling\n    configureErrorHandling()\n\n    // Install authentication\n    configureAuthentication()\n\n    // Initialize database\n    DatabaseFactory.init()\n\n    // Create dependencies\n    val userRepository = UserRepositoryImpl()\n    val userService = UserService(userRepository)\n    val authService = AuthService(userRepository)\n\n    // Configure routes\n    routing {\n        // Public routes (no authentication required)\n        authRoutes(userService, authService)\n\n        // Protected routes (authentication required)\n        userRoutes(userService)\n\n        // Admin routes (admin role required)\n        adminRoutes(userService)\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Breakdown",
              "content": "\n### Authentication Flow\n\n\n### Role-Based Access Control Flow\n\n\n### Extracting User Information in Routes\n\n\n---\n\n",
              "code": "// Get the authenticated user's principal\nval principal = call.principal<UserPrincipal>()\n\n// Use user information\nprintln(\"User ID: ${principal.userId}\")\nprintln(\"Email: ${principal.email}\")\nprintln(\"Role: ${principal.role}\")\n\n// Use in business logic\nuserService.updateProfile(principal.userId, request)",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Testing Protected Routes",
              "content": "\n### Setup: Create Users\n\n\n### Test 1: Access Protected Route Without Token\n\n\nResponse (401 Unauthorized):\n\n### Test 2: Login and Get Token\n\n\nResponse:\n\n**Copy the token** - you'll need it for subsequent requests.\n\n### Test 3: Access Protected Route With Token\n\n\nResponse (200 OK):\n\n‚úÖ **Authentication works!**\n\n### Test 4: Regular User Tries to Access Admin Route\n\n\nResponse (403 Forbidden):\n\n‚úÖ **Authorization works!**\n\n### Test 5: Admin Accesses Admin Route\n\nFirst, create an admin user or promote existing user:\n\n\nLogin as admin:\n\nNow access admin route with admin token:\n\nResponse (200 OK):\n\n‚úÖ **Admin access works!**\n\n---\n\n",
              "code": "{\n  \"success\": true,\n  \"data\": [\n    {\n      \"id\": 1,\n      \"email\": \"alice@example.com\",\n      \"fullName\": \"Alice Johnson\",\n      \"role\": \"ADMIN\",\n      \"createdAt\": \"2025-01-15T10:30:45\"\n    }\n  ],\n  \"message\": \"Retrieved 1 users\"\n}",
              "language": "json"
            },
            {
              "type": "THEORY",
              "title": "Exercise: Resource Ownership Authorization",
              "content": "\nImplement authorization that allows users to only modify their own resources.\n\n### Scenario\n\nYou have a blog API where users can create posts. Requirements:\n- Any authenticated user can create posts\n- Users can only edit/delete their own posts\n- Admins can edit/delete any post\n\n### Requirements\n\n1. **Create Post Model**:\n   - id, title, content, authorId, createdAt\n\n2. **Implement Authorization Logic**:\n   ```kotlin\n   fun canModifyPost(post: Post, principal: UserPrincipal): Boolean {\n       // User can modify if they own the post OR they're an admin\n       return post.authorId == principal.userId || principal.role == \"ADMIN\"\n   }\n   ```\n\n3. **Apply to Routes**:\n   - `PUT /api/posts/:id` - Check ownership before updating\n   - `DELETE /api/posts/:id` - Check ownership before deleting\n\n4. **Error Handling**:\n   - Return 403 Forbidden if user doesn't own the post and isn't admin\n   - Return 404 Not Found if post doesn't exist\n\n### Starter Code\n\n\n---\n\n",
              "code": "@Serializable\ndata class Post(\n    val id: Int,\n    val title: String,\n    val content: String,\n    val authorId: Int,\n    val authorName: String,\n    val createdAt: String\n)\n\n@Serializable\ndata class CreatePostRequest(\n    val title: String,\n    val content: String\n)\n\n// TODO: Implement canModifyPost authorization\n// TODO: Implement update and delete with ownership checks",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Solution",
              "content": "\n### Complete Resource Ownership System\n\n\n\n\n### Test Scenarios\n\n**Test 1: Alice creates a post**:\n\n**Test 2: Bob tries to edit Alice's post** (should fail):\n\nResponse (403 Forbidden):\n\n**Test 3: Alice edits her own post** (should succeed):\n\nResponse (200 OK): Post updated successfully!\n\n**Test 4: Admin edits anyone's post** (should succeed):\n\nResponse (200 OK): Post updated successfully!\n\n---\n\n",
              "code": "# Login as admin\nTOKEN_ADMIN=$(curl -s -X POST http://localhost:8080/api/auth/login \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"email\": \"admin@example.com\", \"password\": \"AdminPass789!\"}' \\\n  | jq -r '.data.token')\n\n# Admin can edit Alice's post\ncurl -X PUT http://localhost:8080/api/posts/1 \\\n  -H \"Authorization: Bearer $TOKEN_ADMIN\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"title\": \"Admin Edit\",\n    \"content\": \"Admins can edit any post\"\n  }'",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Solution Explanation",
              "content": "\n### Authorization Levels\n\nThe solution implements three authorization levels:\n\n**Level 1: Public Access** (no authentication)\n- `GET /api/posts` - Anyone can list posts\n- `GET /api/posts/:id` - Anyone can view a post\n\n**Level 2: Authenticated Access** (requires valid token)\n- `POST /api/posts` - Any authenticated user can create posts\n\n**Level 3: Resource Ownership** (requires ownership or admin role)\n- `PUT /api/posts/:id` - Only owner or admin\n- `DELETE /api/posts/:id` - Only owner or admin\n\n### The canModifyPost Function\n\n\nThis elegant function handles both:\n- **Ownership**: `post.authorId == principal.userId`\n- **Role override**: `principal.role == \"ADMIN\"`\n\nAdmins can modify any post, regular users can only modify their own.\n\n---\n\n",
              "code": "private fun canModifyPost(post: Post, principal: UserPrincipal): Boolean {\n    return post.authorId == principal.userId || principal.role == \"ADMIN\"\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n### Real-World Security\n\n**Without Proper Authorization**:\n- Users can delete other users' data\n- Regular users access admin functions\n- Data breaches and privacy violations\n- Legal liability (GDPR, CCPA violations)\n\n**With Proper Authorization**:\n- Users can only access their own resources\n- Admins have elevated permissions\n- Clear audit trail (who did what)\n- Compliance with data protection laws\n\n### Common Authorization Patterns\n\n1. **Public**: No authentication required\n2. **Authenticated**: Any logged-in user\n3. **Owner**: Only resource owner\n4. **Role-Based**: User has required role (ADMIN, MODERATOR, etc.)\n5. **Permission-Based**: User has specific permission (CAN_DELETE_POST, CAN_BAN_USER, etc.)\n6. **Combination**: Owner OR Admin (like our solution)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Checkpoint Quiz",
              "content": "\n### Question 1\nWhat's the difference between authentication and authorization?\n\nA) They're the same thing\nB) Authentication verifies identity, authorization verifies permissions\nC) Authentication is for users, authorization is for admins\nD) Authorization happens before authentication\n\n### Question 2\nWhere should you extract the authenticated user's information in a protected route?\n\nA) From the database\nB) From the request body\nC) From `call.principal<UserPrincipal>()`\nD) From a query parameter\n\n### Question 3\nWhat HTTP status code should you return when a user tries to access an admin-only endpoint without admin role?\n\nA) 401 Unauthorized\nB) 403 Forbidden\nC) 404 Not Found\nD) 500 Internal Server Error\n\n### Question 4\nIn the resource ownership pattern, who can modify a resource?\n\nA) Only the owner\nB) Only admins\nC) The owner OR admins\nD) Anyone with a valid token\n\n### Question 5\nWhat happens if you try to access a protected route without a token?\n\nA) The route executes normally\nB) Ktor returns 403 Forbidden\nC) The challenge function is called, typically returning 401 Unauthorized\nD) The server crashes\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Answers",
              "content": "\n**Question 1: B) Authentication verifies identity, authorization verifies permissions**\n\n- **Authentication**: \"Who are you?\" (prove identity with username/password)\n- **Authorization**: \"Are you allowed to do this?\" (check permissions/roles)\n\nExample: Alice authenticates (proves she's Alice), then authorization checks if Alice can delete posts.\n\n---\n\n**Question 2: C) From `call.principal<UserPrincipal>()`**\n\nAfter successful authentication, Ktor stores the user information in the principal:\n\n\n---\n\n**Question 3: B) 403 Forbidden**\n\nHTTP status code meanings:\n- **401 Unauthorized**: Not authenticated (no token or invalid token)\n- **403 Forbidden**: Authenticated but not authorized (valid token but insufficient permissions)\n- **404 Not Found**: Resource doesn't exist\n- **500 Internal Server Error**: Server bug\n\n---\n\n**Question 4: C) The owner OR admins**\n\nThe canModifyPost function implements:\n\nThis allows:\n- Owner to modify their own posts\n- Admins to modify any post (moderator pattern)\n\n---\n\n**Question 5: C) The challenge function is called, typically returning 401 Unauthorized**\n\nThe authentication flow:\n1. Request arrives without token (or invalid token)\n2. `validate { }` function returns null\n3. `challenge { }` function is called\n4. Returns 401 Unauthorized with error message\n\n---\n\n",
              "code": "return post.authorId == principal.userId || principal.role == \"ADMIN\"",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "What You've Learned",
              "content": "\n‚úÖ How to configure Ktor's JWT authentication plugin\n‚úÖ How to create protected routes requiring valid tokens\n‚úÖ How to extract authenticated user information with call.principal()\n‚úÖ How to implement role-based access control (USER vs ADMIN)\n‚úÖ How to implement resource ownership authorization\n‚úÖ Difference between authentication (who are you) and authorization (what can you do)\n‚úÖ Proper HTTP status codes (401 vs 403)\n‚úÖ How to combine multiple authorization strategies (ownership OR role)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Next Steps",
              "content": "\nIn **Lesson 5.13**, you'll learn **Dependency Injection with Koin**. You'll discover:\n- Why dependency injection improves testability and maintainability\n- How to set up Koin in Ktor applications\n- How to inject repositories, services, and other dependencies\n- How to create different configurations for development vs testing\n- How to replace manual dependency wiring with automated injection\n\nThe authentication system you built will become even cleaner with DI!\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "5.13",
          "title": "Lesson 5.13: Dependency Injection with Koin",
          "moduleId": "module-05",
          "order": 5,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 60 minutes\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Topic Introduction",
              "content": "\nLook at your Application.kt file. You've been manually creating and wiring dependencies:\n\n\nThis works for small applications, but as your app grows, manual dependency management becomes unwieldy:\n- Hard to test (can't easily swap implementations)\n- Violates Single Responsibility Principle (Application.kt does too much)\n- Difficult to manage complex dependency graphs\n- No compile-time safety for missing dependencies\n\n**Dependency Injection** (DI) frameworks solve these problems. In this lesson, you'll learn Koin‚Äîthe most popular DI framework for Kotlin.\n\n---\n\n",
              "code": "val userRepository = UserRepositoryImpl()\nval userService = UserService(userRepository)\nval authService = AuthService(userRepository)",
              "language": "kotlin"
            },
            {
              "type": "ANALOGY",
              "title": "The Concept",
              "content": "\n### The Restaurant Kitchen Analogy\n\nThink of dependency injection like a restaurant kitchen:\n\n**Without DI (Manual Wiring)**:\n- Chef makes every ingredient from scratch\n- Chef grows vegetables, mills flour, butchers meat\n- Result: Chef spends all day preparing ingredients, no time to cook!\n- Can't easily swap ingredients (hard to test recipes)\n\n**With DI (Koin)**:\n- Chef receives pre-prepared ingredients\n- Pantry manager (Koin) provides what chef needs\n- Chef just cooks (focuses on business logic)\n- Easy to swap ingredients (mock data for testing)\n- ‚úÖ Clean separation of concerns!\n\nKoin is your \"pantry manager\" that provides dependencies when needed.\n\n### What is Dependency Injection?\n\n**Dependency**: An object that another object needs to function\n\n\n**Injection**: Providing dependencies from the outside, rather than creating them inside\n\n\n### Why Dependency Injection?\n\n| Without DI | With DI |\n|------------|---------|\n| Hard-coded dependencies | Flexible, swappable dependencies |\n| Difficult to test | Easy to mock and test |\n| Tight coupling | Loose coupling |\n| Manual wiring everywhere | Centralized configuration |\n| No compile-time safety | Type-safe resolution |\n\n### Koin vs Other DI Frameworks\n\n| Framework | Approach | Pros | Cons |\n|-----------|----------|------|------|\n| **Koin** | Service locator pattern | Simple, lightweight, Kotlin-first | Runtime errors if misconfigured |\n| **Dagger** | Code generation | Compile-time safety, fast runtime | Complex, steep learning curve |\n| **Manual** | Factories, builders | Full control | Tedious, error-prone |\n\nFor Kotlin backend development, **Koin is the sweet spot**: simple yet powerful.\n\n---\n\n",
              "code": "// ‚ùå Without DI: UserService creates its own dependency\nclass UserService {\n    private val userRepository = UserRepositoryImpl()  // Hard-coded!\n}\n\n// ‚úÖ With DI: Dependency provided from outside\nclass UserService(\n    private val userRepository: UserRepository  // Injected via constructor\n)",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Setting Up Koin",
              "content": "\n### Step 1: Add Koin Dependency\n\nUpdate your `build.gradle.kts`:\n\n\n### Step 2: Define Koin Modules\n\nCreate a configuration file that declares all your dependencies:\n\n\n**Key Koin DSL functions**:\n- `single { }`: Creates a singleton (one instance for entire app)\n- `factory { }`: Creates a new instance every time\n- `get()`: Resolves a dependency from Koin\n\n### Step 3: Install Koin in Ktor\n\nUpdate your Application.kt:\n\n\n**Before Koin**:\n\n**After Koin**:\n\nMuch cleaner! Koin handles all the wiring automatically.\n\n---\n\n",
              "code": "// Automatic dependency injection\nval userService by inject<UserService>()\nval authService by inject<AuthService>()",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Advanced Koin Features",
              "content": "\n### Organizing Modules\n\nAs your app grows, split modules by feature:\n\n\nLoad all modules:\n\n### Named Dependencies\n\nSometimes you need multiple instances of the same type:\n\n\n### Scopes\n\nKoin supports scoped instances (created per request, per session, etc.):\n\n\n### Factory vs Single\n\n\n**When to use each**:\n- **Single**: Services, repositories, database connections (stateless or shared state)\n- **Factory**: Request/response objects, temporary data (stateful per-request)\n\n---\n\n",
              "code": "val exampleModule = module {\n    // Single: One instance for entire application\n    single { EmailService() }  // Reused everywhere\n\n    // Factory: New instance every time\n    factory { EmailMessage() }  // Fresh message each time\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Dependency Injection in Routes",
              "content": "\nYou can inject dependencies directly in route functions:\n\n\nUpdate routing setup:\n\n---\n\n",
              "code": "routing {\n    authRoutes()    // No need to pass dependencies!\n    userRoutes()\n    adminRoutes()\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Testing with Koin",
              "content": "\nKoin makes testing incredibly easy by allowing you to swap implementations:\n\n\n**Benefits**:\n- No database setup needed\n- Fast tests (in-memory mock data)\n- Easy to simulate different scenarios\n- Complete isolation between tests\n\n---\n\n",
              "code": "// src/test/kotlin/com/example/UserServiceTest.kt\npackage com.example\n\nimport com.example.di.appModule\nimport com.example.models.User\nimport com.example.repositories.UserRepository\nimport com.example.services.UserService\nimport org.junit.jupiter.api.AfterEach\nimport org.junit.jupiter.api.BeforeEach\nimport org.junit.jupiter.api.Test\nimport org.koin.core.context.startKoin\nimport org.koin.core.context.stopKoin\nimport org.koin.dsl.module\nimport org.koin.test.KoinTest\nimport org.koin.test.inject\nimport kotlin.test.assertEquals\nimport kotlin.test.assertNotNull\n\n/**\n * Mock repository for testing\n */\nclass MockUserRepository : UserRepository {\n    private val users = mutableMapOf<Int, User>()\n    private var nextId = 1\n\n    override fun insert(\n        email: String,\n        passwordHash: String,\n        fullName: String,\n        role: String\n    ): Int {\n        val id = nextId++\n        users[id] = User(\n            id = id,\n            email = email,\n            fullName = fullName,\n            role = role,\n            createdAt = \"2025-01-01T00:00:00\"\n        )\n        return id\n    }\n\n    override fun getById(id: Int): User? = users[id]\n\n    override fun getByEmail(email: String): User? =\n        users.values.find { it.email == email }\n\n    override fun getPasswordHash(email: String): String? = null\n    override fun emailExists(email: String): Boolean = getByEmail(email) != null\n}\n\n/**\n * Test module with mock dependencies\n */\nval testModule = module {\n    single<UserRepository> { MockUserRepository() }  // Mock instead of real\n    single { UserService(get()) }\n}\n\nclass UserServiceTest : KoinTest {\n\n    // Inject UserService (using mock repository)\n    private val userService: UserService by inject()\n\n    @BeforeEach\n    fun setup() {\n        startKoin {\n            modules(testModule)  // Load test module instead of app module\n        }\n    }\n\n    @AfterEach\n    fun teardown() {\n        stopKoin()\n    }\n\n    @Test\n    fun `test user creation`() {\n        // This uses MockUserRepository, no real database needed!\n        val user = userService.createUser(\n            email = \"test@example.com\",\n            passwordHash = \"hash\",\n            fullName = \"Test User\",\n            role = \"USER\"\n        ).getOrNull()\n\n        assertNotNull(user)\n        assertEquals(\"test@example.com\", user.email)\n        assertEquals(\"Test User\", user.fullName)\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "EXAMPLE",
              "title": "Complete Example: Refactoring to Koin",
              "content": "\nLet's refactor our entire application to use Koin:\n\n### Module Definitions\n\n\n### Application Setup\n\n\n### Routes with Injection\n\n\n---\n\n",
              "code": "// src/main/kotlin/com/example/routes/AuthRoutes.kt\npackage com.example.routes\n\nimport com.example.models.ApiResponse\nimport com.example.models.LoginRequest\nimport com.example.models.RegisterRequest\nimport com.example.models.RegisterResponse\nimport com.example.services.AuthService\nimport com.example.services.UserService\nimport io.ktor.http.*\nimport io.ktor.server.application.*\nimport io.ktor.server.request.*\nimport io.ktor.server.response.*\nimport io.ktor.server.routing.*\nimport org.koin.ktor.ext.inject\n\nfun Route.authRoutes() {\n    // Inject dependencies\n    val userService by inject<UserService>()\n    val authService by inject<AuthService>()\n\n    route(\"/api/auth\") {\n        post(\"/register\") {\n            val request = call.receive<RegisterRequest>()\n\n            userService.register(request)\n                .onSuccess { user ->\n                    call.respond(\n                        HttpStatusCode.Created,\n                        ApiResponse(\n                            data = RegisterResponse(\n                                user = user,\n                                message = \"Registration successful\"\n                            )\n                        )\n                    )\n                }\n                .onFailure { error ->\n                    throw error\n                }\n        }\n\n        post(\"/login\") {\n            val request = call.receive<LoginRequest>()\n\n            authService.login(request)\n                .onSuccess { loginResponse ->\n                    call.respond(ApiResponse(data = loginResponse))\n                }\n                .onFailure { error ->\n                    throw error\n                }\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Breakdown",
              "content": "\n### Dependency Resolution Flow\n\n\n### get() Function\n\nThe `get()` function resolves dependencies:\n\n\nType inference determines what to inject based on parameter types.\n\n### by inject<T>() Delegate\n\n\nThis is a **lazy delegate**:\n- `userService` is resolved when first accessed (lazy)\n- Subsequent accesses return the same instance (for singletons)\n- Type-safe (compile-time checking)\n\n---\n\n",
              "code": "val userService by inject<UserService>()",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise: Multi-Tenant Application",
              "content": "\nBuild a multi-tenant blog platform where each tenant has isolated data.\n\n### Requirements\n\n1. **Tenant Context**:\n   - Extract tenant ID from request header: `X-Tenant-ID`\n   - Store in request-scoped object\n\n2. **Tenant-Specific Repositories**:\n   - Each tenant has separate database schema\n   - Repositories filter by tenant ID automatically\n\n3. **Koin Scopes**:\n   - Create request scope for tenant context\n   - Inject tenant-aware repositories\n\n4. **Implementation**:\n   ```kotlin\n   // Tenant context\n   data class TenantContext(val tenantId: String)\n\n   // Tenant-aware repository\n   class TenantUserRepository(private val tenantContext: TenantContext) : UserRepository {\n       override fun getAll(): List<User> {\n           // Filter by tenantContext.tenantId\n       }\n   }\n   ```\n\n### Starter Code\n\n\n---\n\n",
              "code": "val tenantModule = module {\n    // TODO: Define request scope\n    // TODO: Provide TenantContext from request header\n    // TODO: Provide tenant-aware repositories\n}\n\n// TODO: Create middleware to extract tenant ID\n// TODO: Inject tenant-aware repositories in routes",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Solution",
              "content": "\n### Complete Multi-Tenant System\n\n\n### Testing\n\n\n---\n\n",
              "code": "# Request for Tenant A\ncurl -X GET http://localhost:8080/api/users \\\n  -H \"X-Tenant-ID: tenant-a\"\n\n# Returns only Tenant A's users\n\n# Request for Tenant B\ncurl -X GET http://localhost:8080/api/users \\\n  -H \"X-Tenant-ID: tenant-b\"\n\n# Returns only Tenant B's users",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n### Real-World Benefits\n\n**Before Koin** (Manual DI):\n\n**After Koin**:\n\nAll wiring handled centrally in modules!\n\n### Testing Impact\n\n**Without DI**:\n- Tests require real database\n- Hard to isolate components\n- Slow test execution\n- Complex test setup\n\n**With Koin**:\n- Swap implementations with mocks\n- Fast, isolated unit tests\n- Simple test configuration\n- Easy to simulate edge cases\n\n---\n\n",
              "code": "// Application.kt - 5 lines\ninstall(Koin) {\n    modules(appModules)\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Checkpoint Quiz",
              "content": "\n### Question 1\nWhat's the difference between `single` and `factory` in Koin?\n\nA) `single` is faster than `factory`\nB) `single` creates one instance (singleton), `factory` creates new instances each time\nC) `factory` is for factories only\nD) They're the same\n\n### Question 2\nWhat does the `get()` function do in Koin module definitions?\n\nA) Gets data from the database\nB) Resolves a dependency from Koin\nC) Creates a new instance\nD) Makes an HTTP GET request\n\n### Question 3\nWhy is dependency injection important for testing?\n\nA) It makes tests run faster\nB) It allows swapping real implementations with mocks\nC) It's required by JUnit\nD) It generates test data automatically\n\n### Question 4\nWhat is the lazy delegate `by inject<T>()` used for?\n\nA) Making API calls lazily\nB) Lazy loading from database\nC) Resolving dependencies from Koin when first accessed\nD) Delaying function execution\n\n### Question 5\nWhen should you use scoped dependencies instead of singletons?\n\nA) Never, singletons are always better\nB) When you need per-request or per-session instances\nC) Only for testing\nD) When the dependency is expensive to create\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Answers",
              "content": "\n**Question 1: B) `single` creates one instance (singleton), `factory` creates new instances each time**\n\n\nUse `single` for stateless services (UserService, repositories).\nUse `factory` for stateful objects (request data, messages).\n\n---\n\n**Question 2: B) Resolves a dependency from Koin**\n\n\nKoin uses type inference to determine what to inject.\n\n---\n\n**Question 3: B) It allows swapping real implementations with mocks**\n\n\nTests use mock implementations without changing service code!\n\n---\n\n**Question 4: C) Resolving dependencies from Koin when first accessed**\n\n\nThis is more efficient than eager resolution.\n\n---\n\n**Question 5: B) When you need per-request or per-session instances**\n\n**Singleton** (shared state):\n- Database connections\n- Configuration\n- Stateless services\n\n**Scoped** (isolated state):\n- Request context (tenant ID, user session)\n- Transaction boundaries\n- Per-request caches\n\nMulti-tenant applications are a perfect use case for scopes!\n\n---\n\n",
              "code": "val userService by inject<UserService>()\n// Lazy: userService is resolved when first accessed\n// Subsequent accesses return the same instance (for singletons)",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "What You've Learned",
              "content": "\n‚úÖ What dependency injection is and why it matters\n‚úÖ How to set up Koin in Ktor applications\n‚úÖ How to define modules with `single`, `factory`, and `get()`\n‚úÖ How to inject dependencies with `by inject<T>()`\n‚úÖ How to organize modules by feature (repositories, services, etc.)\n‚úÖ How to use named dependencies and scopes\n‚úÖ How to write testable code with mock dependencies\n‚úÖ How to build multi-tenant systems with scoped dependencies\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Next Steps",
              "content": "\nIn **Lesson 5.14**, you'll learn **Testing Your API**. You'll discover:\n- How to write unit tests for services with mock repositories\n- How to write integration tests for full API endpoints\n- How to use Ktor's testing utilities\n- How to test authentication and authorization\n- How to measure code coverage\n\nThe clean DI architecture you built makes testing incredibly easy!\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "5.14",
          "title": "Lesson 5.14: Testing Your API",
          "moduleId": "module-05",
          "order": 6,
          "estimatedMinutes": 70,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 70 minutes\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Topic Introduction",
              "content": "\nYou've built a complete backend API with authentication, validation, and clean architecture. But how do you know it works correctly? How do you ensure new features don't break existing functionality?\n\nThe answer: **automated testing**.\n\nIn this lesson, you'll learn how to write comprehensive tests for your Ktor API, from unit tests for individual services to integration tests for full HTTP endpoints. You'll use Ktor's testing utilities and Koin's test features to build a robust test suite.\n\n---\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "The Concept",
              "content": "\n### The Safety Net Analogy\n\nThink of tests like a safety net for trapeze artists:\n\n**Without Tests (No Safety Net)**:\n- Every code change is scary\n- Fear of breaking things prevents improvements\n- Bugs discovered by users (embarrassing!)\n- Hours spent manually testing after each change\n- üò∞ High stress, low confidence\n\n**With Tests (Safety Net)**:\n- Confident refactoring\n- Catch bugs before deployment\n- Automated validation (run tests in seconds)\n- Documentation (tests show how code should work)\n- ‚úÖ Low stress, high confidence!\n\nTests are your safety net‚Äîthey catch you when you fall.\n\n### The Testing Pyramid\n\n\n**Test Distribution**:\n- **70%** Unit Tests: Fast, isolated, test individual functions\n- **20%** Integration Tests: Test components working together\n- **10%** End-to-End Tests: Test entire system from UI to database\n\nWe'll focus on unit and integration tests for backend APIs.\n\n### Types of Tests for APIs\n\n| Test Type | What It Tests | Example |\n|-----------|---------------|---------|\n| **Unit** | Single function/class in isolation | UserService.createUser() with mock repository |\n| **Integration** | Multiple components together | POST /api/users endpoint with real database |\n| **Contract** | API matches specification | Response has required fields |\n| **Performance** | Speed and scalability | API handles 1000 req/sec |\n\n---\n\n",
              "code": "          /\\\n         /  \\        E2E Tests (Few)\n        /____\\       - Full system, slow, brittle\n       /      \\\n      /        \\     Integration Tests (Some)\n     /__________\\    - Multiple components, medium speed\n    /            \\\n   /              \\  Unit Tests (Many)\n  /________________\\ - Single component, fast, reliable",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Setting Up Testing",
              "content": "\n### Step 1: Add Test Dependencies\n\nUpdate your `build.gradle.kts`:\n\n\n---\n\n",
              "code": "dependencies {\n    // Production dependencies\n    implementation(\"io.ktor:ktor-server-core-jvm:3.0.2\")\n    implementation(\"io.ktor:ktor-server-cio-jvm:3.0.2\")\n    implementation(\"io.ktor:ktor-server-content-negotiation-jvm:3.0.2\")\n    implementation(\"io.ktor:ktor-serialization-kotlinx-json-jvm:3.0.2\")\n    implementation(\"io.ktor:ktor-server-auth-jvm:3.0.2\")\n    implementation(\"io.ktor:ktor-server-auth-jwt-jvm:3.0.2\")\n    implementation(\"org.jetbrains.exposed:exposed-core:0.50.0\")\n    implementation(\"org.jetbrains.exposed:exposed-jdbc:0.50.0\")\n    implementation(\"com.h2database:h2:2.2.224\")\n    implementation(\"com.zaxxer:HikariCP:5.1.0\")\n    implementation(\"de.nycode:bcrypt:2.3.0\")\n    implementation(\"com.auth0:java-jwt:4.5.0\")\n    implementation(\"io.insert-koin:koin-ktor:4.0.3\")\n    implementation(\"io.insert-koin:koin-logger-slf4j:4.0.3\")\n\n    // Test dependencies\n    testImplementation(\"io.ktor:ktor-server-test-host:3.0.2\")\n    testImplementation(\"org.jetbrains.kotlin:kotlin-test-junit5:2.0.0\")\n    testImplementation(\"org.junit.jupiter:junit-jupiter-api:5.10.2\")\n    testRuntimeOnly(\"org.junit.jupiter:junit-jupiter-engine:5.10.2\")\n    testImplementation(\"io.insert-koin:koin-test:4.0.3\")\n    testImplementation(\"io.insert-koin:koin-test-junit5:4.0.3\")\n}\n\ntasks.withType<Test> {\n    useJUnitPlatform()\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Unit Testing Services",
              "content": "\n### Example: Testing UserService\n\n\n### Running Unit Tests\n\n\nOutput:\n\n---\n\n",
              "code": "UserServiceTest > should create user successfully PASSED\nUserServiceTest > should fail when email already exists PASSED\nUserServiceTest > should retrieve user by ID PASSED\nUserServiceTest > should return not found for non-existent user PASSED\nUserServiceTest > should update user profile PASSED\n\nBUILD SUCCESSFUL in 2s\n5 tests completed, 5 passed",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Integration Testing Endpoints",
              "content": "\n### Example: Testing Auth Endpoints\n\n\n---\n\n",
              "code": "// src/test/kotlin/com/example/routes/AuthRoutesTest.kt\npackage com.example.routes\n\nimport com.example.database.DatabaseFactory\nimport com.example.di.appModules\nimport com.example.models.ApiResponse\nimport com.example.models.LoginRequest\nimport com.example.models.LoginResponse\nimport com.example.models.RegisterRequest\nimport com.example.module\nimport io.ktor.client.call.*\nimport io.ktor.client.plugins.contentnegotiation.*\nimport io.ktor.client.request.*\nimport io.ktor.http.*\nimport io.ktor.serialization.kotlinx.json.*\nimport io.ktor.server.testing.*\nimport kotlinx.serialization.json.Json\nimport org.junit.jupiter.api.AfterAll\nimport org.junit.jupiter.api.BeforeAll\nimport org.junit.jupiter.api.Test\nimport org.koin.core.context.stopKoin\nimport kotlin.test.assertEquals\nimport kotlin.test.assertNotNull\nimport kotlin.test.assertTrue\n\nclass AuthRoutesTest {\n\n    companion object {\n        @BeforeAll\n        @JvmStatic\n        fun setup() {\n            // Initialize test database\n            DatabaseFactory.init()\n        }\n\n        @AfterAll\n        @JvmStatic\n        fun teardown() {\n            stopKoin()\n        }\n    }\n\n    @Test\n    fun `test user registration`() = testApplication {\n        application {\n            module()  // Load your application module\n        }\n\n        // Create HTTP client with JSON support\n        val client = createClient {\n            install(ContentNegotiation) {\n                json(Json {\n                    ignoreUnknownKeys = true\n                })\n            }\n        }\n\n        // Send registration request\n        val response = client.post(\"/api/auth/register\") {\n            contentType(ContentType.Application.Json)\n            setBody(\n                RegisterRequest(\n                    email = \"test@example.com\",\n                    password = \"SecurePass123!\",\n                    fullName = \"Test User\"\n                )\n            )\n        }\n\n        // Assert response\n        assertEquals(HttpStatusCode.Created, response.status)\n\n        val apiResponse = response.body<ApiResponse<RegisterResponse>>()\n        assertTrue(apiResponse.success)\n        assertNotNull(apiResponse.data)\n        assertEquals(\"test@example.com\", apiResponse.data?.user?.email)\n        assertEquals(\"Test User\", apiResponse.data?.user?.fullName)\n    }\n\n    @Test\n    fun `test user registration with weak password`() = testApplication {\n        application {\n            module()\n        }\n\n        val client = createClient {\n            install(ContentNegotiation) {\n                json(Json {\n                    ignoreUnknownKeys = true\n                })\n            }\n        }\n\n        val response = client.post(\"/api/auth/register\") {\n            contentType(ContentType.Application.Json)\n            setBody(\n                RegisterRequest(\n                    email = \"test2@example.com\",\n                    password = \"weak\",  // Weak password\n                    fullName = \"Test User 2\"\n                )\n            )\n        }\n\n        // Assert validation error\n        assertEquals(HttpStatusCode.BadRequest, response.status)\n\n        val apiResponse = response.body<ErrorResponse>()\n        assertEquals(false, apiResponse.success)\n        assertNotNull(apiResponse.errors)\n        assertTrue(apiResponse.errors!!.containsKey(\"password\"))\n    }\n\n    @Test\n    fun `test user login`() = testApplication {\n        application {\n            module()\n        }\n\n        val client = createClient {\n            install(ContentNegotiation) {\n                json(Json {\n                    ignoreUnknownKeys = true\n                })\n            }\n        }\n\n        // First, register a user\n        client.post(\"/api/auth/register\") {\n            contentType(ContentType.Application.Json)\n            setBody(\n                RegisterRequest(\n                    email = \"login@example.com\",\n                    password = \"SecurePass123!\",\n                    fullName = \"Login User\"\n                )\n            )\n        }\n\n        // Now, login with credentials\n        val loginResponse = client.post(\"/api/auth/login\") {\n            contentType(ContentType.Application.Json)\n            setBody(\n                LoginRequest(\n                    email = \"login@example.com\",\n                    password = \"SecurePass123!\"\n                )\n            )\n        }\n\n        // Assert successful login\n        assertEquals(HttpStatusCode.OK, loginResponse.status)\n\n        val apiResponse = loginResponse.body<ApiResponse<LoginResponse>>()\n        assertTrue(apiResponse.success)\n        assertNotNull(apiResponse.data)\n        assertNotNull(apiResponse.data?.token)\n        assertEquals(\"login@example.com\", apiResponse.data?.user?.email)\n    }\n\n    @Test\n    fun `test login with wrong password`() = testApplication {\n        application {\n            module()\n        }\n\n        val client = createClient {\n            install(ContentNegotiation) {\n                json(Json {\n                    ignoreUnknownKeys = true\n                })\n            }\n        }\n\n        // Register user\n        client.post(\"/api/auth/register\") {\n            contentType(ContentType.Application.Json)\n            setBody(\n                RegisterRequest(\n                    email = \"wrong@example.com\",\n                    password = \"SecurePass123!\",\n                    fullName = \"Wrong User\"\n                )\n            )\n        }\n\n        // Try to login with wrong password\n        val loginResponse = client.post(\"/api/auth/login\") {\n            contentType(ContentType.Application.Json)\n            setBody(\n                LoginRequest(\n                    email = \"wrong@example.com\",\n                    password = \"WrongPassword!\"\n                )\n            )\n        }\n\n        // Assert unauthorized\n        assertEquals(HttpStatusCode.Unauthorized, loginResponse.status)\n\n        val apiResponse = loginResponse.body<ErrorResponse>()\n        assertEquals(false, apiResponse.success)\n        assertEquals(\"Invalid email or password\", apiResponse.message)\n    }\n\n    @Test\n    fun `test duplicate email registration`() = testApplication {\n        application {\n            module()\n        }\n\n        val client = createClient {\n            install(ContentNegotiation) {\n                json(Json {\n                    ignoreUnknownKeys = true\n                })\n            }\n        }\n\n        // Register first user\n        client.post(\"/api/auth/register\") {\n            contentType(ContentType.Application.Json)\n            setBody(\n                RegisterRequest(\n                    email = \"duplicate@example.com\",\n                    password = \"SecurePass123!\",\n                    fullName = \"First User\"\n                )\n            )\n        }\n\n        // Try to register second user with same email\n        val response = client.post(\"/api/auth/register\") {\n            contentType(ContentType.Application.Json)\n            setBody(\n                RegisterRequest(\n                    email = \"duplicate@example.com\",\n                    password = \"DifferentPass456!\",\n                    fullName = \"Second User\"\n                )\n            )\n        }\n\n        // Assert conflict error\n        assertEquals(HttpStatusCode.Conflict, response.status)\n\n        val apiResponse = response.body<ErrorResponse>()\n        assertEquals(false, apiResponse.success)\n        assertTrue(apiResponse.message.contains(\"already exists\"))\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Testing Protected Endpoints",
              "content": "\n\n---\n\n",
              "code": "// src/test/kotlin/com/example/routes/UserRoutesTest.kt\npackage com.example.routes\n\nimport com.example.database.DatabaseFactory\nimport com.example.models.*\nimport com.example.module\nimport io.ktor.client.call.*\nimport io.ktor.client.plugins.contentnegotiation.*\nimport io.ktor.client.request.*\nimport io.ktor.http.*\nimport io.ktor.serialization.kotlinx.json.*\nimport io.ktor.server.testing.*\nimport kotlinx.serialization.json.Json\nimport org.junit.jupiter.api.AfterAll\nimport org.junit.jupiter.api.BeforeAll\nimport org.junit.jupiter.api.Test\nimport org.koin.core.context.stopKoin\nimport kotlin.test.assertEquals\nimport kotlin.test.assertNotNull\n\nclass UserRoutesTest {\n\n    companion object {\n        @BeforeAll\n        @JvmStatic\n        fun setup() {\n            DatabaseFactory.init()\n        }\n\n        @AfterAll\n        @JvmStatic\n        fun teardown() {\n            stopKoin()\n        }\n    }\n\n    /**\n     * Helper function to register and login, returning the JWT token\n     */\n    private suspend fun ApplicationTestBuilder.registerAndLogin(\n        client: io.ktor.client.HttpClient,\n        email: String = \"test@example.com\",\n        password: String = \"SecurePass123!\",\n        fullName: String = \"Test User\"\n    ): String {\n        // Register\n        client.post(\"/api/auth/register\") {\n            contentType(ContentType.Application.Json)\n            setBody(RegisterRequest(email, password, fullName))\n        }\n\n        // Login\n        val loginResponse = client.post(\"/api/auth/login\") {\n            contentType(ContentType.Application.Json)\n            setBody(LoginRequest(email, password))\n        }\n\n        val apiResponse = loginResponse.body<ApiResponse<LoginResponse>>()\n        return apiResponse.data?.token ?: throw Exception(\"No token received\")\n    }\n\n    @Test\n    fun `test get current user profile`() = testApplication {\n        application {\n            module()\n        }\n\n        val client = createClient {\n            install(ContentNegotiation) {\n                json(Json {\n                    ignoreUnknownKeys = true\n                })\n            }\n        }\n\n        // Get token\n        val token = registerAndLogin(client, email = \"profile@example.com\")\n\n        // Get profile\n        val response = client.get(\"/api/users/me\") {\n            header(HttpHeaders.Authorization, \"Bearer $token\")\n        }\n\n        // Assert\n        assertEquals(HttpStatusCode.OK, response.status)\n\n        val apiResponse = response.body<ApiResponse<User>>()\n        assertNotNull(apiResponse.data)\n        assertEquals(\"profile@example.com\", apiResponse.data?.email)\n    }\n\n    @Test\n    fun `test access protected route without token`() = testApplication {\n        application {\n            module()\n        }\n\n        val client = createClient {\n            install(ContentNegotiation) {\n                json(Json {\n                    ignoreUnknownKeys = true\n                })\n            }\n        }\n\n        // Try to access without token\n        val response = client.get(\"/api/users/me\")\n\n        // Assert unauthorized\n        assertEquals(HttpStatusCode.Unauthorized, response.status)\n    }\n\n    @Test\n    fun `test access protected route with invalid token`() = testApplication {\n        application {\n            module()\n        }\n\n        val client = createClient {\n            install(ContentNegotiation) {\n                json(Json {\n                    ignoreUnknownKeys = true\n                })\n            }\n        }\n\n        // Try with invalid token\n        val response = client.get(\"/api/users/me\") {\n            header(HttpHeaders.Authorization, \"Bearer invalid-token\")\n        }\n\n        // Assert unauthorized\n        assertEquals(HttpStatusCode.Unauthorized, response.status)\n    }\n\n    @Test\n    fun `test update user profile`() = testApplication {\n        application {\n            module()\n        }\n\n        val client = createClient {\n            install(ContentNegotiation) {\n                json(Json {\n                    ignoreUnknownKeys = true\n                })\n            }\n        }\n\n        val token = registerAndLogin(\n            client,\n            email = \"update@example.com\",\n            fullName = \"Original Name\"\n        )\n\n        // Update profile\n        val response = client.put(\"/api/users/me\") {\n            header(HttpHeaders.Authorization, \"Bearer $token\")\n            contentType(ContentType.Application.Json)\n            setBody(UpdateProfileRequest(fullName = \"Updated Name\"))\n        }\n\n        // Assert\n        assertEquals(HttpStatusCode.OK, response.status)\n\n        val apiResponse = response.body<ApiResponse<User>>()\n        assertEquals(\"Updated Name\", apiResponse.data?.fullName)\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Testing with Koin",
              "content": "\n### Test Module Setup\n\n\n---\n\n",
              "code": "// src/test/kotlin/com/example/TestModule.kt\npackage com.example\n\nimport com.example.repositories.UserRepository\nimport com.example.services.AuthService\nimport com.example.services.UserService\nimport org.koin.dsl.module\n\nclass MockUserRepository : UserRepository {\n    // ... implementation\n}\n\nval testModule = module {\n    single<UserRepository> { MockUserRepository() }\n    single { UserService(get()) }\n    single { AuthService(get()) }\n}\n\n// Usage in tests\n@ExtendWith(KoinExtension::class)\n@KoinTest\nclass MyServiceTest {\n\n    @BeforeEach\n    fun setup() {\n        startKoin {\n            modules(testModule)\n        }\n    }\n\n    @AfterEach\n    fun teardown() {\n        stopKoin()\n    }\n\n    @Test\n    fun `test with Koin`() {\n        val userService by inject<UserService>()\n        // Test using injected service\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Test Coverage",
              "content": "\n### Generate Coverage Report\n\nAdd JaCoCo plugin to `build.gradle.kts`:\n\n\nRun tests with coverage:\n\nView report at: `build/reports/jacoco/test/html/index.html`\n\n---\n\n",
              "code": "./gradlew test jacocoTestReport",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Best Practices",
              "content": "\n### 1. Test Naming Convention\n\n\nUse backticks for descriptive test names that read like sentences.\n\n### 2. AAA Pattern\n\n\n### 3. Test Isolation\n\n\nEach test should be independent and not affect others.\n\n### 4. Test Data Builders\n\n\n---\n\n",
              "code": "object TestDataBuilder {\n    fun createUser(\n        id: Int = 1,\n        email: String = \"test@example.com\",\n        fullName: String = \"Test User\",\n        role: String = \"USER\"\n    ) = User(\n        id = id,\n        email = email,\n        fullName = fullName,\n        role = role,\n        createdAt = \"2025-01-01T00:00:00\"\n    )\n\n    fun createRegisterRequest(\n        email: String = \"test@example.com\",\n        password: String = \"SecurePass123!\",\n        fullName: String = \"Test User\"\n    ) = RegisterRequest(email, password, fullName)\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise: Complete Test Suite",
              "content": "\nWrite a complete test suite for the Post API.\n\n### Requirements\n\n1. **Unit Tests for PostService**:\n   - Test create post\n   - Test update post with ownership check\n   - Test delete post with ownership check\n   - Test get posts by user\n\n2. **Integration Tests for Post Routes**:\n   - Test POST /api/posts (create post)\n   - Test GET /api/posts (get all posts)\n   - Test PUT /api/posts/:id (update post - owner only)\n   - Test DELETE /api/posts/:id (delete post - owner only)\n   - Test authorization (user can't modify others' posts)\n   - Test admin can modify any post\n\n3. **Test Coverage**:\n   - Aim for 80%+ coverage on services\n   - Test all error paths (validation, not found, forbidden)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution",
              "content": "\n\n---\n\n",
              "code": "// src/test/kotlin/com/example/services/PostServiceTest.kt\npackage com.example.services\n\nimport com.example.models.Post\nimport com.example.models.CreatePostRequest\nimport com.example.plugins.UserPrincipal\nimport com.example.repositories.PostRepository\nimport org.junit.jupiter.api.BeforeEach\nimport org.junit.jupiter.api.Test\nimport kotlin.test.*\n\nclass MockPostRepository : PostRepository {\n    private val posts = mutableMapOf<Int, Post>()\n    private var nextId = 1\n\n    override fun insert(title: String, content: String, authorId: Int): Int {\n        val id = nextId++\n        posts[id] = Post(\n            id = id,\n            title = title,\n            content = content,\n            authorId = authorId,\n            authorName = \"Test User\",\n            createdAt = \"2025-01-01T00:00:00\"\n        )\n        return id\n    }\n\n    override fun update(id: Int, title: String, content: String): Boolean {\n        val post = posts[id] ?: return false\n        posts[id] = post.copy(title = title, content = content)\n        return true\n    }\n\n    override fun delete(id: Int): Boolean {\n        return posts.remove(id) != null\n    }\n\n    override fun getById(id: Int): Post? = posts[id]\n\n    override fun getAll(): List<Post> = posts.values.toList()\n\n    fun reset() {\n        posts.clear()\n        nextId = 1\n    }\n}\n\nclass PostServiceTest {\n\n    private lateinit var mockPostRepository: MockPostRepository\n    private lateinit var postService: PostService\n\n    @BeforeEach\n    fun setup() {\n        mockPostRepository = MockPostRepository()\n        postService = PostService(mockPostRepository)\n    }\n\n    @Test\n    fun `should create post successfully`() {\n        // Arrange\n        val request = CreatePostRequest(\n            title = \"Test Post\",\n            content = \"Test content\"\n        )\n        val principal = UserPrincipal(1, \"test@example.com\", \"USER\")\n\n        // Act\n        val result = postService.createPost(request, principal)\n\n        // Assert\n        assertTrue(result.isSuccess)\n        val post = result.getOrNull()\n        assertNotNull(post)\n        assertEquals(\"Test Post\", post?.title)\n        assertEquals(1, post?.authorId)\n    }\n\n    @Test\n    fun `should allow owner to update post`() {\n        // Arrange\n        val principal = UserPrincipal(1, \"test@example.com\", \"USER\")\n        val createRequest = CreatePostRequest(\"Original\", \"Content\")\n        val postId = postService.createPost(createRequest, principal).getOrNull()?.id!!\n\n        // Act\n        val updateRequest = UpdatePostRequest(\"Updated\", \"New content\")\n        val result = postService.updatePost(postId, updateRequest, principal)\n\n        // Assert\n        assertTrue(result.isSuccess)\n        assertEquals(\"Updated\", result.getOrNull()?.title)\n    }\n\n    @Test\n    fun `should deny non-owner from updating post`() {\n        // Arrange\n        val owner = UserPrincipal(1, \"owner@example.com\", \"USER\")\n        val attacker = UserPrincipal(2, \"attacker@example.com\", \"USER\")\n\n        val createRequest = CreatePostRequest(\"Owner's Post\", \"Content\")\n        val postId = postService.createPost(createRequest, owner).getOrNull()?.id!!\n\n        // Act\n        val updateRequest = UpdatePostRequest(\"Hacked\", \"Bad content\")\n        val result = postService.updatePost(postId, updateRequest, attacker)\n\n        // Assert\n        assertTrue(result.isFailure)\n        val exception = result.exceptionOrNull()\n        assertTrue(exception is ForbiddenException)\n    }\n\n    @Test\n    fun `should allow admin to update any post`() {\n        // Arrange\n        val user = UserPrincipal(1, \"user@example.com\", \"USER\")\n        val admin = UserPrincipal(2, \"admin@example.com\", \"ADMIN\")\n\n        val createRequest = CreatePostRequest(\"User's Post\", \"Content\")\n        val postId = postService.createPost(createRequest, user).getOrNull()?.id!!\n\n        // Act\n        val updateRequest = UpdatePostRequest(\"Admin Edit\", \"Updated by admin\")\n        val result = postService.updatePost(postId, updateRequest, admin)\n\n        // Assert\n        assertTrue(result.isSuccess)\n        assertEquals(\"Admin Edit\", result.getOrNull()?.title)\n    }\n\n    @Test\n    fun `should delete post when owner requests`() {\n        // Arrange\n        val principal = UserPrincipal(1, \"test@example.com\", \"USER\")\n        val createRequest = CreatePostRequest(\"Delete Me\", \"Content\")\n        val postId = postService.createPost(createRequest, principal).getOrNull()?.id!!\n\n        // Act\n        val result = postService.deletePost(postId, principal)\n\n        // Assert\n        assertTrue(result.isSuccess)\n\n        // Verify post is gone\n        val getResult = postService.getPostById(postId)\n        assertTrue(getResult.isFailure)\n    }\n}\n\n// src/test/kotlin/com/example/routes/PostRoutesTest.kt\npackage com.example.routes\n\nimport com.example.database.DatabaseFactory\nimport com.example.models.*\nimport com.example.module\nimport io.ktor.client.call.*\nimport io.ktor.client.plugins.contentnegotiation.*\nimport io.ktor.client.request.*\nimport io.ktor.http.*\nimport io.ktor.serialization.kotlinx.json.*\nimport io.ktor.server.testing.*\nimport kotlinx.serialization.json.Json\nimport org.junit.jupiter.api.*\nimport org.koin.core.context.stopKoin\nimport kotlin.test.assertEquals\nimport kotlin.test.assertNotNull\nimport kotlin.test.assertTrue\n\n@TestInstance(TestInstance.Lifecycle.PER_CLASS)\nclass PostRoutesTest {\n\n    @BeforeAll\n    fun setup() {\n        DatabaseFactory.init()\n    }\n\n    @AfterAll\n    fun teardown() {\n        stopKoin()\n    }\n\n    private suspend fun ApplicationTestBuilder.getToken(\n        client: io.ktor.client.HttpClient,\n        email: String,\n        password: String = \"SecurePass123!\"\n    ): String {\n        // Register\n        client.post(\"/api/auth/register\") {\n            contentType(ContentType.Application.Json)\n            setBody(RegisterRequest(email, password, email.substringBefore(\"@\")))\n        }\n\n        // Login\n        val loginResponse = client.post(\"/api/auth/login\") {\n            contentType(ContentType.Application.Json)\n            setBody(LoginRequest(email, password))\n        }\n\n        return loginResponse.body<ApiResponse<LoginResponse>>().data?.token!!\n    }\n\n    @Test\n    fun `test create post`() = testApplication {\n        application { module() }\n\n        val client = createClient {\n            install(ContentNegotiation) {\n                json(Json { ignoreUnknownKeys = true })\n            }\n        }\n\n        val token = getToken(client, \"post-creator@example.com\")\n\n        // Create post\n        val response = client.post(\"/api/posts\") {\n            header(HttpHeaders.Authorization, \"Bearer $token\")\n            contentType(ContentType.Application.Json)\n            setBody(CreatePostRequest(\"My Post\", \"Post content\"))\n        }\n\n        assertEquals(HttpStatusCode.Created, response.status)\n\n        val apiResponse = response.body<ApiResponse<Post>>()\n        assertTrue(apiResponse.success)\n        assertEquals(\"My Post\", apiResponse.data?.title)\n    }\n\n    @Test\n    fun `test user cannot update others post`() = testApplication {\n        application { module() }\n\n        val client = createClient {\n            install(ContentNegotiation) {\n                json(Json { ignoreUnknownKeys = true })\n            }\n        }\n\n        // User A creates post\n        val tokenA = getToken(client, \"usera@example.com\")\n        val createResponse = client.post(\"/api/posts\") {\n            header(HttpHeaders.Authorization, \"Bearer $tokenA\")\n            contentType(ContentType.Application.Json)\n            setBody(CreatePostRequest(\"User A Post\", \"Content\"))\n        }\n        val postId = createResponse.body<ApiResponse<Post>>().data?.id!!\n\n        // User B tries to update\n        val tokenB = getToken(client, \"userb@example.com\")\n        val updateResponse = client.put(\"/api/posts/$postId\") {\n            header(HttpHeaders.Authorization, \"Bearer $tokenB\")\n            contentType(ContentType.Application.Json)\n            setBody(UpdatePostRequest(\"Hacked\", \"Bad content\"))\n        }\n\n        assertEquals(HttpStatusCode.Forbidden, updateResponse.status)\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n### Real-World Impact\n\n**Companies With Good Tests**:\n- Deploy multiple times per day with confidence\n- Catch bugs before users do\n- Refactor fearlessly\n- Onboard new developers faster (tests are documentation)\n- Lower maintenance costs\n\n**Companies Without Tests**:\n- Manual testing takes hours\n- Fear of changing code\n- Bugs discovered in production\n- Slow feature development\n- High stress, long hours\n\n**Statistics**:\n- Bugs caught in testing cost 10x less than bugs in production\n- Well-tested code has 40-80% fewer production bugs\n- Test suites pay for themselves within 6 months\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Checkpoint Quiz",
              "content": "\n### Question 1\nWhat's the testing pyramid ratio for a backend API?\n\nA) 10% unit, 20% integration, 70% E2E\nB) 70% unit, 20% integration, 10% E2E\nC) Equal distribution (33% each)\nD) 100% integration tests only\n\n### Question 2\nWhat does the AAA pattern stand for in testing?\n\nA) Assert, Act, Arrange\nB) Arrange, Act, Assert\nC) Always Automate Assertions\nD) API, Authentication, Authorization\n\n### Question 3\nWhy use mock repositories in unit tests?\n\nA) They're faster than real databases\nB) They provide test isolation and don't require database setup\nC) They're required by JUnit\nD) They generate better test reports\n\n### Question 4\nWhat HTTP status code should a test expect when accessing a protected route without a token?\n\nA) 200 OK\nB) 400 Bad Request\nC) 401 Unauthorized\nD) 404 Not Found\n\n### Question 5\nWhat's the main benefit of high test coverage?\n\nA) Makes code run faster\nB) Reduces file size\nC) Increases confidence that code works correctly\nD) Automatically fixes bugs\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Answers",
              "content": "\n**Question 1: B) 70% unit, 20% integration, 10% E2E**\n\nThe testing pyramid recommends:\n- **Most**: Unit tests (fast, cheap, isolated)\n- **Some**: Integration tests (medium speed, test combinations)\n- **Few**: E2E tests (slow, expensive, brittle)\n\n---\n\n**Question 2: B) Arrange, Act, Assert**\n\n\n---\n\n**Question 3: B) They provide test isolation and don't require database setup**\n\nMock repositories:\n- No database needed (tests run in memory)\n- Fast execution (no I/O overhead)\n- Complete control (easily simulate edge cases)\n- Isolated (one test doesn't affect another)\n\n---\n\n**Question 4: C) 401 Unauthorized**\n\nHTTP status codes in authentication:\n- **401 Unauthorized**: Missing or invalid credentials/token\n- **403 Forbidden**: Authenticated but not authorized (valid token, insufficient permissions)\n\n---\n\n**Question 5: C) Increases confidence that code works correctly**\n\nTest coverage shows which code paths are tested:\n- 80%+ coverage = most code is verified\n- Low coverage = many code paths untested (likely bugs)\n- Confidence to refactor and add features\n\nNote: 100% coverage doesn't guarantee bug-free code, but it helps!\n\n---\n\n",
              "code": "@Test\nfun `example test`() {\n    // Arrange - Set up test data and dependencies\n    val user = createTestUser()\n\n    // Act - Perform the action being tested\n    val result = userService.deleteUser(user.id)\n\n    // Assert - Verify the outcome\n    assertTrue(result.isSuccess)\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "What You've Learned",
              "content": "\n‚úÖ Why automated testing is critical for maintainable codebases\n‚úÖ The testing pyramid and when to use each test type\n‚úÖ How to write unit tests for services with mock repositories\n‚úÖ How to write integration tests for HTTP endpoints with testApplication\n‚úÖ How to test protected routes requiring JWT authentication\n‚úÖ How to test authorization (ownership and role-based access)\n‚úÖ Best practices: AAA pattern, test isolation, descriptive names\n‚úÖ How to measure test coverage with JaCoCo\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Next Steps",
              "content": "\nIn **Lesson 5.15: Part 5 Capstone Project**, you'll build a complete production-ready API from scratch using everything you've learned:\n- Full authentication system (registration, login, JWT)\n- Role-based access control\n- Clean architecture (repositories, services, routes)\n- Dependency injection with Koin\n- Comprehensive test suite\n- Validation and error handling\n\nTime to put all your knowledge together into a real-world application!\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "5.15",
          "title": "Lesson 5.15: Part 5 Capstone Project - Task Management API",
          "moduleId": "module-05",
          "order": 7,
          "estimatedMinutes": 30,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 4-6 hours\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Project Overview",
              "content": "\nCongratulations on completing Part 5! You've learned backend development with Ktor, from HTTP fundamentals to authentication, testing, and clean architecture.\n\nNow it's time to put everything together in a **complete, production-ready Task Management API**.\n\nThis capstone project will challenge you to integrate all the skills you've learned:\n- ‚úÖ HTTP REST API design\n- ‚úÖ Database operations with Exposed\n- ‚úÖ Clean architecture (repositories, services, routes)\n- ‚úÖ Request validation and error handling\n- ‚úÖ JWT authentication and authorization\n- ‚úÖ Role-based access control\n- ‚úÖ Dependency injection with Koin\n- ‚úÖ Comprehensive testing\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "The Project: TaskMaster API",
              "content": "\n**TaskMaster** is a collaborative task management system where users can:\n- Create and manage personal tasks\n- Share tasks with team members\n- Assign tasks and track progress\n- Filter and search tasks\n- Receive notifications (bonus)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Requirements",
              "content": "\n### 1. User Management\n\n**Models**:\n\n**Endpoints**:\n- `POST /api/auth/register` - Register new user\n- `POST /api/auth/login` - Login and receive JWT token\n- `GET /api/auth/me` - Get current user (protected)\n- `PUT /api/users/me` - Update profile (protected)\n- `DELETE /api/users/me` - Delete account (protected)\n\n**Requirements**:\n- Email validation\n- Password strength requirements (min 8 chars, uppercase, lowercase, number, special char)\n- Username uniqueness\n- JWT tokens with 1-hour expiration\n- bcrypt password hashing\n\n---\n\n### 2. Task Management\n\n**Models**:\n\n**Endpoints**:\n- `POST /api/tasks` - Create task (protected)\n- `GET /api/tasks` - Get all user's tasks with filters (protected)\n- `GET /api/tasks/:id` - Get task by ID (protected)\n- `PUT /api/tasks/:id` - Update task (owner or assignee)\n- `DELETE /api/tasks/:id` - Delete task (owner only)\n- `POST /api/tasks/:id/assign` - Assign task to user (owner only)\n- `PATCH /api/tasks/:id/status` - Update task status (owner or assignee)\n\n**Query Parameters for GET /api/tasks**:\n- `status` - Filter by status (TODO, IN_PROGRESS, DONE)\n- `priority` - Filter by priority (LOW, MEDIUM, HIGH)\n- `assignedToMe` - Show only tasks assigned to current user\n- `search` - Search in title and description\n- `sortBy` - Sort by (dueDate, priority, createdAt)\n- `order` - Order (asc, desc)\n\n**Authorization Rules**:\n- Users can only see tasks they own or are assigned to\n- Users can only create tasks\n- Owners can update, delete, and assign tasks\n- Assignees can update task status only\n- Admins can see and modify all tasks\n\n---\n\n### 3. Comments (Optional Enhancement)\n\n**Models**:\n\n**Endpoints**:\n- `POST /api/tasks/:id/comments` - Add comment (protected)\n- `GET /api/tasks/:id/comments` - Get task comments (protected)\n- `DELETE /api/comments/:id` - Delete comment (author or admin)\n\n---\n\n### 4. Error Handling\n\nAll errors must return consistent JSON format:\n\n\n**HTTP Status Codes**:\n- 200 OK - Success\n- 201 Created - Resource created\n- 400 Bad Request - Validation error\n- 401 Unauthorized - Not authenticated\n- 403 Forbidden - Not authorized\n- 404 Not Found - Resource doesn't exist\n- 409 Conflict - Duplicate resource\n- 500 Internal Server Error - Unexpected error\n\n---\n\n### 5. Validation\n\n**Task Validation**:\n- Title: required, 1-200 characters\n- Description: optional, max 1000 characters\n- Status: must be TODO, IN_PROGRESS, or DONE\n- Priority: must be LOW, MEDIUM, or HIGH\n- DueDate: optional, must be valid ISO 8601, can't be in the past\n- AssignedToId: optional, must be existing user\n\n**User Validation**:\n- Email: valid email format, unique\n- Username: 3-20 chars, alphanumeric + underscore, unique\n- Password: min 8 chars, uppercase, lowercase, number, special char\n- FullName: 2-100 characters\n\n---\n\n### 6. Testing Requirements\n\n**Unit Tests** (minimum 70% coverage):\n- UserService tests with mock repository\n- AuthService tests for login/register\n- TaskService tests for CRUD and authorization\n- Validator tests for all validation rules\n\n**Integration Tests**:\n- Auth endpoints (register, login)\n- Task CRUD endpoints\n- Authorization tests (owner, assignee, non-member)\n- Query parameter filtering\n- Error cases (validation, not found, forbidden)\n\n---\n\n### 7. Architecture Requirements\n\n**Clean Architecture**:\n\n**Dependency Injection**:\n- Use Koin for all dependency management\n- Separate modules for repositories, services, database\n- Easy to swap implementations for testing\n\n---\n\n",
              "code": "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ  Routes (HTTP Layer)                ‚îÇ\n‚îÇ  - Parse requests                   ‚îÇ\n‚îÇ  - Call services                    ‚îÇ\n‚îÇ  - Return responses                 ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n              ‚Üì\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ  Services (Business Logic)          ‚îÇ\n‚îÇ  - Validation                       ‚îÇ\n‚îÇ  - Authorization                    ‚îÇ\n‚îÇ  - Orchestration                    ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n              ‚Üì\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ  Repositories (Data Access)         ‚îÇ\n‚îÇ  - Database queries                 ‚îÇ\n‚îÇ  - Data mapping                     ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n              ‚Üì\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ  Database (Exposed + H2)            ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Step-by-Step Implementation Guide",
              "content": "\n### Phase 1: Project Setup (30 minutes)\n\n1. **Create New Project**:\n   ```bash\n   mkdir taskmaster-api\n   cd taskmaster-api\n   gradle init --type kotlin-application\n   ```\n\n2. **Add Dependencies** in `build.gradle.kts`:\n   ```kotlin\n   dependencies {\n       implementation(\"io.ktor:ktor-server-core-jvm:3.0.2\")\n       implementation(\"io.ktor:ktor-server-cio-jvm:3.0.2\")\n       implementation(\"io.ktor:ktor-server-content-negotiation-jvm:3.0.2\")\n       implementation(\"io.ktor:ktor-serialization-kotlinx-json-jvm:3.0.2\")\n       implementation(\"io.ktor:ktor-server-auth-jvm:3.0.2\")\n       implementation(\"io.ktor:ktor-server-auth-jwt-jvm:3.0.2\")\n       implementation(\"org.jetbrains.exposed:exposed-core:0.50.0\")\n       implementation(\"org.jetbrains.exposed:exposed-jdbc:0.50.0\")\n       implementation(\"com.h2database:h2:2.2.224\")\n       implementation(\"com.zaxxer:HikariCP:5.1.0\")\n       implementation(\"de.nycode:bcrypt:2.3.0\")\n       implementation(\"com.auth0:java-jwt:4.5.0\")\n       implementation(\"io.insert-koin:koin-ktor:4.0.3\")\n       implementation(\"io.insert-koin:koin-logger-slf4j:4.0.3\")\n       implementation(\"ch.qos.logback:logback-classic:1.4.14\")\n\n       testImplementation(\"io.ktor:ktor-server-test-host:3.0.2\")\n       testImplementation(\"org.jetbrains.kotlin:kotlin-test-junit5:2.0.0\")\n       testImplementation(\"org.junit.jupiter:junit-jupiter-api:5.10.2\")\n       testRuntimeOnly(\"org.junit.jupiter:junit-jupiter-engine:5.10.2\")\n       testImplementation(\"io.insert-koin:koin-test:4.0.3\")\n       testImplementation(\"io.insert-koin:koin-test-junit5:4.0.3\")\n   }\n   ```\n\n3. **Create Package Structure**:\n   ```\n   src/main/kotlin/com/taskmaster/\n   ‚îú‚îÄ‚îÄ Application.kt\n   ‚îú‚îÄ‚îÄ models/\n   ‚îÇ   ‚îú‚îÄ‚îÄ User.kt\n   ‚îÇ   ‚îú‚îÄ‚îÄ Task.kt\n   ‚îÇ   ‚îî‚îÄ‚îÄ Responses.kt\n   ‚îú‚îÄ‚îÄ repositories/\n   ‚îÇ   ‚îú‚îÄ‚îÄ UserRepository.kt\n   ‚îÇ   ‚îî‚îÄ‚îÄ TaskRepository.kt\n   ‚îú‚îÄ‚îÄ services/\n   ‚îÇ   ‚îú‚îÄ‚îÄ UserService.kt\n   ‚îÇ   ‚îú‚îÄ‚îÄ AuthService.kt\n   ‚îÇ   ‚îî‚îÄ‚îÄ TaskService.kt\n   ‚îú‚îÄ‚îÄ routes/\n   ‚îÇ   ‚îú‚îÄ‚îÄ AuthRoutes.kt\n   ‚îÇ   ‚îî‚îÄ‚îÄ TaskRoutes.kt\n   ‚îú‚îÄ‚îÄ validation/\n   ‚îÇ   ‚îú‚îÄ‚îÄ Validator.kt\n   ‚îÇ   ‚îú‚îÄ‚îÄ UserValidator.kt\n   ‚îÇ   ‚îî‚îÄ‚îÄ TaskValidator.kt\n   ‚îú‚îÄ‚îÄ security/\n   ‚îÇ   ‚îú‚îÄ‚îÄ JwtConfig.kt\n   ‚îÇ   ‚îî‚îÄ‚îÄ PasswordHasher.kt\n   ‚îú‚îÄ‚îÄ exceptions/\n   ‚îÇ   ‚îî‚îÄ‚îÄ ApiExceptions.kt\n   ‚îú‚îÄ‚îÄ plugins/\n   ‚îÇ   ‚îú‚îÄ‚îÄ Authentication.kt\n   ‚îÇ   ‚îî‚îÄ‚îÄ ErrorHandling.kt\n   ‚îú‚îÄ‚îÄ database/\n   ‚îÇ   ‚îî‚îÄ‚îÄ DatabaseFactory.kt\n   ‚îî‚îÄ‚îÄ di/\n       ‚îú‚îÄ‚îÄ RepositoryModule.kt\n       ‚îú‚îÄ‚îÄ ServiceModule.kt\n       ‚îî‚îÄ‚îÄ AppModule.kt\n   ```\n\n---\n\n### Phase 2: Core Models & Database (45 minutes)\n\n1. **Define Models** (`models/User.kt`, `models/Task.kt`):\n   - User model with all fields\n   - Task model with status and priority enums\n   - Request/Response DTOs\n\n2. **Create Database Tables** (`database/DatabaseFactory.kt`):\n   - Users table with unique constraints\n   - Tasks table with foreign keys\n   - Initialize H2 database\n\n3. **Implement Repositories**:\n   - UserRepository interface and implementation\n   - TaskRepository interface and implementation\n   - Include query methods (filters, search)\n\n---\n\n### Phase 3: Validation & Error Handling (30 minutes)\n\n1. **Create Validators**:\n   - Base Validator class with common methods\n   - UserValidator for registration\n   - TaskValidator for task creation/updates\n\n2. **Define Exceptions**:\n   - ValidationException\n   - NotFoundException\n   - ConflictException\n   - ForbiddenException\n   - UnauthorizedException\n\n3. **Configure Error Handling**:\n   - StatusPages plugin configuration\n   - Consistent error response format\n\n---\n\n### Phase 4: Authentication System (60 minutes)\n\n1. **Implement Password Hashing**:\n   - PasswordHasher utility with bcrypt\n   - Password strength validation\n\n2. **Configure JWT**:\n   - JwtConfig with token generation\n   - Include user ID, email, role in claims\n\n3. **Build Auth Services**:\n   - UserService with registration\n   - AuthService with login\n\n4. **Create Auth Routes**:\n   - POST /api/auth/register\n   - POST /api/auth/login\n   - GET /api/auth/me\n\n5. **Configure Authentication Plugin**:\n   - JWT validation\n   - UserPrincipal extraction\n\n---\n\n### Phase 5: Task Management (90 minutes)\n\n1. **Implement TaskService**:\n   - Create task (with validation)\n   - Update task (with ownership check)\n   - Delete task (owner only)\n   - Get tasks with filters\n   - Assign task to user\n   - Update task status\n\n2. **Create Task Routes**:\n   - All CRUD endpoints\n   - Query parameter handling\n   - Authorization checks\n\n3. **Implement Authorization Logic**:\n   - canViewTask(task, user)\n   - canModifyTask(task, user)\n   - canDeleteTask(task, user)\n\n---\n\n### Phase 6: Dependency Injection (30 minutes)\n\n1. **Define Koin Modules**:\n   - RepositoryModule\n   - ServiceModule\n   - DatabaseModule\n\n2. **Configure Koin**:\n   - Install Koin plugin\n   - Load modules\n\n3. **Inject Dependencies**:\n   - Update routes to inject services\n   - Remove manual wiring\n\n---\n\n### Phase 7: Testing (90 minutes)\n\n1. **Unit Tests**:\n   - UserService tests (5+ tests)\n   - AuthService tests (5+ tests)\n   - TaskService tests (10+ tests covering authorization)\n   - Validator tests\n\n2. **Integration Tests**:\n   - Auth endpoint tests\n   - Task CRUD tests\n   - Authorization tests\n   - Query filter tests\n\n3. **Run Coverage**:\n   - Configure JaCoCo\n   - Aim for 70%+ coverage\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Evaluation Criteria",
              "content": "\n### Core Requirements (80 points)\n\n- ‚úÖ All endpoints implemented and working (20 points)\n- ‚úÖ Authentication with JWT (15 points)\n- ‚úÖ Authorization (owner/assignee/admin) (15 points)\n- ‚úÖ Validation with clear error messages (10 points)\n- ‚úÖ Clean architecture (repositories, services, routes) (10 points)\n- ‚úÖ Dependency injection with Koin (10 points)\n\n### Testing (15 points)\n\n- ‚úÖ Unit tests with 70%+ coverage (10 points)\n- ‚úÖ Integration tests for main flows (5 points)\n\n### Code Quality (5 points)\n\n- ‚úÖ Consistent code style\n- ‚úÖ Clear naming conventions\n- ‚úÖ No code duplication\n- ‚úÖ Proper error handling\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Bonus Challenges (+20 points)",
              "content": "\n### Challenge 1: Task Comments (+5 points)\nImplement the comment system:\n- Add comments to tasks\n- Get task comments\n- Delete comments (author or admin only)\n\n### Challenge 2: Pagination (+5 points)\nAdd pagination to GET /api/tasks:\n- `page` query parameter (default: 1)\n- `pageSize` query parameter (default: 20)\n- Return metadata: totalPages, totalItems, currentPage\n\n### Challenge 3: Task Tags (+5 points)\nAdd tagging system:\n- Tasks can have multiple tags\n- Filter tasks by tags\n- Create/delete tags\n\n### Challenge 4: Task Analytics (+5 points)\nAdd analytics endpoints:\n- GET /api/analytics/summary - Task counts by status\n- GET /api/analytics/user/:id - User's task statistics\n- GET /api/analytics/overdue - Overdue tasks report\n\n---\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Example Solution Structure",
              "content": "\n\n---\n\n",
              "code": "// models/Task.kt\n@Serializable\ndata class Task(\n    val id: Int,\n    val title: String,\n    val description: String?,\n    val status: TaskStatus,\n    val priority: TaskPriority,\n    val dueDate: String?,\n    val ownerId: Int,\n    val assignedToId: Int?,\n    val createdAt: String,\n    val updatedAt: String\n)\n\n@Serializable\nenum class TaskStatus {\n    TODO, IN_PROGRESS, DONE\n}\n\n@Serializable\nenum class TaskPriority {\n    LOW, MEDIUM, HIGH\n}\n\n@Serializable\ndata class CreateTaskRequest(\n    val title: String,\n    val description: String? = null,\n    val status: String = \"TODO\",\n    val priority: String = \"MEDIUM\",\n    val dueDate: String? = null,\n    val assignedToId: Int? = null\n)\n\n@Serializable\ndata class UpdateTaskRequest(\n    val title: String,\n    val description: String?,\n    val status: String,\n    val priority: String,\n    val dueDate: String?\n)\n\n@Serializable\ndata class UpdateTaskStatusRequest(\n    val status: String\n)\n\n@Serializable\ndata class AssignTaskRequest(\n    val assignedToId: Int\n)\n\n// repositories/TaskRepository.kt\ninterface TaskRepository {\n    fun insert(task: Task): Int\n    fun update(id: Int, task: Task): Boolean\n    fun delete(id: Int): Boolean\n    fun getById(id: Int): Task?\n    fun getAllForUser(userId: Int): List<Task>\n    fun getAssignedToUser(userId: Int): List<Task>\n    fun search(userId: Int, filters: TaskFilters): List<Task>\n}\n\ndata class TaskFilters(\n    val status: TaskStatus? = null,\n    val priority: TaskPriority? = null,\n    val assignedToMe: Boolean = false,\n    val search: String? = null,\n    val sortBy: String = \"createdAt\",\n    val order: String = \"desc\"\n)\n\n// services/TaskService.kt\nclass TaskService(\n    private val taskRepository: TaskRepository,\n    private val userRepository: UserRepository\n) {\n    fun createTask(request: CreateTaskRequest, principal: UserPrincipal): Result<Task>\n    fun updateTask(id: Int, request: UpdateTaskRequest, principal: UserPrincipal): Result<Task>\n    fun deleteTask(id: Int, principal: UserPrincipal): Result<Unit>\n    fun getTaskById(id: Int, principal: UserPrincipal): Result<Task>\n    fun getUserTasks(principal: UserPrincipal, filters: TaskFilters): Result<List<Task>>\n    fun assignTask(id: Int, request: AssignTaskRequest, principal: UserPrincipal): Result<Task>\n    fun updateTaskStatus(id: Int, request: UpdateTaskStatusRequest, principal: UserPrincipal): Result<Task>\n\n    private fun canViewTask(task: Task, principal: UserPrincipal): Boolean {\n        return task.ownerId == principal.userId ||\n               task.assignedToId == principal.userId ||\n               principal.role == \"ADMIN\"\n    }\n\n    private fun canModifyTask(task: Task, principal: UserPrincipal): Boolean {\n        return task.ownerId == principal.userId || principal.role == \"ADMIN\"\n    }\n\n    private fun canUpdateStatus(task: Task, principal: UserPrincipal): Boolean {\n        return task.ownerId == principal.userId ||\n               task.assignedToId == principal.userId ||\n               principal.role == \"ADMIN\"\n    }\n}\n\n// routes/TaskRoutes.kt\nfun Route.taskRoutes() {\n    val taskService by inject<TaskService>()\n\n    authenticate(\"jwt-auth\") {\n        route(\"/api/tasks\") {\n            post {\n                val principal = call.principal<UserPrincipal>()!!\n                val request = call.receive<CreateTaskRequest>()\n\n                taskService.createTask(request, principal)\n                    .onSuccess { task ->\n                        call.respond(\n                            HttpStatusCode.Created,\n                            ApiResponse(data = task, message = \"Task created\")\n                        )\n                    }\n                    .onFailure { error -> throw error }\n            }\n\n            get {\n                val principal = call.principal<UserPrincipal>()!!\n                val filters = TaskFilters(\n                    status = call.request.queryParameters[\"status\"]?.let { TaskStatus.valueOf(it) },\n                    priority = call.request.queryParameters[\"priority\"]?.let { TaskPriority.valueOf(it) },\n                    assignedToMe = call.request.queryParameters[\"assignedToMe\"]?.toBoolean() ?: false,\n                    search = call.request.queryParameters[\"search\"],\n                    sortBy = call.request.queryParameters[\"sortBy\"] ?: \"createdAt\",\n                    order = call.request.queryParameters[\"order\"] ?: \"desc\"\n                )\n\n                taskService.getUserTasks(principal, filters)\n                    .onSuccess { tasks ->\n                        call.respond(ApiResponse(data = tasks))\n                    }\n                    .onFailure { error -> throw error }\n            }\n\n            // ... other routes\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Testing Your Solution",
              "content": "\n### Manual Testing with cURL\n\n\n### Automated Tests\n\nRun all tests:\n\nCheck coverage:\n\n---\n\n",
              "code": "./gradlew test jacocoTestReport\nopen build/reports/jacoco/test/html/index.html",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Submission Checklist",
              "content": "\nBefore submitting, ensure you have:\n\n- [ ] All core endpoints implemented\n- [ ] JWT authentication working\n- [ ] Authorization rules enforced\n- [ ] Validation with clear error messages\n- [ ] Clean architecture (repositories, services, routes)\n- [ ] Dependency injection with Koin\n- [ ] Unit tests with 70%+ coverage\n- [ ] Integration tests for main flows\n- [ ] README.md with setup instructions\n- [ ] No hardcoded secrets (use environment variables)\n- [ ] Code follows Kotlin conventions\n- [ ] Git repository with meaningful commits\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Tips for Success",
              "content": "\n### Time Management\n- **Don't skip Phase 1**: Proper setup saves time later\n- **Test as you go**: Don't wait until the end to test\n- **Use previous lessons**: Copy patterns from earlier exercises\n- **Focus on core features first**: Get basics working before bonuses\n\n### Common Pitfalls\n- ‚ùå Forgetting to hash passwords\n- ‚ùå Not validating token expiration\n- ‚ùå Missing authorization checks\n- ‚ùå Inconsistent error responses\n- ‚ùå Not testing edge cases\n\n### Debugging Tips\n- Use `println()` for quick debugging\n- Check logs for SQL queries\n- Test endpoints with Postman or cURL\n- Verify JWT tokens at jwt.io\n- Run tests frequently\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "What Success Looks Like",
              "content": "\nBy completing this capstone, you will have:\n\n‚úÖ **Built a production-ready REST API** from scratch\n‚úÖ **Implemented authentication and authorization** with JWT\n‚úÖ **Designed clean, maintainable architecture** following best practices\n‚úÖ **Written comprehensive tests** for confidence in your code\n‚úÖ **Integrated multiple technologies** (Ktor, Exposed, Koin, JWT, bcrypt)\n‚úÖ **Demonstrated professional development skills** that employers value\n\nThis project is portfolio-worthy. Host it on GitHub, deploy it to a cloud platform, and showcase it to potential employers!\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Next Steps After Part 5",
              "content": "\nCongratulations on completing Part 5! Here's what comes next:\n\n**Part 6: Android Development**\n- Jetpack Compose fundamentals\n- MVVM architecture\n- Retrofit for API consumption\n- Connecting your TaskMaster API to an Android app\n\n**Part 7: Advanced Topics**\n- Coroutines and async programming\n- Kotlin Multiplatform\n- Performance optimization\n- Production deployment\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Final Words",
              "content": "\nYou've come a long way! From understanding HTTP basics to building a complete backend API with authentication, authorization, testing, and clean architecture.\n\nThe skills you've learned in Part 5 are in high demand:\n- Backend development with Ktor\n- REST API design\n- Authentication with JWT\n- Clean architecture patterns\n- Testing strategies\n- Dependency injection\n\nTake your time with this capstone. It's challenging, but every challenge you overcome makes you a better developer.\n\n**You've got this!** üöÄ\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Resources",
              "content": "\n### Documentation\n- [Ktor Official Docs](https://ktor.io/docs/)\n- [Exposed Documentation](https://github.com/JetBrains/Exposed/wiki)\n- [Koin Documentation](https://insert-koin.io/docs/)\n- [JWT.io](https://jwt.io/)\n\n### Tools\n- [Postman](https://www.postman.com/) - API testing\n- [IntelliJ IDEA](https://www.jetbrains.com/idea/) - Kotlin IDE\n- [H2 Console](http://localhost:8080/h2-console) - Database browser\n\n### Community\n- [Kotlin Slack](https://surveys.jetbrains.com/s3/kotlin-slack-sign-up)\n- [r/Kotlin](https://www.reddit.com/r/Kotlin/)\n- [Stack Overflow](https://stackoverflow.com/questions/tagged/kotlin)\n\n---\n\n**Good luck with your capstone project!** üéØ\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "5.2",
          "title": "Lesson 5.2: Setting Up Your First Ktor Project",
          "moduleId": "module-05",
          "order": 8,
          "estimatedMinutes": 35,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 35 minutes\n**Difficulty**: Beginner\n**Prerequisites**: Lesson 5.1 (HTTP Fundamentals), Kotlin basics\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "üìñ Topic Introduction",
              "content": "\nIn the previous lesson, you learned the concepts: HTTP methods, status codes, and REST API design. Now it's time to build your first actual backend server!\n\nIn this lesson, you'll:\n- Create a Ktor project from scratch\n- Understand the project structure\n- Install essential plugins\n- Run your first server that responds to HTTP requests\n- Test your API with a web browser\n\nBy the end, you'll have a working server running on your computer that you can visit in your browser!\n\n---\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "üí° The Concept: What Is Ktor?",
              "content": "\n### The Building Blocks Analogy\n\nImagine you're building a house:\n\n**Traditional frameworks** = Pre-fabricated houses\n- Lots of features you might not need\n- Heavy and opinionated\n- Hard to customize\n\n**Ktor** = A box of high-quality building blocks\n- Start with a minimal foundation\n- Add only what you need (plugins)\n- Lightweight and flexible\n- Perfect for learning because you see every piece\n\n### Why Ktor for Learning?\n\n1. **Kotlin-first**: Written specifically for Kotlin, not a Java framework adapted for Kotlin\n2. **Lightweight**: Minimal boilerplate, clear code\n3. **Plugin-based**: Each feature (routing, JSON, authentication) is a separate plugin you explicitly add\n4. **Async by default**: Uses Kotlin coroutines for efficient handling of many requests\n5. **Modern**: Built with current best practices\n\n### Ktor Architecture\n\n\n---\n\n",
              "code": "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ      Your Ktor Application          ‚îÇ\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ\n‚îÇ  ‚îÇ  Routing Plugin               ‚îÇ  ‚îÇ  <-- Define endpoints\n‚îÇ  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§  ‚îÇ\n‚îÇ  ‚îÇ  ContentNegotiation Plugin    ‚îÇ  ‚îÇ  <-- JSON support\n‚îÇ  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§  ‚îÇ\n‚îÇ  ‚îÇ  Authentication Plugin        ‚îÇ  ‚îÇ  <-- Login/JWT\n‚îÇ  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§  ‚îÇ\n‚îÇ  ‚îÇ  Your Business Logic          ‚îÇ  ‚îÇ  <-- Your code\n‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ      Ktor Engine (CIO/Netty)        ‚îÇ  <-- Handles HTTP\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "üöÄ Setting Up Your Development Environment",
              "content": "\n### Prerequisites Check\n\nBefore we start, ensure you have:\n\n1. **JDK 17 or higher** installed\n   ```bash\n   java -version\n   # Should show: java version \"17\" or higher\n   ```\n\n2. **IntelliJ IDEA** (Community Edition is free) or any IDE with Kotlin support\n\n3. **Gradle** (usually bundled with IDE, but verify):\n   ```bash\n   gradle -version\n   # Should show: Gradle 8.0 or higher\n   ```\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "üíª Creating Your First Ktor Project",
              "content": "\n### Method 1: Using the Ktor Project Generator (Recommended for Beginners)\n\n1. **Visit the Generator**\n   - Open your browser and go to: https://start.ktor.io/\n\n2. **Configure Your Project**\n   ```\n   Project Name: my-first-api\n   Build System: Gradle Kotlin\n   Website: example.com\n   Artifact: com.example.myfirstapi\n   Ktor Version: 3.2.0 (or latest)\n   Engine: CIO\n   Configuration: Code (not YAML/HOCON for now)\n   ```\n\n3. **Add Plugins**\n   - **Routing**: For defining endpoints (essential!)\n   - **Content Negotiation**: For JSON support (essential!)\n   - **kotlinx.serialization**: For converting objects to/from JSON\n\n4. **Generate and Download**\n   - Click \"Generate Project\"\n   - Download the ZIP file\n   - Extract it to your projects folder\n\n### Method 2: Manual Setup with Gradle (For Understanding)\n\nIf you want to understand every piece, let's build it manually:\n\n**Step 1: Create a new directory**\n\n**Step 2: Create the Gradle build file**\n\nCreate `build.gradle.kts`:\n\n\n**Step 3: Create Gradle wrapper files**\n\nCreate `gradle.properties`:\n\nCreate `settings.gradle.kts`:\n\n---\n\n",
              "code": "rootProject.name = \"my-first-api\"",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "üìÅ Understanding the Project Structure",
              "content": "\nAfter creation, your project should look like this:\n\n\nLet's understand each piece:\n\n- **build.gradle.kts**: Defines dependencies and build configuration\n- **Application.kt**: The main file that starts your server\n- **plugins/**: Modular plugin configurations\n- **resources/**: Configuration files (logging, etc.)\n\n---\n\n",
              "code": "my-first-api/\n‚îú‚îÄ‚îÄ build.gradle.kts              # Gradle build configuration\n‚îú‚îÄ‚îÄ settings.gradle.kts           # Project settings\n‚îú‚îÄ‚îÄ gradle.properties             # Gradle properties\n‚îú‚îÄ‚îÄ gradlew                       # Gradle wrapper (Unix)\n‚îú‚îÄ‚îÄ gradlew.bat                   # Gradle wrapper (Windows)\n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îî‚îÄ‚îÄ main/\n‚îÇ       ‚îú‚îÄ‚îÄ kotlin/\n‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ com/example/\n‚îÇ       ‚îÇ       ‚îú‚îÄ‚îÄ Application.kt      # Main entry point\n‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ plugins/\n‚îÇ       ‚îÇ           ‚îú‚îÄ‚îÄ Routing.kt      # Route definitions\n‚îÇ       ‚îÇ           ‚îî‚îÄ‚îÄ Serialization.kt # JSON config\n‚îÇ       ‚îî‚îÄ‚îÄ resources/\n‚îÇ           ‚îî‚îÄ‚îÄ logback.xml             # Logging configuration\n‚îî‚îÄ‚îÄ .gitignore",
              "language": "kotlin"
            },
            {
              "type": "EXAMPLE",
              "title": "üîß Writing Your First Server Code",
              "content": "\n### Step 1: Create the Main Application File\n\nCreate `src/main/kotlin/com/example/Application.kt`:\n\n\n**Let's break this down:**\n\n- **embeddedServer**: Runs Ktor inside your application (no separate Tomcat/Jetty)\n- **CIO**: Coroutine-based I/O engine (lightweight and perfect for learning)\n- **port = 8080**: Your server will be accessible at `http://localhost:8080`\n- **host = \"0.0.0.0\"**: Accept connections from any network interface\n\n- This is an **extension function** on the `Application` class\n- It's where you configure all your plugins and routes\n\n### Step 2: Configure JSON Serialization\n\nCreate `src/main/kotlin/com/example/plugins/Serialization.kt`:\n\n\n**What this does:**\n- **ContentNegotiation**: Plugin that handles converting Kotlin objects ‚Üî JSON\n- **json()**: Configure JSON serialization settings\n- **prettyPrint**: Makes the JSON output readable (with indentation)\n\n### Step 3: Define Your First Routes\n\nCreate `src/main/kotlin/com/example/plugins/Routing.kt`:\n\n\n**Understanding the routing:**\n\n- **routing { }**: Block where you define all routes\n- **get(\"/\")**: Handle GET requests to the root path\n- **call**: Represents the current HTTP request/response\n- **respondText()**: Send plain text response\n\n### Step 4: Add Logging Configuration\n\nCreate `src/main/resources/logback.xml`:\n\n\nThis configures logging so you can see what your server is doing.\n\n---\n\n",
              "code": "<configuration>\n    <appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\">\n        <encoder>\n            <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>\n        </encoder>\n    </appender>\n\n    <root level=\"INFO\">\n        <appender-ref ref=\"STDOUT\"/>\n    </root>\n\n    <logger name=\"io.ktor\" level=\"DEBUG\"/>\n</configuration>",
              "language": "xml"
            },
            {
              "type": "THEORY",
              "title": "üèÉ Running Your Server",
              "content": "\n### Using IntelliJ IDEA\n\n1. Open the project in IntelliJ IDEA\n2. Wait for Gradle to sync dependencies (bottom right corner)\n3. Open `Application.kt`\n4. Click the green play button next to `fun main()`\n5. Wait for the server to start (you'll see logs in the console)\n\n### Using Command Line\n\n\n### Expected Output\n\nYou should see something like:\n\n\nüéâ **Your server is now running!**\n\n---\n\n",
              "code": "[main] INFO  Application - Autoreload is disabled because the development mode is off.\n[main] INFO  Application - Responding at http://0.0.0.0:8080\n[DefaultDispatcher-worker-1] INFO  Application - Application started in 0.453 seconds.",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "üß™ Testing Your API",
              "content": "\n### Method 1: Web Browser (Simplest)\n\n1. Open your web browser\n2. Visit: `http://localhost:8080/`\n3. You should see: **\"Hello, Ktor! Your server is running! üöÄ\"**\n\nTry these URLs:\n- `http://localhost:8080/health` ‚Üí \"OK\"\n- `http://localhost:8080/api/hello` ‚Üí \"Hello from the API!\"\n\n### Method 2: curl (Command Line)\n\n\nThe `-i` flag shows headers:\n\n\n### Method 3: Postman (GUI Tool)\n\n1. Download Postman (free): https://www.postman.com/downloads/\n2. Create a new request\n3. Set method to GET\n4. Enter URL: `http://localhost:8080/`\n5. Click \"Send\"\n6. See the response in the bottom panel\n\n---\n\n",
              "code": "HTTP/1.1 200 OK\nContent-Length: 42\nContent-Type: text/plain; charset=UTF-8\n\nHello, Ktor! Your server is running! üöÄ",
              "language": "kotlin"
            },
            {
              "type": "EXAMPLE",
              "title": "üîç Code Breakdown: How It All Works",
              "content": "\nLet's trace what happens when you visit `http://localhost:8080/`:\n\n\n### Understanding the `call` Object\n\n\n**`call` provides access to:**\n- `call.request` - Information about the incoming request\n- `call.response` - The response you're building\n- `call.respondText()` - Send plain text\n- `call.respond()` - Send any object (will be converted to JSON)\n- `call.parameters` - URL parameters\n- `call.receive<T>()` - Get request body as object\n\n---\n\n",
              "code": "get(\"/\") {\n    call.respondText(\"Hello\")\n    // 'call' is of type ApplicationCall\n    // It represents the current request/response\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "üéØ Exercise: Add Your Own Endpoints",
              "content": "\nNow it's your turn! Add these endpoints to your `Routing.kt`:\n\n### Exercise Tasks\n\n1. **Create a `/ping` endpoint** that returns \"pong\"\n\n2. **Create a `/api/time` endpoint** that returns the current server time\n\n3. **Create a `/api/greet/{name}` endpoint** that greets the user by name\n   - Example: `/api/greet/Alice` ‚Üí \"Hello, Alice!\"\n\n4. **Create a `/api/random` endpoint** that returns a random number between 1 and 100\n\n### Hints\n\n\nTry to complete these on your own before looking at the solution!\n\n---\n\n",
              "code": "// Hint for current time\nimport java.time.LocalDateTime\nval now = LocalDateTime.now().toString()\n\n// Hint for path parameter\nget(\"/api/greet/{name}\") {\n    val name = call.parameters[\"name\"]\n    call.respondText(\"Hello, $name!\")\n}\n\n// Hint for random number\nimport kotlin.random.Random\nval number = Random.nextInt(1, 101)",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "‚úÖ Solution & Explanation",
              "content": "\nHere's the complete `Routing.kt` with all exercises:\n\n\n### Testing Your Solutions\n\n\n### Key Concepts Demonstrated\n\n1. **Path Parameters**: `{name}` in the route becomes accessible via `call.parameters[\"name\"]`\n2. **String Templates**: `\"Hello, $name\"` embeds variables in strings\n3. **Null Safety**: `name.isNullOrBlank()` checks for null or empty values\n4. **Libraries**: Using `LocalDateTime` and `Random` from Kotlin/Java standard library\n\n---\n\n",
              "code": "# Test ping\ncurl http://localhost:8080/ping\n# Output: pong\n\n# Test time\ncurl http://localhost:8080/api/time\n# Output: Current server time: 2024-11-13T15:30:45.123\n\n# Test greeting\ncurl http://localhost:8080/api/greet/Alice\n# Output: Hello, Alice! Welcome to our API! üëã\n\n# Test random\ncurl http://localhost:8080/api/random\n# Output: Your random number is: 42\n\n# Test bonus\ncurl http://localhost:8080/api/greet/John/Doe\n# Output: Hello, John Doe! üéâ",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "üìù Lesson Checkpoint Quiz",
              "content": "\nTest your understanding of Ktor project setup:\n\n### Question 1\nWhat is the purpose of the `embeddedServer` function in Ktor?\n\nA) It connects to an external web server like Apache\nB) It runs the Ktor application as a standalone server inside your program\nC) It embeds HTML files in your application\nD) It compresses the server code to reduce file size\n\n---\n\n### Question 2\nIn the route definition `get(\"/api/users/{id}\")`, what does `{id}` represent?\n\nA) A comment that will be ignored\nB) A literal string that must include the curly braces\nC) A path parameter that captures a dynamic value from the URL\nD) An error in the syntax\n\n---\n\n### Question 3\nWhich Ktor plugin is required to automatically convert Kotlin objects to JSON?\n\nA) Routing\nB) ContentNegotiation with kotlinx.serialization\nC) CIO\nD) Authentication\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "üéØ Why This Matters",
              "content": "\nYou just built a **real HTTP server** from scratch! This is the foundation of:\n\n- **Every website backend** (Facebook, Twitter, Reddit)\n- **Every mobile app backend** (Instagram, WhatsApp, TikTok)\n- **Every IoT device** that communicates over the internet\n- **Every microservice** in modern cloud architecture\n\n### What You've Actually Accomplished\n\nBefore today, when you visited a website, it felt like magic. Now you understand:\n\n‚úÖ **How servers listen** for requests on ports (`:8080`)\n‚úÖ **How routing works** - matching URLs to code that handles them\n‚úÖ **How responses are built** - your code generates what users see\n‚úÖ **How to test APIs** - using browsers, curl, or Postman\n\n### The Next Steps\n\nRight now, your server only returns simple text. In the next lessons, you'll learn to:\n\n- Return **JSON data** (structured data, not just text)\n- Accept **data from clients** (POST requests with body)\n- Connect to **databases** (persistent storage)\n- Add **authentication** (login systems)\n- **Validate input** (prevent bad data)\n\nBut you've crossed the biggest hurdle: **you have a working server**. Everything else builds on this foundation.\n\n---\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "üìö Key Takeaways",
              "content": "\n‚úÖ **Ktor** is a lightweight Kotlin framework for building servers\n‚úÖ **embeddedServer()** runs your application as a standalone server\n‚úÖ **Plugins** add functionality (routing, JSON, auth) modularly\n‚úÖ **routing { }** is where you define URL endpoints\n‚úÖ **get(\"/path\")** handles HTTP GET requests to that path\n‚úÖ **call.respondText()** sends text responses\n‚úÖ **call.parameters[\"name\"]** accesses URL path parameters\n‚úÖ Test with **browser**, **curl**, or **Postman**\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "üîú Next Steps",
              "content": "\nIn **Lesson 5.3**, you'll:\n- Build a proper REST API for managing books\n- Return JSON instead of plain text\n- Handle POST requests to create data\n- Organize routes into logical groups\n- Implement all CRUD operations (Create, Read, Update, Delete)\n\n---\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "‚úèÔ∏è Quiz Answer Key",
              "content": "\n**Question 1**: **B) It runs the Ktor application as a standalone server inside your program**\n\nExplanation: `embeddedServer` starts Ktor as an embedded server (no external Tomcat/Jetty needed). Your application *is* the server.\n\n---\n\n**Question 2**: **C) A path parameter that captures a dynamic value from the URL**\n\nExplanation: `{id}` is a path parameter placeholder. When someone visits `/api/users/42`, the value `42` is captured and accessible via `call.parameters[\"id\"]`.\n\n---\n\n**Question 3**: **B) ContentNegotiation with kotlinx.serialization**\n\nExplanation: ContentNegotiation handles content type negotiation (JSON, XML, etc.), and kotlinx.serialization provides the actual JSON conversion. Together, they enable automatic Kotlin object ‚Üî JSON transformation.\n\n---\n\n**Congratulations!** You've set up your first Ktor project and built a working server. You're now officially a backend developer! üéâ\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "5.2.1",
              "title": "User Model with Validation",
              "description": "Create a User data class with name and email. Add a method `isValid()` that checks if email contains '@'.",
              "instructions": "Create a User data class with name and email. Add a method `isValid()` that checks if email contains '@'.",
              "starterCode": "data class User(val name: String, val email: String) {\n    // Add isValid method\n}\n\nfun main() {\n    val user1 = User(\"Alice\", \"alice@example.com\")\n    val user2 = User(\"Bob\", \"invalid-email\")\n    println(\"User1 valid: ${user1.isValid()}\")\n    println(\"User2 valid: ${user2.isValid()}\")\n}",
              "solution": "data class User(val name: String, val email: String) {\n    fun isValid(): Boolean {\n        return email.contains(\"@\") && name.isNotBlank()\n    }\n}\n\nfun main() {\n    val user1 = User(\"Alice\", \"alice@example.com\")\n    val user2 = User(\"Bob\", \"invalid-email\")\n    println(\"User1 valid: ${user1.isValid()}\")\n    println(\"User2 valid: ${user2.isValid()}\")\n}",
              "language": "kotlin",
              "testCases": [
                {
                  "description": "Valid user should return true",
                  "expectedOutput": "User1 valid: true",
                  "isVisible": true
                },
                {
                  "description": "Invalid email should return false",
                  "expectedOutput": "User2 valid: false",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Add method inside data class"
                },
                {
                  "level": 2,
                  "text": "Check if email contains @ using contains()"
                },
                {
                  "level": 3,
                  "text": "Also check if name is not blank"
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "5.2.2",
              "title": "Simple In-Memory Database",
              "description": "Create a simple in-memory user database using a mutableListOf. Add methods to add and find users.",
              "instructions": "Create a simple in-memory user database using a mutableListOf. Add methods to add and find users.",
              "starterCode": "data class User(val id: Int, val name: String, val email: String)\n\nclass UserDatabase {\n    private val users = mutableListOf<User>()\n    \n    fun addUser(user: User) {\n        // Add user to list\n    }\n    \n    fun findById(id: Int): User? {\n        // Find user by ID\n    }\n}\n\nfun main() {\n    val db = UserDatabase()\n    db.addUser(User(1, \"Alice\", \"alice@example.com\"))\n    db.addUser(User(2, \"Bob\", \"bob@example.com\"))\n    \n    println(db.findById(1))\n    println(db.findById(99))\n}",
              "solution": "data class User(val id: Int, val name: String, val email: String)\n\nclass UserDatabase {\n    private val users = mutableListOf<User>()\n    \n    fun addUser(user: User) {\n        users.add(user)\n    }\n    \n    fun findById(id: Int): User? {\n        return users.find { it.id == id }\n    }\n}\n\nfun main() {\n    val db = UserDatabase()\n    db.addUser(User(1, \"Alice\", \"alice@example.com\"))\n    db.addUser(User(2, \"Bob\", \"bob@example.com\"))\n    \n    println(db.findById(1))\n    println(db.findById(99))\n}",
              "language": "kotlin",
              "testCases": [
                {
                  "description": "Should find existing user",
                  "expectedOutput": "User(id=1, name=Alice, email=alice@example.com)",
                  "isVisible": true
                },
                {
                  "description": "Should return null for non-existent user",
                  "expectedOutput": "null",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use mutableListOf to store users"
                },
                {
                  "level": 2,
                  "text": "add() method adds to list"
                },
                {
                  "level": 3,
                  "text": "find() method searches list with predicate"
                },
                {
                  "level": 4,
                  "text": "Return null if not found"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "5.3",
          "title": "Lesson 5.3: Routing Fundamentals - Building Your First Endpoints",
          "moduleId": "module-05",
          "order": 9,
          "estimatedMinutes": 40,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 40 minutes\n**Difficulty**: Beginner-Intermediate\n**Prerequisites**: Lessons 5.1-5.2 (HTTP fundamentals, Ktor setup)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "üìñ Topic Introduction",
              "content": "\nIn the previous lesson, you created a basic server that returns plain text. Now it's time to build something more realistic: a **complete REST API** for managing a collection of books.\n\nIn this lesson, you'll:\n- Organize routes into logical groups\n- Return JSON data instead of plain text\n- Implement all CRUD operations (Create, Read, Update, Delete)\n- Use proper HTTP methods and status codes\n- Store data in memory (temporarily, before we learn databases)\n\nBy the end, you'll have a fully functional Books API that behaves like a real-world backend!\n\n---\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "üí° The Concept: RESTful Resource Management",
              "content": "\n### The Library Catalog Analogy\n\nThink of your API as a library's card catalog system:\n\n**GET /books** = \"Show me all books in the catalog\"\n- Like looking at the entire catalog drawer\n\n**GET /books/42** = \"Show me the details of book #42\"\n- Like pulling out a specific card\n\n**POST /books** = \"Add a new book to the catalog\"\n- Like creating a new catalog card\n\n**PUT /books/42** = \"Update all information for book #42\"\n- Like replacing an entire catalog card\n\n**DELETE /books/42** = \"Remove book #42 from the catalog\"\n- Like throwing away a catalog card\n\n### What Makes an API \"RESTful\"?\n\n**REST** (Representational State Transfer) is a set of conventions for building APIs:\n\n1. **Resources are nouns**: `/books`, not `/getBooks`\n2. **HTTP methods are verbs**: Use GET/POST/PUT/DELETE, not custom action names\n3. **Stateless**: Each request contains all needed information\n4. **Standard status codes**: 200 for success, 404 for not found, etc.\n5. **JSON for data**: Structured, language-independent format\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "üóÇÔ∏è Organizing Routes",
              "content": "\nAs your API grows, putting all routes in one function becomes messy. Let's learn to organize them properly.\n\n### Route Organization Patterns\n\n**Pattern 1: Flat (What We Did Before)**\n\n**Pattern 2: Grouped by Resource (Better!)**\n\n**Pattern 3: Separate Files by Resource (Best for Large Projects)**\n\nFor this lesson, we'll use **Pattern 2** (grouped routes).\n\n---\n\n",
              "code": "// BookRoutes.kt\nfun Route.bookRoutes() {\n    route(\"/books\") {\n        get { }\n        post { }\n        // etc.\n    }\n}\n\n// Application.kt\nrouting {\n    bookRoutes()\n    userRoutes()\n    orderRoutes()\n}",
              "language": "kotlin"
            },
            {
              "type": "EXAMPLE",
              "title": "üíª Code: Building a Complete Books API",
              "content": "\nLet's build a complete CRUD API step by step.\n\n### Step 1: Define the Data Model\n\nCreate `src/main/kotlin/com/example/models/Book.kt`:\n\n\n**Understanding the annotations:**\n\n- **@Serializable**: Tells kotlinx.serialization this class can be converted to/from JSON\n- **data class**: Automatically generates `equals()`, `hashCode()`, `toString()`, `copy()`\n- **String?**: The `?` makes `isbn` nullable (optional)\n\n### Step 2: Create an In-Memory Data Store\n\nCreate `src/main/kotlin/com/example/data/BookStorage.kt`:\n\n\n**Key concepts:**\n\n- **object BookStorage**: Singleton pattern (only one instance)\n- **AtomicInteger**: Thread-safe counter for generating IDs\n- **init { }**: Code that runs when the object is first accessed\n- **find { }**: Returns first matching item or `null`\n- **indexOfFirst { }**: Returns index of first match or `-1`\n- **removeIf { }**: Removes all items matching the predicate\n\n### Step 3: Define Request/Response Models\n\nCreate `src/main/kotlin/com/example/models/BookRequest.kt`:\n\n\n**Why separate request models?**\n\n1. **Security**: Clients shouldn't send IDs when creating (server assigns them)\n2. **Flexibility**: Updates can be partial (only changed fields)\n3. **Clarity**: Clear what data is expected\n\n### Step 4: Build the Routes\n\nNow for the main event! Update `src/main/kotlin/com/example/plugins/Routing.kt`:\n\n\n---\n\n",
              "code": "package com.example.plugins\n\nimport com.example.data.BookStorage\nimport com.example.models.*\nimport io.ktor.http.*\nimport io.ktor.server.application.*\nimport io.ktor.server.request.*\nimport io.ktor.server.response.*\nimport io.ktor.server.routing.*\n\nfun Application.configureRouting() {\n    routing {\n        // Root endpoint\n        get(\"/\") {\n            call.respondText(\"Books API is running! Visit /api/books\")\n        }\n\n        // API routes\n        route(\"/api\") {\n            bookRoutes()\n        }\n    }\n}\n\n// Book routes grouped together\nfun Route.bookRoutes() {\n    route(\"/books\") {\n        // GET /api/books - List all books\n        get {\n            val books = BookStorage.getAll()\n            call.respond(\n                HttpStatusCode.OK,\n                ApiResponse(success = true, data = books)\n            )\n        }\n\n        // GET /api/books/{id} - Get specific book\n        get(\"/{id}\") {\n            val id = call.parameters[\"id\"]?.toIntOrNull()\n\n            if (id == null) {\n                call.respond(\n                    HttpStatusCode.BadRequest,\n                    ApiResponse<Book>(\n                        success = false,\n                        message = \"Invalid book ID\"\n                    )\n                )\n                return@get\n            }\n\n            val book = BookStorage.getById(id)\n\n            if (book == null) {\n                call.respond(\n                    HttpStatusCode.NotFound,\n                    ApiResponse<Book>(\n                        success = false,\n                        message = \"Book not found\"\n                    )\n                )\n            } else {\n                call.respond(\n                    HttpStatusCode.OK,\n                    ApiResponse(success = true, data = book)\n                )\n            }\n        }\n\n        // POST /api/books - Create new book\n        post {\n            val request = call.receive<CreateBookRequest>()\n\n            // Simple validation\n            if (request.title.isBlank() || request.author.isBlank()) {\n                call.respond(\n                    HttpStatusCode.BadRequest,\n                    ApiResponse<Book>(\n                        success = false,\n                        message = \"Title and author are required\"\n                    )\n                )\n                return@post\n            }\n\n            val newBook = Book(\n                id = 0, // Will be replaced by storage\n                title = request.title,\n                author = request.author,\n                year = request.year,\n                isbn = request.isbn\n            )\n\n            val created = BookStorage.add(newBook)\n\n            call.respond(\n                HttpStatusCode.Created,\n                ApiResponse(\n                    success = true,\n                    data = created,\n                    message = \"Book created successfully\"\n                )\n            )\n        }\n\n        // PUT /api/books/{id} - Update book\n        put(\"/{id}\") {\n            val id = call.parameters[\"id\"]?.toIntOrNull()\n\n            if (id == null) {\n                call.respond(\n                    HttpStatusCode.BadRequest,\n                    ApiResponse<Book>(\n                        success = false,\n                        message = \"Invalid book ID\"\n                    )\n                )\n                return@put\n            }\n\n            val request = call.receive<CreateBookRequest>()\n\n            val updatedBook = Book(\n                id = id,\n                title = request.title,\n                author = request.author,\n                year = request.year,\n                isbn = request.isbn\n            )\n\n            val success = BookStorage.update(id, updatedBook)\n\n            if (success) {\n                call.respond(\n                    HttpStatusCode.OK,\n                    ApiResponse(\n                        success = true,\n                        data = updatedBook,\n                        message = \"Book updated successfully\"\n                    )\n                )\n            } else {\n                call.respond(\n                    HttpStatusCode.NotFound,\n                    ApiResponse<Book>(\n                        success = false,\n                        message = \"Book not found\"\n                    )\n                )\n            }\n        }\n\n        // DELETE /api/books/{id} - Delete book\n        delete(\"/{id}\") {\n            val id = call.parameters[\"id\"]?.toIntOrNull()\n\n            if (id == null) {\n                call.respond(\n                    HttpStatusCode.BadRequest,\n                    ApiResponse<Unit>(\n                        success = false,\n                        message = \"Invalid book ID\"\n                    )\n                )\n                return@delete\n            }\n\n            val success = BookStorage.delete(id)\n\n            if (success) {\n                call.respond(\n                    HttpStatusCode.OK,\n                    ApiResponse<Unit>(\n                        success = true,\n                        message = \"Book deleted successfully\"\n                    )\n                )\n            } else {\n                call.respond(\n                    HttpStatusCode.NotFound,\n                    ApiResponse<Unit>(\n                        success = false,\n                        message = \"Book not found\"\n                    )\n                )\n            }\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "EXAMPLE",
              "title": "üîç Code Breakdown",
              "content": "\nLet's analyze the key patterns:\n\n### 1. Route Organization\n\n\n**Benefits:**\n- Clear hierarchy\n- Easy to add new routes\n- Can move to separate files as project grows\n\n### 2. Receiving Request Bodies\n\n\n- **call.receive<T>()**: Automatically parses JSON to Kotlin object\n- Throws exception if JSON is invalid (we'll handle this in later lessons)\n\n### 3. Responding with Status Codes\n\n\n**Common patterns:**\n- **200 OK**: Successful GET/PUT\n- **201 Created**: Successful POST (new resource)\n- **204 No Content**: Successful DELETE (no body needed)\n- **400 Bad Request**: Invalid input\n- **404 Not Found**: Resource doesn't exist\n\n### 4. Parameter Extraction and Validation\n\n\n**Key techniques:**\n- **?.toIntOrNull()**: Safe conversion (null if not a number)\n- **Early return**: If validation fails, respond and exit\n- **@get/@post/@put/@delete**: Label for return statement\n\n### 5. API Response Wrapper\n\n\n**Consistent responses:**\n\n---\n\n",
              "code": "{\n  \"success\": true,\n  \"data\": { \"id\": 1, \"title\": \"1984\" },\n  \"message\": \"Book created successfully\"\n}",
              "language": "json"
            },
            {
              "type": "THEORY",
              "title": "üß™ Testing Your Complete API",
              "content": "\n### Test GET All Books\n\n\n**Expected Response:**\n\n### Test GET Single Book\n\n\n### Test CREATE New Book\n\n\n**Expected Response:**\n\n### Test UPDATE Book\n\n\n### Test DELETE Book\n\n\n### Test Error Cases\n\n\n---\n\n",
              "code": "# Invalid ID (not a number)\ncurl http://localhost:8080/api/books/abc\n\n# Non-existent book\ncurl http://localhost:8080/api/books/9999\n\n# Empty title (validation error)\ncurl -X POST http://localhost:8080/api/books \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"title\": \"\", \"author\": \"Unknown\", \"year\": 2024}'",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "üéØ Exercise: Extend the API",
              "content": "\nAdd these features to your Books API:\n\n### Exercise 1: Search by Title\n\nAdd a route that searches books by title (case-insensitive).\n\n**Endpoint**: `GET /api/books/search?title=brave`\n\n**Expected**: Return all books whose title contains \"brave\" (case-insensitive)\n\n**Hints:**\n\n### Exercise 2: Filter by Year\n\nAdd a route to get books published in a specific year range.\n\n**Endpoint**: `GET /api/books/filter?minYear=1930&maxYear=1950`\n\n**Expected**: Return books published between 1930 and 1950 (inclusive)\n\n### Exercise 3: Get Books by Author\n\nAdd a route to get all books by a specific author.\n\n**Endpoint**: `GET /api/books/author/{authorName}`\n\n**Expected**: Return all books by that author (case-insensitive match)\n\n### Exercise 4: Count Endpoint\n\nAdd a route that returns the total number of books.\n\n**Endpoint**: `GET /api/books/count`\n\n**Expected Response**:\n\n---\n\n",
              "code": "{\n  \"success\": true,\n  \"data\": { \"count\": 5 },\n  \"message\": \"Total books counted\"\n}",
              "language": "json"
            },
            {
              "type": "THEORY",
              "title": "‚úÖ Solution & Explanation",
              "content": "\nHere's the complete solution with all exercises:\n\n\n### Testing the Solutions\n\n\n### Key Techniques Used\n\n1. **Query Parameters**: `call.request.queryParameters[\"key\"]`\n2. **Filtering**: `filter { predicate }` on lists\n3. **Range Check**: `it.year in minYear..maxYear`\n4. **Case-Insensitive Search**: `contains(query, ignoreCase = true)`\n5. **Inline Data Classes**: Define response structure locally\n\n---\n\n",
              "code": "# Exercise 1: Search\ncurl \"http://localhost:8080/api/books/search?title=brave\"\n\n# Exercise 2: Filter by year\ncurl \"http://localhost:8080/api/books/filter?minYear=1930&maxYear=1950\"\n\n# Exercise 3: Books by author\ncurl http://localhost:8080/api/books/author/Orwell\n\n# Exercise 4: Count\ncurl http://localhost:8080/api/books/count",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "üìù Lesson Checkpoint Quiz",
              "content": "\nTest your understanding of Ktor routing:\n\n### Question 1\nIn the route definition `route(\"/books\") { get(\"/{id}\") { } }`, what is the full path that will be matched?\n\nA) `/books`\nB) `/books/{id}`\nC) `/{id}/books`\nD) `/books/id`\n\n---\n\n### Question 2\nWhich HTTP status code should you return when a client tries to create a book with an empty title?\n\nA) 200 OK\nB) 201 Created\nC) 400 Bad Request\nD) 404 Not Found\n\n---\n\n### Question 3\nWhat does `call.receive<CreateBookRequest>()` do?\n\nA) Sends a CreateBookRequest to the client\nB) Converts the JSON request body into a CreateBookRequest object\nC) Creates a new book in the database\nD) Validates that the request is correctly formatted\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "üéØ Why This Matters",
              "content": "\nYou just built a **production-ready REST API**! This exact pattern is used by:\n\n- **E-commerce sites** for managing products\n- **Social media** for managing posts and comments\n- **Banking apps** for managing accounts and transactions\n- **Any mobile app** that needs to store data on a server\n\n### What You've Mastered\n\n‚úÖ **CRUD Operations**: The foundation of 90% of all APIs\n‚úÖ **RESTful Design**: Industry-standard API architecture\n‚úÖ **JSON Serialization**: Converting Kotlin ‚Üî JSON automatically\n‚úÖ **Route Organization**: Keeping code clean as it grows\n‚úÖ **Error Handling**: Proper status codes for different scenarios\n‚úÖ **Request/Response Models**: Type-safe API contracts\n\n### The Missing Piece\n\nRight now, your data disappears when the server restarts (it's only in memory). In the next lessons, you'll learn:\n\n- **Databases**: Persistent storage that survives restarts\n- **Validation**: More sophisticated input checking\n- **Authentication**: Protecting routes (login required)\n- **Testing**: Ensuring your API works correctly\n\nBut the routing patterns you learned today? **They stay the same**. You'll just swap the in-memory storage for a database.\n\n---\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "üìö Key Takeaways",
              "content": "\n‚úÖ **route(\"/path\")** groups related endpoints together\n‚úÖ **GET** retrieves data, **POST** creates, **PUT** updates, **DELETE** removes\n‚úÖ **call.receive<T>()** parses JSON request body to Kotlin object\n‚úÖ **call.respond(status, data)** sends JSON response with status code\n‚úÖ **@Serializable** makes Kotlin classes convertible to/from JSON\n‚úÖ **Path parameters** capture dynamic parts of URLs: `/{id}`\n‚úÖ **Query parameters** provide filters: `?title=kotlin&year=2020`\n‚úÖ **Status codes** communicate results: 200, 201, 400, 404\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "üîú Next Steps",
              "content": "\nIn **Lesson 5.4**, you'll dive deeper into:\n- Path parameters vs. query parameters (when to use each)\n- Accessing request headers\n- Complex query parameters (multiple values, optional params)\n- Request body validation patterns\n- Nested routes and sub-resources\n\n---\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "‚úèÔ∏è Quiz Answer Key",
              "content": "\n**Question 1**: **B) `/books/{id}`**\n\nExplanation: The `route(\"/books\")` sets the base path, and `get(\"/{id}\")` appends to it, resulting in `/books/{id}`.\n\n---\n\n**Question 2**: **C) 400 Bad Request**\n\nExplanation: 400 indicates the client sent invalid data. The request format is correct (it's JSON), but the content violates business rules (empty title).\n\n---\n\n**Question 3**: **B) Converts the JSON request body into a CreateBookRequest object**\n\nExplanation: `call.receive<T>()` uses kotlinx.serialization to automatically parse the JSON body into the specified Kotlin type. It's the \"receive\" counterpart to \"respond\".\n\n---\n\n**Congratulations!** You've built a complete REST API with full CRUD operations! You now have a real, testable backend that handles JSON data. üéâ\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "5.3.1",
              "title": "Request Validation",
              "description": "Create a function that validates a registration request. Check that username is at least 3 characters and email contains '@'.",
              "instructions": "Create a function that validates a registration request. Check that username is at least 3 characters and email contains '@'.",
              "starterCode": "data class RegisterRequest(val username: String, val email: String, val password: String)\n\nfun validateRegistration(request: RegisterRequest): List<String> {\n    val errors = mutableListOf<String>()\n    // Add validation logic\n    \n    return errors\n}\n\nfun main() {\n    val request1 = RegisterRequest(\"ab\", \"invalidemail\", \"pass\")\n    val errors = validateRegistration(request1)\n    println(\"Errors: $errors\")\n    \n    val request2 = RegisterRequest(\"alice\", \"alice@example.com\", \"password123\")\n    val errors2 = validateRegistration(request2)\n    println(\"Valid: ${errors2.isEmpty()}\")\n}",
              "solution": "data class RegisterRequest(val username: String, val email: String, val password: String)\n\nfun validateRegistration(request: RegisterRequest): List<String> {\n    val errors = mutableListOf<String>()\n    \n    if (request.username.length < 3) {\n        errors.add(\"Username must be at least 3 characters\")\n    }\n    \n    if (!request.email.contains(\"@\")) {\n        errors.add(\"Email must contain @\")\n    }\n    \n    if (request.password.length < 8) {\n        errors.add(\"Password must be at least 8 characters\")\n    }\n    \n    return errors\n}\n\nfun main() {\n    val request1 = RegisterRequest(\"ab\", \"invalidemail\", \"pass\")\n    val errors = validateRegistration(request1)\n    println(\"Errors: $errors\")\n    \n    val request2 = RegisterRequest(\"alice\", \"alice@example.com\", \"password123\")\n    val errors2 = validateRegistration(request2)\n    println(\"Valid: ${errors2.isEmpty()}\")\n}",
              "language": "kotlin",
              "testCases": [
                {
                  "description": "Should return errors for invalid data",
                  "expectedOutput": "Errors:",
                  "isVisible": true
                },
                {
                  "description": "Should return empty list for valid data",
                  "expectedOutput": "Valid: true",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Create a mutableListOf<String> for errors"
                },
                {
                  "level": 2,
                  "text": "Check username.length >= 3"
                },
                {
                  "level": 3,
                  "text": "Check email.contains(\"@\")"
                },
                {
                  "level": 4,
                  "text": "Check password.length >= 8"
                },
                {
                  "level": 5,
                  "text": "Add error message for each failed check"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "5.4",
          "title": "Lesson 5.4: Request Parameters - Path, Query, and Body",
          "moduleId": "module-05",
          "order": 10,
          "estimatedMinutes": 40,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 40 minutes\n**Difficulty**: Beginner-Intermediate\n**Prerequisites**: Lessons 5.1-5.3 (HTTP fundamentals, Ktor setup, routing)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "üìñ Topic Introduction",
              "content": "\nIn the previous lesson, you built a complete CRUD API. But we only scratched the surface of how data can be sent to your server. There are actually **three main ways** clients send data:\n\n1. **Path Parameters**: Data embedded in the URL path (`/users/42`)\n2. **Query Parameters**: Key-value pairs after `?` (`/search?q=kotlin&page=2`)\n3. **Request Body**: JSON/form data sent with the request\n\nUnderstanding when and how to use each is crucial for building intuitive, flexible APIs. In this lesson, you'll master all three!\n\n---\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "üí° The Concept: Three Ways to Send Data",
              "content": "\n### The Restaurant Order Analogy\n\nImagine ordering food at a restaurant:\n\n**1. Path Parameters** = Table Number\n- **Essential identifier** that's part of the resource location\n- Usually required, not optional\n- Identifies which specific resource you want\n\n**2. Query Parameters** = Special Instructions\n- **Optional filters or modifiers** that refine the request\n- Can have multiple values\n- Doesn't change which resource, but how you want it\n\n**3. Request Body** = The Order Itself\n- **Complex data** that doesn't fit in the URL\n- Used for creating or updating resources\n- Can contain nested structures\n\n---\n\n",
              "code": "POST /orders\nBody: {\n  \"items\": [\"burger\", \"fries\"],\n  \"table\": 12,\n  \"special_instructions\": \"no onions\"\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "üõ§Ô∏è Path Parameters: Identifying Resources",
              "content": "\n### When to Use Path Parameters\n\nUse path parameters for:\n- ‚úÖ Resource identifiers (IDs, usernames, slugs)\n- ‚úÖ Required hierarchical relationships\n- ‚úÖ Data that identifies **which** resource\n\n**Examples:**\n\n### Single Path Parameter\n\n\n### Multiple Path Parameters\n\n\n### Optional Path Parameters\n\n\nThe `?` makes the parameter optional:\n- `/tasks` ‚Üí Returns all tasks\n- `/tasks/high` ‚Üí Returns only high-priority tasks\n\n---\n\n",
              "code": "get(\"/tasks/{priority?}\") {\n    val priority = call.parameters[\"priority\"]\n\n    val tasks = if (priority != null) {\n        TaskStorage.getByPriority(priority)\n    } else {\n        TaskStorage.getAll()\n    }\n\n    call.respond(tasks)\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "üîç Query Parameters: Filtering and Options",
              "content": "\n### When to Use Query Parameters\n\nUse query parameters for:\n- ‚úÖ Filtering results (`?status=active`)\n- ‚úÖ Sorting (`?sort=date&order=desc`)\n- ‚úÖ Pagination (`?page=2&limit=20`)\n- ‚úÖ Search (`?q=kotlin`)\n- ‚úÖ Optional settings (`?format=json`)\n\n**Examples:**\n\n### Accessing Single Query Parameter\n\n\n**Test it:**\n\n### Accessing Multiple Query Parameters\n\n\n**Test it:**\n\n### Query Parameter with Default Values\n\n\nThe `?:` (Elvis operator) provides defaults:\n- No `page` parameter ‚Üí defaults to 1\n- No `limit` parameter ‚Üí defaults to 20\n- No `sort` parameter ‚Üí defaults to \"name\"\n\n### Multiple Values for Same Parameter\n\n\n**Test it:**\n\n---\n\n",
              "code": "curl \"http://localhost:8080/books?tag=fiction&tag=bestseller&tag=scifi\"",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "üì¶ Request Body: Complex Data",
              "content": "\n### When to Use Request Body\n\nUse request body for:\n- ‚úÖ Creating resources (POST)\n- ‚úÖ Updating resources (PUT/PATCH)\n- ‚úÖ Complex search queries\n- ‚úÖ Data that doesn't fit in URLs\n- ‚úÖ Sensitive data (passwords, etc.)\n\n### Receiving JSON Body\n\n\n**Test it:**\n\n### Receiving Plain Text\n\n\n### Receiving Form Data\n\n\n**Test it:**\n\n---\n\n",
              "code": "curl -X POST http://localhost:8080/login \\\n  -d \"username=alice&password=secret123\"",
              "language": "bash"
            },
            {
              "type": "EXAMPLE",
              "title": "üíª Complete Example: Advanced Search API",
              "content": "\nLet's build a comprehensive example combining all three parameter types:\n\n### Define Models\n\n\n### Implement the Search Route\n\n\n### Test the Advanced Search\n\n**Simple search with query parameters:**\n\n**Advanced search with body + pagination:**\n\n**Category search with filters:**\n\n---\n\n",
              "code": "curl \"http://localhost:8080/search/category/fiction?inStock=true&minRating=4.5\"",
              "language": "bash"
            },
            {
              "type": "EXAMPLE",
              "title": "üîç Code Breakdown: Best Practices",
              "content": "\n### 1. Parameter Validation Pattern\n\n\n**Key points:**\n- Always validate parameter types\n- Use `toIntOrNull()`, `toDoubleOrNull()` for safe conversion\n- Return early on validation errors\n- Send appropriate status codes\n\n### 2. Default Values Pattern\n\n\n### 3. Combining Parameters Pattern\n\n\n### 4. Headers as Parameters\n\nDon't forget about headers!\n\n\n---\n\n",
              "code": "get(\"/profile\") {\n    val authToken = call.request.headers[\"Authorization\"]\n    val userAgent = call.request.headers[\"User-Agent\"]\n    val acceptLanguage = call.request.headers[\"Accept-Language\"]\n\n    if (authToken == null) {\n        call.respond(HttpStatusCode.Unauthorized, \"Token required\")\n        return@get\n    }\n\n    // Use the header data\n    val user = AuthService.getUserFromToken(authToken)\n    call.respond(user)\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "üéØ Exercise: Build a Task Filter API",
              "content": "\nCreate a comprehensive task filtering API using all parameter types:\n\n### Requirements\n\n**1. GET /tasks/{status}** - Path parameter for status\n- `status` can be: \"pending\", \"completed\", \"archived\"\n- Example: `/tasks/pending`\n\n**2. Add query parameters for additional filters:**\n- `priority`: \"low\", \"medium\", \"high\"\n- `assignedTo`: username\n- `sort`: \"date\", \"priority\", \"title\"\n- `order`: \"asc\", \"desc\"\n\n**3. POST /tasks/search** - Advanced search with body\n- Body should accept:\n  ```json\n  {\n    \"title\": \"search term\",\n    \"tags\": [\"urgent\", \"bug\"],\n    \"dueDateRange\": {\n      \"start\": \"2024-01-01\",\n      \"end\": \"2024-12-31\"\n    }\n  }\n  ```\n\n### Starter Code\n\n\n---\n\n",
              "code": "@Serializable\ndata class Task(\n    val id: Int,\n    val title: String,\n    val status: String,\n    val priority: String,\n    val assignedTo: String?,\n    val tags: List<String>,\n    val dueDate: String?\n)\n\nobject TaskStorage {\n    private val tasks = mutableListOf(\n        Task(1, \"Fix bug\", \"pending\", \"high\", \"alice\", listOf(\"bug\", \"urgent\"), \"2024-12-01\"),\n        Task(2, \"Write docs\", \"completed\", \"medium\", \"bob\", listOf(\"docs\"), \"2024-11-15\"),\n        Task(3, \"Review PR\", \"pending\", \"medium\", \"alice\", listOf(\"review\"), \"2024-11-20\"),\n        Task(4, \"Deploy\", \"archived\", \"low\", null, listOf(\"deploy\"), null)\n    )\n\n    fun getAll() = tasks.toList()\n    fun getByStatus(status: String) = tasks.filter { it.status == status }\n}\n\n// TODO: Implement the routes!",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "‚úÖ Solution & Explanation",
              "content": "\nHere's the complete implementation:\n\n\n### Testing the Solution\n\n**Test path + query parameters:**\n\n**Test advanced search:**\n\n---\n\n",
              "code": "curl -X POST http://localhost:8080/tasks/search \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"title\": \"bug\",\n    \"tags\": [\"urgent\"],\n    \"dueDateRange\": {\n      \"start\": \"2024-11-01\",\n      \"end\": \"2024-12-31\"\n    }\n  }'",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "üìù Lesson Checkpoint Quiz",
              "content": "\n### Question 1\nWhich parameter type should you use for a required user ID in a route like \"get user profile\"?\n\nA) Query parameter: `/profile?userId=42`\nB) Path parameter: `/profile/42`\nC) Request body: `POST /profile` with `{\"userId\": 42}`\nD) Header: `X-User-ID: 42`\n\n---\n\n### Question 2\nYou're building a product search API with many optional filters (category, price range, brand, color). What's the BEST approach?\n\nA) Use all path parameters: `/products/electronics/100/500/apple/red`\nB) Use all query parameters: `/products?category=electronics&minPrice=100...`\nC) Use request body for all filters: `POST /products/search`\nD) Create separate endpoints for each filter combination\n\n---\n\n### Question 3\nWhat does `call.request.queryParameters[\"page\"]?.toIntOrNull() ?: 1` do?\n\nA) Gets the page parameter and throws an error if it's not a number\nB) Gets the page parameter, converts to Int, or returns 1 if null/invalid\nC) Sets the page parameter to 1\nD) Gets the first page of results\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "üéØ Why This Matters",
              "content": "\nUnderstanding parameter types is crucial for building **intuitive, flexible APIs** that other developers love to use.\n\n### Real-World Examples\n\n**GitHub API:**\n\n**Twitter API:**\n\n**Stripe API:**\n\n### Design Principles You've Learned\n\n‚úÖ **Path parameters**: Required identifiers\n‚úÖ **Query parameters**: Optional filters and settings\n‚úÖ **Request body**: Complex or sensitive data\n‚úÖ **Combine them**: For maximum flexibility\n\n---\n\n",
              "code": "POST /customers\nBody: { \"email\": \"user@example.com\", \"name\": \"Alice\" }",
              "language": "kotlin"
            },
            {
              "type": "KEY_POINT",
              "title": "üìö Key Takeaways",
              "content": "\n‚úÖ **Path parameters** (`/{id}`) identify **which** resource\n‚úÖ **Query parameters** (`?key=value`) refine **how** you want it\n‚úÖ **Request body** contains **complex data** for POST/PUT\n‚úÖ Always **validate** parameter types with `toIntOrNull()`, etc.\n‚úÖ Provide **default values** with Elvis operator `?:`\n‚úÖ **Combine** parameter types for flexible APIs\n‚úÖ Use **early returns** for validation failures\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "üîú Next Steps",
              "content": "\nIn **Lesson 5.5**, you'll dive deeper into:\n- Advanced JSON serialization techniques\n- Custom serializers for complex types\n- Handling nested objects\n- Polymorphic serialization\n- Error handling for malformed JSON\n\n---\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "‚úèÔ∏è Quiz Answer Key",
              "content": "\n**Question 1**: **B) Path parameter: `/profile/42`**\n\nExplanation: User ID is a required identifier that specifies *which* user's profile. Path parameters are perfect for required resource identifiers. Query parameters would make it seem optional.\n\n---\n\n**Question 2**: **B) Use all query parameters**\n\nExplanation: Query parameters are ideal for optional filters. Users can provide as many or as few as they want. Path parameters would be unwieldy, and POST body would be overkill for a simple read operation (GET).\n\n---\n\n**Question 3**: **B) Gets the page parameter, converts to Int, or returns 1 if null/invalid**\n\nExplanation: `?.` safely accesses the parameter (returns null if not present), `toIntOrNull()` converts to Int (returns null if invalid), and `?: 1` provides a default value of 1.\n\n---\n\n**Congratulations!** You now understand all three ways to receive data in Ktor and when to use each! üéâ\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "5.5",
          "title": "Lesson 5.5: JSON Serialization with kotlinx.serialization",
          "moduleId": "module-05",
          "order": 11,
          "estimatedMinutes": 35,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 35 minutes\n**Difficulty**: Beginner-Intermediate\n**Prerequisites**: Lessons 5.1-5.4 (HTTP, Ktor setup, routing, parameters)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "üìñ Topic Introduction",
              "content": "\nYou've been using JSON in your API without really understanding what's happening behind the scenes. When you write `call.receive<Book>()` or `call.respond(book)`, magic happens: Kotlin objects transform into JSON text and back.\n\nIn this lesson, you'll learn:\n- How JSON serialization actually works\n- Advanced `@Serializable` annotations\n- Custom serializers for special types (dates, enums, etc.)\n- Handling nullable and optional fields\n- Polymorphic serialization (base classes and inheritance)\n- Error handling for malformed JSON\n\nBy the end, you'll have complete control over how your API handles JSON data!\n\n---\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "üí° The Concept: What Is Serialization?",
              "content": "\n### The Translation Analogy\n\nImagine you have a letter written in English, and you need to send it to someone who only reads Spanish.\n\n**Serialization** = Translating English ‚Üí Spanish\n\n**Deserialization** = Translating Spanish ‚Üí English\n\n### Why Do We Need It?\n\n**Problem**: Kotlin objects only exist in memory on your server. How do you send them over the internet?\n\n**Solution**: Convert them to a **text format** (JSON) that any programming language can understand.\n\n\n### JSON Basics Refresher\n\n**JSON** (JavaScript Object Notation) is a text format for data:\n\n\n**Supported types:**\n- **Numbers**: `42`, `3.14`\n- **Strings**: `\"hello\"`\n- **Booleans**: `true`, `false`\n- **null**: `null`\n- **Arrays**: `[1, 2, 3]`\n- **Objects**: `{\"key\": \"value\"}`\n\n---\n\n",
              "code": "{\n  \"id\": 1,\n  \"title\": \"1984\",\n  \"author\": \"George Orwell\",\n  \"year\": 1949,\n  \"inStock\": true,\n  \"price\": 12.99,\n  \"tags\": [\"fiction\", \"dystopia\"],\n  \"publisher\": null\n}",
              "language": "json"
            },
            {
              "type": "THEORY",
              "title": "üîß The @Serializable Annotation",
              "content": "\n### Basic Usage\n\n\n**What @Serializable does:**\n1. Generates a **serializer** for the class at compile time\n2. Knows how to convert each field to/from JSON\n3. Works automatically with Ktor's `call.receive()` and `call.respond()`\n\n### What Gets Serialized?\n\n\n**Rule**: Only properties in the **primary constructor** are serialized.\n\n---\n\n",
              "code": "@Serializable\ndata class User(\n    val id: Int,           // ‚úÖ Serialized\n    val name: String,      // ‚úÖ Serialized\n    var age: Int           // ‚úÖ Serialized (var or val doesn't matter)\n) {\n    val isAdult: Boolean   // ‚ùå NOT serialized (not in constructor)\n        get() = age >= 18\n\n    fun greet() {          // ‚ùå NOT serialized (functions never are)\n        println(\"Hello!\")\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "üé® Customizing Field Names",
              "content": "\n### Using @SerialName\n\nSometimes your Kotlin naming doesn't match the JSON format you need:\n\n\n**JSON representation:**\n\n**Why use @SerialName?**\n- ‚úÖ Match external API naming conventions (snake_case vs camelCase)\n- ‚úÖ Keep Kotlin code idiomatic (camelCase)\n- ‚úÖ Avoid breaking changes when refactoring\n\n---\n\n",
              "code": "{\n  \"id\": 1,\n  \"user_name\": \"alice\",\n  \"email_address\": \"alice@example.com\",\n  \"created_at\": \"2024-11-13\"\n}",
              "language": "json"
            },
            {
              "type": "THEORY",
              "title": "üîÑ Handling Nullable and Optional Fields",
              "content": "\n### Nullable Fields\n\n\n**JSON examples:**\n\n### Default Values\n\n\n**JSON examples:**\n\n### Required vs Optional\n\n\n---\n\n",
              "code": "@Serializable\ndata class CreateBookRequest(\n    val title: String,           // REQUIRED (no default, not nullable)\n    val author: String,          // REQUIRED\n    val year: Int? = null,       // OPTIONAL (nullable with default)\n    val isbn: String? = null     // OPTIONAL\n)",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "üìÖ Custom Serializers for Special Types",
              "content": "\n### Problem: Dates and Times\n\n`LocalDateTime` is not supported by default:\n\n\n### Solution: Custom Serializer\n\n**Step 1: Create the serializer**\n\n\n**Step 2: Use it in your data class**\n\n\n**JSON result:**\n\n### Simplified: Using @Contextual\n\nFor types you use frequently, register them globally:\n\n\n---\n\n",
              "code": "// In your Application.kt\ninstall(ContentNegotiation) {\n    json(Json {\n        serializersModule = SerializersModule {\n            contextual(LocalDateTime::class, LocalDateTimeSerializer)\n        }\n    })\n}\n\n// In your data class\n@Serializable\ndata class Event(\n    val id: Int,\n    val name: String,\n    @Contextual\n    val date: LocalDateTime  // No need to specify serializer\n)",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "üé≠ Enums and Sealed Classes",
              "content": "\n### Enum Serialization\n\n\n**JSON:**\n\n### Custom Enum Serialization\n\nSometimes you want custom enum values:\n\n\n### Polymorphic Serialization (Inheritance)\n\n\n**JSON with type discrimination:**\n\n---\n\n",
              "code": "{\n  \"notifications\": [\n    {\n      \"type\": \"email\",\n      \"id\": 1,\n      \"timestamp\": \"2024-11-13T10:00:00\",\n      \"recipient\": \"alice@example.com\",\n      \"subject\": \"Welcome\"\n    },\n    {\n      \"type\": \"sms\",\n      \"id\": 2,\n      \"timestamp\": \"2024-11-13T10:05:00\",\n      \"phoneNumber\": \"+1234567890\",\n      \"message\": \"Your code is 123456\"\n    }\n  ]\n}",
              "language": "json"
            },
            {
              "type": "THEORY",
              "title": "üõ†Ô∏è JSON Configuration Options",
              "content": "\nConfigure how kotlinx.serialization behaves:\n\n\n**Example of prettyPrint:**\n\n\n---\n\n",
              "code": "// prettyPrint = false (default)\n{\"id\":1,\"title\":\"1984\",\"author\":\"George Orwell\"}\n\n// prettyPrint = true\n{\n  \"id\": 1,\n  \"title\": \"1984\",\n  \"author\": \"George Orwell\"\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "üîç Handling JSON Errors",
              "content": "\n### Catching Deserialization Errors\n\n\n### Common Errors and Solutions\n\n**1. Missing required field:**\n**Solution**: Either make field nullable or provide default value\n\n**2. Wrong type:**\n**Solution**: Use correct JSON types or create custom serializer\n\n**3. Unknown fields:**\n**Solution**: Set `ignoreUnknownKeys = true` in JSON config\n\n---\n\n",
              "code": "// Extra field \"publisher\"\n{\"id\": 1, \"title\": \"1984\", \"publisher\": \"Penguin\"}",
              "language": "json"
            },
            {
              "type": "EXAMPLE",
              "title": "üíª Complete Example: Blog Post API",
              "content": "\nLet's build a complete example with custom serializers:\n\n\n### Routes Using the Models\n\n\n### Testing\n\n\n**Response:**\n\n---\n\n",
              "code": "{\n  \"success\": true,\n  \"post\": {\n    \"id\": 1,\n    \"title\": \"Getting Started with Kotlin\",\n    \"content\": \"Kotlin is an amazing language...\",\n    \"author\": {\n      \"id\": 1,\n      \"name\": \"Alice\",\n      \"email\": \"alice@example.com\"\n    },\n    \"status\": \"PUBLISHED\",\n    \"tags\": [\"kotlin\", \"programming\", \"tutorial\"],\n    \"createdAt\": \"2024-11-13T15:30:00\",\n    \"updatedAt\": \"2024-11-13T15:30:00\",\n    \"publishedAt\": \"2024-11-13T15:30:00\"\n  }\n}",
              "language": "json"
            },
            {
              "type": "THEORY",
              "title": "üéØ Exercise: Product Catalog with Variants",
              "content": "\nCreate a product catalog API with these requirements:\n\n### Requirements\n\n1. **Product** model with:\n   - Basic info (id, name, description)\n   - Price (use Double)\n   - Category (enum: ELECTRONICS, CLOTHING, BOOKS, FOOD)\n   - Created/updated timestamps (use LocalDateTime)\n   - Variants (list of ProductVariant)\n\n2. **ProductVariant** model with:\n   - SKU (stock keeping unit)\n   - Size or other attribute\n   - Stock quantity\n   - Price override (nullable)\n\n3. **Create endpoint** to add products with variants\n4. **Handle errors** for invalid JSON\n5. **Custom serializer** for timestamps\n\n### Starter Code\n\n\n---\n\n",
              "code": "enum class ProductCategory {\n    ELECTRONICS,\n    CLOTHING,\n    BOOKS,\n    FOOD\n}\n\n// TODO: Add @Serializable and implement models\ndata class ProductVariant(\n    val sku: String,\n    val attribute: String,  // e.g., \"Size: Large\", \"Color: Red\"\n    val stockQuantity: Int,\n    val priceOverride: Double? = null\n)\n\ndata class Product(\n    val id: Int,\n    val name: String,\n    val description: String,\n    val basePrice: Double,\n    val category: ProductCategory,\n    val variants: List<ProductVariant>,\n    val createdAt: LocalDateTime,\n    val updatedAt: LocalDateTime\n)\n\n// TODO: Create request model\n// TODO: Implement routes",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "‚úÖ Solution & Explanation",
              "content": "\n\n### Testing\n\n\n---\n\n",
              "code": "curl -X POST http://localhost:8080/products \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"T-Shirt\",\n    \"description\": \"100% Cotton T-Shirt\",\n    \"basePrice\": 19.99,\n    \"category\": \"CLOTHING\",\n    \"variants\": [\n      {\n        \"sku\": \"TS-RED-S\",\n        \"attribute\": \"Red, Small\",\n        \"stockQuantity\": 50\n      },\n      {\n        \"sku\": \"TS-BLUE-L\",\n        \"attribute\": \"Blue, Large\",\n        \"stockQuantity\": 30,\n        \"priceOverride\": 24.99\n      }\n    ]\n  }'",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "üìù Lesson Checkpoint Quiz",
              "content": "\n### Question 1\nWhat does the @Serializable annotation do?\n\nA) Makes the class thread-safe\nB) Generates code to convert the class to/from JSON at compile time\nC) Validates that all fields are non-null\nD) Encrypts the data before sending\n\n---\n\n### Question 2\nWhy would you use @SerialName(\"user_name\") on a field?\n\nA) To make the field required in JSON\nB) To map a different JSON field name to your Kotlin property\nC) To make the field private\nD) To change the field type\n\n---\n\n### Question 3\nWhat happens if you try to deserialize JSON with an unknown field and `ignoreUnknownKeys = false`?\n\nA) The field is silently ignored\nB) A SerializationException is thrown\nC) The field is stored as a String\nD) The entire object becomes null\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "üéØ Why This Matters",
              "content": "\nJSON serialization is the **universal translator** of web APIs. Every major API you use (GitHub, Stripe, Twitter) sends and receives JSON.\n\n### What You've Mastered\n\n‚úÖ **Automatic serialization** with @Serializable\n‚úÖ **Custom field names** with @SerialName\n‚úÖ **Nullable and optional fields** with defaults\n‚úÖ **Custom serializers** for types like LocalDateTime\n‚úÖ **Enum serialization** for type-safe status codes\n‚úÖ **Error handling** for malformed JSON\n‚úÖ **JSON configuration** for different output formats\n\n### Real-World Applications\n\n- **Mobile apps** send JSON to your API\n- **Frontend JavaScript** communicates via JSON\n- **Third-party integrations** expect JSON\n- **Database exports** often use JSON\n- **Configuration files** use JSON\n\n---\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "üìö Key Takeaways",
              "content": "\n‚úÖ **@Serializable** makes a class convertible to/from JSON\n‚úÖ **Only primary constructor properties** are serialized\n‚úÖ **@SerialName** maps different JSON field names\n‚úÖ **Nullable types** (String?) allow missing fields\n‚úÖ **Default values** make fields optional in JSON\n‚úÖ **Custom serializers** handle special types (dates, custom formats)\n‚úÖ **SerializationException** catches JSON errors\n‚úÖ **Json { }** configuration controls output format\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "üîú Next Steps",
              "content": "\nIn **Lesson 5.6**, you'll learn:\n- Database fundamentals (why in-memory storage isn't enough)\n- SQL basics for backend developers\n- Setting up Exposed (Kotlin SQL library)\n- Creating database tables\n- Basic queries (INSERT, SELECT)\n- Connecting your API to a real database\n\n---\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "‚úèÔ∏è Quiz Answer Key",
              "content": "\n**Question 1**: **B) Generates code to convert the class to/from JSON at compile time**\n\nExplanation: @Serializable is a compile-time annotation that generates serializer code. The magic of `call.receive<Book>()` works because the serializer was generated at compile time.\n\n---\n\n**Question 2**: **B) To map a different JSON field name to your Kotlin property**\n\nExplanation: @SerialName allows the JSON field name to differ from your Kotlin property name. Common when working with APIs that use snake_case while Kotlin uses camelCase.\n\n---\n\n**Question 3**: **B) A SerializationException is thrown**\n\nExplanation: By default (ignoreUnknownKeys = false), extra fields cause an error. Set `ignoreUnknownKeys = true` in your JSON configuration to silently ignore them.\n\n---\n\n**Congratulations!** You now have complete control over JSON serialization in your Ktor API! üéâ\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "5.6",
          "title": "Lesson 5.6: Database Fundamentals with Exposed - Part 1 (Setup & Queries)",
          "moduleId": "module-05",
          "order": 12,
          "estimatedMinutes": 45,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 45 minutes\n**Difficulty**: Intermediate\n**Prerequisites**: Lessons 5.1-5.5 (HTTP, Ktor, routing, JSON)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "üìñ Topic Introduction",
              "content": "\nSo far, all your data has been stored in memory. When your server restarts, **everything disappears**. That's not acceptable for real applications!\n\nIn this lesson, you'll learn:\n- Why databases are essential\n- SQL basics for backend developers\n- Setting up Exposed (Kotlin's SQL library)\n- Creating database tables\n- Basic queries: INSERT and SELECT\n- Connecting your Ktor API to a real database\n\nBy the end, your API will persist data across server restarts!\n\n---\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "üí° The Concept: Why Databases?",
              "content": "\n### The Filing Cabinet Analogy\n\n**In-Memory Storage** = Writing notes on sticky notes and leaving them on your desk\n- ‚ùå Disappears when you clean your desk (restart server)\n- ‚ùå Can't handle millions of notes (runs out of RAM)\n- ‚ùå Lost forever if the desk catches fire (server crash)\n\n**Database Storage** = Filing cabinet with organized folders\n- ‚úÖ Survives desk cleaning (persists across restarts)\n- ‚úÖ Can store millions of documents (scales beyond RAM)\n- ‚úÖ Can be backed up (disaster recovery)\n- ‚úÖ Multiple people can access simultaneously (concurrent access)\n\n### What Is a Database?\n\nA **database** is software designed specifically for storing, organizing, and retrieving data efficiently.\n\n**Types of databases:**\n1. **Relational (SQL)**: PostgreSQL, MySQL, SQLite, H2\n   - Data stored in tables with rows and columns\n   - Relationships between tables\n   - Strong consistency guarantees\n\n2. **NoSQL**: MongoDB, Redis, Cassandra\n   - Various data models (documents, key-value, etc.)\n   - Often more flexible but less structured\n\nFor this course, we'll use **H2** (a lightweight SQL database perfect for learning).\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "üìä SQL Basics: Tables, Rows, and Columns",
              "content": "\n### The Spreadsheet Analogy\n\nA SQL table is like a spreadsheet:\n\n**Books Table:**\n\n- **Table**: Like a sheet in your spreadsheet (e.g., \"Books\")\n- **Columns**: The headers (id, title, author, year)\n- **Rows**: Each entry/record\n- **Primary Key**: Unique identifier (usually `id`)\n\n### SQL Commands You'll Use\n\n\nDon't worry‚Äîyou won't write SQL directly. Exposed does it for you!\n\n---\n\n",
              "code": "-- Create a table\nCREATE TABLE books (\n    id INT PRIMARY KEY,\n    title VARCHAR(255),\n    author VARCHAR(255),\n    year INT\n);\n\n-- Insert data\nINSERT INTO books (id, title, author, year)\nVALUES (1, '1984', 'George Orwell', 1949);\n\n-- Query data\nSELECT * FROM books;\nSELECT * FROM books WHERE year > 1940;\nSELECT * FROM books WHERE author = 'George Orwell';\n\n-- Update data\nUPDATE books SET year = 1950 WHERE id = 1;\n\n-- Delete data\nDELETE FROM books WHERE id = 1;",
              "language": "sql"
            },
            {
              "type": "THEORY",
              "title": "üõ†Ô∏è Setting Up Exposed",
              "content": "\n### Step 1: Add Dependencies\n\nUpdate your `build.gradle.kts`:\n\n\n**What each dependency does:**\n- **exposed-core**: Core Exposed functionality\n- **exposed-jdbc**: JDBC integration (standard Java database API)\n- **exposed-dao**: DAO (Data Access Object) pattern support\n- **h2**: The actual database engine\n- **HikariCP**: Manages database connection pool (reuses connections efficiently)\n\n### Step 2: Create Database Configuration\n\nCreate `src/main/kotlin/com/example/database/DatabaseFactory.kt`:\n\n\n**Understanding the configuration:**\n\n- **jdbc:h2**: Using H2 database\n- **mem:test**: In-memory database named \"test\"\n- **DB_CLOSE_DELAY=-1**: Keep database open even when no connections\n\n- Connection pool: Reuses up to 3 database connections\n- More efficient than creating a new connection for every request\n\n---\n\n",
              "code": "maximumPoolSize = 3",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "üóÇÔ∏è Defining Tables with Exposed",
              "content": "\n### Creating Your First Table\n\nCreate `src/main/kotlin/com/example/database/tables/Books.kt`:\n\n\n**Breaking this down:**\n\n- **object**: Singleton (only one instance exists)\n- **Table()**: Exposed's base class for defining tables\n\n- **integer(\"id\")**: Column named \"id\" storing integers\n- **autoIncrement()**: Database automatically generates IDs (1, 2, 3, ...)\n\n- **varchar**: Variable-length string\n- **255**: Maximum length\n\n- **nullable()**: This column can be NULL (optional field)\n\n- Defines `id` as the primary key (unique identifier)\n\n### Column Types Reference\n\n\n---\n\n",
              "code": "// Numbers\nval intColumn = integer(\"int_col\")\nval longColumn = long(\"long_col\")\nval floatColumn = float(\"float_col\")\nval doubleColumn = double(\"double_col\")\nval decimalColumn = decimal(\"price\", 10, 2)  // 10 digits, 2 decimal places\n\n// Text\nval stringColumn = varchar(\"name\", 100)\nval textColumn = text(\"description\")  // Unlimited length\n\n// Boolean\nval boolColumn = bool(\"active\")\n\n// Date/Time\nval dateColumn = datetime(\"created_at\")\n\n// Special\nval enumColumn = enumeration<Status>(\"status\")\nval blobColumn = blob(\"image\")  // Binary data",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "üíª Basic Database Operations",
              "content": "\n### Inserting Data\n\nCreate `src/main/kotlin/com/example/database/dao/BookDao.kt`:\n\n\n**Understanding the INSERT:**\n\n\n- **transaction { }**: All database operations must be in a transaction\n- **Books.insert { }**: DSL for SQL INSERT\n- **it[column] = value**: Set column values\n- **[Books.id]**: Extract the auto-generated ID\n\n**Behind the scenes SQL:**\n\n### Querying Data\n\n\n**Mapping to Kotlin objects:**\n\n\n---\n\n",
              "code": "Books.selectAll().map { row ->\n    Book(\n        id = row[Books.id],\n        title = row[Books.title],\n        author = row[Books.author],\n        year = row[Books.year],\n        isbn = row[Books.isbn]\n    )\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "üîå Integrating with Ktor Routes",
              "content": "\n### Initialize Database on Startup\n\nUpdate `src/main/kotlin/com/example/Application.kt`:\n\n\n### Update Routes to Use Database\n\nUpdate `src/main/kotlin/com/example/plugins/Routing.kt`:\n\n\n---\n\n",
              "code": "package com.example.plugins\n\nimport com.example.database.dao.BookDao\nimport com.example.models.*\nimport io.ktor.http.*\nimport io.ktor.server.application.*\nimport io.ktor.server.request.*\nimport io.ktor.server.response.*\nimport io.ktor.server.routing.*\n\nfun Application.configureRouting() {\n    routing {\n        route(\"/api/books\") {\n            // Get all books\n            get {\n                val books = BookDao.getAll()\n                call.respond(ApiResponse(success = true, data = books))\n            }\n\n            // Get book by ID\n            get(\"/{id}\") {\n                val id = call.parameters[\"id\"]?.toIntOrNull()\n                    ?: return@get call.respond(\n                        HttpStatusCode.BadRequest,\n                        ApiResponse<Book>(success = false, message = \"Invalid ID\")\n                    )\n\n                val book = BookDao.getById(id)\n                if (book == null) {\n                    call.respond(\n                        HttpStatusCode.NotFound,\n                        ApiResponse<Book>(success = false, message = \"Book not found\")\n                    )\n                } else {\n                    call.respond(ApiResponse(success = true, data = book))\n                }\n            }\n\n            // Create book\n            post {\n                try {\n                    val request = call.receive<CreateBookRequest>()\n\n                    // Validate\n                    if (request.title.isBlank() || request.author.isBlank()) {\n                        call.respond(\n                            HttpStatusCode.BadRequest,\n                            ApiResponse<Book>(\n                                success = false,\n                                message = \"Title and author required\"\n                            )\n                        )\n                        return@post\n                    }\n\n                    // Create book object (no ID yet)\n                    val book = Book(\n                        id = 0,  // Will be assigned by database\n                        title = request.title,\n                        author = request.author,\n                        year = request.year,\n                        isbn = request.isbn\n                    )\n\n                    // Insert and get generated ID\n                    val generatedId = BookDao.insert(book)\n\n                    // Fetch the created book\n                    val createdBook = BookDao.getById(generatedId)\n\n                    call.respond(\n                        HttpStatusCode.Created,\n                        ApiResponse(\n                            success = true,\n                            data = createdBook,\n                            message = \"Book created successfully\"\n                        )\n                    )\n                } catch (e: Exception) {\n                    call.respond(\n                        HttpStatusCode.InternalServerError,\n                        ApiResponse<Book>(\n                            success = false,\n                            message = \"Error creating book: ${e.message}\"\n                        )\n                    )\n                }\n            }\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "üß™ Testing Your Database-Backed API",
              "content": "\n### Start the Server\n\n\nYou should see SQL logging:\n\n### Test Creating a Book\n\n\n**Response:**\n\n### Test Getting All Books\n\n\n### Restart the Server\n\n**Problem with in-memory database:**\n- Stop the server (Ctrl+C)\n- Start it again\n- Query books again: **They're gone!**\n\n**Solution (for next lesson):**\nChange to persistent storage:\n\n---\n\n",
              "code": "jdbcUrl = \"jdbc:h2:file:./data/mydb\"",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "üîç Understanding Transactions",
              "content": "\n### What Is a Transaction?\n\nA **transaction** is an \"all-or-nothing\" unit of work:\n\n**The Bank Transfer Analogy:**\n\n**If anything fails:**\n- ‚ùå Step 1 succeeds, Step 2 fails ‚Üí **Rollback** (Alice gets money back)\n- ‚úÖ Both succeed ‚Üí **Commit** (changes saved)\n\n**ACID Properties:**\n- **Atomicity**: All or nothing\n- **Consistency**: Database stays valid\n- **Isolation**: Transactions don't interfere\n- **Durability**: Committed data is saved permanently\n\n### Using Transactions in Exposed\n\n\n---\n\n",
              "code": "// All queries must be in a transaction\ntransaction {\n    val books = Books.selectAll().toList()\n    Books.insert { /* ... */ }\n}\n\n// Transactions can return values\nval bookId: Int = transaction {\n    Books.insert { /* ... */ }[Books.id]\n}\n\n// Nested transactions\ntransaction {\n    val id = transaction {\n        Books.insert { /* ... */ }[Books.id]\n    }\n    Users.insert { it[favoriteBookId] = id }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "üéØ Exercise: Add Users Table",
              "content": "\nCreate a Users table and connect it to books (authors).\n\n### Requirements\n\n1. Create a **Users** table with:\n   - id (auto-increment primary key)\n   - username (unique, not null)\n   - email (unique, not null)\n   - createdAt (timestamp)\n\n2. Create **UserDao** with methods:\n   - `insert(user)`\n   - `getAll()`\n   - `getById(id)`\n   - `getByUsername(username)`\n\n3. Add routes:\n   - `POST /api/users` - Create user\n   - `GET /api/users` - Get all users\n   - `GET /api/users/{id}` - Get user by ID\n\n### Starter Code\n\n\n---\n\n",
              "code": "// Define the table\nobject Users : Table() {\n    // TODO: Add columns\n}\n\n// Define the model\n@Serializable\ndata class User(\n    val id: Int,\n    val username: String,\n    val email: String,\n    val createdAt: String\n)\n\n// TODO: Create UserDao\n// TODO: Create routes",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "‚úÖ Solution & Explanation",
              "content": "\n\n**Key features:**\n- **uniqueIndex()**: Ensures no duplicate usernames/emails\n- **datetime()**: Stores timestamp\n- **clientDefault { }**: Default value generated by Kotlin code\n\n\n\n\n### Testing\n\n\n---\n\n",
              "code": "# Create a user\ncurl -X POST http://localhost:8080/api/users \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"username\": \"alice\", \"email\": \"alice@example.com\"}'\n\n# Get all users\ncurl http://localhost:8080/api/users\n\n# Try duplicate username (should fail)\ncurl -X POST http://localhost:8080/api/users \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"username\": \"alice\", \"email\": \"different@example.com\"}'",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "üìù Lesson Checkpoint Quiz",
              "content": "\n### Question 1\nWhat happens to data stored in an H2 in-memory database when you restart your server?\n\nA) It's automatically backed up to disk\nB) It's completely lost\nC) It's cached in RAM for 24 hours\nD) It's saved to a temporary file\n\n---\n\n### Question 2\nWhat does the `autoIncrement()` modifier do on an integer column?\n\nA) Increases the column size automatically\nB) Automatically generates unique sequential IDs for new rows\nC) Makes the column optional\nD) Speeds up queries on that column\n\n---\n\n### Question 3\nWhy do all database operations in Exposed need to be inside a `transaction { }` block?\n\nA) For syntax highlighting\nB) To ensure all-or-nothing execution and maintain data consistency\nC) To make the code run faster\nD) To enable SQL logging\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "üéØ Why This Matters",
              "content": "\nYou just crossed a **massive milestone**: your API now persists data! This is what separates toys from production systems.\n\n### What You've Achieved\n\n‚úÖ **Persistent storage**: Data survives server restarts\n‚úÖ **Type-safe SQL**: Compile-time checking (no SQL injection risks)\n‚úÖ **Clean architecture**: Separation of database code (DAO) from routes\n‚úÖ **Transaction safety**: All-or-nothing guarantees\n‚úÖ **Production-ready pattern**: Used by real companies\n\n### Real-World Context\n\nEvery app you use stores data in databases:\n- **Twitter**: Tweets, users, likes ‚Üí PostgreSQL\n- **Instagram**: Photos, comments ‚Üí PostgreSQL + Cassandra\n- **Netflix**: User preferences ‚Üí MySQL\n- **Uber**: Rides, locations ‚Üí MySQL + Redis\n\n---\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "üìö Key Takeaways",
              "content": "\n‚úÖ **Databases** provide persistent storage that survives restarts\n‚úÖ **Exposed** is Kotlin's type-safe SQL library\n‚úÖ **Tables** are defined as `object TableName : Table()`\n‚úÖ **Columns** use methods like `integer()`, `varchar()`, `nullable()`\n‚úÖ **Transactions** ensure all-or-nothing execution\n‚úÖ **DAO pattern** separates database logic from routes\n‚úÖ **H2** is perfect for learning (in-memory or file-based)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "üîú Next Steps",
              "content": "\nIn **Lesson 5.7**, you'll learn:\n- UPDATE and DELETE operations\n- Complex queries (joins, filters, sorting)\n- One-to-many relationships\n- Database migrations\n- Batch operations\n- Query optimization\n\n---\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "‚úèÔ∏è Quiz Answer Key",
              "content": "\n**Question 1**: **B) It's completely lost**\n\nExplanation: In-memory databases (jdbc:h2:mem:) store everything in RAM. When the process ends, all data is lost. For persistence, use file-based storage (jdbc:h2:file:./data/mydb).\n\n---\n\n**Question 2**: **B) Automatically generates unique sequential IDs for new rows**\n\nExplanation: autoIncrement() tells the database to automatically assign incrementing IDs (1, 2, 3, ...) when you insert new rows, removing the need to manually specify IDs.\n\n---\n\n**Question 3**: **B) To ensure all-or-nothing execution and maintain data consistency**\n\nExplanation: Transactions provide ACID guarantees. If any operation fails, all changes are rolled back, preventing partial updates that could corrupt your data.\n\n---\n\n**Congratulations!** You've connected your API to a real database! Your apps can now remember things! üéâ\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "5.7",
          "title": "Lesson 5.7: Database Operations with Exposed - Part 2 (CRUD & Transactions)",
          "moduleId": "module-05",
          "order": 13,
          "estimatedMinutes": 45,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 45 minutes\n**Difficulty**: Intermediate\n**Prerequisites**: Lesson 5.6 (Database fundamentals, INSERT, SELECT)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "üìñ Topic Introduction",
              "content": "\nIn the previous lesson, you learned to INSERT and SELECT data. Now it's time to complete the CRUD operations: **UPDATE** and **DELETE**.\n\nBut that's not all! You'll also learn:\n- Complex WHERE clauses with multiple conditions\n- Table relationships (foreign keys)\n- JOIN queries to combine data from multiple tables\n- Batch operations for performance\n- Database migrations\n\nBy the end, you'll be able to build complex, production-ready database schemas!\n\n---\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "üí° The Concept: Completing CRUD",
              "content": "\n### The Four Pillars of Data Management\n\n**C**reate - INSERT ‚úÖ (learned in 5.6)\n**R**ead - SELECT ‚úÖ (learned in 5.6)\n**U**pdate - UPDATE üìù (this lesson)\n**D**elete - DELETE üóëÔ∏è (this lesson)\n\n### Real-World Analogy\n\nThink of your database like a filing cabinet:\n\n- **INSERT**: Add a new document to a folder\n- **SELECT**: Find and read documents\n- **UPDATE**: Take out a document, cross out old info, write new info\n- **DELETE**: Remove and shred a document\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "üîÑ UPDATE Operations",
              "content": "\n### Basic Update\n\n\n**Understanding the syntax:**\n\n\n- **update({ condition })**: WHERE clause\n- **it[column] = value**: SET clause\n- Returns the number of rows updated\n\n**Behind the scenes SQL:**\n\n### Conditional Updates\n\n\n### Partial Updates (Only Changed Fields)\n\n\n**This is powerful for PATCH endpoints** where clients only send changed fields!\n\n---\n\n",
              "code": "data class UpdateBookRequest(\n    val title: String? = null,\n    val author: String? = null,\n    val year: Int? = null,\n    val isbn: String? = null\n)\n\nfun partialUpdate(id: Int, request: UpdateBookRequest): Boolean = transaction {\n    // Build update dynamically based on what's provided\n    val updateCount = Books.update({ Books.id eq id }) {\n        request.title?.let { newTitle -> it[Books.title] = newTitle }\n        request.author?.let { newAuthor -> it[Books.author] = newAuthor }\n        request.year?.let { newYear -> it[Books.year] = newYear }\n        request.isbn?.let { newIsbn -> it[Books.isbn] = newIsbn }\n    }\n    updateCount > 0\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "üóëÔ∏è DELETE Operations",
              "content": "\n### Basic Delete\n\n\n**SQL equivalent:**\n\n### Conditional Deletes\n\n\n### Delete All (Dangerous!)\n\n\n‚ö†Ô∏è **Warning**: Always use WHERE clauses unless you really want to delete everything!\n\n---\n\n",
              "code": "// Delete all records (use with caution!)\nfun deleteAll(): Int = transaction {\n    Books.deleteAll()\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "üîç Complex WHERE Clauses",
              "content": "\n### Comparison Operators\n\n\n### Logical Operators\n\n\n### String Operations\n\n\n### IN Operator\n\n\n### NULL Checks\n\n\n---\n\n",
              "code": "// IS NULL\nBooks.selectAll().where {\n    Books.isbn.isNull()\n}\n\n// IS NOT NULL\nBooks.selectAll().where {\n    Books.isbn.isNotNull()\n}",
              "language": "kotlin"
            },
            {
              "type": "KEY_POINT",
              "title": "üîó Table Relationships: Foreign Keys",
              "content": "\n### One-to-Many Relationship Example\n\nLet's model books and reviews (one book can have many reviews):\n\n\n**Key concept:**\n- Creates a **foreign key** linking `Reviews.bookId` to `Books.id`\n- Ensures referential integrity (can't review a non-existent book)\n\n### Creating Tables with Relationships\n\n\n**Important**: Create parent table (Books) before child table (Reviews).\n\n---\n\n",
              "code": "// In DatabaseFactory.init()\ntransaction(database) {\n    SchemaUtils.create(Books, Reviews)  // Order matters!\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "üîÄ JOIN Queries",
              "content": "\n### Inner Join\n\nGet books with their reviews:\n\n\n**SQL equivalent:**\n\n### Left Join\n\nGet all books, even those without reviews:\n\n\n### Simplified: Get Reviews for Specific Book\n\n\n---\n\n",
              "code": "fun getReviewsForBook(bookId: Int): List<Review> = transaction {\n    Reviews.selectAll()\n        .where { Reviews.bookId eq bookId }\n        .map { rowToReview(it) }\n}\n\n// Or with aggregation\nfun getAverageRating(bookId: Int): Double? = transaction {\n    Reviews.select(Reviews.rating.avg())\n        .where { Reviews.bookId eq bookId }\n        .singleOrNull()\n        ?.get(Reviews.rating.avg())\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "üì¶ Batch Operations",
              "content": "\n### Batch Insert\n\nInserting many records efficiently:\n\n\n**Why batch operations?**\n- ‚úÖ Much faster for large datasets\n- ‚úÖ Single database round-trip\n- ‚úÖ Better transaction handling\n\n### Batch Update\n\n\n---\n\n",
              "code": "fun updateBatch(updates: Map<Int, String>): Unit = transaction {\n    updates.forEach { (id, newTitle) ->\n        Books.update({ Books.id eq id }) {\n            it[title] = newTitle\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "EXAMPLE",
              "title": "üíª Complete Example: Book Review System",
              "content": "\nLet's build a complete system with relationships:\n\n### Models\n\n\n### Enhanced BookDao with Statistics\n\n\n### ReviewDao\n\n\n### Routes\n\n\n### Testing\n\n\n---\n\n",
              "code": "# Create a review\ncurl -X POST http://localhost:8080/api/books/1/reviews \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"reviewerName\": \"Alice\",\n    \"rating\": 5,\n    \"comment\": \"Absolutely brilliant dystopian novel!\"\n  }'\n\n# Get all reviews for a book\ncurl http://localhost:8080/api/books/1/reviews\n\n# Get book with statistics\ncurl http://localhost:8080/api/books/1\n\n# Delete a review\ncurl -X DELETE http://localhost:8080/api/books/1/reviews/1",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "üéØ Exercise: Comment System",
              "content": "\nAdd comments on reviews (nested relationship):\n\n### Requirements\n\n1. Create a **Comments** table:\n   - id, reviewId (foreign key to Reviews), commenterName, text, createdAt\n\n2. Implement **CommentDao**:\n   - insert, getByReviewId, delete\n\n3. Add routes:\n   - POST `/api/books/{bookId}/reviews/{reviewId}/comments`\n   - GET `/api/books/{bookId}/reviews/{reviewId}/comments`\n   - DELETE `/api/books/{bookId}/reviews/{reviewId}/comments/{commentId}`\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "‚úÖ Solution & Explanation",
              "content": "\n\n---\n\n",
              "code": "// Table definition\nobject Comments : Table() {\n    val id = integer(\"id\").autoIncrement()\n    val reviewId = integer(\"review_id\").references(Reviews.id)\n    val commenterName = varchar(\"commenter_name\", 100)\n    val text = text(\"text\")\n    val createdAt = datetime(\"created_at\")\n\n    override val primaryKey = PrimaryKey(id)\n}\n\n// Model\n@Serializable\ndata class Comment(\n    val id: Int,\n    val reviewId: Int,\n    val commenterName: String,\n    val text: String,\n    val createdAt: String\n)\n\n@Serializable\ndata class CreateCommentRequest(\n    val commenterName: String,\n    val text: String\n)\n\n// DAO\nobject CommentDao {\n    fun insert(reviewId: Int, request: CreateCommentRequest): Int = transaction {\n        Comments.insert {\n            it[Comments.reviewId] = reviewId\n            it[commenterName] = request.commenterName\n            it[text] = request.text\n            it[createdAt] = LocalDateTime.now()\n        }[Comments.id]\n    }\n\n    fun getByReviewId(reviewId: Int): List<Comment> = transaction {\n        Comments.selectAll()\n            .where { Comments.reviewId eq reviewId }\n            .orderBy(Comments.createdAt)\n            .map { rowToComment(it) }\n    }\n\n    fun delete(id: Int, reviewId: Int): Boolean = transaction {\n        Comments.deleteWhere {\n            (Comments.id eq id) and (Comments.reviewId eq reviewId)\n        } > 0\n    }\n\n    private fun rowToComment(row: ResultRow): Comment {\n        return Comment(\n            id = row[Comments.id],\n            reviewId = row[Comments.reviewId],\n            commenterName = row[Comments.commenterName],\n            text = row[Comments.text],\n            createdAt = row[Comments.createdAt].toString()\n        )\n    }\n}\n\n// Routes\nfun Route.commentRoutes() {\n    route(\"/api/books/{bookId}/reviews/{reviewId}/comments\") {\n        get {\n            val reviewId = call.parameters[\"reviewId\"]?.toIntOrNull()\n                ?: return@get call.respond(HttpStatusCode.BadRequest)\n\n            val comments = CommentDao.getByReviewId(reviewId)\n            call.respond(ApiResponse(success = true, data = comments))\n        }\n\n        post {\n            val reviewId = call.parameters[\"reviewId\"]?.toIntOrNull()\n                ?: return@post call.respond(HttpStatusCode.BadRequest)\n\n            val request = call.receive<CreateCommentRequest>()\n            val commentId = CommentDao.insert(reviewId, request)\n\n            call.respond(HttpStatusCode.Created)\n        }\n\n        delete(\"/{commentId}\") {\n            val reviewId = call.parameters[\"reviewId\"]?.toIntOrNull()\n                ?: return@delete call.respond(HttpStatusCode.BadRequest)\n            val commentId = call.parameters[\"commentId\"]?.toIntOrNull()\n                ?: return@delete call.respond(HttpStatusCode.BadRequest)\n\n            val deleted = CommentDao.delete(commentId, reviewId)\n            if (deleted) {\n                call.respond(HttpStatusCode.OK)\n            } else {\n                call.respond(HttpStatusCode.NotFound)\n            }\n        }\n    }\n}\n\n// Update DatabaseFactory\ntransaction(database) {\n    SchemaUtils.create(Books, Reviews, Comments)\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "üìù Lesson Checkpoint Quiz",
              "content": "\n### Question 1\nWhat does the following code do?\n\nA) Updates all books by incrementing their year by 1\nB) Updates only books published before 1950, incrementing their year by 1\nC) Deletes books from before 1950\nD) Selects books from before 1950\n\n---\n\n### Question 2\nWhat's the difference between `innerJoin` and `leftJoin`?\n\nA) There is no difference\nB) innerJoin only returns rows where both tables have matches; leftJoin returns all rows from the left table\nC) leftJoin is faster\nD) innerJoin supports more tables\n\n---\n\n### Question 3\nWhy use batch operations instead of individual inserts in a loop?\n\nA) They look better in code\nB) They're required by Exposed\nC) They're much faster and use fewer database connections\nD) They provide better error messages\n\n---\n\n",
              "code": "Books.update({ Books.year less 1950 }) { it[year] = year + 1 }",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "üéØ Why This Matters",
              "content": "\nYou now have **complete control** over your database! These operations form the backbone of every backend application.\n\n### What You've Mastered\n\n‚úÖ **UPDATE**: Modify existing records\n‚úÖ **DELETE**: Remove records safely\n‚úÖ **Complex queries**: Multiple conditions, string matching, NULL checks\n‚úÖ **Relationships**: Foreign keys and referential integrity\n‚úÖ **JOINs**: Combine data from multiple tables\n‚úÖ **Batch operations**: Efficient bulk operations\n‚úÖ **Nested resources**: Books ‚Üí Reviews ‚Üí Comments\n\n### Real-World Applications\n\n- **E-commerce**: Products ‚Üí Reviews ‚Üí Questions\n- **Social media**: Posts ‚Üí Comments ‚Üí Reactions\n- **Forums**: Threads ‚Üí Posts ‚Üí Replies\n- **Blogs**: Articles ‚Üí Comments ‚Üí Likes\n\n---\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "üìö Key Takeaways",
              "content": "\n‚úÖ **UPDATE** modifies records: `Books.update({ condition }) { it[column] = value }`\n‚úÖ **DELETE** removes records: `Books.deleteWhere { condition }`\n‚úÖ **Foreign keys** link tables: `.references(OtherTable.id)`\n‚úÖ **JOINs** combine tables: `Books innerJoin Reviews`\n‚úÖ **Batch operations** improve performance for bulk operations\n‚úÖ **Transactions** ensure data consistency\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "üîú Next Steps",
              "content": "\nIn **Lesson 5.8**, you'll learn:\n- The Repository Pattern (organizing database code)\n- Dependency Injection basics\n- Service layer architecture\n- Separating concerns\n- Making code testable\n\n---\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "‚úèÔ∏è Quiz Answer Key",
              "content": "\n**Question 1**: **B) Updates only books published before 1950, incrementing their year by 1**\n\nExplanation: The WHERE clause `{ Books.year less 1950 }` filters to only books before 1950, then `year + 1` increments each one.\n\n---\n\n**Question 2**: **B) innerJoin only returns rows where both tables have matches; leftJoin returns all rows from the left table**\n\nExplanation: INNER JOIN requires matches in both tables. LEFT JOIN returns all left table rows, with NULL for unmatched right table columns.\n\n---\n\n**Question 3**: **C) They're much faster and use fewer database connections**\n\nExplanation: Batch operations send multiple records in a single database round-trip, dramatically improving performance compared to individual operations in a loop.\n\n---\n\n**Congratulations!** You now have complete CRUD mastery with Exposed! üéâ\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "5.8",
          "title": "Lesson 5.8: The Repository Pattern - Organizing Your Data Layer",
          "moduleId": "module-05",
          "order": 14,
          "estimatedMinutes": 50,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 50 minutes\n**Difficulty**: Intermediate\n**Prerequisites**: Lessons 5.6-5.7 (Database operations with Exposed)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "üìñ Topic Introduction",
              "content": "\nYour API is growing. You have routes calling database code directly. What happens when:\n- You need to switch from H2 to PostgreSQL?\n- You want to add caching?\n- You need to write tests without a real database?\n- Multiple routes need the same complex query?\n\nThe **Repository Pattern** solves these problems by creating a clean separation between your business logic and data access.\n\nIn this lesson, you'll learn:\n- What the Repository Pattern is and why it matters\n- Clean Architecture principles\n- Separating concerns: Routes ‚Üí Services ‚Üí Repositories\n- Making your code testable\n- Interface-based design\n- Real-world project structure\n\n---\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "üí° The Concept: What Is the Repository Pattern?",
              "content": "\n### The Librarian Analogy\n\nImagine you're at a library:\n\n**Without Repository Pattern** = You go into the back room, search through filing systems, understand the Dewey Decimal System, find the book yourself.\n- You need to know how the library organizes books\n- Every visitor needs this knowledge\n- Changing the organization system breaks everything\n\n**With Repository Pattern** = You ask the librarian: \"I need books about Kotlin.\"\n- Librarian knows how to find books (that's their job)\n- You don't care if books are organized by author, title, or year\n- Library can reorganize without affecting visitors\n\n### In Code Terms\n\n\n**Benefits:**\n- ‚úÖ Routes don't know about database details\n- ‚úÖ Easy to change database implementation\n- ‚úÖ Can test routes without a database\n- ‚úÖ Reusable data access logic\n\n---\n\n",
              "code": "// WITHOUT Repository Pattern (Bad!)\nfun Route.bookRoutes() {\n    get(\"/books\") {\n        // Routes directly access database\n        val books = transaction {\n            Books.selectAll().map { /* ... */ }\n        }\n        call.respond(books)\n    }\n}\n\n// WITH Repository Pattern (Good!)\nfun Route.bookRoutes() {\n    val bookRepository = BookRepository()\n\n    get(\"/books\") {\n        // Routes ask repository for data\n        val books = bookRepository.getAll()\n        call.respond(books)\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "üèóÔ∏è Clean Architecture Layers",
              "content": "\n### The Three-Layer Architecture\n\n\n### Dependency Flow\n\n**Key principle**: Outer layers depend on inner layers, never the reverse.\n\n\n---\n\n",
              "code": "Routes ‚Üí Services ‚Üí Repositories ‚Üí Database\n  ‚Üì         ‚Üì            ‚Üì\nHTTP    Business      Data\n        Logic       Storage",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "üìù Step 1: Define Repository Interfaces",
              "content": "\nCreate interfaces in the domain/service layer:\n\n\n**Why interfaces?**\n- ‚úÖ Defines what operations are available\n- ‚úÖ Routes depend on interface, not implementation\n- ‚úÖ Easy to create mock implementations for testing\n- ‚úÖ Can swap implementations (in-memory, SQL, NoSQL, etc.)\n\n---\n\n",
              "code": "// src/main/kotlin/com/example/repositories/BookRepository.kt\npackage com.example.repositories\n\nimport com.example.models.Book\n\ninterface BookRepository {\n    fun getAll(): List<Book>\n    fun getById(id: Int): Book?\n    fun insert(book: Book): Int\n    fun update(id: Int, book: Book): Boolean\n    fun delete(id: Int): Boolean\n    fun findByAuthor(author: String): List<Book>\n    fun search(query: String): List<Book>\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "üíª Step 2: Implement Repository",
              "content": "\n\n**Key points:**\n- All database logic is encapsulated\n- `transaction { }` calls are hidden from callers\n- Easy to understand: each method does one thing\n- Private helper method for mapping\n\n---\n\n",
              "code": "// src/main/kotlin/com/example/repositories/BookRepositoryImpl.kt\npackage com.example.repositories\n\nimport com.example.database.tables.Books\nimport com.example.models.Book\nimport org.jetbrains.exposed.sql.*\nimport org.jetbrains.exposed.sql.SqlExpressionBuilder.eq\nimport org.jetbrains.exposed.sql.transactions.transaction\n\nclass BookRepositoryImpl : BookRepository {\n\n    override fun getAll(): List<Book> = transaction {\n        Books.selectAll()\n            .orderBy(Books.title)\n            .map { rowToBook(it) }\n    }\n\n    override fun getById(id: Int): Book? = transaction {\n        Books.selectAll()\n            .where { Books.id eq id }\n            .map { rowToBook(it) }\n            .singleOrNull()\n    }\n\n    override fun insert(book: Book): Int = transaction {\n        Books.insert {\n            it[title] = book.title\n            it[author] = book.author\n            it[year] = book.year\n            it[isbn] = book.isbn\n        }[Books.id]\n    }\n\n    override fun update(id: Int, book: Book): Boolean = transaction {\n        Books.update({ Books.id eq id }) {\n            it[title] = book.title\n            it[author] = book.author\n            it[year] = book.year\n            it[isbn] = book.isbn\n        } > 0\n    }\n\n    override fun delete(id: Int): Boolean = transaction {\n        Books.deleteWhere { Books.id eq id } > 0\n    }\n\n    override fun findByAuthor(author: String): List<Book> = transaction {\n        Books.selectAll()\n            .where { Books.author eq author }\n            .map { rowToBook(it) }\n    }\n\n    override fun search(query: String): List<Book> = transaction {\n        Books.selectAll()\n            .where {\n                (Books.title like \"%$query%\") or\n                (Books.author like \"%$query%\")\n            }\n            .map { rowToBook(it) }\n    }\n\n    private fun rowToBook(row: ResultRow): Book {\n        return Book(\n            id = row[Books.id],\n            title = row[Books.title],\n            author = row[Books.author],\n            year = row[Books.year],\n            isbn = row[Books.isbn]\n        )\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "üéØ Step 3: Service Layer (Business Logic)",
              "content": "\nCreate a service that uses repositories:\n\n\n**Service layer responsibilities:**\n- ‚úÖ Business logic and validation\n- ‚úÖ Orchestrating multiple repositories\n- ‚úÖ Error handling\n- ‚úÖ Use cases (what the app does)\n\n---\n\n",
              "code": "// src/main/kotlin/com/example/services/BookService.kt\npackage com.example.services\n\nimport com.example.models.*\nimport com.example.repositories.BookRepository\n\nclass BookService(\n    private val bookRepository: BookRepository\n) {\n\n    fun getAllBooks(): List<Book> {\n        return bookRepository.getAll()\n    }\n\n    fun getBook(id: Int): Book? {\n        return bookRepository.getById(id)\n    }\n\n    fun createBook(request: CreateBookRequest): Result<Book> {\n        // Validation\n        if (request.title.isBlank()) {\n            return Result.failure(ValidationException(\"Title is required\"))\n        }\n\n        if (request.author.isBlank()) {\n            return Result.failure(ValidationException(\"Author is required\"))\n        }\n\n        // Check for duplicates\n        val existing = bookRepository.findByAuthor(request.author)\n            .find { it.title.equals(request.title, ignoreCase = true) }\n\n        if (existing != null) {\n            return Result.failure(DuplicateException(\"Book already exists\"))\n        }\n\n        // Create book\n        val book = Book(\n            id = 0,  // Will be assigned by database\n            title = request.title,\n            author = request.author,\n            year = request.year,\n            isbn = request.isbn\n        )\n\n        val id = bookRepository.insert(book)\n        val created = bookRepository.getById(id)\n            ?: return Result.failure(Exception(\"Failed to retrieve created book\"))\n\n        return Result.success(created)\n    }\n\n    fun updateBook(id: Int, request: UpdateBookRequest): Result<Book> {\n        // Check if exists\n        val existing = bookRepository.getById(id)\n            ?: return Result.failure(NotFoundException(\"Book not found\"))\n\n        // Build updated book\n        val updated = existing.copy(\n            title = request.title ?: existing.title,\n            author = request.author ?: existing.author,\n            year = request.year ?: existing.year,\n            isbn = request.isbn ?: existing.isbn\n        )\n\n        // Update in database\n        val success = bookRepository.update(id, updated)\n\n        return if (success) {\n            Result.success(updated)\n        } else {\n            Result.failure(Exception(\"Failed to update book\"))\n        }\n    }\n\n    fun deleteBook(id: Int): Result<Unit> {\n        val exists = bookRepository.getById(id) != null\n        if (!exists) {\n            return Result.failure(NotFoundException(\"Book not found\"))\n        }\n\n        val deleted = bookRepository.delete(id)\n\n        return if (deleted) {\n            Result.success(Unit)\n        } else {\n            Result.failure(Exception(\"Failed to delete book\"))\n        }\n    }\n\n    fun searchBooks(query: String): List<Book> {\n        if (query.isBlank()) {\n            return emptyList()\n        }\n        return bookRepository.search(query)\n    }\n}\n\n// Custom exceptions\nclass ValidationException(message: String) : Exception(message)\nclass NotFoundException(message: String) : Exception(message)\nclass DuplicateException(message: String) : Exception(message)",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "üåê Step 4: Updated Routes Using Services",
              "content": "\n\n**Notice:**\n- Routes are thin (no business logic!)\n- Just handle HTTP concerns (parameters, status codes, responses)\n- Call service methods\n- Map service errors to HTTP status codes\n\n---\n\n",
              "code": "// src/main/kotlin/com/example/plugins/Routing.kt\npackage com.example.plugins\n\nimport com.example.models.*\nimport com.example.services.*\nimport io.ktor.http.*\nimport io.ktor.server.application.*\nimport io.ktor.server.request.*\nimport io.ktor.server.response.*\nimport io.ktor.server.routing.*\n\nfun Application.configureRouting(\n    bookService: BookService\n) {\n    routing {\n        bookRoutes(bookService)\n    }\n}\n\nfun Route.bookRoutes(bookService: BookService) {\n    route(\"/api/books\") {\n        // Get all books\n        get {\n            val books = bookService.getAllBooks()\n            call.respond(ApiResponse(success = true, data = books))\n        }\n\n        // Get single book\n        get(\"/{id}\") {\n            val id = call.parameters[\"id\"]?.toIntOrNull()\n                ?: return@get call.respond(\n                    HttpStatusCode.BadRequest,\n                    ApiResponse<Book>(success = false, message = \"Invalid ID\")\n                )\n\n            val book = bookService.getBook(id)\n            if (book == null) {\n                call.respond(\n                    HttpStatusCode.NotFound,\n                    ApiResponse<Book>(success = false, message = \"Book not found\")\n                )\n            } else {\n                call.respond(ApiResponse(success = true, data = book))\n            }\n        }\n\n        // Create book\n        post {\n            try {\n                val request = call.receive<CreateBookRequest>()\n\n                bookService.createBook(request)\n                    .onSuccess { book ->\n                        call.respond(\n                            HttpStatusCode.Created,\n                            ApiResponse(success = true, data = book)\n                        )\n                    }\n                    .onFailure { error ->\n                        when (error) {\n                            is ValidationException -> call.respond(\n                                HttpStatusCode.BadRequest,\n                                ApiResponse<Book>(success = false, message = error.message)\n                            )\n                            is DuplicateException -> call.respond(\n                                HttpStatusCode.Conflict,\n                                ApiResponse<Book>(success = false, message = error.message)\n                            )\n                            else -> call.respond(\n                                HttpStatusCode.InternalServerError,\n                                ApiResponse<Book>(success = false, message = \"Server error\")\n                            )\n                        }\n                    }\n            } catch (e: Exception) {\n                call.respond(\n                    HttpStatusCode.BadRequest,\n                    ApiResponse<Book>(success = false, message = \"Invalid request\")\n                )\n            }\n        }\n\n        // Update book\n        put(\"/{id}\") {\n            val id = call.parameters[\"id\"]?.toIntOrNull()\n                ?: return@put call.respond(HttpStatusCode.BadRequest)\n\n            val request = call.receive<UpdateBookRequest>()\n\n            bookService.updateBook(id, request)\n                .onSuccess { book ->\n                    call.respond(ApiResponse(success = true, data = book))\n                }\n                .onFailure { error ->\n                    when (error) {\n                        is NotFoundException -> call.respond(HttpStatusCode.NotFound)\n                        else -> call.respond(HttpStatusCode.InternalServerError)\n                    }\n                }\n        }\n\n        // Delete book\n        delete(\"/{id}\") {\n            val id = call.parameters[\"id\"]?.toIntOrNull()\n                ?: return@delete call.respond(HttpStatusCode.BadRequest)\n\n            bookService.deleteBook(id)\n                .onSuccess {\n                    call.respond(\n                        HttpStatusCode.OK,\n                        ApiResponse<Unit>(success = true, message = \"Book deleted\")\n                    )\n                }\n                .onFailure { error ->\n                    when (error) {\n                        is NotFoundException -> call.respond(HttpStatusCode.NotFound)\n                        else -> call.respond(HttpStatusCode.InternalServerError)\n                    }\n                }\n        }\n\n        // Search\n        get(\"/search\") {\n            val query = call.request.queryParameters[\"q\"] ?: \"\"\n            val results = bookService.searchBooks(query)\n            call.respond(ApiResponse(success = true, data = results))\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "üîß Step 5: Dependency Injection (Manual)",
              "content": "\nWire everything together:\n\n\n**Dependency flow:**\n\n---\n\n",
              "code": "Database ‚Üí Repository ‚Üí Service ‚Üí Routes",
              "language": "kotlin"
            },
            {
              "type": "EXAMPLE",
              "title": "üß™ Making Code Testable",
              "content": "\n### Why This Architecture Enables Testing\n\n\n**Benefits of testable architecture:**\n- ‚úÖ No database needed for tests\n- ‚úÖ Fast execution (milliseconds)\n- ‚úÖ Reliable (no network/disk issues)\n- ‚úÖ Easy to simulate edge cases\n\n---\n\n",
              "code": "// src/test/kotlin/com/example/services/BookServiceTest.kt\npackage com.example.services\n\nimport com.example.models.*\nimport com.example.repositories.BookRepository\nimport kotlin.test.*\n\nclass BookServiceTest {\n\n    // Mock repository (no real database!)\n    class MockBookRepository : BookRepository {\n        private val books = mutableMapOf<Int, Book>()\n        private var nextId = 1\n\n        override fun getAll() = books.values.toList()\n        override fun getById(id: Int) = books[id]\n\n        override fun insert(book: Book): Int {\n            val id = nextId++\n            books[id] = book.copy(id = id)\n            return id\n        }\n\n        override fun update(id: Int, book: Book): Boolean {\n            if (id !in books) return false\n            books[id] = book.copy(id = id)\n            return true\n        }\n\n        override fun delete(id: Int) = books.remove(id) != null\n\n        override fun findByAuthor(author: String) =\n            books.values.filter { it.author == author }\n\n        override fun search(query: String) =\n            books.values.filter {\n                it.title.contains(query, ignoreCase = true) ||\n                it.author.contains(query, ignoreCase = true)\n            }\n    }\n\n    @Test\n    fun `create book with valid data should succeed`() {\n        val repository = MockBookRepository()\n        val service = BookService(repository)\n\n        val request = CreateBookRequest(\n            title = \"Test Book\",\n            author = \"Test Author\",\n            year = 2024\n        )\n\n        val result = service.createBook(request)\n\n        assertTrue(result.isSuccess)\n        assertEquals(\"Test Book\", result.getOrNull()?.title)\n    }\n\n    @Test\n    fun `create book with blank title should fail`() {\n        val repository = MockBookRepository()\n        val service = BookService(repository)\n\n        val request = CreateBookRequest(\n            title = \"\",\n            author = \"Test Author\",\n            year = 2024\n        )\n\n        val result = service.createBook(request)\n\n        assertTrue(result.isFailure)\n        assertTrue(result.exceptionOrNull() is ValidationException)\n    }\n\n    @Test\n    fun `delete non-existent book should fail`() {\n        val repository = MockBookRepository()\n        val service = BookService(repository)\n\n        val result = service.deleteBook(999)\n\n        assertTrue(result.isFailure)\n        assertTrue(result.exceptionOrNull() is NotFoundException)\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "üìÇ Complete Project Structure",
              "content": "\n\n---\n\n",
              "code": "src/main/kotlin/com/example/\n‚îú‚îÄ‚îÄ Application.kt                    # Entry point, DI setup\n‚îú‚îÄ‚îÄ database/\n‚îÇ   ‚îú‚îÄ‚îÄ DatabaseFactory.kt           # Database initialization\n‚îÇ   ‚îî‚îÄ‚îÄ tables/\n‚îÇ       ‚îú‚îÄ‚îÄ Books.kt                  # Table definitions\n‚îÇ       ‚îî‚îÄ‚îÄ Reviews.kt\n‚îú‚îÄ‚îÄ models/\n‚îÇ   ‚îú‚îÄ‚îÄ Book.kt                       # Domain models\n‚îÇ   ‚îú‚îÄ‚îÄ Review.kt\n‚îÇ   ‚îú‚îÄ‚îÄ Requests.kt                   # API request models\n‚îÇ   ‚îî‚îÄ‚îÄ Responses.kt                  # API response models\n‚îú‚îÄ‚îÄ repositories/\n‚îÇ   ‚îú‚îÄ‚îÄ BookRepository.kt             # Interface\n‚îÇ   ‚îú‚îÄ‚îÄ BookRepositoryImpl.kt         # Implementation\n‚îÇ   ‚îú‚îÄ‚îÄ ReviewRepository.kt\n‚îÇ   ‚îî‚îÄ‚îÄ ReviewRepositoryImpl.kt\n‚îú‚îÄ‚îÄ services/\n‚îÇ   ‚îú‚îÄ‚îÄ BookService.kt                # Business logic\n‚îÇ   ‚îú‚îÄ‚îÄ ReviewService.kt\n‚îÇ   ‚îî‚îÄ‚îÄ Exceptions.kt                 # Custom exceptions\n‚îî‚îÄ‚îÄ plugins/\n    ‚îú‚îÄ‚îÄ Routing.kt                    # HTTP routes\n    ‚îî‚îÄ‚îÄ Serialization.kt              # JSON config",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "üéØ Exercise: Implement User Repository & Service",
              "content": "\nCreate a complete User system with the repository pattern:\n\n### Requirements\n\n1. **UserRepository interface** with:\n   - getAll, getById, getByUsername, getByEmail\n   - insert, update, delete\n   - search(query)\n\n2. **UserRepositoryImpl** with Exposed\n\n3. **UserService** with:\n   - Business logic: username must be unique, email must be valid\n   - Password requirements (min 8 chars)\n   - createUser, updateUser, deleteUser, searchUsers\n\n4. **Routes** using the service\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "‚úÖ Solution & Explanation",
              "content": "\n\n---\n\n",
              "code": "// Repository Interface\ninterface UserRepository {\n    fun getAll(): List<User>\n    fun getById(id: Int): User?\n    fun getByUsername(username: String): User?\n    fun getByEmail(email: String): User?\n    fun insert(user: User): Int\n    fun update(id: Int, user: User): Boolean\n    fun delete(id: Int): Boolean\n    fun search(query: String): List<User>\n}\n\n// Repository Implementation\nclass UserRepositoryImpl : UserRepository {\n    override fun getAll(): List<User> = transaction {\n        Users.selectAll()\n            .orderBy(Users.username)\n            .map { rowToUser(it) }\n    }\n\n    override fun getById(id: Int): User? = transaction {\n        Users.selectAll()\n            .where { Users.id eq id }\n            .map { rowToUser(it) }\n            .singleOrNull()\n    }\n\n    override fun getByUsername(username: String): User? = transaction {\n        Users.selectAll()\n            .where { Users.username eq username }\n            .map { rowToUser(it) }\n            .singleOrNull()\n    }\n\n    override fun getByEmail(email: String): User? = transaction {\n        Users.selectAll()\n            .where { Users.email eq email }\n            .map { rowToUser(it) }\n            .singleOrNull()\n    }\n\n    override fun insert(user: User): Int = transaction {\n        Users.insert {\n            it[username] = user.username\n            it[email] = user.email\n            it[passwordHash] = user.passwordHash\n            it[createdAt] = LocalDateTime.now()\n        }[Users.id]\n    }\n\n    override fun update(id: Int, user: User): Boolean = transaction {\n        Users.update({ Users.id eq id }) {\n            it[email] = user.email\n            it[passwordHash] = user.passwordHash\n        } > 0\n    }\n\n    override fun delete(id: Int): Boolean = transaction {\n        Users.deleteWhere { Users.id eq id } > 0\n    }\n\n    override fun search(query: String): List<User> = transaction {\n        Users.selectAll()\n            .where {\n                (Users.username like \"%$query%\") or\n                (Users.email like \"%$query%\")\n            }\n            .map { rowToUser(it) }\n    }\n\n    private fun rowToUser(row: ResultRow): User {\n        return User(\n            id = row[Users.id],\n            username = row[Users.username],\n            email = row[Users.email],\n            passwordHash = row[Users.passwordHash],\n            createdAt = row[Users.createdAt].toString()\n        )\n    }\n}\n\n// Service\nclass UserService(\n    private val userRepository: UserRepository\n) {\n\n    fun createUser(request: CreateUserRequest): Result<User> {\n        // Validate username\n        if (request.username.length < 3) {\n            return Result.failure(ValidationException(\"Username must be at least 3 characters\"))\n        }\n\n        // Validate email\n        if (!request.email.contains(\"@\")) {\n            return Result.failure(ValidationException(\"Invalid email address\"))\n        }\n\n        // Validate password\n        if (request.password.length < 8) {\n            return Result.failure(ValidationException(\"Password must be at least 8 characters\"))\n        }\n\n        // Check for duplicates\n        if (userRepository.getByUsername(request.username) != null) {\n            return Result.failure(DuplicateException(\"Username already exists\"))\n        }\n\n        if (userRepository.getByEmail(request.email) != null) {\n            return Result.failure(DuplicateException(\"Email already exists\"))\n        }\n\n        // Hash password (simplified - use BCrypt in production!)\n        val passwordHash = request.password.hashCode().toString()\n\n        val user = User(\n            id = 0,\n            username = request.username,\n            email = request.email,\n            passwordHash = passwordHash,\n            createdAt = \"\"\n        )\n\n        val id = userRepository.insert(user)\n        val created = userRepository.getById(id)\n            ?: return Result.failure(Exception(\"Failed to create user\"))\n\n        return Result.success(created)\n    }\n\n    fun getAllUsers(): List<User> {\n        return userRepository.getAll()\n    }\n\n    fun getUser(id: Int): User? {\n        return userRepository.getById(id)\n    }\n\n    fun deleteUser(id: Int): Result<Unit> {\n        if (userRepository.getById(id) == null) {\n            return Result.failure(NotFoundException(\"User not found\"))\n        }\n\n        val deleted = userRepository.delete(id)\n        return if (deleted) {\n            Result.success(Unit)\n        } else {\n            Result.failure(Exception(\"Failed to delete user\"))\n        }\n    }\n}\n\n// Routes\nfun Route.userRoutes(userService: UserService) {\n    route(\"/api/users\") {\n        get {\n            val users = userService.getAllUsers()\n            call.respond(ApiResponse(success = true, data = users))\n        }\n\n        get(\"/{id}\") {\n            val id = call.parameters[\"id\"]?.toIntOrNull()\n                ?: return@get call.respond(HttpStatusCode.BadRequest)\n\n            val user = userService.getUser(id)\n            if (user == null) {\n                call.respond(HttpStatusCode.NotFound)\n            } else {\n                call.respond(ApiResponse(success = true, data = user))\n            }\n        }\n\n        post {\n            val request = call.receive<CreateUserRequest>()\n\n            userService.createUser(request)\n                .onSuccess { user ->\n                    call.respond(\n                        HttpStatusCode.Created,\n                        ApiResponse(success = true, data = user)\n                    )\n                }\n                .onFailure { error ->\n                    when (error) {\n                        is ValidationException -> call.respond(\n                            HttpStatusCode.BadRequest,\n                            ApiResponse<User>(success = false, message = error.message)\n                        )\n                        is DuplicateException -> call.respond(\n                            HttpStatusCode.Conflict,\n                            ApiResponse<User>(success = false, message = error.message)\n                        )\n                        else -> call.respond(HttpStatusCode.InternalServerError)\n                    }\n                }\n        }\n\n        delete(\"/{id}\") {\n            val id = call.parameters[\"id\"]?.toIntOrNull()\n                ?: return@delete call.respond(HttpStatusCode.BadRequest)\n\n            userService.deleteUser(id)\n                .onSuccess { call.respond(HttpStatusCode.OK) }\n                .onFailure { call.respond(HttpStatusCode.NotFound) }\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "üìù Lesson Checkpoint Quiz",
              "content": "\n### Question 1\nWhat is the main purpose of the Repository Pattern?\n\nA) To make code run faster\nB) To separate data access logic from business logic\nC) To add more files to the project\nD) To make database queries prettier\n\n---\n\n### Question 2\nIn a three-layer architecture, which layer should contain validation logic?\n\nA) Repository layer (data access)\nB) Service layer (business logic)\nC) Route layer (presentation)\nD) Database layer\n\n---\n\n### Question 3\nWhy use interfaces for repositories?\n\nA) They make code longer and more impressive\nB) They're required by Kotlin\nC) They enable testing with mock implementations and allow swapping implementations\nD) They make the code run faster\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "üéØ Why This Matters",
              "content": "\nThe Repository Pattern is **fundamental** to professional backend development. Every major framework and architecture uses it.\n\n### What You've Mastered\n\n‚úÖ **Separation of concerns**: Each layer has one job\n‚úÖ **Testability**: Can test without databases\n‚úÖ **Flexibility**: Easy to change implementations\n‚úÖ **Clean code**: Business logic separate from data access\n‚úÖ **Scalability**: Easy to add features\n‚úÖ **Maintainability**: Changes isolated to specific layers\n\n### Real-World Usage\n\n- **Spring Boot**: Repository interfaces are core\n- **Android**: Room database uses repository pattern\n- **iOS**: Core Data uses similar patterns\n- **Enterprise apps**: Standard architecture\n\n---\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "üìö Key Takeaways",
              "content": "\n‚úÖ **Repository Pattern** abstracts data access\n‚úÖ **Interfaces** define contracts, implementations provide details\n‚úÖ **Three layers**: Routes ‚Üí Services ‚Üí Repositories\n‚úÖ **Services** contain business logic and validation\n‚úÖ **Routes** handle HTTP concerns only\n‚úÖ **Testable** without real databases\n‚úÖ **Scalable** and maintainable architecture\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "üîú Next Steps",
              "content": "\nIn **Lesson 5.9**, you'll learn:\n- Advanced request validation\n- Error handling strategies\n- Status pages plugin\n- Custom error responses\n- Validation libraries\n\n---\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "‚úèÔ∏è Quiz Answer Key",
              "content": "\n**Question 1**: **B) To separate data access logic from business logic**\n\nExplanation: The Repository Pattern creates a clean separation between how data is stored/retrieved and how it's used in business logic. This makes code more maintainable and testable.\n\n---\n\n**Question 2**: **B) Service layer (business logic)**\n\nExplanation: Validation is business logic. Services validate data, enforce rules, and coordinate operations. Routes just handle HTTP, repositories just access data.\n\n---\n\n**Question 3**: **C) They enable testing with mock implementations and allow swapping implementations**\n\nExplanation: Interfaces let you create mock repositories for testing (no database needed) and easily swap implementations (e.g., SQL to NoSQL, add caching) without changing dependent code.\n\n---\n\n**Congratulations!** You now understand professional backend architecture! üéâ\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "5.9",
          "title": "Lesson 5.9: Request Validation & Error Handling",
          "moduleId": "module-05",
          "order": 15,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 60 minutes\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Topic Introduction",
              "content": "\nYou've built a beautiful API with repositories, services, and clean architecture. But what happens when someone sends invalid data? What if they try to create a book with an empty title, or a negative publication year, or an email that's not actually an email?\n\nWithout proper validation and error handling, your API becomes unreliable, insecure, and frustrating to use. In this lesson, you'll learn how to protect your application from bad data and communicate errors clearly to API consumers.\n\n---\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "The Concept",
              "content": "\n### The Bouncer Analogy\n\nThink of validation as a bouncer at an exclusive club:\n\n**Without a Bouncer (No Validation)**:\n- Anyone can walk in wearing anything\n- People without IDs get in\n- The club becomes chaotic and unsafe\n- Real customers have a bad experience\n\n**With a Good Bouncer (Proper Validation)**:\n- Checks ID at the door (presence validation)\n- Verifies age requirements (range validation)\n- Enforces dress code (format validation)\n- Refuses entry politely with clear reasons (error messages)\n- Only valid guests get inside\n\nYour API needs these same checks to maintain quality and security.\n\n### Why Validation Matters\n\n**1. Security**: Prevents injection attacks, buffer overflows, and malicious input\n**2. Data Integrity**: Ensures your database stays clean and consistent\n**3. User Experience**: Provides clear, actionable feedback about what went wrong\n**4. Business Logic**: Enforces rules like \"email must be unique\" or \"price must be positive\"\n\n### Types of Validation\n\n| Type | Example | Purpose |\n|------|---------|---------|\n| **Presence** | Title is required | Ensure critical fields aren't empty |\n| **Format** | Email must match pattern | Verify data structure |\n| **Range** | Age must be 13-120 | Enforce numeric boundaries |\n| **Length** | Password must be 8+ chars | Control string sizes |\n| **Uniqueness** | Email must be unique | Prevent duplicates |\n| **Business Rules** | Publish date can't be future | Enforce domain logic |\n\n### The Validation Layers\n\n\n**Key Principle**: Never trust client-side validation. Always validate on the server in the service layer.\n\n---\n\n",
              "code": "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ  Client (Optional Pre-validation)   ‚îÇ  ‚Üê Fast feedback, can be bypassed\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n              ‚Üì\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ  Route Layer                        ‚îÇ  ‚Üê Parse request, basic structure\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n              ‚Üì\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ  Service Layer (VALIDATION HERE)    ‚îÇ  ‚Üê Main validation logic\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n              ‚Üì\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ  Repository Layer                   ‚îÇ  ‚Üê Database constraints (last line)\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Building a Validation System",
              "content": "\n### Step 1: Define Custom Exception Types\n\nCreate a hierarchy of exceptions that represent different error conditions:\n\n\n### Step 2: Create Standardized Error Response Format\n\nConsistent error responses make your API easier to consume:\n\n\n### Step 3: Build a Validation Framework\n\nCreate reusable validation building blocks:\n\n\n### Step 4: Create Domain-Specific Validators\n\nNow build validators for your specific models:\n\n\n### Step 5: Integrate Validation into Service Layer\n\nYour service layer is the perfect place to validate:\n\n\n### Step 6: Handle Errors in Routes with Status Plugins\n\nInstall Ktor's StatusPages plugin for global error handling:\n\n\nConfigure the plugin in your application:\n\n\n### Step 7: Simplify Routes with Error Handling\n\nNow your routes become incredibly clean:\n\n\n---\n\n",
              "code": "// src/main/kotlin/com/example/routes/BookRoutes.kt\npackage com.example.routes\n\nimport com.example.models.ApiResponse\nimport com.example.models.CreateBookRequest\nimport com.example.models.UpdateBookRequest\nimport com.example.services.BookService\nimport io.ktor.http.*\nimport io.ktor.server.application.*\nimport io.ktor.server.request.*\nimport io.ktor.server.response.*\nimport io.ktor.server.routing.*\n\nfun Route.bookRoutes(bookService: BookService) {\n    route(\"/api/books\") {\n\n        // Get all books\n        get {\n            bookService.getAllBooks()\n                .onSuccess { books ->\n                    call.respond(ApiResponse(data = books))\n                }\n                .onFailure { error ->\n                    throw error  // Let StatusPages handle it\n                }\n        }\n\n        // Get book by ID\n        get(\"/{id}\") {\n            val id = call.parameters[\"id\"]?.toIntOrNull()\n                ?: throw ValidationException(\"Invalid book ID\")\n\n            bookService.getBookById(id)\n                .onSuccess { book ->\n                    call.respond(ApiResponse(data = book))\n                }\n                .onFailure { error ->\n                    throw error\n                }\n        }\n\n        // Create new book\n        post {\n            val request = call.receive<CreateBookRequest>()\n\n            bookService.createBook(request)\n                .onSuccess { book ->\n                    call.respond(\n                        HttpStatusCode.Created,\n                        ApiResponse(\n                            data = book,\n                            message = \"Book created successfully\"\n                        )\n                    )\n                }\n                .onFailure { error ->\n                    throw error\n                }\n        }\n\n        // Update book\n        put(\"/{id}\") {\n            val id = call.parameters[\"id\"]?.toIntOrNull()\n                ?: throw ValidationException(\"Invalid book ID\")\n            val request = call.receive<UpdateBookRequest>()\n\n            bookService.updateBook(id, request)\n                .onSuccess { book ->\n                    call.respond(ApiResponse(\n                        data = book,\n                        message = \"Book updated successfully\"\n                    ))\n                }\n                .onFailure { error ->\n                    throw error\n                }\n        }\n\n        // Delete book\n        delete(\"/{id}\") {\n            val id = call.parameters[\"id\"]?.toIntOrNull()\n                ?: throw ValidationException(\"Invalid book ID\")\n\n            bookService.deleteBook(id)\n                .onSuccess {\n                    call.respond(ApiResponse<Unit>(\n                        message = \"Book deleted successfully\"\n                    ))\n                }\n                .onFailure { error ->\n                    throw error\n                }\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Breakdown",
              "content": "\n### The Validation Flow\n\n\n### Error Response Examples\n\n**Validation Error (400 Bad Request)**:\n\n**Not Found Error (404)**:\n\n**Conflict Error (409)**:\n\n### Key Design Patterns\n\n1. **Exception Hierarchy**: Sealed class ensures type safety and exhaustive handling\n2. **Validation Result Accumulation**: Collects all errors instead of failing on first\n3. **Reusable Validators**: Abstract base class with common validation logic\n4. **Service Layer Validation**: Keeps routes thin, concentrates logic\n5. **Result<T> Pattern**: Type-safe success/failure handling\n6. **Global Error Handling**: StatusPages plugin provides consistent error responses\n7. **Never Expose Internals**: Generic messages for unexpected errors, detailed logs server-side\n\n---\n\n",
              "code": "{\n  \"success\": false,\n  \"message\": \"A book with title 'The Hobbit' by J.R.R. Tolkien already exists\",\n  \"timestamp\": \"2025-01-15T10:32:10.789\"\n}",
              "language": "json"
            },
            {
              "type": "THEORY",
              "title": "Exercise: Product Validation System",
              "content": "\nBuild a complete validation system for a product catalog API.\n\n### Requirements\n\n1. **Product Model**:\n   - Name (required, 1-200 chars)\n   - Description (optional, max 1000 chars)\n   - Price (required, must be > 0, max 2 decimal places)\n   - Category (required, must be one of: Electronics, Clothing, Books, Food, Other)\n   - SKU (required, unique, format: 3 letters + 6 digits, e.g., \"ABC123456\")\n   - Stock quantity (required, must be >= 0)\n   - Active (boolean, defaults to true)\n\n2. **Validation Rules**:\n   - Price must be positive and not exceed 1,000,000\n   - Category must match allowed values exactly (case-sensitive)\n   - SKU must be unique across all products\n   - Cannot set stock to negative\n   - Cannot update inactive products (business rule)\n\n3. **Error Handling**:\n   - Return 400 for validation errors with field-specific messages\n   - Return 404 when product doesn't exist\n   - Return 409 for duplicate SKU\n   - Return 422 for business rule violations (updating inactive product)\n\n### Your Task\n\nImplement:\n1. `Product` and `CreateProductRequest` data classes\n2. `ProductValidator` with all validation rules\n3. `ProductService` with create, update, and deactivate methods\n4. Custom exception for business rule violations (`BusinessRuleException`)\n5. Error handling configuration\n6. Routes with proper error responses\n\nTest with these cases:\n- Valid product creation\n- Missing required fields\n- Invalid price (negative, too many decimals)\n- Invalid category\n- Invalid SKU format\n- Duplicate SKU\n- Updating inactive product\n\n### Starter Code\n\n\n---\n\n",
              "code": "// Models\n@Serializable\ndata class Product(\n    val id: Int,\n    val name: String,\n    val description: String?,\n    val price: Double,\n    val category: String,\n    val sku: String,\n    val stockQuantity: Int,\n    val active: Boolean = true\n)\n\n@Serializable\ndata class CreateProductRequest(\n    val name: String,\n    val description: String? = null,\n    val price: Double,\n    val category: String,\n    val sku: String,\n    val stockQuantity: Int\n)\n\n@Serializable\ndata class UpdateProductRequest(\n    val name: String,\n    val description: String? = null,\n    val price: Double,\n    val category: String,\n    val stockQuantity: Int\n)\n\n// TODO: Implement ProductValidator\n// TODO: Implement ProductService\n// TODO: Implement routes",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Solution",
              "content": "\n### Complete Product Validation System\n\n\n\n\n\n\n### Test Cases\n\n**Test 1: Valid Product Creation**\n\nResponse (201 Created):\n\n**Test 2: Validation Errors**\n\nResponse (400 Bad Request):\n\n**Test 3: Duplicate SKU**\n\nResponse (409 Conflict):\n\n**Test 4: Updating Inactive Product**\n\nResponse (422 Unprocessable Entity):\n\n---\n\n",
              "code": "{\n  \"success\": false,\n  \"message\": \"Cannot update inactive product. Reactivate it first.\",\n  \"timestamp\": \"2025-01-15T14:27:45.012\"\n}",
              "language": "json"
            },
            {
              "type": "THEORY",
              "title": "Solution Explanation",
              "content": "\n### Why This Design Works\n\n**1. Layered Validation**:\n- **Format validation** in `ProductValidator` (structure, types, ranges)\n- **Business rules** in `ProductService` (uniqueness, state transitions)\n- **Database constraints** as last line of defense\n\n**2. Accumulated Errors**:\nInstead of failing on the first error, the validator collects all validation failures and returns them together. This provides better UX‚Äîusers can fix multiple issues at once.\n\n**3. Clear Error Taxonomy**:\n- `ValidationException` (400): Bad input format\n- `NotFoundException` (404): Resource doesn't exist\n- `ConflictException` (409): Duplicate resource\n- `BusinessRuleException` (422): Valid format but violates business logic\n\n**4. Separation of Concerns**:\n- **Validator**: Focuses purely on data format and constraints\n- **Service**: Enforces business rules and orchestrates operations\n- **Routes**: Handle HTTP concerns only\n- **StatusPages**: Centralized error response formatting\n\n**5. Type Safety with Result<T>**:\nUsing Kotlin's `Result<T>` type provides compile-time guarantees that errors are handled, preventing unhandled exceptions from reaching users.\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n### Real-World Impact\n\n**Without Validation**:\n- üò± Your database fills with junk data\n- üîì SQL injection and XSS vulnerabilities\n- üò§ Users get cryptic database errors\n- üêõ Debugging becomes nightmare (bad data everywhere)\n- üí∏ Data cleanup costs escalate\n\n**With Proper Validation**:\n- ‚úÖ Clean, trustworthy data\n- üîí Protection against attacks\n- üòä Clear, actionable error messages\n- üêû Easier debugging (problems caught early)\n- üí∞ Lower maintenance costs\n\n### Professional Best Practices\n\n1. **Validate Early, Validate Often**: Don't trust any external input\n2. **Be Specific**: \"Email is required\" is better than \"Invalid input\"\n3. **Accumulate Errors**: Show all problems, not just the first one\n4. **Log Server Errors**: Never expose internal details to clients\n5. **Use Proper Status Codes**: 400 vs 422 vs 409 have distinct meanings\n6. **Test Edge Cases**: Empty strings, null values, extreme numbers\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Checkpoint Quiz",
              "content": "\nTest your understanding of validation and error handling:\n\n### Question 1\nWhere should business rule validation (like \"email must be unique\") primarily occur?\n\nA) Client-side JavaScript\nB) Route layer\nC) Service layer\nD) Repository layer\n\n### Question 2\nWhat HTTP status code should you return for a validation error like \"email format is invalid\"?\n\nA) 200 OK\nB) 400 Bad Request\nC) 422 Unprocessable Entity\nD) 500 Internal Server Error\n\n### Question 3\nWhat's the main benefit of accumulating validation errors instead of failing on the first error?\n\nA) It makes the code run faster\nB) It reduces server load\nC) Users can fix all issues at once, improving UX\nD) It's required by REST standards\n\n### Question 4\nWhat should you do when an unexpected exception occurs in production?\n\nA) Return the full stack trace to the client for debugging\nB) Log the detailed error server-side, return a generic message to client\nC) Ignore it and return 200 OK\nD) Crash the server to alert administrators\n\n### Question 5\nWhy use a sealed class hierarchy for exceptions (ApiException subclasses)?\n\nA) It makes the code look more professional\nB) It enables type-safe, exhaustive error handling\nC) It's required by Ktor\nD) It improves performance\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Answers",
              "content": "\n**Question 1: C) Service layer**\n\nThe service layer is the perfect place for business rule validation:\n- Route layer handles HTTP parsing\n- Service layer knows business logic (\"email must be unique\" requires checking database)\n- Repository layer is just data access\n\nClient-side validation is for UX but can be bypassed, so never trust it alone.\n\n---\n\n**Question 2: B) 400 Bad Request**\n\nHTTP status code guidelines:\n- **400 Bad Request**: Invalid input format (malformed JSON, invalid email format)\n- **422 Unprocessable Entity**: Valid format but violates business rules\n- **409 Conflict**: Duplicate resource\n- **500 Internal Server Error**: Unexpected server error\n\nFor format validation like email pattern matching, use 400.\n\n---\n\n**Question 3: C) Users can fix all issues at once, improving UX**\n\nCompare these experiences:\n\n**Fail-fast approach**:\n1. Submit form ‚Üí \"Name is required\"\n2. Add name, submit ‚Üí \"Email is invalid\"\n3. Fix email, submit ‚Üí \"Password too short\"\n4. üò§ Three round trips!\n\n**Accumulated errors**:\n1. Submit form ‚Üí Shows all three errors at once\n2. Fix all issues, submit ‚Üí Success!\n3. üòä One round trip!\n\n---\n\n**Question 4: B) Log the detailed error server-side, return a generic message to client**\n\nSecurity and UX best practice:\n\n\nNever expose stack traces or internal details‚Äîthey can reveal vulnerabilities.\n\n---\n\n**Question 5: B) It enables type-safe, exhaustive error handling**\n\nUsing a sealed class hierarchy gives you compile-time safety:\n\n\nThis prevents bugs from unhandled exception types.\n\n---\n\n",
              "code": "sealed class ApiException : Exception()\nclass ValidationException : ApiException()\nclass NotFoundException : ApiException()\n\n// The compiler ensures you handle all cases\nwhen (exception) {\n    is ValidationException -> // handle\n    is NotFoundException -> // handle\n    // Compiler error if you forget a case!\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "What You've Learned",
              "content": "\n‚úÖ Why validation and error handling are critical for security and UX\n‚úÖ How to build a reusable validation framework with accumulating errors\n‚úÖ Where to validate (client vs server, which backend layer)\n‚úÖ How to create a clear exception hierarchy for different error types\n‚úÖ How to use Ktor's StatusPages plugin for centralized error handling\n‚úÖ How to provide helpful error messages without exposing internals\n‚úÖ How to use proper HTTP status codes (400, 404, 409, 422, 500)\n‚úÖ How to integrate validation into clean architecture (service layer)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Next Steps",
              "content": "\nIn the next lesson, we'll build on this foundation by implementing **user authentication with password hashing**. You'll learn how to:\n- Securely store passwords using bcrypt\n- Validate registration data (email format, password strength)\n- Handle authentication errors properly\n- Prevent common security vulnerabilities\n\nThe validation patterns you learned today will be essential for validating user credentials safely!\n\n"
            }
          ],
          "challenges": []
        }
      ],
      "quizzes": [
        {
          "id": "part5-quiz-5.1",
          "title": "Introduction to Backend Development Quiz",
          "description": "Knowledge check for Introduction to Backend Development Quiz",
          "moduleId": "module-05",
          "passingScore": 70,
          "estimatedMinutes": 10,
          "questions": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "5.1.q1",
              "title": "What is a backend?",
              "description": "What is a backend?",
              "options": [
                "The user interface",
                "Server-side code that handles logic, data, and APIs",
                "The database only",
                "The styling of a website"
              ],
              "correctAnswer": 1,
              "explanation": "The backend is server-side code that processes requests, manages data, enforces logic, and provides APIs."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "5.1.q2",
              "title": "What does REST stand for?",
              "description": "What does REST stand for?",
              "options": [
                "Really Easy Server Technology",
                "Representational State Transfer",
                "Remote Execution Service Tool",
                "Rapid Enterprise System Toolkit"
              ],
              "correctAnswer": 1,
              "explanation": "REST stands for Representational State Transfer, a standard for designing web APIs."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "5.1.q3",
              "title": "Which HTTP method is used to retrieve data?",
              "description": "Which HTTP method is used to retrieve data?",
              "options": [
                "POST",
                "PUT",
                "GET",
                "DELETE"
              ],
              "correctAnswer": 2,
              "explanation": "GET is used to retrieve/read data from the server."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "5.1.q4",
              "title": "Which HTTP method is used to create new data?",
              "description": "Which HTTP method is used to create new data?",
              "options": [
                "GET",
                "POST",
                "PUT",
                "DELETE"
              ],
              "correctAnswer": 1,
              "explanation": "POST is used to create new resources on the server."
            },
            {
              "type": "TRUE_FALSE",
              "id": "5.1.q5",
              "title": "PUT is used to update existing data.",
              "description": "PUT is used to update existing data.",
              "question": "PUT is used to update existing data.",
              "correctAnswer": true,
              "explanation": "True. PUT is used to update/modify existing resources."
            }
          ]
        },
        {
          "id": "part5-quiz-5.2",
          "title": "Databases and Authentication Quiz",
          "description": "Knowledge check for Databases and Authentication Quiz",
          "moduleId": "module-05",
          "passingScore": 70,
          "estimatedMinutes": 10,
          "questions": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "5.2.q1",
              "title": "What does CRUD stand for?",
              "description": "What does CRUD stand for?",
              "options": [
                "Create, Retrieve, Update, Delete",
                "Create, Read, Update, Delete",
                "Copy, Read, Upload, Download",
                "Connect, Run, Upload, Destroy"
              ],
              "correctAnswer": 1,
              "explanation": "CRUD stands for Create, Read, Update, Delete - the four basic database operations."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "5.2.q2",
              "title": "What is Exposed in Kotlin?",
              "description": "What is Exposed in Kotlin?",
              "options": [
                "A security vulnerability",
                "A SQL library/ORM for database operations",
                "A web framework",
                "A testing tool"
              ],
              "correctAnswer": 1,
              "explanation": "Exposed is a Kotlin SQL library (ORM) that provides a type-safe way to work with databases."
            },
            {
              "type": "TRUE_FALSE",
              "id": "5.2.q3",
              "title": "Passwords should be stored as plain text in the database.",
              "description": "Passwords should be stored as plain text in the database.",
              "question": "Passwords should be stored as plain text in the database.",
              "correctAnswer": false,
              "explanation": "False! Always hash passwords before storing them. Never store plain text passwords."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "5.2.q4",
              "title": "What is a JWT?",
              "description": "What is a JWT?",
              "options": [
                "Java Web Token",
                "JSON Web Token",
                "JavaScript Web Tool",
                "Just Working Technology"
              ],
              "correctAnswer": 1,
              "explanation": "JWT stands for JSON Web Token, a standard for securely transmitting information as JSON."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "5.2.q5",
              "title": "What does CORS stand for?",
              "description": "What does CORS stand for?",
              "options": [
                "Cross-Origin Resource Sharing",
                "Common Object Request System",
                "Central Origin Response Server",
                "Compiled Object Resource Storage"
              ],
              "correctAnswer": 0,
              "explanation": "CORS (Cross-Origin Resource Sharing) allows servers to specify which origins can access their resources."
            }
          ]
        },
        {
          "id": "part5-quiz-5.3",
          "title": "Testing and Validation Quiz",
          "description": "Knowledge check for Testing and Validation Quiz",
          "moduleId": "module-05",
          "passingScore": 70,
          "estimatedMinutes": 8,
          "questions": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "5.3.q1",
              "title": "What is input validation?",
              "description": "What is input validation?",
              "options": [
                "Checking if input is formatted correctly",
                "Checking if user data meets requirements before processing",
                "Encrypting user input",
                "Storing input in database"
              ],
              "correctAnswer": 1,
              "explanation": "Input validation ensures user data meets requirements (format, length, type) before processing."
            },
            {
              "type": "TRUE_FALSE",
              "id": "5.3.q2",
              "title": "You should trust all data coming from users without validation.",
              "description": "You should trust all data coming from users without validation.",
              "question": "You should trust all data coming from users without validation.",
              "correctAnswer": false,
              "explanation": "False! Never trust user input. Always validate and sanitize data to prevent security issues."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "5.3.q3",
              "title": "What HTTP status code indicates a successful request?",
              "description": "What HTTP status code indicates a successful request?",
              "options": [
                "404",
                "500",
                "200",
                "403"
              ],
              "correctAnswer": 2,
              "explanation": "200 OK indicates a successful HTTP request."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "5.3.q4",
              "title": "What HTTP status code indicates 'resource not found'?",
              "description": "What HTTP status code indicates 'resource not found'?",
              "options": [
                "200",
                "404",
                "500",
                "401"
              ],
              "correctAnswer": 1,
              "explanation": "404 Not Found indicates the requested resource doesn't exist."
            }
          ]
        }
      ]
    },
    {
      "id": "module-06",
      "title": "Part 6: Kotlin Fundamentals",
      "description": "Learn Kotlin programming - Part 6",
      "difficulty": "advanced",
      "estimatedHours": 12,
      "lessons": [
        {
          "id": "6.1",
          "title": "Lesson 6.1: Android Fundamentals & Setup",
          "moduleId": "module-06",
          "order": 1,
          "estimatedMinutes": 75,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 75 minutes\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "\nWelcome to **Part 6: Android Development with Kotlin**!\n\nYou've mastered Kotlin fundamentals, object-oriented programming, functional programming, and backend development with Ktor. Now it's time to bring your skills to mobile development.\n\nAndroid is the world's most popular mobile platform with over **3 billion active devices**. With Jetpack Compose, Google's modern UI toolkit, building beautiful Android apps has never been easier or more intuitive.\n\nIn this lesson, you'll:\n- ‚úÖ Understand the Android platform and ecosystem\n- ‚úÖ Install and configure Android Studio (Ladybug/Otter)\n- ‚úÖ Create your first Android project\n- ‚úÖ Understand Android project structure\n- ‚úÖ Learn about the Gradle build system\n- ‚úÖ Run apps on emulator and physical devices\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "The Android Platform",
              "content": "\n### What is Android?\n\n**Android** is an open-source mobile operating system developed by Google, based on the Linux kernel.\n\n**Key Features**:\n- **Open Source**: Free to use and modify (AOSP - Android Open Source Project)\n- **App Sandboxing**: Each app runs in its own secure environment\n- **Rich Framework**: Extensive APIs for sensors, camera, location, networking, etc.\n- **Google Play Store**: Primary distribution channel (3.5+ million apps)\n- **Backward Compatibility**: Support for older devices\n\n### Android Architecture\n\n\n### Android Versions\n\n| Version       | API Level | Release Year | Key Features                    |\n|---------------|-----------|--------------|--------------------------------|\n| **Android 15**| 35        | 2024         | Enhanced privacy, performance  |\n| **Android 14**| 34        | 2023         | Improved battery, gestures     |\n| **Android 13**| 33        | 2022         | Themed icons, permissions      |\n| **Android 12**| 31-32     | 2021         | Material You, widgets          |\n| **Android 11**| 30        | 2020         | Chat bubbles, one-time perms   |\n\n**Minimum API Level**: We'll target **API 24 (Android 7.0)** which covers **95%+ of active devices**.\n\n---\n\n",
              "code": "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ   System Apps                       ‚îÇ  Calendar, Camera, etc.\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ   Java API Framework                ‚îÇ  Activity Manager, View System\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ   Native Libraries    ‚îÇ   ART       ‚îÇ  C/C++ libs, Runtime\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ   Hardware Abstraction Layer (HAL)  ‚îÇ  Camera, Bluetooth, etc.\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ   Linux Kernel                      ‚îÇ  Drivers, Security\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Why Jetpack Compose?",
              "content": "\n### Traditional Android UI (XML)\n\n\nThen in Kotlin:\n\n### Jetpack Compose (Modern)\n\n\n**Benefits**:\n- ‚úÖ **Less Code**: 40% less code than XML\n- ‚úÖ **Type Safety**: Compiler catches errors\n- ‚úÖ **Declarative**: Describe what UI should look like, not how to build it\n- ‚úÖ **Kotlin First**: Leverage Kotlin features (lambdas, extension functions)\n- ‚úÖ **Reactive**: UI automatically updates when state changes\n- ‚úÖ **Interoperable**: Works with existing Android Views\n\n---\n\n",
              "code": "@Composable\nfun Greeting() {\n    Column {\n        Text(\"Hello World\")\n        Button(onClick = { /* handle click */ }) {\n            Text(\"Click Me\")\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Installing Android Studio",
              "content": "\n### Download\n\n1. Go to [developer.android.com/studio](https://developer.android.com/studio)\n2. Download **Android Studio Ladybug** or **Otter** (latest stable version)\n3. Choose your platform:\n   - **Windows**: `.exe` installer\n   - **macOS**: `.dmg` disk image\n   - **Linux**: `.tar.gz` archive\n\n### Installation\n\n**Windows**:\n1. Run the `.exe` installer\n2. Follow the setup wizard\n3. Choose \"Standard\" installation type\n4. Select UI theme (Light or Dark)\n5. Wait for SDK components to download (~3 GB)\n\n**macOS**:\n1. Open the `.dmg` file\n2. Drag **Android Studio** to Applications folder\n3. Launch Android Studio\n4. Follow setup wizard\n5. Grant necessary permissions (disk access, etc.)\n\n**Linux**:\n\n### First Launch\n\nOn first launch, you'll see the **Setup Wizard**:\n\n1. **Import Settings**: Choose \"Do not import settings\" (first time)\n2. **Data Sharing**: Choose whether to share usage data\n3. **Install Type**: Select **Standard**\n4. **UI Theme**: Choose **Darcula** (dark) or **Light**\n5. **Verify Settings**: Review SDK location (usually `~/Android/Sdk`)\n6. **License Agreements**: Accept all licenses\n7. **Download Components**: Wait for SDK download (3-5 GB)\n\n### SDK Components\n\nThe Android SDK includes:\n- **SDK Platform**: Android API libraries for each version\n- **SDK Tools**: Build tools, platform tools (adb, fastboot)\n- **Emulator**: Virtual device for testing\n- **System Images**: OS images for emulator\n\nCheck installed components:\n- **Tools** ‚Üí **SDK Manager**\n\n---\n\n",
              "code": "# Extract archive\ntar -xzf android-studio-*.tar.gz\n\n# Move to /opt\nsudo mv android-studio /opt/\n\n# Run Android Studio\n/opt/android-studio/bin/studio.sh",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Creating Your First Android Project",
              "content": "\n### Step 1: New Project Wizard\n\n1. Open Android Studio\n2. Click **New Project**\n3. Select **Empty Activity** (Compose)\n4. Click **Next**\n\n### Step 2: Configure Project\n\n**Name**: `HelloCompose`\n**Package name**: `com.example.hellocompose`\n**Save location**: Choose a directory\n**Language**: **Kotlin**\n**Minimum SDK**: **API 24 (Android 7.0)**\n**Build configuration language**: **Kotlin DSL (build.gradle.kts)**\n\nClick **Finish** and wait for Gradle sync (~30 seconds).\n\n### Step 3: Explore the Project\n\nAndroid Studio creates a complete project structure with:\n- ‚úÖ Gradle build configuration\n- ‚úÖ Sample `MainActivity.kt`\n- ‚úÖ Composable UI functions\n- ‚úÖ Unit test setup\n- ‚úÖ AndroidManifest.xml\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Project Structure Explained",
              "content": "\n\n### Key Files\n\n#### 1. AndroidManifest.xml\n\nEvery Android app must have a manifest file that declares:\n- App components (activities, services, etc.)\n- Permissions (internet, camera, etc.)\n- App metadata (icon, label, theme)\n\n\n**Key attributes**:\n- `android:icon`: App launcher icon\n- `android:label`: App name (shown in launcher)\n- `android:theme`: App theme\n- `android:exported=\"true\"`: Activity can be launched by other apps\n- `<intent-filter>`: Makes this the launcher activity (app entry point)\n\n#### 2. MainActivity.kt\n\nThe main entry point of your app:\n\n\n**Key concepts**:\n- `ComponentActivity`: Base class for Compose apps\n- `onCreate()`: Called when activity is created\n- `setContent {}`: Sets the Compose UI\n- `@Composable`: Marks a function that emits UI\n- `@Preview`: Allows previewing UI in Android Studio\n\n#### 3. build.gradle.kts (Module Level)\n\nGradle configuration for the app module:\n\n\n**Key sections**:\n- `compileSdk`: SDK version used to compile the app\n- `minSdk`: Minimum Android version supported\n- `targetSdk`: Version the app is tested against\n- `versionCode`: Internal version number (increment for each release)\n- `versionName`: User-visible version string (1.0, 1.1, 2.0, etc.)\n- `dependencies`: Libraries used by the app\n\n#### 4. gradle/libs.versions.toml\n\nCentralized version catalog (new in Android):\n\n\n**Benefits**:\n- ‚úÖ Single source of truth for versions\n- ‚úÖ Easy to update dependencies\n- ‚úÖ Type-safe accessors (`libs.androidx.core.ktx`)\n\n---\n\n",
              "code": "[versions]\nagp = \"8.7.0\"\nkotlin = \"2.0.21\"\ncoreKtx = \"1.15.0\"\njunit = \"4.13.2\"\njunitVersion = \"1.2.1\"\nespressoCore = \"3.6.1\"\nlifecycleRuntimeKtx = \"2.8.7\"\nactivityCompose = \"1.9.3\"\ncomposeBom = \"2025.08.00\"\n\n[libraries]\nandroidx-core-ktx = { group = \"androidx.core\", name = \"core-ktx\", version.ref = \"coreKtx\" }\nandroidx-lifecycle-runtime-ktx = { group = \"androidx.lifecycle\", name = \"lifecycle-runtime-ktx\", version.ref = \"lifecycleRuntimeKtx\" }\nandroidx-activity-compose = { group = \"androidx.activity\", name = \"activity-compose\", version.ref = \"activityCompose\" }\nandroidx-compose-bom = { group = \"androidx.compose\", name = \"compose-bom\", version.ref = \"composeBom\" }\nandroidx-compose-ui = { group = \"androidx.compose.ui\", name = \"ui\" }\nandroidx-compose-ui-graphics = { group = \"androidx.compose.ui\", name = \"ui-graphics\" }\nandroidx-compose-ui-tooling = { group = \"androidx.compose.ui\", name = \"ui-tooling\" }\nandroidx-compose-ui-tooling-preview = { group = \"androidx.compose.ui\", name = \"ui-tooling-preview\" }\nandroidx-compose-ui-test-manifest = { group = \"androidx.compose.ui\", name = \"ui-test-manifest\" }\nandroidx-compose-ui-test-junit4 = { group = \"androidx.compose.ui\", name = \"ui-test-junit4\" }\nandroidx-compose-material3 = { group = \"androidx.compose.material3\", name = \"material3\" }\njunit = { group = \"junit\", name = \"junit\", version.ref = \"junit\" }\nandroidx-test-ext-junit = { group = \"androidx.test.ext\", name = \"junit\", version.ref = \"junitVersion\" }\nandroidx-test-espresso-core = { group = \"androidx.test.espresso\", name = \"espresso-core\", version.ref = \"espressoCore\" }\n\n[plugins]\nandroid-application = { id = \"com.android.application\", version.ref = \"agp\" }\nkotlin-android = { id = \"org.jetbrains.kotlin.android\", version.ref = \"kotlin\" }\nkotlin-compose = { id = \"org.jetbrains.kotlin.plugin.compose\", version.ref = \"kotlin\" }",
              "language": "toml"
            },
            {
              "type": "THEORY",
              "title": "Understanding Gradle",
              "content": "\n### What is Gradle?\n\n**Gradle** is a build automation tool that:\n- Compiles Kotlin/Java code\n- Packages resources (images, strings, layouts)\n- Generates APK/AAB files\n- Runs tests\n- Manages dependencies\n\n### Gradle Build Process\n\n\n**Steps**:\n1. **Download dependencies** from Maven repositories\n2. **Compile Kotlin** to JVM bytecode\n3. **Convert bytecode** to DEX (Dalvik Executable) for Android\n4. **Package** code, resources, and assets into APK/AAB\n5. **Sign** the package with a keystore\n\n### Gradle Tasks\n\nCommon tasks (run from Terminal in Android Studio):\n\n\n### Sync Project\n\nAfter modifying `build.gradle.kts`, click **Sync Now** or:\n- **File** ‚Üí **Sync Project with Gradle Files**\n\nThis downloads new dependencies and updates the project.\n\n---\n\n",
              "code": "# Build debug APK\n./gradlew assembleDebug\n\n# Build release APK\n./gradlew assembleRelease\n\n# Install app on connected device\n./gradlew installDebug\n\n# Run unit tests\n./gradlew test\n\n# Run instrumented tests\n./gradlew connectedAndroidTest\n\n# Clean build\n./gradlew clean",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Running Your App",
              "content": "\n### Option 1: Android Emulator\n\n#### Create a Virtual Device\n\n1. Click **Device Manager** (phone icon in toolbar)\n2. Click **Create Device**\n3. Select hardware:\n   - **Phone** ‚Üí **Pixel 8** (recommended)\n   - Or choose any device\n4. Click **Next**\n5. Select system image:\n   - **Release Name**: **VanillaIceCream** (API 35, Android 15)\n   - Click **Download** if not installed\n6. Click **Next**\n7. Name: **Pixel_8_API_35**\n8. Click **Finish**\n\n#### Run on Emulator\n\n1. Select **Pixel_8_API_35** from device dropdown\n2. Click **Run** (green play button) or press **Shift + F10**\n3. Wait for emulator to boot (~30 seconds first time)\n4. App launches automatically\n\n### Option 2: Physical Device\n\n#### Enable Developer Options\n\n**Android 12+**:\n1. Open **Settings**\n2. Go to **About phone**\n3. Tap **Build number** 7 times\n4. Enter PIN/password\n5. \"You are now a developer!\" appears\n\n#### Enable USB Debugging\n\n1. Go to **Settings** ‚Üí **System** ‚Üí **Developer options**\n2. Enable **USB debugging**\n\n#### Connect Device\n\n1. Connect phone to computer via USB\n2. On phone, allow USB debugging prompt\n3. In Android Studio, select your device from dropdown\n4. Click **Run**\n\n### Option 3: Wireless Debugging (Android 11+)\n\n1. Connect phone and computer to same Wi-Fi\n2. Enable **Wireless debugging** in Developer options\n3. Click **Pair device with pairing code**\n4. In Android Studio: **Pair Devices Using Wi-Fi**\n5. Enter pairing code\n6. Run app wirelessly\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Understanding the Build Output",
              "content": "\n### APK vs AAB\n\n**APK (Android Package)**:\n- Installable file for Android devices\n- Contains all code, resources, and assets\n- Used for direct installation and testing\n\n**AAB (Android App Bundle)**:\n- Publishing format for Google Play\n- Google Play generates optimized APKs for each device\n- Smaller downloads (only includes necessary resources)\n\n### Build Locations\n\n**Debug APK**:\n\n**Release APK**:\n\n**AAB**:\n\n---\n\n",
              "code": "app/build/outputs/bundle/release/app-release.aab",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Debugging Tools",
              "content": "\n### Logcat\n\nView app logs in real-time:\n\n\n**Log levels**:\n- `Log.v()`: Verbose (lowest priority)\n- `Log.d()`: Debug\n- `Log.i()`: Info\n- `Log.w()`: Warning\n- `Log.e()`: Error\n- `Log.wtf()`: What a Terrible Failure (critical errors)\n\nView logs in **Logcat** tab (bottom of Android Studio).\n\n### Android Debug Bridge (adb)\n\nCommand-line tool for device communication:\n\n\n### Layout Inspector\n\nInspect UI hierarchy in real-time:\n1. Run app on device/emulator\n2. **Tools** ‚Üí **Layout Inspector**\n3. Select running process\n4. Explore component tree and properties\n\n---\n\n",
              "code": "# List connected devices\nadb devices\n\n# Install APK\nadb install app-debug.apk\n\n# Uninstall app\nadb uninstall com.example.hellocompose\n\n# View logs\nadb logcat\n\n# Clear logs\nadb logcat -c\n\n# Shell into device\nadb shell\n\n# Take screenshot\nadb shell screencap /sdcard/screen.png\nadb pull /sdcard/screen.png\n\n# Record screen\nadb shell screenrecord /sdcard/demo.mp4",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Exercise 1: Customize the App",
              "content": "\nModify your `MainActivity.kt` to:\n1. Change greeting to your name\n2. Add a second `Text` composable with your favorite color\n3. Add log statements in `onCreate()`\n\n### Requirements\n\n\nRun the app and verify:\n- Both text lines appear\n- Logs appear in Logcat\n\n---\n\n",
              "code": "@Composable\nfun Greeting(name: String, modifier: Modifier = Modifier) {\n    Column(modifier = modifier) {\n        Text(text = \"Hello $name!\")\n        Text(text = \"My favorite color is Blue\")\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Solution 1",
              "content": "\n\n**Logcat output**:\n\n---\n\n",
              "code": "D/MainActivity: onCreate: Activity is being created\nI/MainActivity: App version: 1.0\nD/MainActivity: onCreate: UI setup complete",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 2: Create a Virtual Device",
              "content": "\nCreate a new emulator with different specifications:\n\n### Requirements\n\n1. Create a tablet emulator\n2. Use **Pixel Tablet** hardware\n3. Install **API 34 (Android 14)** system image\n4. Name it **MyTablet**\n5. Run your app on this device\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 2",
              "content": "\n**Steps**:\n\n1. Click **Device Manager**\n2. Click **Create Device**\n3. Select **Tablet** category\n4. Choose **Pixel Tablet**\n5. Click **Next**\n6. Select **UpsideDownCake** (API 34)\n7. Download if necessary\n8. Click **Next**\n9. AVD Name: **MyTablet**\n10. Click **Finish**\n11. Select **MyTablet** from dropdown\n12. Click **Run**\n\n**Result**: App runs on a larger screen, text appears smaller relative to screen size.\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Exercise 3: Explore Project Files",
              "content": "\nAnswer these questions by exploring the project:\n\n1. What is the app's package name?\n2. What is the minimum SDK version?\n3. What is the Compose BOM version?\n4. Where are app icons stored?\n5. What is the launcher activity name?\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 3",
              "content": "\n**Answers**:\n\n1. **Package name**: `com.example.hellocompose`\n   - Found in `build.gradle.kts` ‚Üí `namespace`\n   - Also in `AndroidManifest.xml` ‚Üí `package`\n\n2. **Minimum SDK**: API 24 (Android 7.0)\n   - Found in `build.gradle.kts` ‚Üí `defaultConfig` ‚Üí `minSdk`\n\n3. **Compose BOM version**: `2025.08.00`\n   - Found in `gradle/libs.versions.toml` ‚Üí `[versions]` ‚Üí `composeBom`\n\n4. **App icons**: `app/src/main/res/mipmap/`\n   - `ic_launcher.png` (various densities: hdpi, mdpi, xhdpi, etc.)\n   - `ic_launcher_round.png`\n\n5. **Launcher activity**: `MainActivity`\n   - Found in `AndroidManifest.xml`:\n   ```xml\n   <activity android:name=\".MainActivity\">\n       <intent-filter>\n           <action android:name=\"android.intent.action.MAIN\" />\n           <category android:name=\"android.intent.category.LAUNCHER\" />\n       </intent-filter>\n   </activity>\n   ```\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Checkpoint Quiz",
              "content": "\n### Question 1\nWhat is the minimum API level that covers 95%+ of Android devices in 2025?\n\nA) API 21 (Android 5.0)\nB) API 24 (Android 7.0)\nC) API 28 (Android 9.0)\nD) API 31 (Android 12)\n\n### Question 2\nWhat is the main benefit of Jetpack Compose over XML layouts?\n\nA) Faster app runtime performance\nB) Smaller APK size\nC) Declarative UI with less code and better type safety\nD) Works on older Android versions\n\n### Question 3\nWhat file declares app components, permissions, and metadata?\n\nA) build.gradle.kts\nB) MainActivity.kt\nC) AndroidManifest.xml\nD) settings.gradle.kts\n\n### Question 4\nWhat does the `@Composable` annotation do?\n\nA) Makes a function run faster\nB) Marks a function that emits UI elements\nC) Automatically generates preview\nD) Enables dependency injection\n\n### Question 5\nWhat is the purpose of the Gradle build system?\n\nA) Run the app on devices\nB) Design the user interface\nC) Compile code, manage dependencies, and package the app\nD) Debug runtime errors\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Answers",
              "content": "\n**Question 1: B) API 24 (Android 7.0)**\n\nAPI 24 (Nougat) covers approximately 95-98% of active Android devices. While API 21 covers more, API 24 provides better security and modern features without sacrificing reach.\n\n**Why not lower?**\n- API 21 has security vulnerabilities\n- API 24+ has better TLS support\n- Modern libraries often require API 24+\n\n---\n\n**Question 2: C) Declarative UI with less code and better type safety**\n\nJetpack Compose benefits:\n- **40% less code** than XML\n- **Type-safe**: Compiler catches errors\n- **Reactive**: UI updates automatically\n- **Kotlin-first**: Lambdas, extension functions\n\nXML required:\n- Separate layout files\n- `findViewById()` boilerplate\n- Manual view updates\n- No type safety for IDs\n\n---\n\n**Question 3: C) AndroidManifest.xml**\n\nThe manifest file declares:\n\n**Other files**:\n- `build.gradle.kts`: Dependencies, SDK versions\n- `MainActivity.kt`: Activity code\n- `settings.gradle.kts`: Project modules\n\n---\n\n**Question 4: B) Marks a function that emits UI elements**\n\n`@Composable` tells the compiler:\n- This function describes UI\n- Can call other `@Composable` functions\n- Can only be called from composable context\n\n\n---\n\n**Question 5: C) Compile code, manage dependencies, and package the app**\n\nGradle handles the entire build process:\n\n\nTasks:\n- Download libraries from Maven\n- Compile Kotlin to bytecode\n- Convert to DEX format\n- Package into APK/AAB\n- Sign with keystore\n- Run tests\n\n---\n\n",
              "code": "Source Code + Resources + Dependencies\n         ‚Üì\n    Gradle Build\n         ‚Üì\n  Compilation ‚Üí DEX ‚Üí APK/AAB",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "What You've Learned",
              "content": "\n‚úÖ Android platform architecture and version history\n‚úÖ Benefits of Jetpack Compose over XML layouts\n‚úÖ How to install and configure Android Studio (Ladybug/Otter)\n‚úÖ Creating a new Android project with Compose\n‚úÖ Understanding Android project structure (manifest, build files, resources)\n‚úÖ How Gradle builds and packages Android apps\n‚úÖ Running apps on emulator and physical devices\n‚úÖ Using debugging tools (Logcat, adb, Layout Inspector)\n‚úÖ Version catalog (libs.versions.toml) for dependency management\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Next Steps",
              "content": "\nIn **Lesson 6.2: Introduction to Jetpack Compose**, you'll dive deep into Compose:\n- Composable functions and the declarative paradigm\n- Preview annotations for rapid development\n- Basic UI components (Text, Button, Image)\n- Modifiers for styling and layout\n- State management with `remember` and `mutableStateOf`\n- Building interactive UIs\n\nGet ready to build beautiful, reactive UIs with modern Android development!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "6.1.1",
              "title": "Component Props Simulation",
              "description": "Create a data class to represent component props with a name property. Create an instance and display it.",
              "instructions": "Create a data class to represent component props with a name property. Create an instance and display it.",
              "starterCode": "// Create a GreetingProps data class\n\nfun main() {\n    val props = GreetingProps(\"Alice\")\n    println(\"Hello, ${props.name}!\")\n}",
              "solution": "data class GreetingProps(val name: String)\n\nfun main() {\n    val props = GreetingProps(\"Alice\")\n    println(\"Hello, ${props.name}!\")\n}",
              "language": "kotlin",
              "testCases": [
                {
                  "description": "Should create and display greeting",
                  "expectedOutput": "Hello, Alice!",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use data class for props"
                },
                {
                  "level": 2,
                  "text": "Props typically have val properties"
                },
                {
                  "level": 3,
                  "text": "Access property with dot notation"
                }
              ],
              "difficulty": "beginner"
            },
            {
              "type": "FREE_CODING",
              "id": "6.1.2",
              "title": "State Management Simulation",
              "description": "Simulate React state by creating a Counter class with a count property and increment/decrement methods.",
              "instructions": "Simulate React state by creating a Counter class with a count property and increment/decrement methods.",
              "starterCode": "class Counter {\n    var count: Int = 0\n    \n    // Add increment method\n    \n    // Add decrement method\n}\n\nfun main() {\n    val counter = Counter()\n    println(\"Initial: ${counter.count}\")\n    counter.increment()\n    counter.increment()\n    println(\"After increments: ${counter.count}\")\n    counter.decrement()\n    println(\"After decrement: ${counter.count}\")\n}",
              "solution": "class Counter {\n    var count: Int = 0\n    \n    fun increment() {\n        count++\n    }\n    \n    fun decrement() {\n        count--\n    }\n}\n\nfun main() {\n    val counter = Counter()\n    println(\"Initial: ${counter.count}\")\n    counter.increment()\n    counter.increment()\n    println(\"After increments: ${counter.count}\")\n    counter.decrement()\n    println(\"After decrement: ${counter.count}\")\n}",
              "language": "kotlin",
              "testCases": [
                {
                  "description": "Initial count should be 0",
                  "expectedOutput": "Initial: 0",
                  "isVisible": true
                },
                {
                  "description": "After two increments should be 2",
                  "expectedOutput": "After increments: 2",
                  "isVisible": true
                },
                {
                  "description": "After decrement should be 1",
                  "expectedOutput": "After decrement: 1",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "count must be var to be mutable"
                },
                {
                  "level": 2,
                  "text": "Use count++ to increment"
                },
                {
                  "level": 3,
                  "text": "Use count-- to decrement"
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "6.1.3",
              "title": "Event Handler Simulation",
              "description": "Create a Button class that stores a click handler lambda and calls it when clicked.",
              "instructions": "Create a Button class that stores a click handler lambda and calls it when clicked.",
              "starterCode": "class Button(val label: String, val onClick: () -> Unit) {\n    fun click() {\n        // Call the onClick handler\n    }\n}\n\nfun main() {\n    val button = Button(\"Click Me\") {\n        println(\"Button was clicked!\")\n    }\n    \n    println(\"Button label: ${button.label}\")\n    button.click()\n}",
              "solution": "class Button(val label: String, val onClick: () -> Unit) {\n    fun click() {\n        onClick()\n    }\n}\n\nfun main() {\n    val button = Button(\"Click Me\") {\n        println(\"Button was clicked!\")\n    }\n    \n    println(\"Button label: ${button.label}\")\n    button.click()\n}",
              "language": "kotlin",
              "testCases": [
                {
                  "description": "Should have correct label",
                  "expectedOutput": "Button label: Click Me",
                  "isVisible": true
                },
                {
                  "description": "Should call click handler",
                  "expectedOutput": "Button was clicked!",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "onClick is a lambda with no parameters"
                },
                {
                  "level": 2,
                  "text": "Call lambda like a function: onClick()"
                },
                {
                  "level": 3,
                  "text": "() -> Unit means function that takes nothing and returns nothing"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "6.10",
          "title": "Lesson 6.10: Part 6 Capstone - Task Manager App",
          "moduleId": "module-06",
          "order": 2,
          "estimatedMinutes": 30,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 4-6 hours\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Project Overview",
              "content": "\nCongratulations on completing Part 6! You've learned Android development from fundamentals to advanced concepts.\n\nNow it's time to build a **complete, production-ready Task Manager App** that integrates everything you've learned:\n- ‚úÖ Jetpack Compose UI\n- ‚úÖ Material Design 3\n- ‚úÖ MVVM architecture\n- ‚úÖ Room database for local storage\n- ‚úÖ Navigation between screens\n- ‚úÖ State management\n- ‚úÖ Animations and gestures\n- ‚úÖ Dependency injection with Hilt\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "The Project: TaskMaster",
              "content": "\n**TaskMaster** is a comprehensive task management app where users can:\n- Create, edit, and delete tasks\n- Organize tasks by categories\n- Set priorities (Low, Medium, High)\n- Add due dates\n- Mark tasks as complete\n- Filter and search tasks\n- View statistics\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Features",
              "content": "\n### Core Features\n\n1. **Task Management**\n   - Create new tasks with title, description, due date, priority\n   - Edit existing tasks\n   - Delete tasks (swipe to dismiss)\n   - Mark tasks as complete/incomplete\n\n2. **Categories**\n   - Predefined categories (Work, Personal, Shopping, Health)\n   - Color-coded categories\n   - Filter tasks by category\n\n3. **Priorities**\n   - Low, Medium, High\n   - Visual indicators (colors, icons)\n   - Sort by priority\n\n4. **Due Dates**\n   - Set due date with date picker\n   - Overdue indicator\n   - Sort by due date\n\n5. **Filters & Search**\n   - All tasks, Active, Completed\n   - Search by title/description\n   - Filter by category and priority\n\n6. **Statistics**\n   - Total tasks\n   - Completed percentage\n   - Tasks by category\n   - Tasks by priority\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Project Structure",
              "content": "\n\n---\n\n",
              "code": "app/src/main/java/com/example/taskmaster/\n‚îú‚îÄ‚îÄ data/\n‚îÇ   ‚îú‚îÄ‚îÄ local/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TaskDatabase.kt\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TaskDao.kt\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ TaskEntity.kt\n‚îÇ   ‚îú‚îÄ‚îÄ repository/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ TaskRepository.kt\n‚îÇ   ‚îî‚îÄ‚îÄ model/\n‚îÇ       ‚îú‚îÄ‚îÄ Task.kt\n‚îÇ       ‚îú‚îÄ‚îÄ Category.kt\n‚îÇ       ‚îî‚îÄ‚îÄ Priority.kt\n‚îú‚îÄ‚îÄ di/\n‚îÇ   ‚îî‚îÄ‚îÄ AppModule.kt\n‚îú‚îÄ‚îÄ ui/\n‚îÇ   ‚îú‚îÄ‚îÄ theme/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Color.kt\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Theme.kt\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Type.kt\n‚îÇ   ‚îú‚îÄ‚îÄ components/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TaskItem.kt\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CategoryChip.kt\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ PriorityBadge.kt\n‚îÇ   ‚îú‚îÄ‚îÄ screens/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ home/\n‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ HomeScreen.kt\n‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ HomeViewModel.kt\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ addEdit/\n‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AddEditScreen.kt\n‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ AddEditViewModel.kt\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ statistics/\n‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ StatisticsScreen.kt\n‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ StatisticsViewModel.kt\n‚îÇ   ‚îî‚îÄ‚îÄ navigation/\n‚îÇ       ‚îî‚îÄ‚îÄ NavGraph.kt\n‚îî‚îÄ‚îÄ MainActivity.kt",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Complete Implementation",
              "content": "\n### 1. Data Models\n\n\n### 2. Database Layer\n\n\n### 3. Repository\n\n\n### 4. Dependency Injection\n\n\n### 5. Home Screen\n\n\n### 6. Add/Edit Screen\n\n\n### 7. Statistics Screen\n\n\n---\n\n",
              "code": "// ui/screens/statistics/StatisticsScreen.kt\n@Composable\nfun StatisticsScreen(\n    onNavigateBack: () -> Unit,\n    viewModel: StatisticsViewModel = hiltViewModel()\n) {\n    val stats by viewModel.stats.collectAsState()\n\n    Scaffold(\n        topBar = {\n            TopAppBar(\n                title = { Text(\"Statistics\") },\n                navigationIcon = {\n                    IconButton(onClick = onNavigateBack) {\n                        Icon(Icons.Default.ArrowBack, contentDescription = \"Back\")\n                    }\n                }\n            )\n        }\n    ) { innerPadding ->\n        Column(\n            modifier = Modifier\n                .fillMaxSize()\n                .padding(innerPadding)\n                .padding(16.dp),\n            verticalArrangement = Arrangement.spacedBy(16.dp)\n        ) {\n            // Summary cards\n            Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {\n                StatCard(\n                    title = \"Total\",\n                    value = stats.totalTasks.toString(),\n                    modifier = Modifier.weight(1f)\n                )\n                StatCard(\n                    title = \"Completed\",\n                    value = stats.completedTasks.toString(),\n                    modifier = Modifier.weight(1f)\n                )\n                StatCard(\n                    title = \"Active\",\n                    value = stats.activeTasks.toString(),\n                    modifier = Modifier.weight(1f)\n                )\n            }\n\n            // Completion percentage\n            LinearProgressIndicator(\n                progress = stats.completionPercentage,\n                modifier = Modifier.fillMaxWidth()\n            )\n            Text(\"${(stats.completionPercentage * 100).toInt()}% Completed\")\n\n            // By category\n            Text(\"By Category\", style = MaterialTheme.typography.titleMedium)\n            stats.byCategory.forEach { (category, count) ->\n                Row(\n                    modifier = Modifier.fillMaxWidth(),\n                    horizontalArrangement = Arrangement.SpaceBetween\n                ) {\n                    Text(\"${category.icon} ${category.displayName}\")\n                    Text(\"$count\")\n                }\n            }\n        }\n    }\n}\n\n@Composable\nfun StatCard(title: String, value: String, modifier: Modifier = Modifier) {\n    Card(modifier = modifier) {\n        Column(\n            modifier = Modifier.padding(16.dp),\n            horizontalAlignment = Alignment.CenterHorizontally\n        ) {\n            Text(value, style = MaterialTheme.typography.headlineMedium)\n            Text(title, style = MaterialTheme.typography.bodySmall)\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Extension Challenges",
              "content": "\nAfter completing the base project, try these advanced features:\n\n1. **Notifications**\n   - Remind user of upcoming due dates\n   - Use WorkManager for scheduling\n\n2. **Themes**\n   - Light/Dark mode toggle\n   - Custom color schemes\n\n3. **Cloud Sync**\n   - Firebase integration\n   - Sync across devices\n\n4. **Widgets**\n   - Home screen widget showing tasks\n   - Glance API\n\n5. **Collaboration**\n   - Share tasks with others\n   - Real-time updates\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Testing",
              "content": "\n\n---\n\n",
              "code": "@Test\nfun `adding task should insert to database`() = runTest {\n    val task = Task(\n        title = \"Test Task\",\n        category = Category.WORK,\n        priority = Priority.HIGH\n    )\n\n    repository.insertTask(task)\n\n    val tasks = repository.getAllTasks().first()\n    assertTrue(tasks.any { it.title == \"Test Task\" })\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "What You've Learned",
              "content": "\n‚úÖ Building a complete Android app from scratch\n‚úÖ MVVM architecture in practice\n‚úÖ Room database for local storage\n‚úÖ Navigation between multiple screens\n‚úÖ Material Design 3 implementation\n‚úÖ State management at scale\n‚úÖ Dependency injection with Hilt\n‚úÖ Animations and gestures\n‚úÖ Production-ready code structure\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Congratulations!",
              "content": "\nYou've completed **Part 6: Android Development with Kotlin**!\n\nYou can now:\n- Build modern Android apps with Jetpack Compose\n- Implement MVVM architecture\n- Manage local data with Room\n- Create beautiful UIs with Material Design 3\n- Handle navigation and state management\n- Add animations and gestures\n- Structure code for maintainability\n\n**Next Steps**:\n- Publish your app to Google Play\n- Learn advanced topics (WorkManager, Notifications, Services)\n- Explore Kotlin Multiplatform\n- Contribute to open-source Android projects\n- Build your portfolio with real apps\n\n**Keep building, keep learning!** üöÄ\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "6.2",
          "title": "Lesson 6.2: Introduction to Jetpack Compose",
          "moduleId": "module-06",
          "order": 3,
          "estimatedMinutes": 70,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 70 minutes\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "\nWelcome to the world of **Jetpack Compose** - Google's modern toolkit for building native Android UIs!\n\nTraditional Android development required XML layouts, `findViewById()` calls, and manual view updates. Compose changes everything with a **declarative** approach: you describe what the UI should look like, and Compose handles the rest.\n\nIn this lesson, you'll learn:\n- ‚úÖ What Jetpack Compose is and why it's revolutionary\n- ‚úÖ How to write composable functions\n- ‚úÖ Using Preview annotations for instant feedback\n- ‚úÖ Basic UI components (Text, Button, Image, Column, Row)\n- ‚úÖ Modifiers for styling and layout\n- ‚úÖ Basic state management with `remember`\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "What is Jetpack Compose?",
              "content": "\n### Declarative UI Framework\n\n**Imperative (Old Way)**:\n\n**Declarative (Compose Way)**:\n\n**Benefits**:\n- ‚úÖ Less code (40% reduction)\n- ‚úÖ Easier to read and maintain\n- ‚úÖ No manual view updates (automatic recomposition)\n- ‚úÖ Type-safe (compiler catches errors)\n\n### Compose vs XML Comparison\n\n| Feature           | XML + Views        | Jetpack Compose       |\n|-------------------|--------------------|-----------------------|\n| **Language**      | XML + Kotlin       | Kotlin only           |\n| **Lines of Code** | ~100 lines         | ~60 lines (40% less)  |\n| **Type Safety**   | No (IDs are ints)  | Yes (full type safety)|\n| **Preview**       | Limited            | Real-time, interactive|\n| **Reusability**   | Difficult          | Easy (functions)      |\n| **State Updates** | Manual             | Automatic             |\n\n---\n\n",
              "code": "// Describe WHAT the UI should look like\n@Composable\nfun MyScreen() {\n    var text by remember { mutableStateOf(\"Hello\") }\n\n    Column {\n        Text(\n            text = text,\n            fontSize = 20.sp,\n            color = Color.Blue\n        )\n        Button(onClick = { text = \"Clicked!\" }) {\n            Text(\"Click Me\")\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Composable Functions",
              "content": "\n### The @Composable Annotation\n\nA **composable function** is a regular Kotlin function annotated with `@Composable`:\n\n\n**Rules**:\n1. Must be annotated with `@Composable`\n2. Can only be called from other `@Composable` functions\n3. Can emit UI elements\n4. Can call other `@Composable` functions\n\n### Basic Composable\n\n\n### Composable Naming Convention\n\n**Convention**: Use **PascalCase** (same as classes):\n\n\n**Why?**\n- Composables represent UI components (like classes)\n- Distinguishes them from regular functions\n- Follows official Compose style guide\n\n---\n\n",
              "code": "@Composable\nfun UserProfile() { }  // ‚úÖ Good\n\n@Composable\nfun userProfile() { }  // ‚ùå Bad (should be PascalCase)",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Preview Annotations",
              "content": "\n### @Preview Basics\n\nThe `@Preview` annotation lets you see composables without running the app:\n\n\nClick the **Preview** tab (right side of editor) to see the UI instantly.\n\n### Preview Parameters\n\n\n### Multiple Previews\n\nPreview the same composable in different scenarios:\n\n\n### Interactive Preview\n\nClick the **Interactive Mode** button in preview to:\n- Click buttons\n- Type in text fields\n- Test interactions without running the app\n\n---\n\n",
              "code": "@Preview(name = \"Light Mode\", showBackground = true)\n@Preview(name = \"Large Text\", showBackground = true, fontScale = 2f)\n@Preview(name = \"Small Screen\", widthDp = 360, heightDp = 640)\n@Composable\nfun MultiPreview() {\n    WelcomeMessage()\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Basic UI Components",
              "content": "\n### Text\n\nDisplay text on screen:\n\n\n**Units**:\n- `sp` (scaled pixels): For text size (respects accessibility settings)\n- `dp` (density-independent pixels): For sizes, padding, margins\n\n### Button\n\nInteractive button with click handling:\n\n\n**Button variations**:\n\n\n### Image\n\nDisplay images from resources or URLs:\n\n\n**Content Scales**:\n- `ContentScale.Fit`: Fit entire image (may have empty space)\n- `ContentScale.Crop`: Fill entire area (may crop image)\n- `ContentScale.FillWidth`: Fill width, maintain aspect ratio\n- `ContentScale.FillHeight`: Fill height, maintain aspect ratio\n\n### Icon\n\nMaterial icons for common UI elements:\n\n\n**Popular icons**:\n- `Icons.Default.Home`\n- `Icons.Default.Settings`\n- `Icons.Default.Favorite`\n- `Icons.Default.Search`\n- `Icons.Default.Menu`\n- `Icons.Default.Person`\n- `Icons.Default.ShoppingCart`\n\n---\n\n",
              "code": "@Composable\nfun IconExamples() {\n    Row {\n        Icon(\n            imageVector = Icons.Default.Home,\n            contentDescription = \"Home\"\n        )\n\n        Icon(\n            imageVector = Icons.Default.Favorite,\n            contentDescription = \"Favorite\",\n            tint = Color.Red\n        )\n\n        Icon(\n            imageVector = Icons.Default.Settings,\n            contentDescription = \"Settings\",\n            modifier = Modifier.size(48.dp)\n        )\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Layout Composables",
              "content": "\n### Column (Vertical Stack)\n\nArrange children vertically:\n\n\nResult:\n\n### Row (Horizontal Stack)\n\nArrange children horizontally:\n\n\nResult:\n\n### Nested Layouts\n\nCombine `Column` and `Row`:\n\n\n---\n\n",
              "code": "@Composable\nfun ProfileCard() {\n    Column {\n        Text(\"John Doe\", fontSize = 24.sp, fontWeight = FontWeight.Bold)\n\n        Row {\n            Icon(Icons.Default.Email, contentDescription = \"Email\")\n            Text(\"john@example.com\")\n        }\n\n        Row {\n            Icon(Icons.Default.Phone, contentDescription = \"Phone\")\n            Text(\"+1 234 567 8900\")\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Modifiers",
              "content": "\n### What are Modifiers?\n\n**Modifiers** customize the appearance and behavior of composables:\n- Size (width, height)\n- Padding and margins\n- Background colors\n- Click handling\n- Alignment\n\n### Basic Modifiers\n\n\n### Padding\n\n\n### Background and Border\n\n\n### Clickable\n\n\n### Modifier Chaining\n\nOrder matters! Modifiers are applied sequentially:\n\n\n---\n\n",
              "code": "@Composable\nfun ModifierOrder() {\n    // Padding INSIDE background\n    Text(\n        \"Padding Inside\",\n        modifier = Modifier\n            .background(Color.Blue)\n            .padding(16.dp)  // Blue extends to edges, text has padding\n    )\n\n    // Padding OUTSIDE background\n    Text(\n        \"Padding Outside\",\n        modifier = Modifier\n            .padding(16.dp)  // Gap around blue background\n            .background(Color.Blue)\n    )\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "State Management Basics",
              "content": "\n### What is State?\n\n**State** is any value that can change over time and affects the UI.\n\nExamples:\n- Text field input\n- Counter value\n- Checkbox checked/unchecked\n- List of items\n\n### remember and mutableStateOf\n\n\n**How it works**:\n1. `mutableStateOf(0)` creates state with initial value `0`\n2. `remember { }` preserves state across recompositions\n3. `by` delegates property access (requires `import androidx.compose.runtime.getValue` and `setValue`)\n4. When `count` changes, Compose automatically recomposes (rebuilds) the UI\n\n### Without Delegation\n\n\n### Multiple State Variables\n\n\n---\n\n",
              "code": "@Composable\nfun LoginForm() {\n    var email by remember { mutableStateOf(\"\") }\n    var password by remember { mutableStateOf(\"\") }\n    var rememberMe by remember { mutableStateOf(false) }\n\n    Column {\n        Text(\"Email: $email\")\n        Text(\"Password: $password\")\n        Text(\"Remember: $rememberMe\")\n\n        Button(onClick = {\n            // Use state values\n            println(\"Login: $email / $password\")\n        }) {\n            Text(\"Login\")\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Putting It All Together",
              "content": "\n### Profile Card Example\n\n\n### Interactive Counter App\n\n\n---\n\n",
              "code": "@Composable\nfun CounterApp() {\n    var count by remember { mutableStateOf(0) }\n\n    Column(\n        modifier = Modifier\n            .fillMaxSize()\n            .padding(16.dp),\n        horizontalAlignment = Alignment.CenterHorizontally,\n        verticalArrangement = Arrangement.Center\n    ) {\n        Text(\n            text = \"Count: $count\",\n            fontSize = 48.sp,\n            fontWeight = FontWeight.Bold\n        )\n\n        Spacer(modifier = Modifier.height(16.dp))\n\n        Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {\n            Button(onClick = { count-- }) {\n                Text(\"-\")\n            }\n\n            Button(onClick = { count = 0 }) {\n                Text(\"Reset\")\n            }\n\n            Button(onClick = { count++ }) {\n                Text(\"+\")\n            }\n        }\n    }\n}\n\n@Preview(showBackground = true)\n@Composable\nfun CounterAppPreview() {\n    CounterApp()\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 1: Build a Business Card",
              "content": "\nCreate a digital business card with:\n- Your name (large, bold)\n- Your title (smaller, gray)\n- Email address with icon\n- Phone number with icon\n- Rounded corners and background color\n\n### Requirements\n\n\n---\n\n",
              "code": "@Composable\nfun BusinessCard() {\n    // Your implementation here\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Solution 1",
              "content": "\n\n---\n\n",
              "code": "import androidx.compose.foundation.background\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.Email\nimport androidx.compose.material.icons.filled.Phone\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.tooling.preview.Preview\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\n\n@Composable\nfun BusinessCard() {\n    Column(\n        modifier = Modifier\n            .fillMaxWidth()\n            .background(\n                color = Color(0xFF1976D2),\n                shape = RoundedCornerShape(16.dp)\n            )\n            .padding(24.dp),\n        horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        // Name\n        Text(\n            text = \"Alice Johnson\",\n            fontSize = 28.sp,\n            fontWeight = FontWeight.Bold,\n            color = Color.White\n        )\n\n        Spacer(modifier = Modifier.height(8.dp))\n\n        // Title\n        Text(\n            text = \"Android Developer\",\n            fontSize = 18.sp,\n            color = Color(0xFFB3E5FC)\n        )\n\n        Spacer(modifier = Modifier.height(24.dp))\n\n        // Email\n        Row(\n            verticalAlignment = Alignment.CenterVertically,\n            modifier = Modifier.fillMaxWidth()\n        ) {\n            Icon(\n                imageVector = Icons.Default.Email,\n                contentDescription = \"Email\",\n                tint = Color.White\n            )\n            Spacer(modifier = Modifier.width(8.dp))\n            Text(\n                text = \"alice@example.com\",\n                fontSize = 16.sp,\n                color = Color.White\n            )\n        }\n\n        Spacer(modifier = Modifier.height(12.dp))\n\n        // Phone\n        Row(\n            verticalAlignment = Alignment.CenterVertically,\n            modifier = Modifier.fillMaxWidth()\n        ) {\n            Icon(\n                imageVector = Icons.Default.Phone,\n                contentDescription = \"Phone\",\n                tint = Color.White\n            )\n            Spacer(modifier = Modifier.width(8.dp))\n            Text(\n                text = \"+1 (555) 123-4567\",\n                fontSize = 16.sp,\n                color = Color.White\n            )\n        }\n    }\n}\n\n@Preview(showBackground = true)\n@Composable\nfun BusinessCardPreview() {\n    BusinessCard()\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 2: Interactive Like Button",
              "content": "\nCreate a like button that:\n- Shows a heart icon\n- Toggles between outlined and filled when clicked\n- Changes color (gray ‚Üí red)\n- Shows like count that increments/decrements\n\n### Requirements\n\n\n---\n\n",
              "code": "@Composable\nfun LikeButton() {\n    // Your implementation here\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Solution 2",
              "content": "\n\n---\n\n",
              "code": "import androidx.compose.foundation.layout.*\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.Favorite\nimport androidx.compose.material.icons.outlined.FavoriteBorder\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.IconButton\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.tooling.preview.Preview\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\n\n@Composable\nfun LikeButton() {\n    var isLiked by remember { mutableStateOf(false) }\n    var likeCount by remember { mutableStateOf(42) }\n\n    Row(\n        verticalAlignment = Alignment.CenterVertically,\n        horizontalArrangement = Arrangement.Center,\n        modifier = Modifier.padding(16.dp)\n    ) {\n        IconButton(onClick = {\n            isLiked = !isLiked\n            likeCount = if (isLiked) likeCount + 1 else likeCount - 1\n        }) {\n            Icon(\n                imageVector = if (isLiked) Icons.Filled.Favorite else Icons.Outlined.FavoriteBorder,\n                contentDescription = if (isLiked) \"Unlike\" else \"Like\",\n                tint = if (isLiked) Color.Red else Color.Gray,\n                modifier = Modifier.size(32.dp)\n            )\n        }\n\n        Spacer(modifier = Modifier.width(4.dp))\n\n        Text(\n            text = \"$likeCount\",\n            fontSize = 18.sp,\n            color = if (isLiked) Color.Red else Color.Gray\n        )\n    }\n}\n\n@Preview(showBackground = true)\n@Composable\nfun LikeButtonPreview() {\n    LikeButton()\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 3: User List",
              "content": "\nCreate a list of 3 user profiles using the `ProfileCard` composable:\n\n### Requirements\n\n\n---\n\n",
              "code": "@Composable\nfun UserList() {\n    // Display 3 ProfileCards vertically\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Solution 3",
              "content": "\n\n---\n\n",
              "code": "import androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.Spacer\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.tooling.preview.Preview\nimport androidx.compose.ui.unit.dp\n\n@Composable\nfun UserList() {\n    Column {\n        ProfileCard(\n            name = \"Alice Johnson\",\n            role = \"Android Developer\",\n            imageRes = R.drawable.ic_launcher_foreground\n        )\n\n        Spacer(modifier = Modifier.height(8.dp))\n\n        ProfileCard(\n            name = \"Bob Smith\",\n            role = \"Product Manager\",\n            imageRes = R.drawable.ic_launcher_foreground\n        )\n\n        Spacer(modifier = Modifier.height(8.dp))\n\n        ProfileCard(\n            name = \"Carol Williams\",\n            role = \"UX Designer\",\n            imageRes = R.drawable.ic_launcher_foreground\n        )\n    }\n}\n\n@Preview(showBackground = true)\n@Composable\nfun UserListPreview() {\n    UserList()\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n### Real-World Impact\n\n**Companies Using Jetpack Compose**:\n- **Google**: Gmail, Google Play Store, Google Drive\n- **Twitter**: Android app rebuilt with Compose\n- **Airbnb**: Migrating to Compose\n- **Square**: Cash App using Compose\n\n**Benefits in Production**:\n- ‚úÖ 40% less code ‚Üí faster development\n- ‚úÖ Fewer bugs (type safety, automatic state management)\n- ‚úÖ Better performance (smart recomposition)\n- ‚úÖ Easier to test (composables are functions)\n- ‚úÖ Modern, maintainable codebase\n\n**Industry Trends**:\n- Compose is now the **recommended** way to build Android UIs\n- All new Google apps use Compose\n- Strong community support and growing ecosystem\n- Multiplatform: Compose for Desktop, Web, iOS (experimental)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Checkpoint Quiz",
              "content": "\n### Question 1\nWhat does the `@Composable` annotation do?\n\nA) Makes a function run faster\nB) Marks a function that can emit UI elements\nC) Automatically creates previews\nD) Enables state management\n\n### Question 2\nWhat is the purpose of `remember { mutableStateOf(0) }`?\n\nA) Improves performance by caching values\nB) Creates state that persists across recompositions\nC) Makes the variable immutable\nD) Enables preview mode\n\n### Question 3\nHow do you make a Text composable clickable?\n\nA) Add `onClick` parameter to Text\nB) Wrap it in a Button\nC) Use the `.clickable()` modifier\nD) Use the `@Clickable` annotation\n\n### Question 4\nWhat's the difference between `dp` and `sp`?\n\nA) They're the same thing\nB) `dp` for sizes/padding, `sp` for text (respects accessibility)\nC) `sp` is larger than `dp`\nD) `dp` only works on tablets\n\n### Question 5\nWhat happens when state changes in a composable?\n\nA) The entire app restarts\nB) The composable automatically recomposes (rebuilds)\nC) Nothing, you must manually update UI\nD) The state is lost\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Answers",
              "content": "\n**Question 1: B) Marks a function that can emit UI elements**\n\nThe `@Composable` annotation tells the Compose compiler:\n- This function describes UI\n- It can call other `@Composable` functions\n- It can only be called from composable context\n\n\n---\n\n**Question 2: B) Creates state that persists across recompositions**\n\nWithout `remember`, state is lost on every recomposition:\n\n\n---\n\n**Question 3: C) Use the `.clickable()` modifier**\n\n\nAlternative: Wrap in a `Button`, but that adds button styling.\n\n---\n\n**Question 4: B) `dp` for sizes/padding, `sp` for text (respects accessibility)**\n\n- **`dp`** (density-independent pixels): Fixed size, same on all devices\n  - Use for: padding, margins, component sizes\n- **`sp`** (scalable pixels): Scales with user's font size preference\n  - Use for: text size only\n  - Respects accessibility settings\n\n\n---\n\n**Question 5: B) The composable automatically recomposes (rebuilds)**\n\nCompose tracks state reads and automatically recomposes when state changes:\n\n\n**Smart Recomposition**: Only the composables that read the changed state are recomposed, not the entire UI.\n\n---\n\n",
              "code": "@Composable\nfun Counter() {\n    var count by remember { mutableStateOf(0) }\n\n    // When count changes:\n    // 1. Compose detects the change\n    // 2. Automatically calls Counter() again\n    // 3. UI updates with new count value\n\n    Text(\"Count: $count\")  // Auto-updates when count changes!\n    Button(onClick = { count++ }) { Text(\"+\") }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "What You've Learned",
              "content": "\n‚úÖ What Jetpack Compose is and its benefits over XML layouts\n‚úÖ How to write composable functions with `@Composable`\n‚úÖ Using `@Preview` for instant UI feedback\n‚úÖ Basic components: Text, Button, Image, Icon\n‚úÖ Layout composables: Column, Row\n‚úÖ Modifiers for styling (size, padding, background, clickable)\n‚úÖ State management basics with `remember` and `mutableStateOf`\n‚úÖ Building interactive UIs that respond to user input\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Next Steps",
              "content": "\nIn **Lesson 6.3: Layouts and UI Design**, you'll master:\n- Advanced layouts: Box, LazyColumn, LazyRow\n- Arrangement and alignment options\n- Material Design 3 components\n- Theming: colors, typography, shapes\n- Building complex, scrollable UIs\n- Responsive layouts\n\nGet ready to build professional-looking Android apps!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "6.2.1",
              "title": "Form State Management",
              "description": "Create a FormState data class with name and email fields, and a copy method to update individual fields.",
              "instructions": "Create a FormState data class with name and email fields, and a copy method to update individual fields.",
              "starterCode": "data class FormState(val name: String = \"\", val email: String = \"\")\n\nfun main() {\n    var formState = FormState()\n    println(\"Initial: $formState\")\n    \n    // Update name\n    formState = formState.copy(name = \"Alice\")\n    println(\"After name update: $formState\")\n    \n    // Update email\n    formState = formState.copy(email = \"alice@example.com\")\n    println(\"After email update: $formState\")\n}",
              "solution": "data class FormState(val name: String = \"\", val email: String = \"\")\n\nfun main() {\n    var formState = FormState()\n    println(\"Initial: $formState\")\n    \n    formState = formState.copy(name = \"Alice\")\n    println(\"After name update: $formState\")\n    \n    formState = formState.copy(email = \"alice@example.com\")\n    println(\"After email update: $formState\")\n}",
              "language": "kotlin",
              "testCases": [
                {
                  "description": "Initial state should be empty",
                  "expectedOutput": "Initial: FormState(name=, email=)",
                  "isVisible": true
                },
                {
                  "description": "Name should update",
                  "expectedOutput": "After name update: FormState(name=Alice, email=)",
                  "isVisible": true
                },
                {
                  "description": "Email should update",
                  "expectedOutput": "After email update: FormState(name=Alice, email=alice@example.com)",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Data classes automatically have copy() method"
                },
                {
                  "level": 2,
                  "text": "copy() creates new instance with specified changes"
                },
                {
                  "level": 3,
                  "text": "Use default parameter values for optional fields"
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "6.2.2",
              "title": "Form Validation",
              "description": "Create a validation function for a login form that checks email and password requirements.",
              "instructions": "Create a validation function for a login form that checks email and password requirements.",
              "starterCode": "data class LoginForm(val email: String, val password: String)\n\nfun validateLogin(form: LoginForm): Map<String, String> {\n    val errors = mutableMapOf<String, String>()\n    // Add validation logic\n    \n    return errors\n}\n\nfun main() {\n    val form1 = LoginForm(\"invalidemail\", \"short\")\n    println(\"Errors: ${validateLogin(form1)}\")\n    \n    val form2 = LoginForm(\"user@example.com\", \"password123\")\n    println(\"Valid: ${validateLogin(form2).isEmpty()}\")\n}",
              "solution": "data class LoginForm(val email: String, val password: String)\n\nfun validateLogin(form: LoginForm): Map<String, String> {\n    val errors = mutableMapOf<String, String>()\n    \n    if (!form.email.contains(\"@\")) {\n        errors[\"email\"] = \"Invalid email format\"\n    }\n    \n    if (form.password.length < 8) {\n        errors[\"password\"] = \"Password must be at least 8 characters\"\n    }\n    \n    return errors\n}\n\nfun main() {\n    val form1 = LoginForm(\"invalidemail\", \"short\")\n    println(\"Errors: ${validateLogin(form1)}\")\n    \n    val form2 = LoginForm(\"user@example.com\", \"password123\")\n    println(\"Valid: ${validateLogin(form2).isEmpty()}\")\n}",
              "language": "kotlin",
              "testCases": [
                {
                  "description": "Should detect validation errors",
                  "expectedOutput": "Errors: {email=Invalid email format, password=Password must be at least 8 characters}",
                  "isVisible": true
                },
                {
                  "description": "Should pass valid form",
                  "expectedOutput": "Valid: true",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use Map<String, String> for field-specific errors"
                },
                {
                  "level": 2,
                  "text": "Key is field name, value is error message"
                },
                {
                  "level": 3,
                  "text": "Check email contains @"
                },
                {
                  "level": 4,
                  "text": "Check password length >= 8"
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "6.2.3",
              "title": "Todo List State",
              "description": "Create a TodoListState class that manages a list of todos with add, toggle, and delete operations.",
              "instructions": "Create a TodoListState class that manages a list of todos with add, toggle, and delete operations.",
              "starterCode": "data class Todo(val id: Int, val text: String, var completed: Boolean = false)\n\nclass TodoListState {\n    private val todos = mutableListOf<Todo>()\n    private var nextId = 1\n    \n    fun addTodo(text: String) {\n        // Add new todo\n    }\n    \n    fun toggleTodo(id: Int) {\n        // Toggle completed status\n    }\n    \n    fun getTodos(): List<Todo> = todos.toList()\n}\n\nfun main() {\n    val state = TodoListState()\n    state.addTodo(\"Learn Kotlin\")\n    state.addTodo(\"Build app\")\n    println(\"Todos: ${state.getTodos()}\")\n    state.toggleTodo(1)\n    println(\"After toggle: ${state.getTodos()}\")\n}",
              "solution": "data class Todo(val id: Int, val text: String, var completed: Boolean = false)\n\nclass TodoListState {\n    private val todos = mutableListOf<Todo>()\n    private var nextId = 1\n    \n    fun addTodo(text: String) {\n        todos.add(Todo(nextId++, text))\n    }\n    \n    fun toggleTodo(id: Int) {\n        todos.find { it.id == id }?.let { it.completed = !it.completed }\n    }\n    \n    fun getTodos(): List<Todo> = todos.toList()\n}\n\nfun main() {\n    val state = TodoListState()\n    state.addTodo(\"Learn Kotlin\")\n    state.addTodo(\"Build app\")\n    println(\"Todos: ${state.getTodos()}\")\n    state.toggleTodo(1)\n    println(\"After toggle: ${state.getTodos()}\")\n}",
              "language": "kotlin",
              "testCases": [
                {
                  "description": "Should add todos",
                  "expectedOutput": "Todos: [Todo(id=1, text=Learn Kotlin, completed=false), Todo(id=2, text=Build app, completed=false)]",
                  "isVisible": true
                },
                {
                  "description": "Should toggle completion",
                  "expectedOutput": "After toggle: [Todo(id=1, text=Learn Kotlin, completed=true), Todo(id=2, text=Build app, completed=false)]",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use nextId++ to auto-increment IDs"
                },
                {
                  "level": 2,
                  "text": "find() returns first matching element"
                },
                {
                  "level": 3,
                  "text": "Use let to safely operate on nullable result"
                },
                {
                  "level": 4,
                  "text": "Toggle with: completed = !completed"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "6.3",
          "title": "Lesson 6.3: Layouts and UI Design",
          "moduleId": "module-06",
          "order": 4,
          "estimatedMinutes": 75,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 75 minutes\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "\nBeautiful UI is crucial for app success. Users judge apps within **milliseconds** - if your UI looks outdated or confusing, users uninstall.\n\nIn this lesson, you'll master:\n- ‚úÖ Advanced layout composables (Box, LazyColumn, LazyRow)\n- ‚úÖ Arrangement and alignment strategies\n- ‚úÖ Spacer for spacing control\n- ‚úÖ Material Design 3 components\n- ‚úÖ Theming: colors, typography, shapes\n- ‚úÖ Building complex, professional UIs\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Advanced Layout Composables",
              "content": "\n### Box (Stacking/Overlapping)\n\n`Box` stacks children on top of each other (like `FrameLayout` in XML):\n\n\n**Alignment options**:\n\n### LazyColumn (Efficient Vertical List)\n\n`LazyColumn` is like `RecyclerView` - only renders visible items:\n\n\n**With custom data**:\n\n\n**Key with items for better performance**:\n\n\n### LazyRow (Efficient Horizontal List)\n\nSame as `LazyColumn` but horizontal:\n\n\n### LazyVerticalGrid (Grid Layout)\n\nDisplay items in a grid:\n\n\n**Grid column options**:\n\n---\n\n",
              "code": "GridCells.Fixed(3)              // Exactly 3 columns\nGridCells.Adaptive(120.dp)      // As many columns as fit (min 120dp each)\nGridCells.FixedSize(120.dp)     // Fixed column width",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Arrangement and Alignment",
              "content": "\n### Column Arrangement\n\nControl vertical spacing:\n\n\n### Column Alignment\n\nControl horizontal alignment of children:\n\n\n### Row Arrangement and Alignment\n\n\n---\n\n",
              "code": "@Composable\nfun RowLayouts() {\n    // Horizontal arrangement\n    Row(horizontalArrangement = Arrangement.SpaceBetween) {\n        Text(\"Left\")\n        Text(\"Right\")\n    }\n\n    // Vertical alignment\n    Row(verticalAlignment = Alignment.Top) { }\n    Row(verticalAlignment = Alignment.CenterVertically) { }\n    Row(verticalAlignment = Alignment.Bottom) { }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Spacer",
              "content": "\nCreate fixed spacing between composables:\n\n\n---\n\n",
              "code": "@Composable\nfun SpacerExamples() {\n    Column {\n        Text(\"First\")\n        Spacer(modifier = Modifier.height(16.dp))\n        Text(\"Second\")\n    }\n\n    Row {\n        Text(\"Left\")\n        Spacer(modifier = Modifier.width(24.dp))\n        Text(\"Right\")\n    }\n\n    // Fill available space\n    Row(modifier = Modifier.fillMaxWidth()) {\n        Text(\"Left\")\n        Spacer(modifier = Modifier.weight(1f))  // Takes all remaining space\n        Text(\"Right\")\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Material Design 3 Components",
              "content": "\n### Cards\n\n\n**Clickable cards**:\n\n\n### Surface\n\nMaterial surface with elevation and color:\n\n\n### Divider\n\nVisual separator:\n\n\n### Chips\n\n\n### TextField\n\n\n### Checkbox, Switch, RadioButton\n\n\n### Slider\n\n\n---\n\n",
              "code": "@Composable\nfun SliderExample() {\n    var sliderValue by remember { mutableStateOf(50f) }\n\n    Column {\n        Text(\"Volume: ${sliderValue.toInt()}%\")\n\n        Slider(\n            value = sliderValue,\n            onValueChange = { sliderValue = it },\n            valueRange = 0f..100f,\n            steps = 10  // Creates 11 discrete values (0, 10, 20, ..., 100)\n        )\n\n        // Range slider\n        var rangeValues by remember { mutableStateOf(20f..80f) }\n        Text(\"Range: ${rangeValues.start.toInt()} - ${rangeValues.endInclusive.toInt()}\")\n\n        RangeSlider(\n            value = rangeValues,\n            onValueChange = { rangeValues = it },\n            valueRange = 0f..100f\n        )\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Material Design 3 Theming",
              "content": "\n### Color Scheme\n\nMaterial 3 uses a **dynamic color system**:\n\n\n### Theme Setup\n\n\n### Typography\n\n\n### Using Theme\n\n\n---\n\n",
              "code": "@Composable\nfun ThemedContent() {\n    // Access theme colors\n    val backgroundColor = MaterialTheme.colorScheme.background\n    val primaryColor = MaterialTheme.colorScheme.primary\n    val textColor = MaterialTheme.colorScheme.onBackground\n\n    Column(\n        modifier = Modifier\n            .fillMaxSize()\n            .background(backgroundColor)\n    ) {\n        // Use theme typography\n        Text(\n            \"Headline\",\n            style = MaterialTheme.typography.headlineLarge,\n            color = MaterialTheme.colorScheme.onBackground\n        )\n\n        Text(\n            \"Body text\",\n            style = MaterialTheme.typography.bodyMedium\n        )\n\n        // Components automatically use theme colors\n        Button(onClick = { }) {\n            Text(\"Themed Button\")  // Uses primary color\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 1: Product Card",
              "content": "\nCreate a product card with:\n- Product image at top\n- Product name (bold, large)\n- Price (primary color)\n- Short description\n- \"Add to Cart\" button\n- Material 3 card with elevation\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 1",
              "content": "\n\n---\n\n",
              "code": "import androidx.compose.foundation.Image\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.AddShoppingCart\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.layout.ContentScale\nimport androidx.compose.ui.res.painterResource\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.tooling.preview.Preview\nimport androidx.compose.ui.unit.dp\n\n@Composable\nfun ProductCard(\n    name: String,\n    price: Double,\n    description: String,\n    imageRes: Int,\n    onAddToCart: () -> Unit\n) {\n    ElevatedCard(\n        modifier = Modifier\n            .fillMaxWidth()\n            .padding(16.dp),\n        elevation = CardDefaults.elevatedCardElevation(\n            defaultElevation = 4.dp\n        ),\n        shape = RoundedCornerShape(12.dp)\n    ) {\n        Column {\n            // Product image\n            Image(\n                painter = painterResource(imageRes),\n                contentDescription = name,\n                contentScale = ContentScale.Crop,\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .height(200.dp)\n            )\n\n            Column(modifier = Modifier.padding(16.dp)) {\n                // Product name\n                Text(\n                    text = name,\n                    style = MaterialTheme.typography.titleLarge,\n                    fontWeight = FontWeight.Bold\n                )\n\n                Spacer(modifier = Modifier.height(8.dp))\n\n                // Price\n                Text(\n                    text = \"$${\"%.2f\".format(price)}\",\n                    style = MaterialTheme.typography.titleMedium,\n                    color = MaterialTheme.colorScheme.primary,\n                    fontWeight = FontWeight.Bold\n                )\n\n                Spacer(modifier = Modifier.height(8.dp))\n\n                // Description\n                Text(\n                    text = description,\n                    style = MaterialTheme.typography.bodyMedium,\n                    color = MaterialTheme.colorScheme.onSurfaceVariant\n                )\n\n                Spacer(modifier = Modifier.height(16.dp))\n\n                // Add to Cart button\n                Button(\n                    onClick = onAddToCart,\n                    modifier = Modifier.fillMaxWidth()\n                ) {\n                    Icon(\n                        Icons.Default.AddShoppingCart,\n                        contentDescription = null,\n                        modifier = Modifier.size(18.dp)\n                    )\n                    Spacer(modifier = Modifier.width(8.dp))\n                    Text(\"Add to Cart\")\n                }\n            }\n        }\n    }\n}\n\n@Preview(showBackground = true)\n@Composable\nfun ProductCardPreview() {\n    MaterialTheme {\n        ProductCard(\n            name = \"Wireless Headphones\",\n            price = 129.99,\n            description = \"Premium noise-cancelling headphones with 30-hour battery life.\",\n            imageRes = R.drawable.ic_launcher_foreground,\n            onAddToCart = { }\n        )\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 2: Settings Screen",
              "content": "\nCreate a settings screen with:\n- Section headers\n- Toggle switches for notifications\n- Navigation items (Profile, Privacy, About)\n- Dividers between sections\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 2",
              "content": "\n\n---\n\n",
              "code": "import androidx.compose.foundation.clickable\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.*\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.tooling.preview.Preview\nimport androidx.compose.ui.unit.dp\n\n@Composable\nfun SettingsScreen() {\n    Column(modifier = Modifier.fillMaxSize()) {\n        // Header\n        Surface(\n            modifier = Modifier.fillMaxWidth(),\n            color = MaterialTheme.colorScheme.primaryContainer\n        ) {\n            Text(\n                \"Settings\",\n                style = MaterialTheme.typography.headlineMedium,\n                modifier = Modifier.padding(16.dp)\n            )\n        }\n\n        // Notifications section\n        SettingsSectionHeader(\"Notifications\")\n\n        var pushNotifications by remember { mutableStateOf(true) }\n        SettingsToggle(\n            title = \"Push Notifications\",\n            subtitle = \"Receive push notifications\",\n            checked = pushNotifications,\n            onCheckedChange = { pushNotifications = it },\n            icon = Icons.Default.Notifications\n        )\n\n        var emailNotifications by remember { mutableStateOf(false) }\n        SettingsToggle(\n            title = \"Email Notifications\",\n            subtitle = \"Receive email updates\",\n            checked = emailNotifications,\n            onCheckedChange = { emailNotifications = it },\n            icon = Icons.Default.Email\n        )\n\n        HorizontalDivider(modifier = Modifier.padding(vertical = 8.dp))\n\n        // Account section\n        SettingsSectionHeader(\"Account\")\n\n        SettingsItem(\n            title = \"Profile\",\n            subtitle = \"Edit your profile information\",\n            icon = Icons.Default.Person,\n            onClick = { }\n        )\n\n        SettingsItem(\n            title = \"Privacy\",\n            subtitle = \"Manage your privacy settings\",\n            icon = Icons.Default.Lock,\n            onClick = { }\n        )\n\n        SettingsItem(\n            title = \"About\",\n            subtitle = \"App version and information\",\n            icon = Icons.Default.Info,\n            onClick = { }\n        )\n    }\n}\n\n@Composable\nfun SettingsSectionHeader(title: String) {\n    Text(\n        text = title,\n        style = MaterialTheme.typography.titleSmall,\n        color = MaterialTheme.colorScheme.primary,\n        modifier = Modifier.padding(horizontal = 16.dp, vertical = 8.dp)\n    )\n}\n\n@Composable\nfun SettingsToggle(\n    title: String,\n    subtitle: String,\n    checked: Boolean,\n    onCheckedChange: (Boolean) -> Unit,\n    icon: androidx.compose.ui.graphics.vector.ImageVector\n) {\n    Row(\n        modifier = Modifier\n            .fillMaxWidth()\n            .padding(horizontal = 16.dp, vertical = 12.dp),\n        verticalAlignment = Alignment.CenterVertically\n    ) {\n        Icon(\n            imageVector = icon,\n            contentDescription = null,\n            tint = MaterialTheme.colorScheme.primary\n        )\n\n        Spacer(modifier = Modifier.width(16.dp))\n\n        Column(modifier = Modifier.weight(1f)) {\n            Text(\n                text = title,\n                style = MaterialTheme.typography.bodyLarge\n            )\n            Text(\n                text = subtitle,\n                style = MaterialTheme.typography.bodySmall,\n                color = MaterialTheme.colorScheme.onSurfaceVariant\n            )\n        }\n\n        Switch(\n            checked = checked,\n            onCheckedChange = onCheckedChange\n        )\n    }\n}\n\n@Composable\nfun SettingsItem(\n    title: String,\n    subtitle: String,\n    icon: androidx.compose.ui.graphics.vector.ImageVector,\n    onClick: () -> Unit\n) {\n    Row(\n        modifier = Modifier\n            .fillMaxWidth()\n            .clickable(onClick = onClick)\n            .padding(horizontal = 16.dp, vertical = 12.dp),\n        verticalAlignment = Alignment.CenterVertically\n    ) {\n        Icon(\n            imageVector = icon,\n            contentDescription = null,\n            tint = MaterialTheme.colorScheme.primary\n        )\n\n        Spacer(modifier = Modifier.width(16.dp))\n\n        Column(modifier = Modifier.weight(1f)) {\n            Text(\n                text = title,\n                style = MaterialTheme.typography.bodyLarge\n            )\n            Text(\n                text = subtitle,\n                style = MaterialTheme.typography.bodySmall,\n                color = MaterialTheme.colorScheme.onSurfaceVariant\n            )\n        }\n\n        Icon(\n            imageVector = Icons.Default.ChevronRight,\n            contentDescription = \"Navigate\",\n            tint = MaterialTheme.colorScheme.onSurfaceVariant\n        )\n    }\n}\n\n@Preview(showBackground = true)\n@Composable\nfun SettingsScreenPreview() {\n    MaterialTheme {\n        SettingsScreen()\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 3: Photo Gallery Grid",
              "content": "\nCreate a photo gallery with:\n- 3-column grid layout\n- Square images\n- Rounded corners\n- Spacing between items\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 3",
              "content": "\n\n---\n\n",
              "code": "import androidx.compose.foundation.Image\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.lazy.grid.GridCells\nimport androidx.compose.foundation.lazy.grid.LazyVerticalGrid\nimport androidx.compose.foundation.lazy.grid.items\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.clip\nimport androidx.compose.ui.layout.ContentScale\nimport androidx.compose.ui.res.painterResource\nimport androidx.compose.ui.tooling.preview.Preview\nimport androidx.compose.ui.unit.dp\n\ndata class Photo(val id: Int, val resourceId: Int)\n\n@Composable\nfun PhotoGallery(photos: List<Photo>) {\n    LazyVerticalGrid(\n        columns = GridCells.Fixed(3),\n        contentPadding = PaddingValues(8.dp),\n        horizontalArrangement = Arrangement.spacedBy(8.dp),\n        verticalArrangement = Arrangement.spacedBy(8.dp)\n    ) {\n        items(photos, key = { it.id }) { photo ->\n            Image(\n                painter = painterResource(photo.resourceId),\n                contentDescription = \"Photo ${photo.id}\",\n                contentScale = ContentScale.Crop,\n                modifier = Modifier\n                    .aspectRatio(1f)  // Square\n                    .clip(RoundedCornerShape(8.dp))\n            )\n        }\n    }\n}\n\n@Preview(showBackground = true)\n@Composable\nfun PhotoGalleryPreview() {\n    val samplePhotos = List(12) { index ->\n        Photo(\n            id = index,\n            resourceId = R.drawable.ic_launcher_foreground\n        )\n    }\n\n    PhotoGallery(photos = samplePhotos)\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n### Real-World Impact\n\n**User Statistics**:\n- **94%** of first impressions are design-related\n- **88%** of users won't return after a bad experience\n- **75%** judge credibility based on design\n- Apps with good UI have **3x** higher retention\n\n**Business Impact**:\n- Well-designed apps get **5x more downloads**\n- Higher ratings (4.5+ stars) increase installs by **300%**\n- Better UI reduces support requests by **40%**\n\n**Material Design 3 Benefits**:\n- ‚úÖ **Consistent**: Familiar patterns across apps\n- ‚úÖ **Accessible**: Built-in accessibility features\n- ‚úÖ **Adaptive**: Dynamic colors on Android 12+\n- ‚úÖ **Modern**: Fresh, contemporary look\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Checkpoint Quiz",
              "content": "\n### Question 1\nWhat's the main difference between `Column` and `LazyColumn`?\n\nA) Column is faster\nB) LazyColumn only renders visible items (efficient for long lists)\nC) Column supports more composables\nD) LazyColumn is deprecated\n\n### Question 2\nWhich modifier creates spacing between items in a Column?\n\nA) `Modifier.spacing(16.dp)`\nB) `Arrangement.spacedBy(16.dp)`\nC) `Modifier.gap(16.dp)`\nD) `Spacer(16.dp)`\n\n### Question 3\nWhat does `GridCells.Adaptive(120.dp)` do?\n\nA) Creates exactly 120 columns\nB) Creates as many columns as fit (each min 120dp wide)\nC) Makes each cell 120dp tall\nD) Limits grid to 120 items\n\n### Question 4\nWhy use `sp` for text size instead of `dp`?\n\nA) sp is smaller\nB) sp looks better\nC) sp scales with user's font size preference (accessibility)\nD) sp is required by Material Design\n\n### Question 5\nWhat is Material Design 3's dynamic color feature?\n\nA) Colors change randomly\nB) Colors adapt based on user's wallpaper (Android 12+)\nC) Colors animate automatically\nD) Developers can't customize colors\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Answers",
              "content": "\n**Question 1: B) LazyColumn only renders visible items (efficient for long lists)**\n\n\n**Performance**:\n- Column with 1000 items: Slow, high memory usage\n- LazyColumn with 1000 items: Fast, low memory (like RecyclerView)\n\n---\n\n**Question 2: B) `Arrangement.spacedBy(16.dp)`**\n\n\n---\n\n**Question 3: B) Creates as many columns as fit (each min 120dp wide)**\n\n\n**Benefits**:\n- Responsive: Adapts to screen size\n- Works on phones, tablets, foldables\n\n---\n\n**Question 4: C) sp scales with user's font size preference (accessibility)**\n\n\n**Accessibility**:\n- Users can increase font size in Settings\n- `sp` respects this preference\n- `dp` does not\n\n**Use `dp` for**: padding, margins, component sizes\n**Use `sp` for**: text size only\n\n---\n\n**Question 5: B) Colors adapt based on user's wallpaper (Android 12+)**\n\nMaterial Design 3's dynamic color extracts colors from the user's wallpaper:\n\n\n**Benefits**:\n- Personalized: Each user gets unique colors\n- Cohesive: Matches system UI\n- Fresh: Changes with wallpaper\n\n---\n\n",
              "code": "@Composable\nfun AppTheme(\n    dynamicColor: Boolean = true,\n    content: @Composable () -> Unit\n) {\n    val colorScheme = when {\n        dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {\n            // Extract colors from wallpaper\n            if (darkTheme) {\n                dynamicDarkColorScheme(LocalContext.current)\n            } else {\n                dynamicLightColorScheme(LocalContext.current)\n            }\n        }\n        else -> {\n            // Fallback to static colors\n            if (darkTheme) DarkColorScheme else LightColorScheme\n        }\n    }\n\n    MaterialTheme(colorScheme = colorScheme, content = content)\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "What You've Learned",
              "content": "\n‚úÖ Advanced layouts: Box, LazyColumn, LazyRow, LazyVerticalGrid\n‚úÖ Arrangement and alignment options for precise positioning\n‚úÖ Spacer for controlling spacing\n‚úÖ Material Design 3 components: Cards, Chips, TextFields, Sliders\n‚úÖ Selection controls: Checkbox, Switch, RadioButton\n‚úÖ Theming system: ColorScheme, Typography, Shapes\n‚úÖ Dynamic colors on Android 12+\n‚úÖ Building complex, professional UIs with Material Design 3\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Next Steps",
              "content": "\nIn **Lesson 6.4: State Management**, you'll master:\n- Deep dive into state and recomposition\n- `remember` vs `rememberSaveable`\n- State hoisting patterns\n- ViewModel integration\n- Managing complex state\n- Best practices for state management\n\nGet ready to build truly interactive, data-driven apps!\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "6.4",
          "title": "Lesson 6.4: State Management",
          "moduleId": "module-06",
          "order": 5,
          "estimatedMinutes": 70,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 70 minutes\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "\nState is the **heart** of any interactive app. When a user clicks a button, types text, or scrolls a list - all of these change state, and the UI must respond.\n\nIn Jetpack Compose, state management is **declarative** and **automatic**. When state changes, Compose intelligently recomposes only the affected parts of the UI.\n\nIn this lesson, you'll master:\n- ‚úÖ Understanding state and recomposition\n- ‚úÖ `remember` vs `rememberSaveable`\n- ‚úÖ State hoisting pattern\n- ‚úÖ ViewModel integration\n- ‚úÖ Different state holders and patterns\n- ‚úÖ Best practices for managing state\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "What is State?",
              "content": "\n**State** is any value that can change over time and affects what's displayed in the UI.\n\n### Examples of State\n\n\n---\n\n",
              "code": "// UI state\nvar isLoading: Boolean = false\nvar errorMessage: String? = null\nvar searchQuery: String = \"\"\n\n// Data state\nvar userProfile: User? = null\nvar todoList: List<Todo> = emptyList()\nvar selectedTab: Int = 0\n\n// Form state\nvar email: String = \"\"\nvar password: String = \"\"\nvar agreeToTerms: Boolean = false",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Recomposition",
              "content": "\n### What is Recomposition?\n\n**Recomposition** is when Compose re-executes composable functions to update the UI after state changes.\n\n\n**Flow**:\n1. User clicks button\n2. `count` increases\n3. Compose detects state change\n4. Recomposes `Text(\"Count: $count\")`\n5. UI updates with new value\n\n### Smart Recomposition\n\nCompose only recomposes what's necessary:\n\n\n**Optimization**: Only the `Text` displaying `count` recomposes, not the entire `Column`.\n\n---\n\n",
              "code": "@Composable\nfun SmartRecomposition() {\n    var count by remember { mutableStateOf(0) }\n\n    Column {\n        Text(\"Static text\")  // ‚ùå Never recomposes\n\n        Text(\"Count: $count\")  // ‚úÖ Recomposes when count changes\n\n        Button(onClick = { count++ }) {\n            Text(\"Increment\")  // ‚ùå Never recomposes\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "KEY_POINT",
              "title": "remember vs rememberSaveable",
              "content": "\n### remember\n\nPreserves state across recompositions but **lost on configuration changes** (rotation, language change):\n\n\n### rememberSaveable\n\nPreserves state across **recompositions AND configuration changes**:\n\n\n### When to Use Each\n\n| Use Case                          | Use                |\n|-----------------------------------|--------------------|\n| Temporary UI state (dialog open) | `remember`         |\n| Form input                        | `rememberSaveable` |\n| User selections                   | `rememberSaveable` |\n| Scroll position                   | `rememberSaveable` |\n| Animation values                  | `remember`         |\n\n### Custom Saver\n\nFor complex objects, implement a custom `Saver`:\n\n\n---\n\n",
              "code": "data class User(val name: String, val email: String)\n\n@Composable\nfun CustomSaverExample() {\n    var user by rememberSaveable(stateSaver = UserSaver) {\n        mutableStateOf(User(\"\", \"\"))\n    }\n\n    // user survives configuration changes\n}\n\nval UserSaver = Saver<User, List<String>>(\n    save = { listOf(it.name, it.email) },\n    restore = { User(it[0], it[1]) }\n)",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "State Hoisting",
              "content": "\n### What is State Hoisting?\n\n**State hoisting** means moving state to a composable's caller to make it stateless and reusable.\n\n**Bad (Stateful)**:\n\n\n**Good (Stateless)**:\n\n\n### Benefits of State Hoisting\n\n- ‚úÖ **Reusable**: Composable can be used with different state\n- ‚úÖ **Testable**: Easy to test with different inputs\n- ‚úÖ **Single source of truth**: State in one place\n- ‚úÖ **Control**: Parent controls state\n\n### Pattern\n\n\n---\n\n",
              "code": "// Stateless composable (receives state + callbacks)\n@Composable\nfun MyComponent(\n    value: String,\n    onValueChange: (String) -> Unit,\n    modifier: Modifier = Modifier\n) {\n    // UI implementation\n}\n\n// Stateful wrapper (manages state)\n@Composable\nfun MyComponentStateful() {\n    var value by remember { mutableStateOf(\"\") }\n\n    MyComponent(\n        value = value,\n        onValueChange = { value = it }\n    )\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "ViewModel Integration",
              "content": "\n### Why ViewModel?\n\n**ViewModel** survives configuration changes and manages UI-related data:\n\n\n### Setup\n\nAdd dependencies in `build.gradle.kts`:\n\n\nIn `gradle/libs.versions.toml`:\n\n\n### Creating a ViewModel\n\n\n### Using ViewModel in Composable\n\n\n---\n\n",
              "code": "import androidx.lifecycle.viewmodel.compose.viewModel\nimport androidx.compose.runtime.collectAsState\n\n@Composable\nfun TodoScreen(\n    viewModel: TodoViewModel = viewModel()\n) {\n    val uiState by viewModel.uiState.collectAsState()\n\n    Column(modifier = Modifier.fillMaxSize()) {\n        if (uiState.isLoading) {\n            CircularProgressIndicator()\n        }\n\n        uiState.errorMessage?.let { error ->\n            Text(\"Error: $error\", color = Color.Red)\n        }\n\n        LazyColumn {\n            items(uiState.todos.size) { index ->\n                TodoItem(\n                    todo = uiState.todos[index],\n                    onDelete = { viewModel.removeTodo(index) }\n                )\n            }\n        }\n\n        var newTodo by remember { mutableStateOf(\"\") }\n        Row {\n            TextField(\n                value = newTodo,\n                onValueChange = { newTodo = it }\n            )\n            Button(onClick = {\n                viewModel.addTodo(newTodo)\n                newTodo = \"\"\n            }) {\n                Text(\"Add\")\n            }\n        }\n    }\n}\n\n@Composable\nfun TodoItem(todo: String, onDelete: () -> Unit) {\n    Row(\n        modifier = Modifier\n            .fillMaxWidth()\n            .padding(16.dp),\n        horizontalArrangement = Arrangement.SpaceBetween\n    ) {\n        Text(todo)\n        IconButton(onClick = onDelete) {\n            Icon(Icons.Default.Delete, contentDescription = \"Delete\")\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "State Holders",
              "content": "\n### Different State Holder Types\n\n\n### When to Use Each\n\n| State Type            | Use Case                              |\n|-----------------------|---------------------------------------|\n| `remember { mutableStateOf }` | Simple values (counter, toggle) |\n| State object          | Related values (form fields)          |\n| State holder class    | Complex logic + multiple values       |\n| ViewModel             | Screen state, survives config changes |\n\n---\n\n",
              "code": "// 1. Plain state (for simple values)\nvar count by remember { mutableStateOf(0) }\n\n// 2. State object (for related state)\ndata class FormState(\n    val email: String = \"\",\n    val password: String = \"\",\n    val isValid: Boolean = false\n)\n\nvar formState by remember { mutableStateOf(FormState()) }\n\n// 3. State holder class (for complex logic)\n@Stable\nclass SearchState(\n    initialQuery: String = \"\"\n) {\n    var query by mutableStateOf(initialQuery)\n        private set\n\n    var suggestions by mutableStateOf<List<String>>(emptyList())\n        private set\n\n    fun updateQuery(newQuery: String) {\n        query = newQuery\n        // Update suggestions based on query\n        suggestions = getSuggestions(newQuery)\n    }\n\n    private fun getSuggestions(query: String): List<String> {\n        // Logic to fetch suggestions\n        return emptyList()\n    }\n}\n\n@Composable\nfun rememberSearchState() = remember { SearchState() }\n\n// 4. ViewModel (for screen-level state)\nclass MyViewModel : ViewModel() {\n    val uiState: StateFlow<UiState> = /* ... */\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Derived State",
              "content": "\nState computed from other state:\n\n\n---\n\n",
              "code": "@Composable\nfun DerivedStateExample() {\n    var firstName by remember { mutableStateOf(\"\") }\n    var lastName by remember { mutableStateOf(\"\") }\n\n    // ‚ùå Bad: Recomposes on every keystroke\n    val fullName = \"$firstName $lastName\"\n\n    // ‚úÖ Good: Only recomposes when firstName or lastName change\n    val fullName by remember(firstName, lastName) {\n        derivedStateOf { \"$firstName $lastName\" }\n    }\n\n    Column {\n        TextField(value = firstName, onValueChange = { firstName = it })\n        TextField(value = lastName, onValueChange = { lastName = it })\n        Text(\"Full name: $fullName\")\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 1: Login Form",
              "content": "\nCreate a login form with:\n- Email and password fields\n- \"Remember me\" checkbox\n- Login button (disabled until valid)\n- State hoisting pattern\n\n### Requirements\n\n- Email must contain \"@\"\n- Password must be 6+ characters\n- Button enabled only when both valid\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 1",
              "content": "\n\n---\n\n",
              "code": "import androidx.compose.foundation.layout.*\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.Email\nimport androidx.compose.material.icons.filled.Lock\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.text.input.PasswordVisualTransformation\nimport androidx.compose.ui.tooling.preview.Preview\nimport androidx.compose.ui.unit.dp\n\ndata class LoginState(\n    val email: String = \"\",\n    val password: String = \"\",\n    val rememberMe: Boolean = false\n) {\n    val isValid: Boolean\n        get() = email.contains(\"@\") && password.length >= 6\n}\n\n@Composable\nfun LoginScreen() {\n    var loginState by rememberSaveable(stateSaver = LoginStateSaver) {\n        mutableStateOf(LoginState())\n    }\n\n    LoginForm(\n        loginState = loginState,\n        onEmailChange = { loginState = loginState.copy(email = it) },\n        onPasswordChange = { loginState = loginState.copy(password = it) },\n        onRememberMeChange = { loginState = loginState.copy(rememberMe = it) },\n        onLoginClick = {\n            // Handle login\n            println(\"Login: ${loginState.email}\")\n        }\n    )\n}\n\n@Composable\nfun LoginForm(\n    loginState: LoginState,\n    onEmailChange: (String) -> Unit,\n    onPasswordChange: (String) -> Unit,\n    onRememberMeChange: (Boolean) -> Unit,\n    onLoginClick: () -> Unit,\n    modifier: Modifier = Modifier\n) {\n    Column(\n        modifier = modifier\n            .fillMaxSize()\n            .padding(24.dp),\n        horizontalAlignment = Alignment.CenterHorizontally,\n        verticalArrangement = Arrangement.Center\n    ) {\n        Text(\n            \"Login\",\n            style = MaterialTheme.typography.headlineLarge\n        )\n\n        Spacer(modifier = Modifier.height(32.dp))\n\n        // Email field\n        OutlinedTextField(\n            value = loginState.email,\n            onValueChange = onEmailChange,\n            label = { Text(\"Email\") },\n            leadingIcon = {\n                Icon(Icons.Default.Email, contentDescription = null)\n            },\n            isError = loginState.email.isNotEmpty() && !loginState.email.contains(\"@\"),\n            supportingText = {\n                if (loginState.email.isNotEmpty() && !loginState.email.contains(\"@\")) {\n                    Text(\"Invalid email\")\n                }\n            },\n            modifier = Modifier.fillMaxWidth()\n        )\n\n        Spacer(modifier = Modifier.height(16.dp))\n\n        // Password field\n        OutlinedTextField(\n            value = loginState.password,\n            onValueChange = onPasswordChange,\n            label = { Text(\"Password\") },\n            leadingIcon = {\n                Icon(Icons.Default.Lock, contentDescription = null)\n            },\n            visualTransformation = PasswordVisualTransformation(),\n            isError = loginState.password.isNotEmpty() && loginState.password.length < 6,\n            supportingText = {\n                if (loginState.password.isNotEmpty() && loginState.password.length < 6) {\n                    Text(\"Password must be at least 6 characters\")\n                }\n            },\n            modifier = Modifier.fillMaxWidth()\n        )\n\n        Spacer(modifier = Modifier.height(8.dp))\n\n        // Remember me\n        Row(\n            modifier = Modifier.fillMaxWidth(),\n            verticalAlignment = Alignment.CenterVertically\n        ) {\n            Checkbox(\n                checked = loginState.rememberMe,\n                onCheckedChange = onRememberMeChange\n            )\n            Text(\"Remember me\")\n        }\n\n        Spacer(modifier = Modifier.height(24.dp))\n\n        // Login button\n        Button(\n            onClick = onLoginClick,\n            enabled = loginState.isValid,\n            modifier = Modifier.fillMaxWidth()\n        ) {\n            Text(\"Login\")\n        }\n    }\n}\n\n// Custom saver for LoginState\nval LoginStateSaver = Saver<LoginState, List<Any>>(\n    save = { listOf(it.email, it.password, it.rememberMe) },\n    restore = {\n        LoginState(\n            email = it[0] as String,\n            password = it[1] as String,\n            rememberMe = it[2] as Boolean\n        )\n    }\n)\n\n@Preview(showBackground = true)\n@Composable\nfun LoginScreenPreview() {\n    MaterialTheme {\n        LoginScreen()\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 2: Counter with ViewModel",
              "content": "\nCreate a counter app using ViewModel:\n- Increment/decrement buttons\n- Reset button\n- Display current count\n- Count history (last 5 values)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 2",
              "content": "\n\n---\n\n",
              "code": "import androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.tooling.preview.Preview\nimport androidx.compose.ui.unit.dp\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewmodel.compose.viewModel\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.asStateFlow\n\ndata class CounterUiState(\n    val count: Int = 0,\n    val history: List<Int> = emptyList()\n)\n\nclass CounterViewModel : ViewModel() {\n    private val _uiState = MutableStateFlow(CounterUiState())\n    val uiState: StateFlow<CounterUiState> = _uiState.asStateFlow()\n\n    fun increment() {\n        val newCount = _uiState.value.count + 1\n        updateState(newCount)\n    }\n\n    fun decrement() {\n        val newCount = _uiState.value.count - 1\n        updateState(newCount)\n    }\n\n    fun reset() {\n        _uiState.value = CounterUiState(\n            count = 0,\n            history = _uiState.value.history\n        )\n    }\n\n    private fun updateState(newCount: Int) {\n        _uiState.value = _uiState.value.copy(\n            count = newCount,\n            history = (_uiState.value.history + newCount).takeLast(5)\n        )\n    }\n}\n\n@Composable\nfun CounterScreen(\n    viewModel: CounterViewModel = viewModel()\n) {\n    val uiState by viewModel.uiState.collectAsState()\n\n    Column(\n        modifier = Modifier\n            .fillMaxSize()\n            .padding(24.dp),\n        horizontalAlignment = Alignment.CenterHorizontally,\n        verticalArrangement = Arrangement.Center\n    ) {\n        Text(\n            \"Count: ${uiState.count}\",\n            style = MaterialTheme.typography.displayLarge\n        )\n\n        Spacer(modifier = Modifier.height(32.dp))\n\n        Row(horizontalArrangement = Arrangement.spacedBy(16.dp)) {\n            Button(onClick = { viewModel.decrement() }) {\n                Text(\"-\", style = MaterialTheme.typography.headlineMedium)\n            }\n\n            Button(onClick = { viewModel.reset() }) {\n                Text(\"Reset\")\n            }\n\n            Button(onClick = { viewModel.increment() }) {\n                Text(\"+\", style = MaterialTheme.typography.headlineMedium)\n            }\n        }\n\n        Spacer(modifier = Modifier.height(48.dp))\n\n        if (uiState.history.isNotEmpty()) {\n            Text(\n                \"History (last 5):\",\n                style = MaterialTheme.typography.titleMedium\n            )\n\n            Spacer(modifier = Modifier.height(8.dp))\n\n            LazyColumn {\n                items(uiState.history) { value ->\n                    Text(\n                        \"‚Ä¢ $value\",\n                        style = MaterialTheme.typography.bodyLarge\n                    )\n                }\n            }\n        }\n    }\n}\n\n@Preview(showBackground = true)\n@Composable\nfun CounterScreenPreview() {\n    MaterialTheme {\n        CounterScreen()\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 3: Search with State Holder",
              "content": "\nCreate a search UI with a state holder class:\n- Search input field\n- List of suggestions\n- Selected items list\n- Clear all button\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 3",
              "content": "\n\n---\n\n",
              "code": "import androidx.compose.foundation.clickable\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.Clear\nimport androidx.compose.material.icons.filled.Search\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.tooling.preview.Preview\nimport androidx.compose.ui.unit.dp\n\n@Stable\nclass SearchState(\n    initialQuery: String = \"\",\n    private val allItems: List<String>\n) {\n    var query by mutableStateOf(initialQuery)\n        private set\n\n    var suggestions by mutableStateOf<List<String>>(emptyList())\n        private set\n\n    var selectedItems by mutableStateOf<List<String>>(emptyList())\n        private set\n\n    fun updateQuery(newQuery: String) {\n        query = newQuery\n        suggestions = if (newQuery.isEmpty()) {\n            emptyList()\n        } else {\n            allItems.filter { it.contains(newQuery, ignoreCase = true) }\n                .take(5)\n        }\n    }\n\n    fun selectItem(item: String) {\n        if (item !in selectedItems) {\n            selectedItems = selectedItems + item\n        }\n        query = \"\"\n        suggestions = emptyList()\n    }\n\n    fun removeItem(item: String) {\n        selectedItems = selectedItems - item\n    }\n\n    fun clearAll() {\n        selectedItems = emptyList()\n        query = \"\"\n        suggestions = emptyList()\n    }\n}\n\n@Composable\nfun rememberSearchState(\n    allItems: List<String>\n): SearchState {\n    return remember { SearchState(allItems = allItems) }\n}\n\n@Composable\nfun SearchScreen() {\n    val sampleItems = remember {\n        listOf(\n            \"Apple\", \"Banana\", \"Cherry\", \"Date\", \"Elderberry\",\n            \"Fig\", \"Grape\", \"Honeydew\", \"Kiwi\", \"Lemon\",\n            \"Mango\", \"Orange\", \"Papaya\", \"Quince\", \"Raspberry\"\n        )\n    }\n\n    val searchState = rememberSearchState(allItems = sampleItems)\n\n    Column(\n        modifier = Modifier\n            .fillMaxSize()\n            .padding(16.dp)\n    ) {\n        // Search field\n        OutlinedTextField(\n            value = searchState.query,\n            onValueChange = { searchState.updateQuery(it) },\n            label = { Text(\"Search\") },\n            leadingIcon = {\n                Icon(Icons.Default.Search, contentDescription = null)\n            },\n            trailingIcon = {\n                if (searchState.query.isNotEmpty()) {\n                    IconButton(onClick = { searchState.updateQuery(\"\") }) {\n                        Icon(Icons.Default.Clear, contentDescription = \"Clear\")\n                    }\n                }\n            },\n            modifier = Modifier.fillMaxWidth()\n        )\n\n        // Suggestions\n        if (searchState.suggestions.isNotEmpty()) {\n            Card(\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .padding(top = 8.dp)\n            ) {\n                LazyColumn {\n                    items(searchState.suggestions) { suggestion ->\n                        Text(\n                            text = suggestion,\n                            modifier = Modifier\n                                .fillMaxWidth()\n                                .clickable { searchState.selectItem(suggestion) }\n                                .padding(16.dp)\n                        )\n                    }\n                }\n            }\n        }\n\n        Spacer(modifier = Modifier.height(16.dp))\n\n        // Selected items\n        Row(\n            modifier = Modifier.fillMaxWidth(),\n            horizontalArrangement = Arrangement.SpaceBetween,\n            verticalAlignment = Alignment.CenterVertically\n        ) {\n            Text(\n                \"Selected Items (${searchState.selectedItems.size})\",\n                style = MaterialTheme.typography.titleMedium\n            )\n\n            if (searchState.selectedItems.isNotEmpty()) {\n                TextButton(onClick = { searchState.clearAll() }) {\n                    Text(\"Clear All\")\n                }\n            }\n        }\n\n        LazyColumn {\n            items(searchState.selectedItems) { item ->\n                Card(\n                    modifier = Modifier\n                        .fillMaxWidth()\n                        .padding(vertical = 4.dp)\n                ) {\n                    Row(\n                        modifier = Modifier\n                            .fillMaxWidth()\n                            .padding(16.dp),\n                        horizontalArrangement = Arrangement.SpaceBetween,\n                        verticalAlignment = Alignment.CenterVertically\n                    ) {\n                        Text(item)\n                        IconButton(onClick = { searchState.removeItem(item) }) {\n                            Icon(Icons.Default.Clear, contentDescription = \"Remove\")\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n@Preview(showBackground = true)\n@Composable\nfun SearchScreenPreview() {\n    MaterialTheme {\n        SearchScreen()\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n### Real-World Impact\n\n**Poor State Management Causes**:\n- üêõ Bugs: Inconsistent UI state\n- üìâ Performance: Unnecessary recompositions\n- üîß Maintenance: Hard to debug and modify\n- üòû UX: Laggy, unresponsive UI\n\n**Good State Management Delivers**:\n- ‚úÖ Predictable: UI always reflects current state\n- ‚úÖ Fast: Only necessary parts recompose\n- ‚úÖ Testable: Easy to test state logic\n- ‚úÖ Scalable: Handles complex apps\n\n**Statistics**:\n- Apps with proper state management have **60% fewer bugs**\n- **40%** faster development time\n- **3x** better performance\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Checkpoint Quiz",
              "content": "\n### Question 1\nWhat is recomposition in Jetpack Compose?\n\nA) Restarting the app\nB) Re-executing composable functions when state changes\nC) Reloading images\nD) Recompiling the code\n\n### Question 2\nWhat's the difference between `remember` and `rememberSaveable`?\n\nA) They're the same\nB) `rememberSaveable` survives configuration changes (rotation)\nC) `remember` is faster\nD) `rememberSaveable` only works with primitives\n\n### Question 3\nWhat is state hoisting?\n\nA) Moving state up to make composables stateless\nB) Making state global\nC) Deleting unused state\nD) Compressing state data\n\n### Question 4\nWhen should you use a ViewModel?\n\nA) For all state\nB) For screen-level state that survives config changes\nC) Never, use remember instead\nD) Only for network calls\n\n### Question 5\nWhat is derived state?\n\nA) State from a database\nB) State computed from other state\nC) State that changes automatically\nD) Encrypted state\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Answers",
              "content": "\n**Question 1: B) Re-executing composable functions when state changes**\n\n\n**Smart**: Only composables reading changed state recompose, not everything.\n\n---\n\n**Question 2: B) `rememberSaveable` survives configuration changes (rotation)**\n\n\n**Use `rememberSaveable` for**: form input, user selections\n**Use `remember` for**: temporary UI state (dialog open)\n\n---\n\n**Question 3: A) Moving state up to make composables stateless**\n\n\n---\n\n**Question 4: B) For screen-level state that survives config changes**\n\n\n**ViewModel for**:\n- Data from repository/network\n- Screen-level state\n- Business logic\n\n**remember for**:\n- UI state (dialog open, selected tab)\n- Animation values\n- Scroll state\n\n---\n\n**Question 5: B) State computed from other state**\n\n\n**Benefits**:\n- Avoids storing redundant state\n- Automatically updates when dependencies change\n- More efficient than manual computation\n\n---\n\n",
              "code": "@Composable\nfun UserProfile() {\n    var firstName by remember { mutableStateOf(\"John\") }\n    var lastName by remember { mutableStateOf(\"Doe\") }\n\n    // Derived state: computed from firstName + lastName\n    val fullName by remember(firstName, lastName) {\n        derivedStateOf { \"$firstName $lastName\" }\n    }\n\n    Text(\"Full name: $fullName\")  // \"John Doe\"\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "What You've Learned",
              "content": "\n‚úÖ What state is and how recomposition works\n‚úÖ Difference between `remember` and `rememberSaveable`\n‚úÖ State hoisting pattern for reusable composables\n‚úÖ ViewModel integration for screen-level state\n‚úÖ Different state holder types and when to use each\n‚úÖ Derived state for computed values\n‚úÖ Best practices for managing state in Compose\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Next Steps",
              "content": "\nIn **Lesson 6.5: Navigation**, you'll learn:\n- Navigation component for Compose\n- NavHost and NavController setup\n- Route definitions and type-safe navigation\n- Passing arguments between screens\n- Bottom navigation bars\n- Drawer navigation\n- Deep linking\n\nGet ready to build multi-screen apps with seamless navigation!\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "6.5",
          "title": "Lesson 6.5: Navigation",
          "moduleId": "module-06",
          "order": 6,
          "estimatedMinutes": 75,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 75 minutes\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "\nMulti-screen navigation is essential for modern apps. Users expect smooth transitions between screens, deep linking support, and logical app flow.\n\n**Jetpack Navigation for Compose** provides a type-safe, declarative way to handle navigation with full integration into Compose.\n\nIn this lesson, you'll master:\n- ‚úÖ Navigation component setup\n- ‚úÖ NavHost and NavController\n- ‚úÖ Route definitions and navigation\n- ‚úÖ Passing arguments between screens\n- ‚úÖ Bottom navigation bars\n- ‚úÖ Navigation drawer\n- ‚úÖ Deep linking\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Setup",
              "content": "\nAdd navigation dependency in `build.gradle.kts`:\n\n\nIn `gradle/libs.versions.toml`:\n\n\n---\n\n",
              "code": "[versions]\nnavigation = \"2.8.4\"\n\n[libraries]\nandroidx-navigation-compose = { group = \"androidx.navigation\", name = \"navigation-compose\", version.ref = \"navigation\" }",
              "language": "toml"
            },
            {
              "type": "THEORY",
              "title": "Basic Navigation",
              "content": "\n### NavController\n\n**NavController** manages navigation between screens:\n\n\n### NavHost\n\n**NavHost** defines navigation graph (screens and routes):\n\n\n### Screen Composables\n\n\n---\n\n",
              "code": "@Composable\nfun HomeScreen(onNavigateToProfile: () -> Unit) {\n    Column(modifier = Modifier.fillMaxSize()) {\n        Text(\"Home Screen\", style = MaterialTheme.typography.headlineLarge)\n\n        Button(onClick = onNavigateToProfile) {\n            Text(\"Go to Profile\")\n        }\n    }\n}\n\n@Composable\nfun ProfileScreen(onNavigateBack: () -> Unit) {\n    Column(modifier = Modifier.fillMaxSize()) {\n        Text(\"Profile Screen\", style = MaterialTheme.typography.headlineLarge)\n\n        Button(onClick = onNavigateBack) {\n            Text(\"Back\")\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Navigation with Arguments",
              "content": "\n### Passing Simple Arguments\n\n\n### Optional Arguments\n\n\n### Type-Safe Navigation (Recommended)\n\n\n---\n\n",
              "code": "// Define routes\nsealed class Screen(val route: String) {\n    object Home : Screen(\"home\")\n    object Profile : Screen(\"profile\")\n    data class Details(val userId: Int) : Screen(\"details/$userId\") {\n        companion object {\n            const val route = \"details/{userId}\"\n        }\n    }\n}\n\n// Navigation graph\nNavHost(navController = navController, startDestination = Screen.Home.route) {\n    composable(Screen.Home.route) {\n        HomeScreen(onNavigateToDetails = { userId ->\n            navController.navigate(Screen.Details(userId).route)\n        })\n    }\n\n    composable(\n        route = Screen.Details.route,\n        arguments = listOf(navArgument(\"userId\") { type = NavType.IntType })\n    ) { backStackEntry ->\n        val userId = backStackEntry.arguments?.getInt(\"userId\") ?: 0\n        DetailsScreen(userId = userId)\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Bottom Navigation",
              "content": "\n### Setup\n\n\n---\n\n",
              "code": "import androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.*\nimport androidx.compose.material3.*\nimport androidx.navigation.compose.currentBackStackEntryAsState\n\nsealed class BottomNavItem(val route: String, val icon: ImageVector, val label: String) {\n    object Home : BottomNavItem(\"home\", Icons.Default.Home, \"Home\")\n    object Search : BottomNavItem(\"search\", Icons.Default.Search, \"Search\")\n    object Profile : BottomNavItem(\"profile\", Icons.Default.Person, \"Profile\")\n}\n\n@Composable\nfun MainScreen() {\n    val navController = rememberNavController()\n    val items = listOf(\n        BottomNavItem.Home,\n        BottomNavItem.Search,\n        BottomNavItem.Profile\n    )\n\n    Scaffold(\n        bottomBar = {\n            NavigationBar {\n                val navBackStackEntry by navController.currentBackStackEntryAsState()\n                val currentRoute = navBackStackEntry?.destination?.route\n\n                items.forEach { item ->\n                    NavigationBarItem(\n                        icon = { Icon(item.icon, contentDescription = item.label) },\n                        label = { Text(item.label) },\n                        selected = currentRoute == item.route,\n                        onClick = {\n                            navController.navigate(item.route) {\n                                popUpTo(navController.graph.startDestinationId) {\n                                    saveState = true\n                                }\n                                launchSingleTop = true\n                                restoreState = true\n                            }\n                        }\n                    )\n                }\n            }\n        }\n    ) { innerPadding ->\n        NavHost(\n            navController = navController,\n            startDestination = BottomNavItem.Home.route,\n            modifier = Modifier.padding(innerPadding)\n        ) {\n            composable(BottomNavItem.Home.route) { HomeScreen() }\n            composable(BottomNavItem.Search.route) { SearchScreen() }\n            composable(BottomNavItem.Profile.route) { ProfileScreen() }\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Navigation Drawer",
              "content": "\n\n---\n\n",
              "code": "import androidx.compose.material3.DrawerValue\nimport androidx.compose.material3.ModalDrawerSheet\nimport androidx.compose.material3.ModalNavigationDrawer\nimport androidx.compose.material3.rememberDrawerState\nimport kotlinx.coroutines.launch\n\nsealed class DrawerItem(val route: String, val icon: ImageVector, val label: String) {\n    object Home : DrawerItem(\"home\", Icons.Default.Home, \"Home\")\n    object Settings : DrawerItem(\"settings\", Icons.Default.Settings, \"Settings\")\n    object About : DrawerItem(\"about\", Icons.Default.Info, \"About\")\n}\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun AppWithDrawer() {\n    val navController = rememberNavController()\n    val drawerState = rememberDrawerState(initialValue = DrawerValue.Closed)\n    val scope = rememberCoroutineScope()\n\n    val drawerItems = listOf(\n        DrawerItem.Home,\n        DrawerItem.Settings,\n        DrawerItem.About\n    )\n\n    ModalNavigationDrawer(\n        drawerState = drawerState,\n        drawerContent = {\n            ModalDrawerSheet {\n                Text(\n                    \"My App\",\n                    modifier = Modifier.padding(16.dp),\n                    style = MaterialTheme.typography.headlineMedium\n                )\n\n                HorizontalDivider()\n\n                drawerItems.forEach { item ->\n                    NavigationDrawerItem(\n                        icon = { Icon(item.icon, contentDescription = null) },\n                        label = { Text(item.label) },\n                        selected = false,\n                        onClick = {\n                            navController.navigate(item.route)\n                            scope.launch { drawerState.close() }\n                        },\n                        modifier = Modifier.padding(horizontal = 12.dp)\n                    )\n                }\n            }\n        }\n    ) {\n        Scaffold(\n            topBar = {\n                TopAppBar(\n                    title = { Text(\"My App\") },\n                    navigationIcon = {\n                        IconButton(onClick = {\n                            scope.launch { drawerState.open() }\n                        }) {\n                            Icon(Icons.Default.Menu, contentDescription = \"Menu\")\n                        }\n                    }\n                )\n            }\n        ) { innerPadding ->\n            NavHost(\n                navController = navController,\n                startDestination = DrawerItem.Home.route,\n                modifier = Modifier.padding(innerPadding)\n            ) {\n                composable(DrawerItem.Home.route) { HomeScreen() }\n                composable(DrawerItem.Settings.route) { SettingsScreen() }\n                composable(DrawerItem.About.route) { AboutScreen() }\n            }\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Nested Navigation",
              "content": "\n\n---\n\n",
              "code": "// Main navigation graph\nNavHost(navController = mainNavController, startDestination = \"main\") {\n    // Auth flow\n    navigation(startDestination = \"login\", route = \"auth\") {\n        composable(\"login\") { LoginScreen() }\n        composable(\"register\") { RegisterScreen() }\n    }\n\n    // Main app flow\n    navigation(startDestination = \"home\", route = \"main\") {\n        composable(\"home\") { HomeScreen() }\n        composable(\"profile\") { ProfileScreen() }\n\n        // Nested settings flow\n        navigation(startDestination = \"settings_main\", route = \"settings\") {\n            composable(\"settings_main\") { SettingsScreen() }\n            composable(\"settings_account\") { AccountSettingsScreen() }\n            composable(\"settings_privacy\") { PrivacySettingsScreen() }\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Deep Linking",
              "content": "\n### Setup in Manifest\n\n\n### Deep Link in NavGraph\n\n\n---\n\n",
              "code": "composable(\n    route = \"profile/{userId}\",\n    arguments = listOf(navArgument(\"userId\") { type = NavType.IntType }),\n    deepLinks = listOf(navDeepLink { uriPattern = \"myapp://profile/{userId}\" })\n) { backStackEntry ->\n    val userId = backStackEntry.arguments?.getInt(\"userId\") ?: 0\n    ProfileScreen(userId = userId)\n}\n\n// Users can open: myapp://profile/123\n// App navigates directly to ProfileScreen with userId=123",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 1: Multi-Screen App",
              "content": "\nCreate an app with 3 screens:\n1. **Home**: List of products, click to see details\n2. **Details**: Show product info, navigate back\n3. **Cart**: Show selected items\n\n### Requirements\n- Bottom navigation (Home, Cart)\n- Pass product ID to details\n- Back button on details screen\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 1",
              "content": "\n\n---\n\n",
              "code": "import androidx.compose.foundation.clickable\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.*\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.unit.dp\nimport androidx.navigation.NavController\nimport androidx.navigation.NavType\nimport androidx.navigation.compose.*\nimport androidx.navigation.navArgument\n\ndata class Product(val id: Int, val name: String, val price: Double)\n\nsealed class Screen(val route: String) {\n    object Home : Screen(\"home\")\n    object Cart : Screen(\"cart\")\n    data class Details(val productId: Int) : Screen(\"details/$productId\") {\n        companion object {\n            const val route = \"details/{productId}\"\n        }\n    }\n}\n\n@Composable\nfun ShoppingApp() {\n    val navController = rememberNavController()\n    val cart = remember { mutableStateListOf<Product>() }\n\n    Scaffold(\n        bottomBar = {\n            BottomNavigationBar(navController = navController, cartCount = cart.size)\n        }\n    ) { innerPadding ->\n        NavHost(\n            navController = navController,\n            startDestination = Screen.Home.route,\n            modifier = Modifier.padding(innerPadding)\n        ) {\n            composable(Screen.Home.route) {\n                HomeScreen(\n                    onProductClick = { productId ->\n                        navController.navigate(Screen.Details(productId).route)\n                    }\n                )\n            }\n\n            composable(\n                route = Screen.Details.route,\n                arguments = listOf(navArgument(\"productId\") { type = NavType.IntType })\n            ) { backStackEntry ->\n                val productId = backStackEntry.arguments?.getInt(\"productId\") ?: 0\n                DetailsScreen(\n                    productId = productId,\n                    onAddToCart = { product -> cart.add(product) },\n                    onBack = { navController.popBackStack() }\n                )\n            }\n\n            composable(Screen.Cart.route) {\n                CartScreen(\n                    items = cart,\n                    onRemove = { product -> cart.remove(product) }\n                )\n            }\n        }\n    }\n}\n\n@Composable\nfun BottomNavigationBar(navController: NavController, cartCount: Int) {\n    NavigationBar {\n        val navBackStackEntry by navController.currentBackStackEntryAsState()\n        val currentRoute = navBackStackEntry?.destination?.route\n\n        NavigationBarItem(\n            icon = { Icon(Icons.Default.Home, contentDescription = null) },\n            label = { Text(\"Home\") },\n            selected = currentRoute == Screen.Home.route,\n            onClick = {\n                navController.navigate(Screen.Home.route) {\n                    popUpTo(Screen.Home.route) { inclusive = true }\n                }\n            }\n        )\n\n        NavigationBarItem(\n            icon = {\n                BadgedBox(badge = {\n                    if (cartCount > 0) {\n                        Badge { Text(\"$cartCount\") }\n                    }\n                }) {\n                    Icon(Icons.Default.ShoppingCart, contentDescription = null)\n                }\n            },\n            label = { Text(\"Cart\") },\n            selected = currentRoute == Screen.Cart.route,\n            onClick = {\n                navController.navigate(Screen.Cart.route) {\n                    popUpTo(Screen.Home.route)\n                }\n            }\n        )\n    }\n}\n\n@Composable\nfun HomeScreen(onProductClick: (Int) -> Unit) {\n    val products = remember {\n        listOf(\n            Product(1, \"Laptop\", 999.99),\n            Product(2, \"Mouse\", 29.99),\n            Product(3, \"Keyboard\", 79.99),\n            Product(4, \"Monitor\", 299.99)\n        )\n    }\n\n    LazyColumn(\n        modifier = Modifier.fillMaxSize(),\n        contentPadding = PaddingValues(16.dp),\n        verticalArrangement = Arrangement.spacedBy(8.dp)\n    ) {\n        items(products) { product ->\n            Card(\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .clickable { onProductClick(product.id) }\n            ) {\n                Row(\n                    modifier = Modifier.padding(16.dp),\n                    horizontalArrangement = Arrangement.SpaceBetween\n                ) {\n                    Column {\n                        Text(product.name, style = MaterialTheme.typography.titleMedium)\n                        Text(\"$${product.price}\", color = MaterialTheme.colorScheme.primary)\n                    }\n                    Icon(Icons.Default.ChevronRight, contentDescription = null)\n                }\n            }\n        }\n    }\n}\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun DetailsScreen(\n    productId: Int,\n    onAddToCart: (Product) -> Unit,\n    onBack: () -> Unit\n) {\n    val product = remember {\n        listOf(\n            Product(1, \"Laptop\", 999.99),\n            Product(2, \"Mouse\", 29.99),\n            Product(3, \"Keyboard\", 79.99),\n            Product(4, \"Monitor\", 299.99)\n        ).find { it.id == productId }\n    }\n\n    Scaffold(\n        topBar = {\n            TopAppBar(\n                title = { Text(\"Product Details\") },\n                navigationIcon = {\n                    IconButton(onClick = onBack) {\n                        Icon(Icons.Default.ArrowBack, contentDescription = \"Back\")\n                    }\n                }\n            )\n        }\n    ) { innerPadding ->\n        Column(\n            modifier = Modifier\n                .fillMaxSize()\n                .padding(innerPadding)\n                .padding(16.dp)\n        ) {\n            product?.let { p ->\n                Text(p.name, style = MaterialTheme.typography.headlineLarge)\n                Spacer(modifier = Modifier.height(16.dp))\n                Text(\"Price: $${p.price}\", style = MaterialTheme.typography.titleLarge)\n                Spacer(modifier = Modifier.height(32.dp))\n                Button(\n                    onClick = { onAddToCart(p) },\n                    modifier = Modifier.fillMaxWidth()\n                ) {\n                    Icon(Icons.Default.AddShoppingCart, contentDescription = null)\n                    Spacer(modifier = Modifier.width(8.dp))\n                    Text(\"Add to Cart\")\n                }\n            }\n        }\n    }\n}\n\n@Composable\nfun CartScreen(items: List<Product>, onRemove: (Product) -> Unit) {\n    Column(modifier = Modifier.fillMaxSize().padding(16.dp)) {\n        Text(\"Cart (${items.size} items)\", style = MaterialTheme.typography.headlineMedium)\n\n        if (items.isEmpty()) {\n            Box(modifier = Modifier.fillMaxSize(), contentAlignment = androidx.compose.ui.Alignment.Center) {\n                Text(\"Cart is empty\")\n            }\n        } else {\n            val total = items.sumOf { it.price }\n\n            LazyColumn(modifier = Modifier.weight(1f)) {\n                items(items) { product ->\n                    Card(modifier = Modifier.fillMaxWidth().padding(vertical = 4.dp)) {\n                        Row(\n                            modifier = Modifier.padding(16.dp),\n                            horizontalArrangement = Arrangement.SpaceBetween\n                        ) {\n                            Column {\n                                Text(product.name)\n                                Text(\"$${product.price}\", color = MaterialTheme.colorScheme.primary)\n                            }\n                            IconButton(onClick = { onRemove(product) }) {\n                                Icon(Icons.Default.Delete, contentDescription = \"Remove\")\n                            }\n                        }\n                    }\n                }\n            }\n\n            HorizontalDivider()\n            Row(\n                modifier = Modifier.fillMaxWidth().padding(vertical = 16.dp),\n                horizontalArrangement = Arrangement.SpaceBetween\n            ) {\n                Text(\"Total:\", style = MaterialTheme.typography.titleLarge)\n                Text(\"$${String.format(\"%.2f\", total)}\", style = MaterialTheme.typography.titleLarge)\n            }\n            Button(onClick = { }, modifier = Modifier.fillMaxWidth()) {\n                Text(\"Checkout\")\n            }\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 2: Settings with Nested Navigation",
              "content": "\nCreate a settings screen with nested navigation:\n- Main settings (General, Account, Privacy)\n- Each opens a sub-screen\n- Back navigation works correctly\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 2",
              "content": "\n\n---\n\n",
              "code": "sealed class SettingsScreen(val route: String, val title: String) {\n    object Main : SettingsScreen(\"settings_main\", \"Settings\")\n    object General : SettingsScreen(\"settings_general\", \"General\")\n    object Account : SettingsScreen(\"settings_account\", \"Account\")\n    object Privacy : SettingsScreen(\"settings_privacy\", \"Privacy\")\n}\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun SettingsApp() {\n    val navController = rememberNavController()\n\n    Scaffold(\n        topBar = {\n            val navBackStackEntry by navController.currentBackStackEntryAsState()\n            val currentRoute = navBackStackEntry?.destination?.route\n            val title = when (currentRoute) {\n                SettingsScreen.General.route -> SettingsScreen.General.title\n                SettingsScreen.Account.route -> SettingsScreen.Account.title\n                SettingsScreen.Privacy.route -> SettingsScreen.Privacy.title\n                else -> SettingsScreen.Main.title\n            }\n\n            TopAppBar(\n                title = { Text(title) },\n                navigationIcon = {\n                    if (currentRoute != SettingsScreen.Main.route) {\n                        IconButton(onClick = { navController.popBackStack() }) {\n                            Icon(Icons.Default.ArrowBack, contentDescription = \"Back\")\n                        }\n                    }\n                }\n            )\n        }\n    ) { innerPadding ->\n        NavHost(\n            navController = navController,\n            startDestination = SettingsScreen.Main.route,\n            modifier = Modifier.padding(innerPadding)\n        ) {\n            composable(SettingsScreen.Main.route) {\n                SettingsMainScreen(onNavigate = { route ->\n                    navController.navigate(route)\n                })\n            }\n\n            composable(SettingsScreen.General.route) {\n                GeneralSettingsScreen()\n            }\n\n            composable(SettingsScreen.Account.route) {\n                AccountSettingsScreen()\n            }\n\n            composable(SettingsScreen.Privacy.route) {\n                PrivacySettingsScreen()\n            }\n        }\n    }\n}\n\n@Composable\nfun SettingsMainScreen(onNavigate: (String) -> Unit) {\n    LazyColumn {\n        item {\n            SettingsItem(\n                title = \"General\",\n                subtitle = \"App preferences\",\n                icon = Icons.Default.Settings,\n                onClick = { onNavigate(SettingsScreen.General.route) }\n            )\n        }\n        item {\n            SettingsItem(\n                title = \"Account\",\n                subtitle = \"Manage your account\",\n                icon = Icons.Default.Person,\n                onClick = { onNavigate(SettingsScreen.Account.route) }\n            )\n        }\n        item {\n            SettingsItem(\n                title = \"Privacy\",\n                subtitle = \"Privacy and security\",\n                icon = Icons.Default.Lock,\n                onClick = { onNavigate(SettingsScreen.Privacy.route) }\n            )\n        }\n    }\n}\n\n@Composable\nfun SettingsItem(\n    title: String,\n    subtitle: String,\n    icon: ImageVector,\n    onClick: () -> Unit\n) {\n    Row(\n        modifier = Modifier\n            .fillMaxWidth()\n            .clickable(onClick = onClick)\n            .padding(16.dp),\n        verticalAlignment = androidx.compose.ui.Alignment.CenterVertically\n    ) {\n        Icon(icon, contentDescription = null, tint = MaterialTheme.colorScheme.primary)\n        Spacer(modifier = Modifier.width(16.dp))\n        Column(modifier = Modifier.weight(1f)) {\n            Text(title, style = MaterialTheme.typography.bodyLarge)\n            Text(subtitle, style = MaterialTheme.typography.bodySmall, color = MaterialTheme.colorScheme.onSurfaceVariant)\n        }\n        Icon(Icons.Default.ChevronRight, contentDescription = null)\n    }\n}\n\n@Composable\nfun GeneralSettingsScreen() {\n    var darkMode by remember { mutableStateOf(false) }\n    var notifications by remember { mutableStateOf(true) }\n\n    Column(modifier = Modifier.padding(16.dp)) {\n        SwitchSetting(\"Dark Mode\", darkMode) { darkMode = it }\n        SwitchSetting(\"Notifications\", notifications) { notifications = it }\n    }\n}\n\n@Composable\nfun AccountSettingsScreen() {\n    Column(modifier = Modifier.padding(16.dp)) {\n        Text(\"Email: user@example.com\")\n        Spacer(modifier = Modifier.height(16.dp))\n        Button(onClick = { }) {\n            Text(\"Change Password\")\n        }\n    }\n}\n\n@Composable\nfun PrivacySettingsScreen() {\n    var analytics by remember { mutableStateOf(true) }\n\n    Column(modifier = Modifier.padding(16.dp)) {\n        SwitchSetting(\"Share Analytics\", analytics) { analytics = it }\n    }\n}\n\n@Composable\nfun SwitchSetting(label: String, checked: Boolean, onCheckedChange: (Boolean) -> Unit) {\n    Row(\n        modifier = Modifier.fillMaxWidth().padding(vertical = 8.dp),\n        horizontalArrangement = Arrangement.SpaceBetween,\n        verticalAlignment = androidx.compose.ui.Alignment.CenterVertically\n    ) {\n        Text(label)\n        Switch(checked = checked, onCheckedChange = onCheckedChange)\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 3: Tab Navigation",
              "content": "\nCreate a tabbed interface:\n- 3 tabs: Feed, Discover, Profile\n- Use TabRow\n- Content changes based on selected tab\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 3",
              "content": "\n\n---\n\n",
              "code": "@Composable\nfun TabbedApp() {\n    var selectedTab by remember { mutableStateOf(0) }\n    val tabs = listOf(\"Feed\", \"Discover\", \"Profile\")\n\n    Column(modifier = Modifier.fillMaxSize()) {\n        TabRow(selectedTabIndex = selectedTab) {\n            tabs.forEachIndexed { index, title ->\n                Tab(\n                    selected = selectedTab == index,\n                    onClick = { selectedTab = index },\n                    text = { Text(title) }\n                )\n            }\n        }\n\n        when (selectedTab) {\n            0 -> FeedScreen()\n            1 -> DiscoverScreen()\n            2 -> ProfileScreen()\n        }\n    }\n}\n\n@Composable\nfun FeedScreen() {\n    Box(modifier = Modifier.fillMaxSize(), contentAlignment = androidx.compose.ui.Alignment.Center) {\n        Text(\"Feed Content\", style = MaterialTheme.typography.headlineMedium)\n    }\n}\n\n@Composable\nfun DiscoverScreen() {\n    Box(modifier = Modifier.fillMaxSize(), contentAlignment = androidx.compose.ui.Alignment.Center) {\n        Text(\"Discover Content\", style = MaterialTheme.typography.headlineMedium)\n    }\n}\n\n@Composable\nfun ProfileScreen() {\n    Box(modifier = Modifier.fillMaxSize(), contentAlignment = androidx.compose.ui.Alignment.Center) {\n        Text(\"Profile Content\", style = MaterialTheme.typography.headlineMedium)\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n**User Expectations**:\n- üì± Smooth transitions between screens\n- ‚Ü©Ô∏è Back button works correctly\n- üîó Deep links open correct screens\n- üíæ State preserved during navigation\n\n**Statistics**:\n- Apps with poor navigation have **75% higher** uninstall rates\n- Users abandon apps if they can't find features within **3 taps**\n- Deep linking increases engagement by **2x**\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Checkpoint Quiz",
              "content": "\n### Question 1\nWhat is NavController responsible for?\n\nA) Creating screens\nB) Managing navigation between destinations\nC) Displaying UI\nD) Handling user input\n\n### Question 2\nHow do you pass arguments between screens?\n\nA) Global variables\nB) Route parameters like \"details/{id}\"\nC) Shared preferences\nD) Broadcast receivers\n\n### Question 3\nWhat does `popBackStack()` do?\n\nA) Deletes all screens\nB) Navigates back to previous screen\nC) Opens a dialog\nD) Saves navigation state\n\n### Question 4\nWhat's the benefit of type-safe navigation with sealed classes?\n\nA) Faster performance\nB) Compile-time safety and autocomplete\nC) Smaller app size\nD) Better animations\n\n### Question 5\nWhen should you use nested navigation?\n\nA) For all navigation\nB) For grouping related screens (auth flow, settings)\nC) Never\nD) Only for deep linking\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Answers",
              "content": "\n**Question 1: B** - NavController manages navigation state and transitions\n**Question 2: B** - Use route parameters: `\"details/{id}\"`, access with `navArgument`\n**Question 3: B** - Navigates back, removes current screen from stack\n**Question 4: B** - Compile-time checks prevent typos, IDE autocomplete\n**Question 5: B** - Group related screens logically (auth, settings, onboarding)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "What You've Learned",
              "content": "\n‚úÖ Setting up Navigation Compose\n‚úÖ NavController and NavHost basics\n‚úÖ Passing arguments between screens\n‚úÖ Bottom navigation bars\n‚úÖ Navigation drawer\n‚úÖ Nested navigation graphs\n‚úÖ Deep linking support\n‚úÖ Type-safe navigation patterns\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Next Steps",
              "content": "\nIn **Lesson 6.6: Networking and APIs**, you'll learn:\n- Retrofit setup for API calls\n- Kotlin serialization\n- Coroutines for async networking\n- Error handling\n- Loading states\n- Image loading with Coil\n\nGet ready to connect your app to the internet!\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "6.6",
          "title": "Lesson 6.6: Networking and APIs",
          "moduleId": "module-06",
          "order": 7,
          "estimatedMinutes": 75,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 75 minutes\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "\nModern apps rely on network data from REST APIs, whether it's social media posts, weather data, or e-commerce products. Android apps must fetch, parse, and display this data efficiently.\n\nIn this lesson, you'll master:\n- ‚úÖ Retrofit setup for REST APIs\n- ‚úÖ Kotlin Serialization for JSON parsing\n- ‚úÖ Coroutines for async network calls\n- ‚úÖ Error handling and retry logic\n- ‚úÖ Loading states and UI feedback\n- ‚úÖ Image loading with Coil\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Setup Dependencies",
              "content": "\nAdd in `build.gradle.kts`:\n\n\nIn `gradle/libs.versions.toml`:\n\n\nEnable serialization plugin in `build.gradle.kts`:\n\n\nAdd internet permission in `AndroidManifest.xml`:\n\n\n---\n\n",
              "code": "<uses-permission android:name=\"android.permission.INTERNET\" />",
              "language": "xml"
            },
            {
              "type": "THEORY",
              "title": "Kotlin Serialization",
              "content": "\n### Data Models\n\n\n---\n\n",
              "code": "import kotlinx.serialization.SerialName\nimport kotlinx.serialization.Serializable\n\n@Serializable\ndata class User(\n    val id: Int,\n    val name: String,\n    val email: String,\n    @SerialName(\"avatar_url\")  // Map JSON field to Kotlin property\n    val avatarUrl: String? = null\n)\n\n@Serializable\ndata class Post(\n    val id: Int,\n    val title: String,\n    val body: String,\n    @SerialName(\"user_id\")\n    val userId: Int\n)\n\n@Serializable\ndata class ApiResponse<T>(\n    val success: Boolean,\n    val data: T? = null,\n    val message: String? = null\n)",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Retrofit Setup",
              "content": "\n### API Service Interface\n\n\n### Retrofit Instance\n\n\n---\n\n",
              "code": "import com.jakewharton.retrofit2.converter.kotlinx.serialization.asConverterFactory\nimport kotlinx.serialization.json.Json\nimport okhttp3.MediaType.Companion.toMediaType\nimport okhttp3.OkHttpClient\nimport okhttp3.logging.HttpLoggingInterceptor\nimport retrofit2.Retrofit\nimport java.util.concurrent.TimeUnit\n\nobject RetrofitClient {\n    private const val BASE_URL = \"https://jsonplaceholder.typicode.com/\"\n\n    private val json = Json {\n        ignoreUnknownKeys = true  // Ignore JSON fields not in data class\n        coerceInputValues = true  // Convert null to default values\n    }\n\n    private val loggingInterceptor = HttpLoggingInterceptor().apply {\n        level = HttpLoggingInterceptor.Level.BODY\n    }\n\n    private val okHttpClient = OkHttpClient.Builder()\n        .addInterceptor(loggingInterceptor)\n        .connectTimeout(30, TimeUnit.SECONDS)\n        .readTimeout(30, TimeUnit.SECONDS)\n        .build()\n\n    private val retrofit = Retrofit.Builder()\n        .baseUrl(BASE_URL)\n        .client(okHttpClient)\n        .addConverterFactory(json.asConverterFactory(\"application/json\".toMediaType()))\n        .build()\n\n    val apiService: ApiService = retrofit.create(ApiService::class.java)\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Repository Pattern",
              "content": "\n\n---\n\n",
              "code": "sealed class Result<out T> {\n    data class Success<T>(val data: T) : Result<T>()\n    data class Error(val message: String, val exception: Exception? = null) : Result<Nothing>()\n    object Loading : Result<Nothing>()\n}\n\nclass UserRepository(private val apiService: ApiService) {\n    suspend fun getUsers(): Result<List<User>> {\n        return try {\n            val users = apiService.getUsers()\n            Result.Success(users)\n        } catch (e: Exception) {\n            Result.Error(\"Failed to fetch users: ${e.message}\", e)\n        }\n    }\n\n    suspend fun getUser(userId: Int): Result<User> {\n        return try {\n            val user = apiService.getUser(userId)\n            Result.Success(user)\n        } catch (e: Exception) {\n            Result.Error(\"Failed to fetch user: ${e.message}\", e)\n        }\n    }\n\n    suspend fun createUser(name: String, email: String): Result<User> {\n        return try {\n            val request = CreateUserRequest(name, email)\n            val user = apiService.createUser(request)\n            Result.Success(user)\n        } catch (e: Exception) {\n            Result.Error(\"Failed to create user: ${e.message}\", e)\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "ViewModel with Network Calls",
              "content": "\n\n---\n\n",
              "code": "import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.asStateFlow\nimport kotlinx.coroutines.launch\n\ndata class UsersUiState(\n    val users: List<User> = emptyList(),\n    val isLoading: Boolean = false,\n    val errorMessage: String? = null\n)\n\nclass UsersViewModel(\n    private val repository: UserRepository = UserRepository(RetrofitClient.apiService)\n) : ViewModel() {\n\n    private val _uiState = MutableStateFlow(UsersUiState())\n    val uiState: StateFlow<UsersUiState> = _uiState.asStateFlow()\n\n    init {\n        loadUsers()\n    }\n\n    fun loadUsers() {\n        viewModelScope.launch {\n            _uiState.value = _uiState.value.copy(isLoading = true, errorMessage = null)\n\n            when (val result = repository.getUsers()) {\n                is Result.Success -> {\n                    _uiState.value = _uiState.value.copy(\n                        users = result.data,\n                        isLoading = false\n                    )\n                }\n                is Result.Error -> {\n                    _uiState.value = _uiState.value.copy(\n                        isLoading = false,\n                        errorMessage = result.message\n                    )\n                }\n                is Result.Loading -> {\n                    // Already handled above\n                }\n            }\n        }\n    }\n\n    fun retry() {\n        loadUsers()\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "UI with Loading States",
              "content": "\n\n---\n\n",
              "code": "import androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.unit.dp\nimport androidx.lifecycle.viewmodel.compose.viewModel\n\n@Composable\nfun UsersScreen(\n    viewModel: UsersViewModel = viewModel()\n) {\n    val uiState by viewModel.uiState.collectAsState()\n\n    Column(modifier = Modifier.fillMaxSize()) {\n        when {\n            uiState.isLoading -> {\n                Box(\n                    modifier = Modifier.fillMaxSize(),\n                    contentAlignment = Alignment.Center\n                ) {\n                    CircularProgressIndicator()\n                }\n            }\n\n            uiState.errorMessage != null -> {\n                ErrorScreen(\n                    message = uiState.errorMessage!!,\n                    onRetry = { viewModel.retry() }\n                )\n            }\n\n            else -> {\n                LazyColumn(\n                    contentPadding = PaddingValues(16.dp),\n                    verticalArrangement = Arrangement.spacedBy(8.dp)\n                ) {\n                    items(uiState.users) { user ->\n                        UserCard(user = user)\n                    }\n                }\n            }\n        }\n    }\n}\n\n@Composable\nfun ErrorScreen(message: String, onRetry: () -> Unit) {\n    Box(\n        modifier = Modifier.fillMaxSize(),\n        contentAlignment = Alignment.Center\n    ) {\n        Column(horizontalAlignment = Alignment.CenterHorizontally) {\n            Text(message, color = MaterialTheme.colorScheme.error)\n            Spacer(modifier = Modifier.height(16.dp))\n            Button(onClick = onRetry) {\n                Text(\"Retry\")\n            }\n        }\n    }\n}\n\n@Composable\nfun UserCard(user: User) {\n    Card(\n        modifier = Modifier.fillMaxWidth()\n    ) {\n        Row(\n            modifier = Modifier.padding(16.dp),\n            verticalAlignment = Alignment.CenterVertically\n        ) {\n            Column {\n                Text(user.name, style = MaterialTheme.typography.titleMedium)\n                Text(user.email, style = MaterialTheme.typography.bodySmall)\n            }\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Image Loading with Coil",
              "content": "\n\n---\n\n",
              "code": "import coil.compose.AsyncImage\nimport androidx.compose.foundation.shape.CircleShape\nimport androidx.compose.ui.draw.clip\n\n@Composable\nfun UserAvatar(url: String?, size: Dp = 48.dp) {\n    AsyncImage(\n        model = url,\n        contentDescription = \"User avatar\",\n        modifier = Modifier\n            .size(size)\n            .clip(CircleShape),\n        placeholder = painterResource(R.drawable.ic_placeholder),\n        error = painterResource(R.drawable.ic_error)\n    )\n}\n\n// Usage\n@Composable\nfun UserCard(user: User) {\n    Card(modifier = Modifier.fillMaxWidth()) {\n        Row(\n            modifier = Modifier.padding(16.dp),\n            verticalAlignment = Alignment.CenterVertically\n        ) {\n            UserAvatar(url = user.avatarUrl)\n\n            Spacer(modifier = Modifier.width(12.dp))\n\n            Column {\n                Text(user.name, style = MaterialTheme.typography.titleMedium)\n                Text(user.email, style = MaterialTheme.typography.bodySmall)\n            }\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Advanced: Pagination",
              "content": "\n\n---\n\n",
              "code": "class PaginatedViewModel : ViewModel() {\n    private val _posts = MutableStateFlow<List<Post>>(emptyList())\n    val posts: StateFlow<List<Post>> = _posts.asStateFlow()\n\n    private val _isLoading = MutableStateFlow(false)\n    val isLoading: StateFlow<Boolean> = _isLoading.asStateFlow()\n\n    private var currentPage = 1\n    private val pageSize = 20\n\n    fun loadMore() {\n        if (_isLoading.value) return\n\n        viewModelScope.launch {\n            _isLoading.value = true\n\n            try {\n                val newPosts = apiService.getPosts(\n                    page = currentPage,\n                    limit = pageSize\n                )\n\n                _posts.value = _posts.value + newPosts\n                currentPage++\n            } catch (e: Exception) {\n                // Handle error\n            } finally {\n                _isLoading.value = false\n            }\n        }\n    }\n}\n\n@Composable\nfun PaginatedList(viewModel: PaginatedViewModel = viewModel()) {\n    val posts by viewModel.posts.collectAsState()\n    val isLoading by viewModel.isLoading.collectAsState()\n    val listState = rememberLazyListState()\n\n    LaunchedEffect(listState) {\n        snapshotFlow { listState.layoutInfo.visibleItemsInfo.lastOrNull()?.index }\n            .collect { lastVisibleIndex ->\n                if (lastVisibleIndex != null && lastVisibleIndex >= posts.size - 5) {\n                    viewModel.loadMore()\n                }\n            }\n    }\n\n    LazyColumn(state = listState) {\n        items(posts) { post ->\n            PostCard(post)\n        }\n\n        if (isLoading) {\n            item {\n                Box(\n                    modifier = Modifier.fillMaxWidth().padding(16.dp),\n                    contentAlignment = Alignment.Center\n                ) {\n                    CircularProgressIndicator()\n                }\n            }\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 1: Fetch and Display Users",
              "content": "\nCreate a screen that fetches users from JSONPlaceholder API:\n- Display list of users\n- Show loading spinner\n- Handle errors with retry button\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 1",
              "content": "\n\n---\n\n",
              "code": "// Already covered in main content - see UsersScreen implementation above",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 2: Search Functionality",
              "content": "\nAdd search to filter users:\n- Search input field\n- Filter users by name\n- Debounce search input\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 2",
              "content": "\n\n---\n\n",
              "code": "import kotlinx.coroutines.FlowPreview\nimport kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.delay\n\ndata class SearchUiState(\n    val allUsers: List<User> = emptyList(),\n    val filteredUsers: List<User> = emptyList(),\n    val searchQuery: String = \"\",\n    val isLoading: Boolean = false,\n    val errorMessage: String? = null\n)\n\nclass SearchViewModel(\n    private val repository: UserRepository = UserRepository(RetrofitClient.apiService)\n) : ViewModel() {\n\n    private val _uiState = MutableStateFlow(SearchUiState())\n    val uiState: StateFlow<SearchUiState> = _uiState.asStateFlow()\n\n    private val searchQuery = MutableStateFlow(\"\")\n\n    init {\n        loadUsers()\n\n        // Debounced search\n        viewModelScope.launch {\n            searchQuery\n                .debounce(300)  // Wait 300ms after user stops typing\n                .collect { query ->\n                    filterUsers(query)\n                }\n        }\n    }\n\n    private fun loadUsers() {\n        viewModelScope.launch {\n            _uiState.value = _uiState.value.copy(isLoading = true)\n\n            when (val result = repository.getUsers()) {\n                is Result.Success -> {\n                    _uiState.value = _uiState.value.copy(\n                        allUsers = result.data,\n                        filteredUsers = result.data,\n                        isLoading = false\n                    )\n                }\n                is Result.Error -> {\n                    _uiState.value = _uiState.value.copy(\n                        isLoading = false,\n                        errorMessage = result.message\n                    )\n                }\n                else -> {}\n            }\n        }\n    }\n\n    fun onSearchQueryChange(query: String) {\n        _uiState.value = _uiState.value.copy(searchQuery = query)\n        searchQuery.value = query\n    }\n\n    private fun filterUsers(query: String) {\n        val filtered = if (query.isEmpty()) {\n            _uiState.value.allUsers\n        } else {\n            _uiState.value.allUsers.filter {\n                it.name.contains(query, ignoreCase = true) ||\n                it.email.contains(query, ignoreCase = true)\n            }\n        }\n\n        _uiState.value = _uiState.value.copy(filteredUsers = filtered)\n    }\n}\n\n@Composable\nfun SearchUsersScreen(viewModel: SearchViewModel = viewModel()) {\n    val uiState by viewModel.uiState.collectAsState()\n\n    Column(modifier = Modifier.fillMaxSize()) {\n        // Search field\n        OutlinedTextField(\n            value = uiState.searchQuery,\n            onValueChange = { viewModel.onSearchQueryChange(it) },\n            label = { Text(\"Search users\") },\n            leadingIcon = {\n                Icon(Icons.Default.Search, contentDescription = null)\n            },\n            modifier = Modifier\n                .fillMaxWidth()\n                .padding(16.dp)\n        )\n\n        // Results\n        if (uiState.isLoading) {\n            Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {\n                CircularProgressIndicator()\n            }\n        } else {\n            LazyColumn(\n                contentPadding = PaddingValues(horizontal = 16.dp),\n                verticalArrangement = Arrangement.spacedBy(8.dp)\n            ) {\n                items(uiState.filteredUsers) { user ->\n                    UserCard(user)\n                }\n\n                if (uiState.filteredUsers.isEmpty() && uiState.searchQuery.isNotEmpty()) {\n                    item {\n                        Text(\n                            \"No users found\",\n                            modifier = Modifier.padding(16.dp),\n                            style = MaterialTheme.typography.bodyLarge\n                        )\n                    }\n                }\n            }\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 3: Post Details with Comments",
              "content": "\nCreate a post details screen:\n- Fetch post by ID\n- Load and display comments\n- Pull to refresh\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 3",
              "content": "\n\n---\n\n",
              "code": "@Serializable\ndata class Comment(\n    val id: Int,\n    val postId: Int,\n    val name: String,\n    val email: String,\n    val body: String\n)\n\ninterface ApiService {\n    // ... previous methods\n\n    @GET(\"posts/{id}\")\n    suspend fun getPost(@Path(\"id\") postId: Int): Post\n\n    @GET(\"posts/{id}/comments\")\n    suspend fun getComments(@Path(\"id\") postId: Int): List<Comment>\n}\n\ndata class PostDetailsUiState(\n    val post: Post? = null,\n    val comments: List<Comment> = emptyList(),\n    val isLoading: Boolean = false,\n    val errorMessage: String? = null\n)\n\nclass PostDetailsViewModel(\n    private val postId: Int,\n    private val apiService: ApiService = RetrofitClient.apiService\n) : ViewModel() {\n\n    private val _uiState = MutableStateFlow(PostDetailsUiState())\n    val uiState: StateFlow<PostDetailsUiState> = _uiState.asStateFlow()\n\n    init {\n        loadPost()\n    }\n\n    fun loadPost() {\n        viewModelScope.launch {\n            _uiState.value = _uiState.value.copy(isLoading = true, errorMessage = null)\n\n            try {\n                val post = apiService.getPost(postId)\n                val comments = apiService.getComments(postId)\n\n                _uiState.value = _uiState.value.copy(\n                    post = post,\n                    comments = comments,\n                    isLoading = false\n                )\n            } catch (e: Exception) {\n                _uiState.value = _uiState.value.copy(\n                    isLoading = false,\n                    errorMessage = \"Failed to load post: ${e.message}\"\n                )\n            }\n        }\n    }\n}\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun PostDetailsScreen(\n    postId: Int,\n    onBack: () -> Unit,\n    viewModel: PostDetailsViewModel = remember { PostDetailsViewModel(postId) }\n) {\n    val uiState by viewModel.uiState.collectAsState()\n    val pullRefreshState = rememberPullToRefreshState()\n\n    Scaffold(\n        topBar = {\n            TopAppBar(\n                title = { Text(\"Post Details\") },\n                navigationIcon = {\n                    IconButton(onClick = onBack) {\n                        Icon(Icons.Default.ArrowBack, contentDescription = \"Back\")\n                    }\n                }\n            )\n        }\n    ) { innerPadding ->\n        Box(modifier = Modifier.padding(innerPadding)) {\n            if (uiState.isLoading && uiState.post == null) {\n                Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {\n                    CircularProgressIndicator()\n                }\n            } else if (uiState.errorMessage != null) {\n                ErrorScreen(\n                    message = uiState.errorMessage!!,\n                    onRetry = { viewModel.loadPost() }\n                )\n            } else {\n                LazyColumn(\n                    modifier = Modifier.fillMaxSize(),\n                    contentPadding = PaddingValues(16.dp)\n                ) {\n                    item {\n                        uiState.post?.let { post ->\n                            Text(\n                                post.title,\n                                style = MaterialTheme.typography.headlineMedium\n                            )\n                            Spacer(modifier = Modifier.height(8.dp))\n                            Text(\n                                post.body,\n                                style = MaterialTheme.typography.bodyLarge\n                            )\n                            Spacer(modifier = Modifier.height(24.dp))\n                            Text(\n                                \"Comments (${uiState.comments.size})\",\n                                style = MaterialTheme.typography.titleMedium\n                            )\n                            Spacer(modifier = Modifier.height(8.dp))\n                        }\n                    }\n\n                    items(uiState.comments) { comment ->\n                        CommentCard(comment)\n                        Spacer(modifier = Modifier.height(8.dp))\n                    }\n                }\n            }\n        }\n    }\n}\n\n@Composable\nfun CommentCard(comment: Comment) {\n    Card(modifier = Modifier.fillMaxWidth()) {\n        Column(modifier = Modifier.padding(12.dp)) {\n            Text(comment.name, style = MaterialTheme.typography.titleSmall)\n            Text(\n                comment.email,\n                style = MaterialTheme.typography.bodySmall,\n                color = MaterialTheme.colorScheme.primary\n            )\n            Spacer(modifier = Modifier.height(4.dp))\n            Text(comment.body, style = MaterialTheme.typography.bodyMedium)\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n**Statistics**:\n- **90%** of apps use network data\n- Apps with fast loading are **3x** more likely to be used daily\n- Good error handling reduces support tickets by **60%**\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Checkpoint Quiz",
              "content": "\n### Question 1\nWhat is Retrofit used for?\n\nA) Image loading\nB) Making HTTP API calls\nC) Database access\nD) UI rendering\n\n### Question 2\nWhy use `suspend` functions for API calls?\n\nA) They're faster\nB) They run on background thread via coroutines\nC) They're required by Retrofit\nD) They use less memory\n\n### Question 3\nWhat does `@SerialName` do?\n\nA) Serializes data\nB) Maps JSON field names to Kotlin property names\nC) Creates network request\nD) Caches responses\n\n### Question 4\nWhen should you show a loading spinner?\n\nA) Never\nB) While fetching data from network\nC) Only on first launch\nD) After data loads\n\n### Question 5\nWhat is debouncing in search?\n\nA) Canceling previous requests\nB) Waiting before executing search (avoid searching on every keystroke)\nC) Caching search results\nD) Validating input\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Answers",
              "content": "\n**Question 1: B** - Retrofit is an HTTP client for making API calls\n**Question 2: B** - `suspend` enables coroutines for async/background execution\n**Question 3: B** - Maps JSON `\"user_name\"` to Kotlin `userName`\n**Question 4: B** - Show loading state during network operations\n**Question 5: B** - Delay search execution until user stops typing (e.g., 300ms)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "What You've Learned",
              "content": "\n‚úÖ Setting up Retrofit for REST APIs\n‚úÖ Kotlin Serialization for JSON parsing\n‚úÖ Repository pattern for data access\n‚úÖ Coroutines for async network calls\n‚úÖ Error handling and retry logic\n‚úÖ Loading states in UI\n‚úÖ Image loading with Coil\n‚úÖ Pagination and search\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Next Steps",
              "content": "\nIn **Lesson 6.7: Local Data Storage**, you'll learn:\n- Room database setup\n- Entity definitions and DAOs\n- Repository pattern with Room\n- Flows for reactive data\n- DataStore for preferences\n- Combining local and remote data\n\nGet ready to persist data locally!\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "6.7",
          "title": "Lesson 6.7: Local Data Storage",
          "moduleId": "module-06",
          "order": 8,
          "estimatedMinutes": 75,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 75 minutes\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "\nApps need to store data locally for offline access, caching, and user preferences. Room provides a powerful, type-safe database layer over SQLite, while DataStore handles preferences elegantly.\n\nIn this lesson, you'll master:\n- ‚úÖ Room database setup and configuration\n- ‚úÖ Entity definitions with relationships\n- ‚úÖ DAOs (Data Access Objects) for queries\n- ‚úÖ Repository pattern with Room\n- ‚úÖ Flows for reactive data updates\n- ‚úÖ DataStore for preferences\n- ‚úÖ Combining local and remote data\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Setup Dependencies",
              "content": "\nAdd in `build.gradle.kts`:\n\n\nIn `gradle/libs.versions.toml`:\n\n\n---\n\n",
              "code": "[versions]\nroom = \"2.6.1\"\nksp = \"2.0.21-1.0.27\"\ndatastore = \"1.1.1\"\n\n[libraries]\nandroidx-room-runtime = { group = \"androidx.room\", name = \"room-runtime\", version.ref = \"room\" }\nandroidx-room-ktx = { group = \"androidx.room\", name = \"room-ktx\", version.ref = \"room\" }\nandroidx-room-compiler = { group = \"androidx.room\", name = \"room-compiler\", version.ref = \"room\" }\nandroidx-datastore-preferences = { group = \"androidx.datastore\", name = \"datastore-preferences\", version.ref = \"datastore\" }\n\n[plugins]\nksp = { id = \"com.google.devtools.ksp\", version.ref = \"ksp\" }",
              "language": "toml"
            },
            {
              "type": "THEORY",
              "title": "Room Database",
              "content": "\n### Entity (Table)\n\n\n### Type Converters\n\n\n### DAO (Data Access Object)\n\n\n### Database\n\n\n---\n\n",
              "code": "import android.content.Context\nimport androidx.room.Database\nimport androidx.room.Room\nimport androidx.room.RoomDatabase\nimport androidx.room.TypeConverters\n\n@Database(\n    entities = [Task::class],\n    version = 1,\n    exportSchema = false\n)\n@TypeConverters(Converters::class)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun taskDao(): TaskDao\n\n    companion object {\n        @Volatile\n        private var INSTANCE: AppDatabase? = null\n\n        fun getDatabase(context: Context): AppDatabase {\n            return INSTANCE ?: synchronized(this) {\n                val instance = Room.databaseBuilder(\n                    context.applicationContext,\n                    AppDatabase::class.java,\n                    \"app_database\"\n                )\n                    .fallbackToDestructiveMigration()  // For development only!\n                    .build()\n\n                INSTANCE = instance\n                instance\n            }\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Repository with Room",
              "content": "\n\n---\n\n",
              "code": "class TaskRepository(private val taskDao: TaskDao) {\n    val allTasks: Flow<List<Task>> = taskDao.getAllTasks()\n\n    fun getTask(taskId: Int): Flow<Task?> = taskDao.getTask(taskId)\n\n    fun getActiveTasks(): Flow<List<Task>> = taskDao.getTasksByStatus(false)\n\n    fun getCompletedTasks(): Flow<List<Task>> = taskDao.getTasksByStatus(true)\n\n    suspend fun insertTask(task: Task): Long {\n        return taskDao.insertTask(task)\n    }\n\n    suspend fun updateTask(task: Task) {\n        taskDao.updateTask(task)\n    }\n\n    suspend fun deleteTask(task: Task) {\n        taskDao.deleteTask(task)\n    }\n\n    suspend fun toggleTaskStatus(taskId: Int, isCompleted: Boolean) {\n        taskDao.updateTaskStatus(taskId, isCompleted)\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "ViewModel with Room",
              "content": "\n\n---\n\n",
              "code": "import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport kotlinx.coroutines.flow.SharingStarted\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.stateIn\nimport kotlinx.coroutines.launch\n\nclass TasksViewModel(\n    private val repository: TaskRepository\n) : ViewModel() {\n\n    val allTasks: StateFlow<List<Task>> = repository.allTasks\n        .stateIn(\n            scope = viewModelScope,\n            started = SharingStarted.WhileSubscribed(5000),\n            initialValue = emptyList()\n        )\n\n    fun addTask(title: String, description: String, priority: Priority) {\n        viewModelScope.launch {\n            val task = Task(\n                title = title,\n                description = description,\n                priority = priority\n            )\n            repository.insertTask(task)\n        }\n    }\n\n    fun toggleTask(task: Task) {\n        viewModelScope.launch {\n            repository.updateTask(task.copy(isCompleted = !task.isCompleted))\n        }\n    }\n\n    fun deleteTask(task: Task) {\n        viewModelScope.launch {\n            repository.deleteTask(task)\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "UI with Room Data",
              "content": "\n\n---\n\n",
              "code": "@Composable\nfun TasksScreen(viewModel: TasksViewModel) {\n    val tasks by viewModel.allTasks.collectAsState()\n    var showDialog by remember { mutableStateOf(false) }\n\n    Scaffold(\n        floatingActionButton = {\n            FloatingActionButton(onClick = { showDialog = true }) {\n                Icon(Icons.Default.Add, contentDescription = \"Add task\")\n            }\n        }\n    ) { innerPadding ->\n        if (tasks.isEmpty()) {\n            Box(\n                modifier = Modifier\n                    .fillMaxSize()\n                    .padding(innerPadding),\n                contentAlignment = Alignment.Center\n            ) {\n                Text(\"No tasks yet. Add one!\")\n            }\n        } else {\n            LazyColumn(\n                modifier = Modifier.padding(innerPadding),\n                contentPadding = PaddingValues(16.dp),\n                verticalArrangement = Arrangement.spacedBy(8.dp)\n            ) {\n                items(tasks, key = { it.id }) { task ->\n                    TaskItem(\n                        task = task,\n                        onToggle = { viewModel.toggleTask(task) },\n                        onDelete = { viewModel.deleteTask(task) }\n                    )\n                }\n            }\n        }\n    }\n\n    if (showDialog) {\n        AddTaskDialog(\n            onDismiss = { showDialog = false },\n            onAdd = { title, description, priority ->\n                viewModel.addTask(title, description, priority)\n                showDialog = false\n            }\n        )\n    }\n}\n\n@Composable\nfun TaskItem(\n    task: Task,\n    onToggle: () -> Unit,\n    onDelete: () -> Unit\n) {\n    Card(\n        modifier = Modifier.fillMaxWidth()\n    ) {\n        Row(\n            modifier = Modifier.padding(16.dp),\n            verticalAlignment = Alignment.CenterVertically\n        ) {\n            Checkbox(\n                checked = task.isCompleted,\n                onCheckedChange = { onToggle() }\n            )\n\n            Spacer(modifier = Modifier.width(8.dp))\n\n            Column(modifier = Modifier.weight(1f)) {\n                Text(\n                    task.title,\n                    style = MaterialTheme.typography.titleMedium,\n                    textDecoration = if (task.isCompleted) {\n                        TextDecoration.LineThrough\n                    } else null\n                )\n                Text(\n                    task.description,\n                    style = MaterialTheme.typography.bodySmall,\n                    color = MaterialTheme.colorScheme.onSurfaceVariant\n                )\n            }\n\n            IconButton(onClick = onDelete) {\n                Icon(Icons.Default.Delete, contentDescription = \"Delete\")\n            }\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Relationships",
              "content": "\n### One-to-Many\n\n\n---\n\n",
              "code": "@Entity(tableName = \"categories\")\ndata class Category(\n    @PrimaryKey(autoGenerate = true)\n    val id: Int = 0,\n    val name: String,\n    val color: String\n)\n\n@Entity(\n    tableName = \"tasks_with_category\",\n    foreignKeys = [\n        ForeignKey(\n            entity = Category::class,\n            parentColumns = [\"id\"],\n            childColumns = [\"categoryId\"],\n            onDelete = ForeignKey.CASCADE\n        )\n    ]\n)\ndata class TaskWithCategory(\n    @PrimaryKey(autoGenerate = true)\n    val id: Int = 0,\n    val title: String,\n    val categoryId: Int\n)\n\n// Query with relationship\ndata class CategoryWithTasks(\n    @Embedded val category: Category,\n    @Relation(\n        parentColumn = \"id\",\n        entityColumn = \"categoryId\"\n    )\n    val tasks: List<TaskWithCategory>\n)\n\n@Dao\ninterface CategoryDao {\n    @Transaction\n    @Query(\"SELECT * FROM categories\")\n    fun getCategoriesWithTasks(): Flow<List<CategoryWithTasks>>\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "DataStore for Preferences",
              "content": "\n\n---\n\n",
              "code": "import android.content.Context\nimport androidx.datastore.core.DataStore\nimport androidx.datastore.preferences.core.*\nimport androidx.datastore.preferences.preferencesDataStore\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.map\n\nprivate val Context.dataStore: DataStore<Preferences> by preferencesDataStore(name = \"settings\")\n\nclass PreferencesRepository(private val context: Context) {\n\n    private object PreferencesKeys {\n        val THEME_KEY = stringPreferencesKey(\"theme\")\n        val NOTIFICATIONS_ENABLED = booleanPreferencesKey(\"notifications_enabled\")\n        val USERNAME = stringPreferencesKey(\"username\")\n    }\n\n    val theme: Flow<String> = context.dataStore.data\n        .map { preferences ->\n            preferences[PreferencesKeys.THEME_KEY] ?: \"system\"\n        }\n\n    val notificationsEnabled: Flow<Boolean> = context.dataStore.data\n        .map { preferences ->\n            preferences[PreferencesKeys.NOTIFICATIONS_ENABLED] ?: true\n        }\n\n    suspend fun setTheme(theme: String) {\n        context.dataStore.edit { preferences ->\n            preferences[PreferencesKeys.THEME_KEY] = theme\n        }\n    }\n\n    suspend fun setNotificationsEnabled(enabled: Boolean) {\n        context.dataStore.edit { preferences ->\n            preferences[PreferencesKeys.NOTIFICATIONS_ENABLED] = enabled\n        }\n    }\n\n    suspend fun setUsername(username: String) {\n        context.dataStore.edit { preferences ->\n            preferences[PreferencesKeys.USERNAME] = username\n        }\n    }\n\n    suspend fun clearPreferences() {\n        context.dataStore.edit { it.clear() }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Migration",
              "content": "\n\n---\n\n",
              "code": "val MIGRATION_1_2 = object : Migration(1, 2) {\n    override fun migrate(database: SupportSQLiteDatabase) {\n        database.execSQL(\"ALTER TABLE tasks ADD COLUMN categoryId INTEGER\")\n    }\n}\n\nval database = Room.databaseBuilder(\n    context,\n    AppDatabase::class.java,\n    \"app_database\"\n)\n    .addMigrations(MIGRATION_1_2)\n    .build()",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 1: Notes App with Room",
              "content": "\nCreate a notes app:\n- Add, edit, delete notes\n- Search notes\n- Persist to Room database\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 1",
              "content": "\n\n---\n\n",
              "code": "@Entity(tableName = \"notes\")\ndata class Note(\n    @PrimaryKey(autoGenerate = true)\n    val id: Int = 0,\n    val title: String,\n    val content: String,\n    val timestamp: Long = System.currentTimeMillis()\n)\n\n@Dao\ninterface NoteDao {\n    @Query(\"SELECT * FROM notes ORDER BY timestamp DESC\")\n    fun getAllNotes(): Flow<List<Note>>\n\n    @Query(\"SELECT * FROM notes WHERE title LIKE '%' || :query || '%' OR content LIKE '%' || :query || '%'\")\n    fun searchNotes(query: String): Flow<List<Note>>\n\n    @Insert\n    suspend fun insertNote(note: Note)\n\n    @Update\n    suspend fun updateNote(note: Note)\n\n    @Delete\n    suspend fun deleteNote(note: Note)\n}\n\nclass NotesViewModel(private val noteDao: NoteDao) : ViewModel() {\n    val allNotes: StateFlow<List<Note>> = noteDao.getAllNotes()\n        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())\n\n    fun addNote(title: String, content: String) {\n        viewModelScope.launch {\n            noteDao.insertNote(Note(title = title, content = content))\n        }\n    }\n\n    fun updateNote(note: Note) {\n        viewModelScope.launch {\n            noteDao.updateNote(note)\n        }\n    }\n\n    fun deleteNote(note: Note) {\n        viewModelScope.launch {\n            noteDao.deleteNote(note)\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 2: Favorites with DataStore",
              "content": "\nImplement favorites functionality:\n- Save favorite item IDs\n- Load favorites on app start\n- Toggle favorite status\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 2",
              "content": "\n\n---\n\n",
              "code": "import androidx.datastore.preferences.core.stringSetPreferencesKey\n\nclass FavoritesRepository(private val context: Context) {\n    private val FAVORITES_KEY = stringSetPreferencesKey(\"favorites\")\n\n    val favorites: Flow<Set<String>> = context.dataStore.data\n        .map { preferences ->\n            preferences[FAVORITES_KEY] ?: emptySet()\n        }\n\n    suspend fun addFavorite(itemId: String) {\n        context.dataStore.edit { preferences ->\n            val currentFavorites = preferences[FAVORITES_KEY]?.toMutableSet() ?: mutableSetOf()\n            currentFavorites.add(itemId)\n            preferences[FAVORITES_KEY] = currentFavorites\n        }\n    }\n\n    suspend fun removeFavorite(itemId: String) {\n        context.dataStore.edit { preferences ->\n            val currentFavorites = preferences[FAVORITES_KEY]?.toMutableSet() ?: mutableSetOf()\n            currentFavorites.remove(itemId)\n            preferences[FAVORITES_KEY] = currentFavorites\n        }\n    }\n\n    suspend fun toggleFavorite(itemId: String) {\n        context.dataStore.edit { preferences ->\n            val currentFavorites = preferences[FAVORITES_KEY]?.toMutableSet() ?: mutableSetOf()\n            if (currentFavorites.contains(itemId)) {\n                currentFavorites.remove(itemId)\n            } else {\n                currentFavorites.add(itemId)\n            }\n            preferences[FAVORITES_KEY] = currentFavorites\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 3: Offline-First App",
              "content": "\nCombine Room + Retrofit:\n- Fetch data from API\n- Cache in Room\n- Show cached data while loading\n- Update cache when new data arrives\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 3",
              "content": "\n\n---\n\n",
              "code": "class OfflineFirstRepository(\n    private val apiService: ApiService,\n    private val userDao: UserDao\n) {\n    fun getUsers(): Flow<Result<List<User>>> = flow {\n        // Emit cached data first\n        emit(Result.Loading)\n\n        val cachedUsers = userDao.getAllUsers().first()\n        if (cachedUsers.isNotEmpty()) {\n            emit(Result.Success(cachedUsers))\n        }\n\n        // Fetch from network\n        try {\n            val remoteUsers = apiService.getUsers()\n\n            // Update cache\n            userDao.deleteAll()\n            userDao.insertAll(remoteUsers)\n\n            // Emit fresh data\n            emit(Result.Success(remoteUsers))\n        } catch (e: Exception) {\n            // If network fails and we have cache, keep showing cached data\n            if (cachedUsers.isNotEmpty()) {\n                emit(Result.Success(cachedUsers))\n            } else {\n                emit(Result.Error(e.message ?: \"Unknown error\"))\n            }\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n**Statistics**:\n- **80%** of app usage happens offline or on slow networks\n- Apps with local storage have **5x** better retention\n- Users expect instant data (not \"Loading...\")\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Checkpoint Quiz",
              "content": "\n### Question 1\nWhat is Room?\n\nA) Image loading library\nB) SQLite database wrapper with type safety\nC) Network library\nD) UI component\n\n### Question 2\nWhat does `Flow<List<Task>>` provide?\n\nA) One-time data fetch\nB) Reactive updates when database changes\nC) Faster queries\nD) Automatic caching\n\n### Question 3\nWhen should you use DataStore instead of Room?\n\nA) For large datasets\nB) For simple key-value preferences\nC) For complex queries\nD) For images\n\n### Question 4\nWhat does `@PrimaryKey(autoGenerate = true)` do?\n\nA) Makes field required\nB) Generates unique ID automatically\nC) Enables caching\nD) Creates index\n\n### Question 5\nWhat is an offline-first strategy?\n\nA) Never use network\nB) Show cached data immediately, update from network\nC) Only load data once\nD) Disable network features\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Answers",
              "content": "\n**Question 1: B** - Room is a type-safe SQLite wrapper\n**Question 2: B** - Flow provides reactive, automatic updates\n**Question 3: B** - DataStore for preferences, Room for structured data\n**Question 4: B** - Auto-generates incrementing IDs\n**Question 5: B** - Show cache first, then update from network\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "What You've Learned",
              "content": "\n‚úÖ Room database setup and entities\n‚úÖ DAOs for type-safe queries\n‚úÖ Repository pattern with Room\n‚úÖ Flows for reactive data\n‚úÖ Entity relationships (one-to-many)\n‚úÖ DataStore for preferences\n‚úÖ Database migrations\n‚úÖ Offline-first architecture\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Next Steps",
              "content": "\nIn **Lesson 6.8: MVVM Architecture**, you'll learn:\n- MVVM pattern in depth\n- ViewModel lifecycle\n- LiveData vs StateFlow\n- Dependency injection with Hilt\n- Clean architecture layers\n- Testing ViewModels\n\nGet ready to structure professional apps!\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "6.8",
          "title": "Lesson 6.8: MVVM Architecture",
          "moduleId": "module-06",
          "order": 9,
          "estimatedMinutes": 70,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 70 minutes\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "\nArchitecture patterns separate concerns, make code testable, and enable team collaboration. MVVM (Model-View-ViewModel) is the recommended architecture for Android apps.\n\nIn this lesson, you'll master:\n- ‚úÖ MVVM pattern explained\n- ‚úÖ ViewModel lifecycle and scope\n- ‚úÖ LiveData vs StateFlow comparison\n- ‚úÖ Dependency injection with Hilt\n- ‚úÖ Clean architecture layers\n- ‚úÖ Testing ViewModels\n- ‚úÖ Best practices\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "MVVM Pattern",
              "content": "\n### Architecture Overview\n\n\n### Responsibilities\n\n**View** (Composables):\n- Display UI\n- Capture user input\n- Observe ViewModel state\n- **No business logic**\n\n**ViewModel**:\n- Hold UI state\n- Handle user events\n- Call repository methods\n- Transform data for UI\n- **No Android framework dependencies** (except AndroidX)\n\n**Repository**:\n- Abstract data sources\n- Combine local + remote data\n- Caching strategy\n- **Single source of truth**\n\n**Model** (Data Classes):\n- Plain data structures\n- No logic\n\n---\n\n",
              "code": "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ  View (Composables)                  ‚îÇ  UI Layer\n‚îÇ  - Displays data                     ‚îÇ\n‚îÇ  - Handles user input                ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n              ‚îÇ observes\n              ‚Üì\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ  ViewModel                           ‚îÇ  Presentation Layer\n‚îÇ  - Holds UI state                    ‚îÇ\n‚îÇ  - Business logic                    ‚îÇ\n‚îÇ  - Survives config changes           ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n              ‚îÇ calls\n              ‚Üì\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ  Repository                          ‚îÇ  Data Layer\n‚îÇ  - Single source of truth            ‚îÇ\n‚îÇ  - Manages data sources              ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n              ‚îÇ\n       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n       ‚Üì             ‚Üì\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ  Remote     ‚îÇ ‚îÇ  Local      ‚îÇ\n‚îÇ  (API)      ‚îÇ ‚îÇ  (Room)     ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "ViewModel Lifecycle",
              "content": "\n### Lifecycle Scope\n\n\n**Lifecycle**:\n\n### ViewModelScope\n\n\n---\n\n",
              "code": "class UserViewModel(private val repository: UserRepository) : ViewModel() {\n    private val _users = MutableStateFlow<List<User>>(emptyList())\n    val users: StateFlow<List<User>> = _users.asStateFlow()\n\n    fun loadUsers() {\n        viewModelScope.launch {\n            // Automatically cancelled when ViewModel is cleared\n            val result = repository.getUsers()\n            _users.value = result\n        }\n    }\n\n    override fun onCleared() {\n        super.onCleared()\n        // viewModelScope is automatically cancelled here\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "LiveData vs StateFlow",
              "content": "\n### LiveData (Legacy)\n\n\n### StateFlow (Modern, Recommended)\n\n\n### Comparison\n\n| Feature              | LiveData        | StateFlow         |\n|----------------------|-----------------|-------------------|\n| **Lifecycle aware**  | Yes             | No (use collectAsStateWithLifecycle) |\n| **Initial value**    | Optional        | Required          |\n| **Kotlin/Multiplatform** | No          | Yes               |\n| **Operators**        | Limited         | Full Flow API     |\n| **Recommendation**   | Legacy          | **Use this**      |\n\n---\n\n",
              "code": "class UserViewModel : ViewModel() {\n    private val _users = MutableStateFlow<List<User>>(emptyList())\n    val users: StateFlow<List<User>> = _users.asStateFlow()\n\n    fun loadUsers() {\n        viewModelScope.launch {\n            _users.value = repository.getUsers()\n        }\n    }\n}\n\n// In Composable\n@Composable\nfun UsersScreen(viewModel: UserViewModel) {\n    val users by viewModel.users.collectAsState()\n\n    LazyColumn {\n        items(users) { user ->\n            Text(user.name)\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Dependency Injection with Hilt",
              "content": "\n### Setup\n\nAdd in `build.gradle.kts` (project level):\n\n\nAdd in `build.gradle.kts` (app level):\n\n\n### Application Class\n\n\nUpdate `AndroidManifest.xml`:\n\n\n### Provide Dependencies\n\n\n### Inject into ViewModel\n\n\n### Use in Composable\n\n\n---\n\n",
              "code": "import androidx.hilt.navigation.compose.hiltViewModel\n\n@Composable\nfun TasksScreen(\n    viewModel: TasksViewModel = hiltViewModel()\n) {\n    val tasks by viewModel.tasks.collectAsState()\n\n    LazyColumn {\n        items(tasks) { task ->\n            Text(task.title)\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Clean Architecture Layers",
              "content": "\n### Domain Layer (Business Logic)\n\n\n### ViewModel with Use Cases\n\n\n---\n\n",
              "code": "@HiltViewModel\nclass TasksViewModel @Inject constructor(\n    private val getTasksUseCase: GetTasksUseCase,\n    private val addTaskUseCase: AddTaskUseCase,\n    private val deleteTaskUseCase: DeleteTaskUseCase\n) : ViewModel() {\n\n    val tasks: StateFlow<List<Task>> = getTasksUseCase()\n        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())\n\n    fun addTask(title: String, description: String) {\n        viewModelScope.launch {\n            addTaskUseCase(title, description)\n        }\n    }\n\n    fun deleteTask(task: Task) {\n        viewModelScope.launch {\n            deleteTaskUseCase(task)\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "UI State Pattern",
              "content": "\n### Sealed UI State\n\n\n---\n\n",
              "code": "sealed class UiState<out T> {\n    object Loading : UiState<Nothing>()\n    data class Success<T>(val data: T) : UiState<T>()\n    data class Error(val message: String) : UiState<Nothing>()\n}\n\nclass UsersViewModel @Inject constructor(\n    private val repository: UserRepository\n) : ViewModel() {\n\n    private val _uiState = MutableStateFlow<UiState<List<User>>>(UiState.Loading)\n    val uiState: StateFlow<UiState<List<User>>> = _uiState.asStateFlow()\n\n    init {\n        loadUsers()\n    }\n\n    fun loadUsers() {\n        viewModelScope.launch {\n            _uiState.value = UiState.Loading\n\n            when (val result = repository.getUsers()) {\n                is Result.Success -> {\n                    _uiState.value = UiState.Success(result.data)\n                }\n                is Result.Error -> {\n                    _uiState.value = UiState.Error(result.message)\n                }\n            }\n        }\n    }\n}\n\n@Composable\nfun UsersScreen(viewModel: UsersViewModel = hiltViewModel()) {\n    val uiState by viewModel.uiState.collectAsState()\n\n    when (val state = uiState) {\n        is UiState.Loading -> {\n            Box(Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {\n                CircularProgressIndicator()\n            }\n        }\n        is UiState.Success -> {\n            UserList(users = state.data)\n        }\n        is UiState.Error -> {\n            ErrorScreen(message = state.message, onRetry = { viewModel.loadUsers() })\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Testing ViewModels",
              "content": "\n### Unit Test Setup\n\n\n### Test ViewModel\n\n\n---\n\n",
              "code": "import kotlinx.coroutines.ExperimentalCoroutinesApi\nimport kotlinx.coroutines.test.*\nimport org.junit.After\nimport org.junit.Before\nimport org.junit.Test\nimport kotlin.test.assertEquals\n\n@ExperimentalCoroutinesApi\nclass TasksViewModelTest {\n\n    private val testDispatcher = StandardTestDispatcher()\n    private lateinit var repository: FakeTaskRepository\n    private lateinit var viewModel: TasksViewModel\n\n    @Before\n    fun setup() {\n        Dispatchers.setMain(testDispatcher)\n        repository = FakeTaskRepository()\n        viewModel = TasksViewModel(repository)\n    }\n\n    @After\n    fun tearDown() {\n        Dispatchers.resetMain()\n    }\n\n    @Test\n    fun `addTask should add task to repository`() = runTest {\n        // Given\n        val title = \"Test Task\"\n        val description = \"Test Description\"\n\n        // When\n        viewModel.addTask(title, description)\n        advanceUntilIdle()\n\n        // Then\n        val tasks = repository.tasks.value\n        assertEquals(1, tasks.size)\n        assertEquals(title, tasks[0].title)\n    }\n\n    @Test\n    fun `deleteTask should remove task from repository`() = runTest {\n        // Given\n        val task = Task(id = 1, title = \"Task\")\n        repository.insertTask(task)\n\n        // When\n        viewModel.deleteTask(task)\n        advanceUntilIdle()\n\n        // Then\n        val tasks = repository.tasks.value\n        assertEquals(0, tasks.size)\n    }\n}\n\n// Fake repository for testing\nclass FakeTaskRepository : TaskRepository {\n    private val _tasks = MutableStateFlow<List<Task>>(emptyList())\n    override val tasks: Flow<List<Task>> = _tasks\n\n    override suspend fun insertTask(task: Task) {\n        _tasks.value = _tasks.value + task\n    }\n\n    override suspend fun deleteTask(task: Task) {\n        _tasks.value = _tasks.value - task\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 1: Notes App with MVVM",
              "content": "\nCreate a notes app with proper MVVM:\n- ViewModel\n- Repository\n- Room DAO\n- UI State\n- Add/Delete notes\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 1",
              "content": "\n\n---\n\n",
              "code": "// Data class\n@Entity\ndata class Note(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    val title: String,\n    val content: String,\n    val timestamp: Long = System.currentTimeMillis()\n)\n\n// DAO\n@Dao\ninterface NoteDao {\n    @Query(\"SELECT * FROM note ORDER BY timestamp DESC\")\n    fun getAllNotes(): Flow<List<Note>>\n\n    @Insert\n    suspend fun insert(note: Note)\n\n    @Delete\n    suspend fun delete(note: Note)\n}\n\n// Repository\nclass NoteRepository @Inject constructor(\n    private val noteDao: NoteDao\n) {\n    fun getAllNotes(): Flow<List<Note>> = noteDao.getAllNotes()\n\n    suspend fun insertNote(note: Note) {\n        noteDao.insert(note)\n    }\n\n    suspend fun deleteNote(note: Note) {\n        noteDao.delete(note)\n    }\n}\n\n// ViewModel\n@HiltViewModel\nclass NotesViewModel @Inject constructor(\n    private val repository: NoteRepository\n) : ViewModel() {\n\n    val notes: StateFlow<List<Note>> = repository.getAllNotes()\n        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())\n\n    fun addNote(title: String, content: String) {\n        viewModelScope.launch {\n            repository.insertNote(Note(title = title, content = content))\n        }\n    }\n\n    fun deleteNote(note: Note) {\n        viewModelScope.launch {\n            repository.deleteNote(note)\n        }\n    }\n}\n\n// UI\n@Composable\nfun NotesScreen(viewModel: NotesViewModel = hiltViewModel()) {\n    val notes by viewModel.notes.collectAsState()\n\n    Scaffold(\n        floatingActionButton = {\n            FloatingActionButton(onClick = { /* Show add dialog */ }) {\n                Icon(Icons.Default.Add, contentDescription = \"Add\")\n            }\n        }\n    ) { padding ->\n        LazyColumn(modifier = Modifier.padding(padding)) {\n            items(notes) { note ->\n                NoteCard(note = note, onDelete = { viewModel.deleteNote(note) })\n            }\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 2: Weather App with API",
              "content": "\nCreate weather app:\n- Fetch from weather API\n- Cache in Room\n- Display with loading/error states\n- Use Hilt\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 2",
              "content": "\n\n---\n\n",
              "code": "// API\ninterface WeatherApi {\n    @GET(\"weather\")\n    suspend fun getWeather(@Query(\"city\") city: String): WeatherResponse\n}\n\n@Serializable\ndata class WeatherResponse(\n    val temperature: Double,\n    val description: String,\n    val city: String\n)\n\n// Entity\n@Entity\ndata class WeatherEntity(\n    @PrimaryKey val city: String,\n    val temperature: Double,\n    val description: String,\n    val timestamp: Long = System.currentTimeMillis()\n)\n\n// Repository\nclass WeatherRepository @Inject constructor(\n    private val api: WeatherApi,\n    private val dao: WeatherDao\n) {\n    suspend fun getWeather(city: String): Result<WeatherEntity> {\n        return try {\n            val response = api.getWeather(city)\n            val entity = WeatherEntity(\n                city = response.city,\n                temperature = response.temperature,\n                description = response.description\n            )\n            dao.insert(entity)\n            Result.Success(entity)\n        } catch (e: Exception) {\n            val cached = dao.getWeather(city)\n            if (cached != null) {\n                Result.Success(cached)\n            } else {\n                Result.Error(e.message ?: \"Unknown error\")\n            }\n        }\n    }\n}\n\n// ViewModel\n@HiltViewModel\nclass WeatherViewModel @Inject constructor(\n    private val repository: WeatherRepository\n) : ViewModel() {\n\n    private val _uiState = MutableStateFlow<UiState<WeatherEntity>>(UiState.Loading)\n    val uiState: StateFlow<UiState<WeatherEntity>> = _uiState.asStateFlow()\n\n    fun loadWeather(city: String) {\n        viewModelScope.launch {\n            _uiState.value = UiState.Loading\n\n            when (val result = repository.getWeather(city)) {\n                is Result.Success -> {\n                    _uiState.value = UiState.Success(result.data)\n                }\n                is Result.Error -> {\n                    _uiState.value = UiState.Error(result.message)\n                }\n            }\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 3: Test ViewModel",
              "content": "\nWrite unit tests for TasksViewModel:\n- Test adding task\n- Test deleting task\n- Test loading state\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 3",
              "content": "\n\n---\n\n",
              "code": "// See \"Testing ViewModels\" section above for complete example",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n**Benefits of MVVM + Clean Architecture**:\n- ‚úÖ **Testable**: ViewModels can be unit tested\n- ‚úÖ **Maintainable**: Clear separation of concerns\n- ‚úÖ **Scalable**: Easy to add features\n- ‚úÖ **Team-friendly**: Multiple developers can work independently\n\n**Statistics**:\n- Apps with architecture have **60% fewer bugs**\n- **3x** faster onboarding for new developers\n- **50%** easier to add new features\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Checkpoint Quiz",
              "content": "\n### Question 1\nWhat is the main purpose of ViewModel?\n\nA) Make network calls\nB) Hold UI state and survive configuration changes\nC) Display UI\nD) Store data in database\n\n### Question 2\nWhich is recommended for new Android apps?\n\nA) LiveData\nB) StateFlow\nC) Both are equally good\nD) Neither\n\n### Question 3\nWhat does Hilt provide?\n\nA) Network library\nB) Dependency injection\nC) Database ORM\nD) UI components\n\n### Question 4\nWhere should business logic go in MVVM?\n\nA) Composables\nB) Repository\nC) ViewModel\nD) Activity\n\n### Question 5\nWhy test ViewModels?\n\nA) Required by Google\nB) Faster than UI tests, verify business logic\nC) Makes app run faster\nD) Reduces APK size\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Answers",
              "content": "\n**Question 1: B** - ViewModel holds UI state and survives rotation\n**Question 2: B** - StateFlow is modern, Kotlin-first, more powerful\n**Question 3: B** - Hilt provides dependency injection\n**Question 4: C** - ViewModel contains business logic, View just displays\n**Question 5: B** - Unit tests are fast, reliable, verify logic without UI\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "What You've Learned",
              "content": "\n‚úÖ MVVM architecture pattern\n‚úÖ ViewModel lifecycle and scope\n‚úÖ StateFlow vs LiveData\n‚úÖ Dependency injection with Hilt\n‚úÖ Clean architecture layers\n‚úÖ UI state management\n‚úÖ Testing ViewModels\n‚úÖ Best practices for scalable apps\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Next Steps",
              "content": "\nIn **Lesson 6.9: Advanced UI & Animations**, you'll learn:\n- Animation APIs in Compose\n- animateDpAsState, animateColorAsState\n- AnimatedVisibility\n- Custom animations\n- Gestures and touch handling\n- Canvas for custom drawing\n\nGet ready to make your apps beautiful and interactive!\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "6.9",
          "title": "Lesson 6.9: Advanced UI & Animations",
          "moduleId": "module-06",
          "order": 10,
          "estimatedMinutes": 75,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 75 minutes\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "\nAnimations make apps feel alive and responsive. They guide user attention, provide feedback, and create delightful experiences. Jetpack Compose makes animations simple and declarative.\n\nIn this lesson, you'll master:\n- ‚úÖ Animation APIs overview\n- ‚úÖ Simple value animations (animateDpAsState, animateColorAsState)\n- ‚úÖ AnimatedVisibility for enter/exit animations\n- ‚úÖ Transitions for complex state changes\n- ‚úÖ Infinite and repeating animations\n- ‚úÖ Gestures and touch handling\n- ‚úÖ Canvas for custom drawing\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Animation Basics",
              "content": "\n### animate*AsState\n\nAnimate a single value when it changes:\n\n\n### Multiple Property Animations\n\n\n### Animation Specs\n\nControl animation duration and easing:\n\n\n---\n\n",
              "code": "val size by animateDpAsState(\n    targetValue = if (isExpanded) 200.dp else 100.dp,\n    animationSpec = tween(\n        durationMillis = 500,\n        easing = FastOutSlowInEasing\n    )\n)\n\n// Spring animation (bouncy)\nval offset by animateDpAsState(\n    targetValue = if (isVisible) 0.dp else 100.dp,\n    animationSpec = spring(\n        dampingRatio = Spring.DampingRatioMediumBouncy,\n        stiffness = Spring.StiffnessLow\n    )\n)\n\n// Repeatable animation\nval alpha by animateFloatAsState(\n    targetValue = if (isHighlighted) 1f else 0.3f,\n    animationSpec = repeatable(\n        iterations = 3,\n        animation = tween(durationMillis = 300),\n        repeatMode = RepeatMode.Reverse\n    )\n)",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "AnimatedVisibility",
              "content": "\n### Enter and Exit Animations\n\n\n### Custom Enter/Exit Transitions\n\n\n### Animated Content\n\nAnimate content changes:\n\n\n---\n\n",
              "code": "@Composable\nfun AnimatedCounter() {\n    var count by remember { mutableStateOf(0) }\n\n    Column(horizontalAlignment = Alignment.CenterHorizontally) {\n        AnimatedContent(\n            targetState = count,\n            transitionSpec = {\n                if (targetState > initialState) {\n                    // Counting up\n                    slideInVertically { -it } + fadeIn() togetherWith\n                            slideOutVertically { it } + fadeOut()\n                } else {\n                    // Counting down\n                    slideInVertically { it } + fadeIn() togetherWith\n                            slideOutVertically { -it } + fadeOut()\n                }\n            },\n            label = \"count\"\n        ) { targetCount ->\n            Text(\n                text = \"$targetCount\",\n                style = MaterialTheme.typography.displayLarge\n            )\n        }\n\n        Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {\n            Button(onClick = { count-- }) { Text(\"-\") }\n            Button(onClick = { count++ }) { Text(\"+\") }\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Transitions",
              "content": "\n### updateTransition\n\nCoordinate multiple animations:\n\n\n---\n\n",
              "code": "enum class BoxState { Small, Large }\n\n@Composable\nfun TransitionExample() {\n    var currentState by remember { mutableStateOf(BoxState.Small) }\n\n    val transition = updateTransition(targetState = currentState, label = \"box\")\n\n    val size by transition.animateDp(label = \"size\") { state ->\n        when (state) {\n            BoxState.Small -> 100.dp\n            BoxState.Large -> 200.dp\n        }\n    }\n\n    val color by transition.animateColor(label = \"color\") { state ->\n        when (state) {\n            BoxState.Small -> Color.Blue\n            BoxState.Large -> Color.Red\n        }\n    }\n\n    val cornerRadius by transition.animateDp(label = \"cornerRadius\") { state ->\n        when (state) {\n            BoxState.Small -> 8.dp\n            BoxState.Large -> 50.dp\n        }\n    }\n\n    Box(\n        modifier = Modifier\n            .size(size)\n            .background(color, RoundedCornerShape(cornerRadius))\n            .clickable {\n                currentState = if (currentState == BoxState.Small) {\n                    BoxState.Large\n                } else {\n                    BoxState.Small\n                }\n            }\n    )\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Infinite Animations",
              "content": "\n\n---\n\n",
              "code": "@Composable\nfun LoadingSpinner() {\n    val infiniteTransition = rememberInfiniteTransition(label = \"infinite\")\n\n    val rotation by infiniteTransition.animateFloat(\n        initialValue = 0f,\n        targetValue = 360f,\n        animationSpec = infiniteRepeatable(\n            animation = tween(durationMillis = 1000, easing = LinearEasing),\n            repeatMode = RepeatMode.Restart\n        ),\n        label = \"rotation\"\n    )\n\n    Icon(\n        Icons.Default.Refresh,\n        contentDescription = \"Loading\",\n        modifier = Modifier\n            .size(48.dp)\n            .rotate(rotation)\n    )\n}\n\n@Composable\nfun PulsingHeart() {\n    val infiniteTransition = rememberInfiniteTransition(label = \"pulse\")\n\n    val scale by infiniteTransition.animateFloat(\n        initialValue = 1f,\n        targetValue = 1.3f,\n        animationSpec = infiniteRepeatable(\n            animation = tween(600),\n            repeatMode = RepeatMode.Reverse\n        ),\n        label = \"scale\"\n    )\n\n    Icon(\n        Icons.Default.Favorite,\n        contentDescription = \"Heart\",\n        tint = Color.Red,\n        modifier = Modifier\n            .size(48.dp)\n            .scale(scale)\n    )\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Gestures",
              "content": "\n### Clickable with Ripple\n\n\n### Draggable\n\n\n### Swipe to Dismiss\n\n\n### Pointer Input (Advanced)\n\n\n---\n\n",
              "code": "@Composable\nfun DoubleTapExample() {\n    var isLiked by remember { mutableStateOf(false) }\n\n    Box(\n        modifier = Modifier\n            .size(200.dp)\n            .background(if (isLiked) Color.Red else Color.Gray)\n            .pointerInput(Unit) {\n                detectTapGestures(\n                    onDoubleTap = {\n                        isLiked = !isLiked\n                    }\n                )\n            },\n        contentAlignment = Alignment.Center\n    ) {\n        Icon(\n            Icons.Default.Favorite,\n            contentDescription = null,\n            tint = Color.White,\n            modifier = Modifier.size(64.dp)\n        )\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Canvas Drawing",
              "content": "\n### Basic Shapes\n\n\n### Custom Progress Indicator\n\n\n---\n\n",
              "code": "@Composable\nfun CircularProgressBar(\n    progress: Float,  // 0f to 1f\n    modifier: Modifier = Modifier\n) {\n    Canvas(modifier = modifier.size(120.dp)) {\n        val strokeWidth = 12.dp.toPx()\n\n        // Background circle\n        drawCircle(\n            color = Color.LightGray,\n            radius = size.minDimension / 2 - strokeWidth / 2,\n            style = Stroke(width = strokeWidth)\n        )\n\n        // Progress arc\n        drawArc(\n            color = Color.Blue,\n            startAngle = -90f,\n            sweepAngle = 360f * progress,\n            useCenter = false,\n            style = Stroke(width = strokeWidth, cap = StrokeCap.Round),\n            size = Size(\n                width = size.minDimension - strokeWidth,\n                height = size.minDimension - strokeWidth\n            ),\n            topLeft = Offset(strokeWidth / 2, strokeWidth / 2)\n        )\n    }\n}\n\n@Composable\nfun ProgressDemo() {\n    var progress by remember { mutableStateOf(0f) }\n\n    Column(horizontalAlignment = Alignment.CenterHorizontally) {\n        CircularProgressBar(progress = progress)\n\n        Slider(\n            value = progress,\n            onValueChange = { progress = it },\n            modifier = Modifier.padding(16.dp)\n        )\n\n        Text(\"${(progress * 100).toInt()}%\")\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 1: Animated Like Button",
              "content": "\nCreate a like button:\n- Heart icon\n- Scale animation when clicked\n- Color change (gray ‚Üí red)\n- Particle effect (bonus)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 1",
              "content": "\n\n---\n\n",
              "code": "@Composable\nfun AnimatedLikeButton() {\n    var isLiked by remember { mutableStateOf(false) }\n    var animationTrigger by remember { mutableStateOf(0) }\n\n    val scale by animateFloatAsState(\n        targetValue = if (animationTrigger > 0) 1.3f else 1f,\n        animationSpec = spring(\n            dampingRatio = Spring.DampingRatioMediumBouncy,\n            stiffness = Spring.StiffnessLow\n        ),\n        finishedListener = {\n            if (animationTrigger > 0) {\n                animationTrigger = 0\n            }\n        }\n    )\n\n    IconButton(\n        onClick = {\n            isLiked = !isLiked\n            animationTrigger++\n        }\n    ) {\n        Icon(\n            imageVector = if (isLiked) Icons.Filled.Favorite else Icons.Outlined.FavoriteBorder,\n            contentDescription = \"Like\",\n            tint = if (isLiked) Color.Red else Color.Gray,\n            modifier = Modifier\n                .size(32.dp)\n                .scale(scale)\n        )\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 2: Loading Skeleton",
              "content": "\nCreate a shimmer loading effect:\n- Animated gradient\n- Placeholder cards\n- Smooth animation\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 2",
              "content": "\n\n---\n\n",
              "code": "@Composable\nfun ShimmerEffect() {\n    val infiniteTransition = rememberInfiniteTransition(label = \"shimmer\")\n\n    val offset by infiniteTransition.animateFloat(\n        initialValue = 0f,\n        targetValue = 1000f,\n        animationSpec = infiniteRepeatable(\n            animation = tween(durationMillis = 1000, easing = LinearEasing),\n            repeatMode = RepeatMode.Restart\n        ),\n        label = \"offset\"\n    )\n\n    val brush = Brush.linearGradient(\n        colors = listOf(\n            Color.LightGray.copy(alpha = 0.6f),\n            Color.LightGray.copy(alpha = 0.2f),\n            Color.LightGray.copy(alpha = 0.6f)\n        ),\n        start = Offset(offset - 300f, offset - 300f),\n        end = Offset(offset, offset)\n    )\n\n    Column(modifier = Modifier.padding(16.dp), verticalArrangement = Arrangement.spacedBy(16.dp)) {\n        repeat(3) {\n            Card(modifier = Modifier.fillMaxWidth()) {\n                Row(modifier = Modifier.padding(16.dp)) {\n                    // Avatar placeholder\n                    Box(\n                        modifier = Modifier\n                            .size(48.dp)\n                            .clip(CircleShape)\n                            .background(brush)\n                    )\n\n                    Spacer(modifier = Modifier.width(12.dp))\n\n                    Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {\n                        // Title placeholder\n                        Box(\n                            modifier = Modifier\n                                .width(200.dp)\n                                .height(16.dp)\n                                .clip(RoundedCornerShape(4.dp))\n                                .background(brush)\n                        )\n\n                        // Subtitle placeholder\n                        Box(\n                            modifier = Modifier\n                                .width(150.dp)\n                                .height(14.dp)\n                                .clip(RoundedCornerShape(4.dp))\n                                .background(brush)\n                        )\n                    }\n                }\n            }\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 3: Pull to Refresh",
              "content": "\nImplement pull-to-refresh:\n- Drag gesture\n- Loading indicator\n- Smooth animation\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 3",
              "content": "\n\n---\n\n",
              "code": "@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun PullToRefreshExample() {\n    var isRefreshing by remember { mutableStateOf(false) }\n    var items by remember { mutableStateOf(List(20) { \"Item $it\" }) }\n    val pullRefreshState = rememberPullToRefreshState()\n\n    LaunchedEffect(isRefreshing) {\n        if (isRefreshing) {\n            delay(2000)  // Simulate network call\n            items = List(20) { \"Item ${it + items.size}\" }\n            isRefreshing = false\n        }\n    }\n\n    Box(modifier = Modifier.fillMaxSize()) {\n        LazyColumn(\n            modifier = Modifier\n                .fillMaxSize()\n                .pullToRefresh(\n                    state = pullRefreshState,\n                    isRefreshing = isRefreshing,\n                    onRefresh = { isRefreshing = true }\n                )\n        ) {\n            items(items) { item ->\n                Text(\n                    item,\n                    modifier = Modifier\n                        .fillMaxWidth()\n                        .padding(16.dp)\n                )\n            }\n        }\n\n        if (pullRefreshState.isRefreshing) {\n            LinearProgressIndicator(modifier = Modifier.fillMaxWidth())\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n**User Experience Impact**:\n- Animations increase engagement by **20%**\n- Users perceive animated apps as **faster** and more polished\n- Proper feedback reduces perceived wait time by **30%**\n\n**Best Practices**:\n- ‚úÖ Keep animations under 300ms (feel instant)\n- ‚úÖ Use spring animations for natural feel\n- ‚úÖ Provide feedback for all user actions\n- ‚úÖ Don't overuse animations (distracting)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Checkpoint Quiz",
              "content": "\n### Question 1\nWhat does `animateDpAsState` do?\n\nA) Creates a static value\nB) Animates a Dp value when target changes\nC) Only works for colors\nD) Requires manual triggering\n\n### Question 2\nHow do you create an infinite animation?\n\nA) Set duration to infinity\nB) Use `rememberInfiniteTransition`\nC) Call animation repeatedly\nD) Not possible\n\n### Question 3\nWhat is `AnimatedVisibility` used for?\n\nA) Making views transparent\nB) Animating enter/exit of composables\nC) Checking if animation is running\nD) Debugging animations\n\n### Question 4\nWhich gesture detector is built into Compose?\n\nA) Only click\nB) Click, drag, swipe, and custom gestures\nC) No gestures supported\nD) Only swipe\n\n### Question 5\nWhat can Canvas be used for?\n\nA) Only images\nB) Custom drawings (shapes, paths, gradients)\nC) Only text\nD) Cannot draw anything\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Answers",
              "content": "\n**Question 1: B** - Animates Dp when target value changes\n**Question 2: B** - Use `rememberInfiniteTransition` with `infiniteRepeatable`\n**Question 3: B** - Handles enter/exit animations automatically\n**Question 4: B** - Full gesture support (tap, drag, swipe, custom)\n**Question 5: B** - Draw custom shapes, paths, gradients, etc.\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "What You've Learned",
              "content": "\n‚úÖ Simple value animations with animate*AsState\n‚úÖ AnimatedVisibility for enter/exit transitions\n‚úÖ Complex transitions with updateTransition\n‚úÖ Infinite animations for loaders\n‚úÖ Gesture handling (click, drag, swipe)\n‚úÖ Custom drawing with Canvas\n‚úÖ Performance considerations\n‚úÖ UX best practices\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Next Steps",
              "content": "\nIn **Lesson 6.10: Part 6 Capstone - Task Manager App**, you'll build:\n- Complete Android app from scratch\n- All concepts integrated (MVVM, Room, Navigation, Animations)\n- Task CRUD operations\n- Categories, priorities, due dates\n- Material Design 3 UI\n- Fully functional production-ready app\n\nTime to put everything together!\n\n"
            }
          ],
          "challenges": []
        }
      ],
      "quizzes": [
        {
          "id": "part6-quiz-6.1",
          "title": "Introduction to Frontend Development Quiz",
          "description": "Knowledge check for Introduction to Frontend Development Quiz",
          "moduleId": "module-06",
          "passingScore": 70,
          "estimatedMinutes": 10,
          "questions": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "6.1.q1",
              "title": "What is frontend development?",
              "description": "What is frontend development?",
              "options": [
                "Server-side programming",
                "Database management",
                "Building the user interface that users interact with",
                "Network configuration"
              ],
              "correctAnswer": 2,
              "explanation": "Frontend development is building the user interface - everything users see and interact with."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "6.1.q2",
              "title": "What is React?",
              "description": "What is React?",
              "options": [
                "A database",
                "A component-based UI library",
                "A backend framework",
                "A programming language"
              ],
              "correctAnswer": 1,
              "explanation": "React is a JavaScript library for building component-based user interfaces."
            },
            {
              "type": "TRUE_FALSE",
              "id": "6.1.q3",
              "title": "Kotlin/JS allows you to write frontend code in Kotlin that compiles to JavaScript.",
              "description": "Kotlin/JS allows you to write frontend code in Kotlin that compiles to JavaScript.",
              "question": "Kotlin/JS allows you to write frontend code in Kotlin that compiles to JavaScript.",
              "correctAnswer": true,
              "explanation": "True. Kotlin/JS compiles Kotlin code to JavaScript that runs in browsers."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "6.1.q4",
              "title": "What is state in React?",
              "description": "What is state in React?",
              "options": [
                "The physical location of the server",
                "Data that changes over time and triggers re-renders",
                "CSS styling",
                "The HTML structure"
              ],
              "correctAnswer": 1,
              "explanation": "State is data that changes over time. When state changes, React re-renders the component."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "6.1.q5",
              "title": "What are props in React?",
              "description": "What are props in React?",
              "options": [
                "CSS properties",
                "Database properties",
                "Data passed from parent to child components",
                "Server endpoints"
              ],
              "correctAnswer": 2,
              "explanation": "Props (properties) are data passed from parent components to child components."
            }
          ]
        },
        {
          "id": "part6-quiz-6.2",
          "title": "Advanced Frontend Quiz",
          "description": "Knowledge check for Advanced Frontend Quiz",
          "moduleId": "module-06",
          "passingScore": 70,
          "estimatedMinutes": 10,
          "questions": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "6.2.q1",
              "title": "What is useState used for?",
              "description": "What is useState used for?",
              "options": [
                "Making API calls",
                "Managing component state",
                "Routing between pages",
                "Styling components"
              ],
              "correctAnswer": 1,
              "explanation": "useState is a React hook for managing state within functional components."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "6.2.q2",
              "title": "What is useEffect used for?",
              "description": "What is useEffect used for?",
              "options": [
                "Creating variables",
                "Handling side effects like API calls and subscriptions",
                "Styling components",
                "Defining routes"
              ],
              "correctAnswer": 1,
              "explanation": "useEffect handles side effects like data fetching, subscriptions, and DOM manipulation."
            },
            {
              "type": "TRUE_FALSE",
              "id": "6.2.q3",
              "title": "Form validation should be done on both frontend and backend.",
              "description": "Form validation should be done on both frontend and backend.",
              "question": "Form validation should be done on both frontend and backend.",
              "correctAnswer": true,
              "explanation": "True. Always validate on both sides - frontend for UX, backend for security."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "6.2.q4",
              "title": "What is a custom hook?",
              "description": "What is a custom hook?",
              "options": [
                "A fishing tool",
                "A reusable function that uses React hooks",
                "A CSS property",
                "A database query"
              ],
              "correctAnswer": 1,
              "explanation": "Custom hooks are reusable functions that encapsulate logic using React hooks."
            },
            {
              "type": "TRUE_FALSE",
              "id": "6.2.q5",
              "title": "In React, you should never mutate state directly - always use setState.",
              "description": "In React, you should never mutate state directly - always use setState.",
              "question": "In React, you should never mutate state directly - always use setState.",
              "correctAnswer": true,
              "explanation": "True. Direct state mutation doesn't trigger re-renders. Always use setState functions."
            }
          ]
        }
      ]
    },
    {
      "id": "module-07",
      "title": "Part 7: Kotlin Fundamentals",
      "description": "Learn Kotlin programming - Part 7",
      "difficulty": "advanced",
      "estimatedHours": 10,
      "lessons": [
        {
          "id": "7.1",
          "title": "Lesson 7.1: Kotlin Multiplatform (KMP) Basics",
          "moduleId": "module-07",
          "order": 1,
          "estimatedMinutes": 75,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 75 minutes\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "\nWelcome to Part 7 of the Kotlin Training Course! In this final section, we'll explore advanced topics and deployment strategies that will take your Kotlin skills to a professional level.\n\n**Kotlin Multiplatform (KMP)** is one of Kotlin's most powerful features - it allows you to share code across multiple platforms (Android, iOS, web, desktop, backend) while still accessing platform-specific APIs when needed.\n\nImagine writing your business logic once and using it everywhere:\n- ‚úÖ Android app (Jetpack Compose)\n- ‚úÖ iOS app (SwiftUI)\n- ‚úÖ Web application (Kotlin/JS)\n- ‚úÖ Desktop application (Compose Desktop)\n- ‚úÖ Backend server (Ktor)\n\nThis isn't just theory - companies like Netflix, VMware, Philips, and Cash App use KMP in production.\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "What is Kotlin Multiplatform?",
              "content": "\n### The Problem It Solves\n\nTraditional mobile development faces challenges:\n\n**Without KMP**:\n\n**Issues**:\n- Same logic written 4 times in 4 languages\n- Bug fixes need to be applied 4 times\n- Features roll out inconsistently\n- Testing multiplied by 4\n\n**With KMP**:\n\n**Benefits**:\n- Write business logic once, use everywhere\n- Fix bugs in one place\n- Consistent behavior across platforms\n- 40-70% code sharing in real projects\n\n---\n\n",
              "code": "Shared Code (Kotlin)\n    ‚îú‚îÄ‚îÄ Business Logic (once!)\n    ‚îú‚îÄ‚îÄ Data Models\n    ‚îú‚îÄ‚îÄ API Client\n    ‚îú‚îÄ‚îÄ Database Logic\n    ‚îî‚îÄ‚îÄ Validation Rules\n\nPlatform-Specific Code\n    ‚îú‚îÄ‚îÄ Android UI (Jetpack Compose)\n    ‚îú‚îÄ‚îÄ iOS UI (SwiftUI)\n    ‚îú‚îÄ‚îÄ Web UI (React/Kotlin JS)\n    ‚îî‚îÄ‚îÄ Desktop UI (Compose Desktop)",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "KMP Architecture",
              "content": "\n### Shared vs Platform-Specific Code\n\n\n### What to Share\n\n**Perfect for Sharing**:\n- ‚úÖ Data models\n- ‚úÖ Business logic\n- ‚úÖ API clients\n- ‚úÖ Validation rules\n- ‚úÖ Utilities (date formatting, calculations)\n- ‚úÖ Database operations\n\n**Platform-Specific**:\n- ‚ùå UI code (different frameworks)\n- ‚ùå Platform APIs (camera, notifications)\n- ‚ùå Platform-specific libraries\n\n---\n\n",
              "code": "project/\n‚îú‚îÄ‚îÄ commonMain/          # Shared code for all platforms\n‚îÇ   ‚îú‚îÄ‚îÄ kotlin/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models/      # Data classes\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api/         # Network client\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ database/    # Database logic\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ business/    # Business logic\n‚îÇ   ‚îî‚îÄ‚îÄ resources/\n‚îú‚îÄ‚îÄ androidMain/         # Android-specific code\n‚îÇ   ‚îî‚îÄ‚îÄ kotlin/\n‚îú‚îÄ‚îÄ iosMain/             # iOS-specific code\n‚îÇ   ‚îî‚îÄ‚îÄ kotlin/\n‚îú‚îÄ‚îÄ jvmMain/             # JVM/Desktop-specific code\n‚îÇ   ‚îî‚îÄ‚îÄ kotlin/\n‚îî‚îÄ‚îÄ jsMain/              # JavaScript-specific code\n    ‚îî‚îÄ‚îÄ kotlin/",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Expect/Actual Declarations",
              "content": "\nThe `expect/actual` mechanism allows you to declare a common interface in shared code and provide platform-specific implementations.\n\n### How It Works\n\n**Common Code (commonMain)**:\n\n**Android Implementation (androidMain)**:\n\n**iOS Implementation (iosMain)**:\n\n**Usage in Shared Code**:\n\n---\n\n",
              "code": "// This works on all platforms!\nfun greet(): String {\n    val platform = Platform()\n    return \"Hello from ${platform.name} at ${getCurrentTimeMillis()}\"\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Setting Up a KMP Project",
              "content": "\n### Project Structure\n\n**build.gradle.kts (Project Level)**:\n\n**build.gradle.kts (Module Level)**:\n\n---\n\n",
              "code": "plugins {\n    kotlin(\"multiplatform\")\n    kotlin(\"plugin.serialization\")\n}\n\nkotlin {\n    // Target platforms\n    androidTarget {\n        compilations.all {\n            kotlinOptions {\n                jvmTarget = \"17\"\n            }\n        }\n    }\n\n    iosX64()\n    iosArm64()\n    iosSimulatorArm64()\n\n    jvm() // For desktop/backend\n    js(IR) { browser() } // For web\n\n    // Source sets\n    sourceSets {\n        // Common code\n        val commonMain by getting {\n            dependencies {\n                implementation(\"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.7.3\")\n                implementation(\"org.jetbrains.kotlinx:kotlinx-serialization-json:1.6.2\")\n                implementation(\"io.ktor:ktor-client-core:2.3.7\")\n            }\n        }\n\n        val commonTest by getting {\n            dependencies {\n                implementation(kotlin(\"test\"))\n            }\n        }\n\n        // Android\n        val androidMain by getting {\n            dependencies {\n                implementation(\"io.ktor:ktor-client-android:2.3.7\")\n            }\n        }\n\n        // iOS\n        val iosMain by creating {\n            dependsOn(commonMain)\n            dependencies {\n                implementation(\"io.ktor:ktor-client-darwin:2.3.7\")\n            }\n        }\n\n        val iosX64Main by getting { dependsOn(iosMain) }\n        val iosArm64Main by getting { dependsOn(iosMain) }\n        val iosSimulatorArm64Main by getting { dependsOn(iosMain) }\n\n        // JVM\n        val jvmMain by getting {\n            dependencies {\n                implementation(\"io.ktor:ktor-client-cio:2.3.7\")\n            }\n        }\n\n        // JS\n        val jsMain by getting {\n            dependencies {\n                implementation(\"io.ktor:ktor-client-js:2.3.7\")\n            }\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Sharing Business Logic",
              "content": "\n### Example: Shopping Cart\n\n**Shared Models (commonMain)**:\n\n**Shared Business Logic (commonMain)**:\n\n**Usage in Android**:\n\n**Usage in iOS**:\n\n---\n\n",
              "code": "// iOS ViewModel (Swift)\nclass ShoppingViewModel: ObservableObject {\n    private let cart = ShoppingCart() // Same shared code!\n\n    @Published var items: [CartItem] = []\n\n    func addToCart(product: Product) {\n        cart.addItem(product: product, quantity: 1)\n        items = cart.getItems()\n    }\n\n    var total: Double {\n        cart.getTotal()\n    }\n}",
              "language": "swift"
            },
            {
              "type": "THEORY",
              "title": "Platform-Specific Implementations",
              "content": "\n### Example: Storage Layer\n\n**Common Interface (commonMain)**:\n\n**Android Implementation (androidMain)**:\n\n**iOS Implementation (iosMain)**:\n\n**Usage in Shared Code**:\n\n---\n\n",
              "code": "class UserPreferences(private val storage: KeyValueStorage) {\n    fun saveUsername(username: String) {\n        storage.putString(\"username\", username)\n    }\n\n    fun getUsername(): String? {\n        return storage.getString(\"username\")\n    }\n\n    fun logout() {\n        storage.clear()\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Shared API Client",
              "content": "\n### Common Network Layer\n\n**API Client (commonMain)**:\n\n**Models (commonMain)**:\n\nThis API client works on **all platforms** without modification!\n\n---\n\n",
              "code": "package com.example.shared.api\n\nimport kotlinx.serialization.Serializable\n\n@Serializable\ndata class CreateOrderRequest(\n    val items: List<OrderItem>,\n    val totalAmount: Double\n)\n\n@Serializable\ndata class OrderItem(\n    val productId: String,\n    val quantity: Int,\n    val price: Double\n)\n\n@Serializable\ndata class Order(\n    val id: String,\n    val items: List<OrderItem>,\n    val totalAmount: Double,\n    val status: String,\n    val createdAt: String\n)",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 1: Build a Shared Authentication Module",
              "content": "\nCreate a KMP module that handles user authentication across platforms.\n\n### Requirements\n\n1. **Shared Models** (commonMain):\n   - `User` (id, email, name, token)\n   - `LoginRequest` (email, password)\n   - `RegisterRequest` (email, password, name)\n   - `AuthResponse` (success, user, token, message)\n\n2. **Shared AuthService** (commonMain):\n   - `login(email, password): Result<User>`\n   - `register(request): Result<User>`\n   - `logout()`\n   - `isLoggedIn(): Boolean`\n   - `getCurrentUser(): User?`\n\n3. **Platform-Specific Storage**:\n   - Android: Use SharedPreferences\n   - iOS: Use UserDefaults\n   - Store and retrieve auth token\n\n4. **Validation**:\n   - Email validation\n   - Password strength check (min 8 chars, 1 uppercase, 1 number)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 1",
              "content": "\n**Common Models (commonMain)**:\n\n**Validation Utilities (commonMain)**:\n\n**Storage Interface (commonMain)**:\n\n**Android Storage (androidMain)**:\n\n**iOS Storage (iosMain)**:\n\n**Auth Service (commonMain)**:\n\n---\n\n",
              "code": "// shared/src/commonMain/kotlin/com/example/shared/service/AuthService.kt\npackage com.example.shared.service\n\nimport com.example.shared.models.*\nimport com.example.shared.storage.TokenStorage\nimport com.example.shared.utils.Validation\nimport io.ktor.client.*\nimport io.ktor.client.call.*\nimport io.ktor.client.request.*\nimport io.ktor.client.plugins.contentnegotiation.*\nimport io.ktor.serialization.kotlinx.json.*\nimport kotlinx.serialization.json.Json\n\nclass AuthService(\n    private val baseUrl: String,\n    private val tokenStorage: TokenStorage\n) {\n    private var currentUser: User? = null\n\n    private val client = HttpClient {\n        install(ContentNegotiation) {\n            json(Json { ignoreUnknownKeys = true })\n        }\n    }\n\n    suspend fun login(email: String, password: String): Result<User> {\n        val request = LoginRequest(email, password)\n\n        // Validate\n        val validationError = Validation.validateLoginRequest(request)\n        if (validationError != null) {\n            return Result.failure(IllegalArgumentException(validationError))\n        }\n\n        return try {\n            val response: AuthResponse = client.post(\"$baseUrl/auth/login\") {\n                setBody(request)\n            }.body()\n\n            if (response.success && response.user != null && response.token != null) {\n                currentUser = response.user\n                tokenStorage.saveToken(response.token)\n                Result.success(response.user)\n            } else {\n                Result.failure(Exception(response.message ?: \"Login failed\"))\n            }\n        } catch (e: Exception) {\n            Result.failure(e)\n        }\n    }\n\n    suspend fun register(request: RegisterRequest): Result<User> {\n        // Validate\n        val validationError = Validation.validateRegisterRequest(request)\n        if (validationError != null) {\n            return Result.failure(IllegalArgumentException(validationError))\n        }\n\n        return try {\n            val response: AuthResponse = client.post(\"$baseUrl/auth/register\") {\n                setBody(request)\n            }.body()\n\n            if (response.success && response.user != null && response.token != null) {\n                currentUser = response.user\n                tokenStorage.saveToken(response.token)\n                Result.success(response.user)\n            } else {\n                Result.failure(Exception(response.message ?: \"Registration failed\"))\n            }\n        } catch (e: Exception) {\n            Result.failure(e)\n        }\n    }\n\n    fun logout() {\n        currentUser = null\n        tokenStorage.clearToken()\n    }\n\n    fun isLoggedIn(): Boolean {\n        return tokenStorage.getToken() != null\n    }\n\n    fun getCurrentUser(): User? {\n        return currentUser\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 2: Create a Platform Logger",
              "content": "\nBuild a logging utility that uses platform-specific logging mechanisms.\n\n### Requirements\n\n1. Create `Logger` expect class with methods:\n   - `debug(tag: String, message: String)`\n   - `info(tag: String, message: String)`\n   - `warning(tag: String, message: String)`\n   - `error(tag: String, message: String, throwable: Throwable?)`\n\n2. Android: Use `android.util.Log`\n3. iOS: Use `NSLog`\n4. JVM: Use `println` with timestamps\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 2",
              "content": "\n**Common Declaration (commonMain)**:\n\n**Android Implementation (androidMain)**:\n\n**iOS Implementation (iosMain)**:\n\n**JVM Implementation (jvmMain)**:\n\n**Usage (commonMain)**:\n\n---\n\n",
              "code": "class UserRepository {\n    suspend fun getUser(id: String): User? {\n        Logger.debug(\"UserRepository\", \"Fetching user: $id\")\n\n        return try {\n            val user = api.getUser(id)\n            Logger.info(\"UserRepository\", \"User fetched successfully\")\n            user\n        } catch (e: Exception) {\n            Logger.error(\"UserRepository\", \"Failed to fetch user\", e)\n            null\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 3: Build a Shared Repository Pattern",
              "content": "\nCreate a repository that manages data fetching and caching across platforms.\n\n### Requirements\n\n1. **ProductRepository** (commonMain):\n   - Fetch products from API\n   - Cache in memory\n   - Return cached data if available and fresh (< 5 minutes)\n   - Refresh from API if cache expired\n\n2. Use Ktor for networking\n3. Handle errors gracefully\n4. Log cache hits/misses\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 3",
              "content": "\n\n**Platform Implementations**:\n\n\n\n\n---\n\n",
              "code": "// shared/src/jvmMain/kotlin/com/example/shared/repository/Time.kt\npackage com.example.shared.repository\n\nactual fun getCurrentTimeMillis(): Long = System.currentTimeMillis()",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n### Real-World Impact\n\n**Companies Using KMP**:\n- **Netflix**: Shares business logic between Android and iOS apps\n- **VMware**: Uses KMP for cross-platform SDK\n- **Philips**: Medical devices with shared Bluetooth logic\n- **Cash App**: Payment processing logic shared across platforms\n- **Autodesk**: CAD software with shared rendering engine\n\n**Business Benefits**:\n- **40-70% code reuse** in production apps\n- **Faster time to market**: Build features once\n- **Fewer bugs**: Single source of truth\n- **Consistent UX**: Same logic = same behavior\n- **Easier maintenance**: Fix once, deploy everywhere\n\n**Developer Benefits**:\n- Write Kotlin (not Swift/Java/JavaScript)\n- Share tests across platforms\n- Type-safe, null-safe code everywhere\n- Use Kotlin coroutines on all platforms\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Checkpoint Quiz",
              "content": "\n### Question 1\nWhat is the primary benefit of Kotlin Multiplatform?\n\nA) Faster app performance\nB) Sharing code across multiple platforms\nC) Smaller app size\nD) Better UI design\n\n### Question 2\nWhat does the `expect` keyword do in KMP?\n\nA) Waits for a coroutine to complete\nB) Declares a function that must be implemented on each platform\nC) Handles exceptions\nD) Creates a nullable type\n\n### Question 3\nWhich type of code is best suited for sharing in KMP?\n\nA) UI components\nB) Business logic and data models\nC) Platform-specific APIs\nD) Native libraries\n\n### Question 4\nIn a KMP project, where do you write code that works on all platforms?\n\nA) androidMain\nB) iosMain\nC) commonMain\nD) jvmMain\n\n### Question 5\nWhat happens if you don't provide an `actual` implementation for an `expect` declaration?\n\nA) It uses a default implementation\nB) Compilation fails\nC) It returns null\nD) It throws a runtime exception\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Answers",
              "content": "\n**Question 1: B) Sharing code across multiple platforms**\n\nKMP's main goal is code reuse:\n- Write business logic once in Kotlin\n- Use on Android, iOS, web, desktop, backend\n- Reduce duplication and maintenance burden\n- 40-70% code sharing in real projects\n\n---\n\n**Question 2: B) Declares a function that must be implemented on each platform**\n\nThe `expect/actual` mechanism:\n\nEach platform provides its `actual` implementation.\n\n---\n\n**Question 3: B) Business logic and data models**\n\n**Perfect for sharing**:\n- Data models (User, Product, Order)\n- Business logic (validation, calculations)\n- API clients\n- Repositories\n- Utilities\n\n**Not suitable for sharing**:\n- UI code (different frameworks)\n- Platform-specific APIs (camera, GPS)\n\n---\n\n**Question 4: C) commonMain**\n\nKMP source sets:\n- **commonMain**: Code for all platforms\n- **androidMain**: Android-specific code\n- **iosMain**: iOS-specific code\n- **jvmMain**: JVM/Desktop code\n- **jsMain**: JavaScript/Web code\n\n---\n\n**Question 5: B) Compilation fails**\n\nThe compiler enforces complete implementation:\n\nThis prevents runtime errors and ensures consistency.\n\n---\n\n",
              "code": "// commonMain\nexpect class Logger {\n    fun log(message: String)\n}\n\n// If you forget androidMain implementation:\n// ERROR: Expected class Logger has no actual declaration",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "What You've Learned",
              "content": "\n‚úÖ What Kotlin Multiplatform is and why it matters\n‚úÖ The architecture of KMP projects (commonMain, platform-specific)\n‚úÖ How to use `expect/actual` declarations for platform-specific code\n‚úÖ How to set up a KMP project with Gradle\n‚úÖ How to share business logic across Android, iOS, and other platforms\n‚úÖ How to create platform-specific implementations (storage, logging)\n‚úÖ How to build shared API clients and repositories\n‚úÖ Real-world use cases and benefits of KMP\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Next Steps",
              "content": "\nIn **Lesson 7.2: Testing Strategies**, you'll learn:\n- Unit testing with JUnit 5 and Kotest\n- Mocking with MockK\n- Testing coroutines and flows\n- Testing Jetpack Compose UI\n- Test-driven development (TDD)\n- Measuring and improving code coverage\n\nTesting shared KMP code ensures it works correctly on all platforms!\n\n---\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "7.1.1",
              "title": "API Request/Response Models",
              "description": "Create data classes for a task management API: Task, CreateTaskRequest, and UpdateTaskRequest.",
              "instructions": "Create data classes for a task management API: Task, CreateTaskRequest, and UpdateTaskRequest.",
              "starterCode": "// Create Task data class with: id, title, description, completed, priority, userId\n\n// Create CreateTaskRequest with: title, description, priority\n\n// Create UpdateTaskRequest with nullable fields: title?, description?, completed?\n\nfun main() {\n    val task = Task(1, \"Learn Kotlin\", \"Complete course\", false, \"high\", 1)\n    val createRequest = CreateTaskRequest(\"New Task\", \"Description\", \"medium\")\n    val updateRequest = UpdateTaskRequest(null, null, true)\n    \n    println(task)\n    println(createRequest)\n    println(updateRequest)\n}",
              "solution": "data class Task(\n    val id: Int,\n    val title: String,\n    val description: String,\n    val completed: Boolean,\n    val priority: String,\n    val userId: Int\n)\n\ndata class CreateTaskRequest(\n    val title: String,\n    val description: String,\n    val priority: String\n)\n\ndata class UpdateTaskRequest(\n    val title: String?,\n    val description: String?,\n    val completed: Boolean?\n)\n\nfun main() {\n    val task = Task(1, \"Learn Kotlin\", \"Complete course\", false, \"high\", 1)\n    val createRequest = CreateTaskRequest(\"New Task\", \"Description\", \"medium\")\n    val updateRequest = UpdateTaskRequest(null, null, true)\n    \n    println(task)\n    println(createRequest)\n    println(updateRequest)\n}",
              "language": "kotlin",
              "testCases": [
                {
                  "description": "Should create task model",
                  "expectedOutput": "Task(id=1, title=Learn Kotlin",
                  "isVisible": true
                },
                {
                  "description": "Should create request models",
                  "expectedOutput": "CreateTaskRequest(title=New Task",
                  "isVisible": true
                },
                {
                  "description": "Should handle nullable updates",
                  "expectedOutput": "UpdateTaskRequest(title=null, description=null, completed=true)",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use data class for all models"
                },
                {
                  "level": 2,
                  "text": "Task has all required fields"
                },
                {
                  "level": 3,
                  "text": "CreateTaskRequest doesn't include id (server generates it)"
                },
                {
                  "level": 4,
                  "text": "UpdateTaskRequest has nullable fields (only update what's provided)"
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "7.1.2",
              "title": "Task Repository Pattern",
              "description": "Create a TaskRepository class with in-memory storage for CRUD operations on tasks.",
              "instructions": "Create a TaskRepository class with in-memory storage for CRUD operations on tasks.",
              "starterCode": "data class Task(\n    val id: Int,\n    val title: String,\n    val description: String,\n    var completed: Boolean,\n    val userId: Int\n)\n\nclass TaskRepository {\n    private val tasks = mutableListOf<Task>()\n    private var nextId = 1\n    \n    fun create(title: String, description: String, userId: Int): Task {\n        // Create and add task\n    }\n    \n    fun findAll(userId: Int): List<Task> {\n        // Find all tasks for user\n    }\n    \n    fun findById(id: Int): Task? {\n        // Find task by ID\n    }\n    \n    fun update(id: Int, title: String?, description: String?, completed: Boolean?): Boolean {\n        // Update task fields if not null\n    }\n    \n    fun delete(id: Int): Boolean {\n        // Delete task\n    }\n}\n\nfun main() {\n    val repo = TaskRepository()\n    val task1 = repo.create(\"Task 1\", \"Description 1\", 1)\n    val task2 = repo.create(\"Task 2\", \"Description 2\", 1)\n    \n    println(\"All tasks: ${repo.findAll(1)}\")\n    repo.update(1, null, null, true)\n    println(\"After update: ${repo.findById(1)}\")\n    repo.delete(2)\n    println(\"After delete: ${repo.findAll(1).size}\")\n}",
              "solution": "data class Task(\n    val id: Int,\n    val title: String,\n    val description: String,\n    var completed: Boolean,\n    val userId: Int\n)\n\nclass TaskRepository {\n    private val tasks = mutableListOf<Task>()\n    private var nextId = 1\n    \n    fun create(title: String, description: String, userId: Int): Task {\n        val task = Task(nextId++, title, description, false, userId)\n        tasks.add(task)\n        return task\n    }\n    \n    fun findAll(userId: Int): List<Task> {\n        return tasks.filter { it.userId == userId }\n    }\n    \n    fun findById(id: Int): Task? {\n        return tasks.find { it.id == id }\n    }\n    \n    fun update(id: Int, title: String?, description: String?, completed: Boolean?): Boolean {\n        val task = findById(id) ?: return false\n        val index = tasks.indexOf(task)\n        tasks[index] = task.copy(\n            title = title ?: task.title,\n            description = description ?: task.description,\n            completed = completed ?: task.completed\n        )\n        return true\n    }\n    \n    fun delete(id: Int): Boolean {\n        return tasks.removeIf { it.id == id }\n    }\n}\n\nfun main() {\n    val repo = TaskRepository()\n    val task1 = repo.create(\"Task 1\", \"Description 1\", 1)\n    val task2 = repo.create(\"Task 2\", \"Description 2\", 1)\n    \n    println(\"All tasks: ${repo.findAll(1)}\")\n    repo.update(1, null, null, true)\n    println(\"After update: ${repo.findById(1)}\")\n    repo.delete(2)\n    println(\"After delete: ${repo.findAll(1).size}\")\n}",
              "language": "kotlin",
              "testCases": [
                {
                  "description": "Should create and find all tasks",
                  "expectedOutput": "All tasks: [Task(id=1",
                  "isVisible": true
                },
                {
                  "description": "Should update task",
                  "expectedOutput": "completed=true",
                  "isVisible": true
                },
                {
                  "description": "Should delete task",
                  "expectedOutput": "After delete: 1",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use mutableListOf for storage"
                },
                {
                  "level": 2,
                  "text": "Auto-increment nextId for new tasks"
                },
                {
                  "level": 3,
                  "text": "filter() returns tasks matching userId"
                },
                {
                  "level": 4,
                  "text": "Use Elvis operator ?: to keep existing values on update"
                },
                {
                  "level": 5,
                  "text": "removeIf() returns true if element was removed"
                }
              ],
              "difficulty": "advanced"
            },
            {
              "type": "FREE_CODING",
              "id": "7.1.3",
              "title": "Authentication Token Management",
              "description": "Create a simple session manager that generates tokens and validates them.",
              "instructions": "Create a simple session manager that generates tokens and validates them.",
              "starterCode": "import java.util.UUID\n\ndata class Session(val userId: Int, val token: String)\n\nclass SessionManager {\n    private val sessions = mutableMapOf<String, Session>()\n    \n    fun createSession(userId: Int): String {\n        // Generate token and store session\n    }\n    \n    fun validateToken(token: String): Int? {\n        // Return userId if valid, null otherwise\n    }\n    \n    fun removeSession(token: String) {\n        // Remove session\n    }\n}\n\nfun main() {\n    val manager = SessionManager()\n    val token = manager.createSession(1)\n    println(\"Token created: $token\")\n    println(\"User ID: ${manager.validateToken(token)}\")\n    println(\"Invalid token: ${manager.validateToken(\"invalid\")}\")\n    manager.removeSession(token)\n    println(\"After logout: ${manager.validateToken(token)}\")\n}",
              "solution": "import java.util.UUID\n\ndata class Session(val userId: Int, val token: String)\n\nclass SessionManager {\n    private val sessions = mutableMapOf<String, Session>()\n    \n    fun createSession(userId: Int): String {\n        val token = UUID.randomUUID().toString()\n        sessions[token] = Session(userId, token)\n        return token\n    }\n    \n    fun validateToken(token: String): Int? {\n        return sessions[token]?.userId\n    }\n    \n    fun removeSession(token: String) {\n        sessions.remove(token)\n    }\n}\n\nfun main() {\n    val manager = SessionManager()\n    val token = manager.createSession(1)\n    println(\"Token created: $token\")\n    println(\"User ID: ${manager.validateToken(token)}\")\n    println(\"Invalid token: ${manager.validateToken(\"invalid\")}\")\n    manager.removeSession(token)\n    println(\"After logout: ${manager.validateToken(token)}\")\n}",
              "language": "kotlin",
              "testCases": [
                {
                  "description": "Should create token",
                  "expectedOutput": "Token created:",
                  "isVisible": true
                },
                {
                  "description": "Should validate token and return user ID",
                  "expectedOutput": "User ID: 1",
                  "isVisible": true
                },
                {
                  "description": "Should return null for invalid token",
                  "expectedOutput": "Invalid token: null",
                  "isVisible": true
                },
                {
                  "description": "Should invalidate after logout",
                  "expectedOutput": "After logout: null",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use UUID.randomUUID().toString() to generate unique token"
                },
                {
                  "level": 2,
                  "text": "Store sessions in Map with token as key"
                },
                {
                  "level": 3,
                  "text": "Use safe call ?. to handle missing sessions"
                },
                {
                  "level": 4,
                  "text": "remove() deletes from map"
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "7.1.4",
              "title": "Full-Stack Integration Simulation",
              "description": "Simulate a complete flow: create user, login, create task, fetch tasks. This ties together authentication and task management.",
              "instructions": "Simulate a complete flow: create user, login, create task, fetch tasks. This ties together authentication and task management.",
              "starterCode": "data class User(val id: Int, val username: String, val email: String)\ndata class Task(val id: Int, val title: String, val completed: Boolean, val userId: Int)\n\nclass Application {\n    private val users = mutableMapOf<Int, User>()\n    private val tasks = mutableListOf<Task>()\n    private val sessions = mutableMapOf<String, Int>() // token to userId\n    private var nextUserId = 1\n    private var nextTaskId = 1\n    \n    fun register(username: String, email: String): User {\n        // Create and store user\n    }\n    \n    fun login(userId: Int): String {\n        // Create session and return token\n    }\n    \n    fun createTask(token: String, title: String): Task? {\n        // Validate token, create task\n    }\n    \n    fun getTasks(token: String): List<Task>? {\n        // Validate token, return user's tasks\n    }\n}\n\nfun main() {\n    val app = Application()\n    val user = app.register(\"alice\", \"alice@example.com\")\n    println(\"User registered: $user\")\n    \n    val token = app.login(user.id)\n    println(\"Logged in with token\")\n    \n    app.createTask(token, \"Learn Kotlin\")\n    app.createTask(token, \"Build App\")\n    \n    val tasks = app.getTasks(token)\n    println(\"Tasks: $tasks\")\n}",
              "solution": "import java.util.UUID\n\ndata class User(val id: Int, val username: String, val email: String)\ndata class Task(val id: Int, val title: String, val completed: Boolean, val userId: Int)\n\nclass Application {\n    private val users = mutableMapOf<Int, User>()\n    private val tasks = mutableListOf<Task>()\n    private val sessions = mutableMapOf<String, Int>() // token to userId\n    private var nextUserId = 1\n    private var nextTaskId = 1\n    \n    fun register(username: String, email: String): User {\n        val user = User(nextUserId++, username, email)\n        users[user.id] = user\n        return user\n    }\n    \n    fun login(userId: Int): String {\n        val token = UUID.randomUUID().toString()\n        sessions[token] = userId\n        return token\n    }\n    \n    fun createTask(token: String, title: String): Task? {\n        val userId = sessions[token] ?: return null\n        val task = Task(nextTaskId++, title, false, userId)\n        tasks.add(task)\n        return task\n    }\n    \n    fun getTasks(token: String): List<Task>? {\n        val userId = sessions[token] ?: return null\n        return tasks.filter { it.userId == userId }\n    }\n}\n\nfun main() {\n    val app = Application()\n    val user = app.register(\"alice\", \"alice@example.com\")\n    println(\"User registered: $user\")\n    \n    val token = app.login(user.id)\n    println(\"Logged in with token\")\n    \n    app.createTask(token, \"Learn Kotlin\")\n    app.createTask(token, \"Build App\")\n    \n    val tasks = app.getTasks(token)\n    println(\"Tasks: $tasks\")\n}",
              "language": "kotlin",
              "testCases": [
                {
                  "description": "Should register user",
                  "expectedOutput": "User registered: User(id=1, username=alice",
                  "isVisible": true
                },
                {
                  "description": "Should login",
                  "expectedOutput": "Logged in with token",
                  "isVisible": true
                },
                {
                  "description": "Should fetch tasks",
                  "expectedOutput": "Tasks: [Task(id=1, title=Learn Kotlin",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Store users in Map by ID"
                },
                {
                  "level": 2,
                  "text": "Store tasks in List"
                },
                {
                  "level": 3,
                  "text": "Sessions map token to userId"
                },
                {
                  "level": 4,
                  "text": "Validate token by checking if it exists in sessions"
                },
                {
                  "level": 5,
                  "text": "Filter tasks by userId"
                }
              ],
              "difficulty": "advanced"
            }
          ]
        },
        {
          "id": "7.2",
          "title": "Lesson 7.2: Testing Strategies",
          "moduleId": "module-07",
          "order": 2,
          "estimatedMinutes": 80,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 80 minutes\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "\nTesting is not optional in professional software development - it's a critical skill that separates hobbyist code from production-ready applications.\n\nIn this lesson, you'll master advanced testing strategies for Kotlin applications:\n- ‚úÖ Unit testing with JUnit 5 and Kotest\n- ‚úÖ Mocking dependencies with MockK\n- ‚úÖ Testing coroutines and flows\n- ‚úÖ Testing Jetpack Compose UI\n- ‚úÖ Test-driven development (TDD)\n- ‚úÖ Measuring code coverage\n\nBy the end, you'll write tests that give you confidence to refactor, deploy, and sleep peacefully at night.\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Why Testing Matters",
              "content": "\n### The Cost of Bugs\n\n**Production Bug Cost**:\n\n**Real Example**: A banking app bug that allowed duplicate withdrawals:\n- Development: Could be caught with 1 unit test ($100)\n- Production: Cost $2.3M in fraudulent transactions + reputation damage\n\n**Statistics**:\n- Well-tested codebases have 40-80% fewer production bugs\n- Companies with good test coverage deploy 46x more frequently\n- Automated tests reduce debugging time by 60%\n\n---\n\n",
              "code": "Bug found in:\n‚îî‚îÄ Development (writing code): $100\n‚îî‚îÄ Testing (QA phase): $1,000\n‚îî‚îÄ Staging (before release): $10,000\n‚îî‚îÄ Production (after release): $100,000+",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Testing Pyramid",
              "content": "\n### The Right Balance\n\n\n**Unit Tests (70%)**:\n- Test individual functions/classes in isolation\n- Fast (milliseconds)\n- Easy to write and maintain\n- Run on every code change\n\n**Integration Tests (20%)**:\n- Test multiple components together\n- Medium speed (seconds)\n- Test real interactions\n\n**E2E Tests (10%)**:\n- Test entire user flows\n- Slow (minutes)\n- Fragile (UI changes break tests)\n- Only for critical paths\n\n---\n\n",
              "code": "       /\\\n      /  \\     E2E Tests (UI)\n     /    \\    10% - Slow, expensive, brittle\n    /------\\\n   /        \\  Integration Tests\n  /          \\ 20% - Medium speed, test components together\n /------------\\\n/              \\ Unit Tests\n----------------  70% - Fast, cheap, test individual functions",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "JUnit 5 Fundamentals",
              "content": "\n### Basic Test Structure\n\n\n**Simple Test**:\n\n### Test Lifecycle\n\n\n### Parameterized Tests\n\n\n---\n\n",
              "code": "import org.junit.jupiter.params.ParameterizedTest\nimport org.junit.jupiter.params.provider.*\n\nclass ValidationTest {\n\n    @ParameterizedTest\n    @ValueSource(strings = [\"test@example.com\", \"user@domain.co\", \"name+tag@email.com\"])\n    fun `valid emails should pass validation`(email: String) {\n        assertTrue(Validator.isValidEmail(email))\n    }\n\n    @ParameterizedTest\n    @CsvSource(\n        \"0, INFANT\",\n        \"5, CHILD\",\n        \"13, TEEN\",\n        \"20, ADULT\",\n        \"70, SENIOR\"\n    )\n    fun `age categories should be correct`(age: Int, expectedCategory: String) {\n        assertEquals(expectedCategory, getAgeCategory(age))\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"passwordProvider\")\n    fun `weak passwords should fail validation`(password: String) {\n        assertFalse(Validator.isStrongPassword(password))\n    }\n\n    companion object {\n        @JvmStatic\n        fun passwordProvider() = listOf(\n            \"123\",\n            \"password\",\n            \"abc123\",\n            \"NoNumber\"\n        )\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Kotest - Beautiful Testing DSL",
              "content": "\n### Why Kotest?\n\nKotest provides a more readable, Kotlin-idiomatic testing syntax.\n\n\n**Comparison**:\n\n**JUnit**:\n\n**Kotest**:\n\n### Kotest Matchers\n\n\n---\n\n",
              "code": "import io.kotest.matchers.*\nimport io.kotest.matchers.collections.*\nimport io.kotest.matchers.string.*\n\nclass KotestMatchersTest : StringSpec({\n\n    \"string matchers\" {\n        val name = \"Kotlin\"\n\n        name shouldStartWith \"Kot\"\n        name shouldEndWith \"lin\"\n        name shouldContain \"otl\"\n        name shouldHaveLength 6\n        name shouldMatch \"K[a-z]+\".toRegex()\n    }\n\n    \"collection matchers\" {\n        val list = listOf(1, 2, 3, 4, 5)\n\n        list shouldHaveSize 5\n        list shouldContain 3\n        list shouldContainAll listOf(1, 3, 5)\n        list.shouldBeSorted()\n\n        val emptyList = emptyList<Int>()\n        emptyList.shouldBeEmpty()\n    }\n\n    \"numeric matchers\" {\n        val price = 99.99\n\n        price shouldBeGreaterThan 50.0\n        price shouldBeLessThan 100.0\n        price.shouldBeBetween(90.0, 100.0)\n    }\n\n    \"exception matchers\" {\n        shouldThrow<IllegalArgumentException> {\n            require(false) { \"Error message\" }\n        }.message shouldBe \"Error message\"\n    }\n})",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "MockK - Powerful Mocking",
              "content": "\n### Why Mock?\n\n**Problem**: Testing a service that depends on a database:\n\n\nTo test `UserService`, we don't want to:\n- Set up a real database\n- Insert test data\n- Clean up after tests\n- Deal with slow I/O operations\n\n**Solution**: Mock the database!\n\n\n### Basic Mocking\n\n\n### Advanced Mocking\n\n**Relaxed Mocks** (return default values):\n\n**Spy** (real object with partial mocking):\n\n**Capture Arguments**:\n\n---\n\n",
              "code": "@Test\nfun `verify method was called with specific arguments`() {\n    val mockRepo = mockk<UserRepository>(relaxed = true)\n    val service = UserService(mockRepo)\n\n    val slot = slot<User>()\n\n    service.updateUser(User(1, \"John\", \"john@example.com\"))\n\n    verify { mockRepo.update(capture(slot)) }\n\n    assertEquals(\"John\", slot.captured.name)\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Testing Coroutines",
              "content": "\n### runTest - The Testing Coroutine\n\n\n**Basic Coroutine Test**:\n\n### Testing Flows\n\n\n### Testing ViewModels with Coroutines\n\n\n---\n\n",
              "code": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.test.*\nimport org.junit.jupiter.api.*\n\nclass UserViewModelTest {\n\n    private val testDispatcher = StandardTestDispatcher()\n\n    @BeforeEach\n    fun setup() {\n        Dispatchers.setMain(testDispatcher)\n    }\n\n    @AfterEach\n    fun cleanup() {\n        Dispatchers.resetMain()\n    }\n\n    @Test\n    fun `loading users should update state`() = runTest {\n        val mockRepo = mockk<UserRepository>()\n        every { mockRepo.getUsers() } returns flowOf(\n            listOf(User(1, \"John\"), User(2, \"Jane\"))\n        )\n\n        val viewModel = UserViewModel(mockRepo)\n\n        // Trigger action\n        viewModel.loadUsers()\n\n        // Advance until idle\n        advanceUntilIdle()\n\n        // Verify state\n        assertEquals(2, viewModel.users.value.size)\n        assertEquals(false, viewModel.isLoading.value)\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Testing Jetpack Compose UI",
              "content": "\n### Compose Testing Library\n\n\n**Basic Compose Test**:\n\n### Testing Interactions\n\n\n---\n\n",
              "code": "@Test\nfun todoList_addItem_showsInList() {\n    composeTestRule.setContent {\n        TodoApp()\n    }\n\n    // Enter new todo\n    composeTestRule.onNodeWithTag(\"todoInput\")\n        .performTextInput(\"Buy groceries\")\n\n    // Click add button\n    composeTestRule.onNodeWithTag(\"addButton\")\n        .performClick()\n\n    // Verify item appears\n    composeTestRule.onNodeWithText(\"Buy groceries\")\n        .assertIsDisplayed()\n\n    // Verify input is cleared\n    composeTestRule.onNodeWithTag(\"todoInput\")\n        .assertTextEquals(\"\")\n}\n\n@Test\nfun todoItem_clickCheckbox_marksAsComplete() {\n    composeTestRule.setContent {\n        TodoItem(\n            todo = Todo(id = 1, text = \"Test\", completed = false),\n            onToggle = { }\n        )\n    }\n\n    // Initially unchecked\n    composeTestRule.onNodeWithTag(\"checkbox-1\")\n        .assertIsOff()\n\n    // Click checkbox\n    composeTestRule.onNodeWithTag(\"checkbox-1\")\n        .performClick()\n\n    // Verify it's checked\n    composeTestRule.onNodeWithTag(\"checkbox-1\")\n        .assertIsOn()\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Test-Driven Development (TDD)",
              "content": "\n### The TDD Cycle\n\n\n### Example: Building a Password Validator\n\n**Step 1: Write the test (Red)**:\n\nTest fails (class doesn't exist yet) ‚ùå\n\n**Step 2: Minimal implementation (Green)**:\n\nTest passes ‚úÖ\n\n**Step 3: Add more tests**:\n\n**Step 4: Implement to pass all tests**:\n\n**Benefits of TDD**:\n- Forces you to think about design before implementation\n- Ensures code is testable\n- Provides immediate feedback\n- Creates a safety net for refactoring\n\n---\n\n",
              "code": "class PasswordValidator {\n    fun isValid(password: String): Boolean {\n        if (password.length < 8) return false\n        if (!password.any { it.isUpperCase() }) return false\n        if (!password.any { it.isDigit() }) return false\n        return true\n    }\n\n    fun getErrors(password: String): List<String> {\n        val errors = mutableListOf<String>()\n\n        if (password.length < 8) {\n            errors.add(\"Password must be at least 8 characters\")\n        }\n        if (!password.any { it.isUpperCase() }) {\n            errors.add(\"Password must contain an uppercase letter\")\n        }\n        if (!password.any { it.isDigit() }) {\n            errors.add(\"Password must contain a number\")\n        }\n\n        return errors\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Coverage",
              "content": "\n### Measuring Coverage with JaCoCo\n\n\n**Run Coverage**:\n\n**View Report**:\nOpen `build/reports/jacoco/test/html/index.html`\n\n### Coverage Metrics\n\n**What's Good Coverage?**:\n- **80%+**: Excellent\n- **60-80%**: Good\n- **40-60%**: Needs improvement\n- **<40%**: Risky\n\n**Important**: 100% coverage ‚â† bug-free code. Focus on testing critical paths.\n\n---\n\n",
              "code": "./gradlew test jacocoTestReport",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Exercise 1: Build a Tested Repository",
              "content": "\nCreate a `ProductRepository` with full test coverage.\n\n### Requirements\n\n1. **ProductRepository** with methods:\n   - `getProducts(): List<Product>`\n   - `getProduct(id: String): Product?`\n   - `createProduct(product: Product): Result<Product>`\n   - `updateProduct(id: String, product: Product): Result<Product>`\n   - `deleteProduct(id: String): Result<Unit>`\n\n2. **Tests** (use MockK):\n   - Test successful operations\n   - Test error cases (not found, network errors)\n   - Test caching behavior\n   - Verify mock interactions\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 1",
              "content": "\n\n**Tests**:\n\n---\n\n",
              "code": "// src/test/kotlin/com/example/repository/ProductRepositoryTest.kt\npackage com.example.repository\n\nimport io.mockk.*\nimport kotlinx.coroutines.test.runTest\nimport org.junit.jupiter.api.BeforeEach\nimport org.junit.jupiter.api.Test\nimport kotlin.test.*\n\nclass ProductRepositoryTest {\n\n    private lateinit var mockApi: ProductApi\n    private lateinit var repository: ProductRepository\n\n    @BeforeEach\n    fun setup() {\n        mockApi = mockk()\n        repository = ProductRepository(mockApi)\n    }\n\n    @Test\n    fun `getProducts should fetch from API and cache results`() = runTest {\n        val products = listOf(\n            Product(\"1\", \"Laptop\", 999.99, 10),\n            Product(\"2\", \"Mouse\", 29.99, 50)\n        )\n\n        coEvery { mockApi.getProducts() } returns products\n\n        val result = repository.getProducts()\n\n        assertEquals(2, result.size)\n        assertEquals(\"Laptop\", result[0].name)\n\n        coVerify(exactly = 1) { mockApi.getProducts() }\n    }\n\n    @Test\n    fun `getProducts should return cached data when API fails`() = runTest {\n        val products = listOf(Product(\"1\", \"Laptop\", 999.99, 10))\n\n        // First call succeeds\n        coEvery { mockApi.getProducts() } returns products\n        repository.getProducts()\n\n        // Second call fails\n        coEvery { mockApi.getProducts() } throws Exception(\"Network error\")\n        val result = repository.getProducts()\n\n        // Should return cached data\n        assertEquals(1, result.size)\n        assertEquals(\"Laptop\", result[0].name)\n    }\n\n    @Test\n    fun `getProduct should return cached product if available`() = runTest {\n        val product = Product(\"1\", \"Laptop\", 999.99, 10)\n\n        coEvery { mockApi.getProducts() } returns listOf(product)\n        repository.getProducts() // Populate cache\n\n        val result = repository.getProduct(\"1\")\n\n        assertNotNull(result)\n        assertEquals(\"Laptop\", result.name)\n\n        // API not called (used cache)\n        coVerify(exactly = 0) { mockApi.getProduct(any()) }\n    }\n\n    @Test\n    fun `getProduct should fetch from API if not cached`() = runTest {\n        val product = Product(\"1\", \"Laptop\", 999.99, 10)\n\n        coEvery { mockApi.getProduct(\"1\") } returns product\n\n        val result = repository.getProduct(\"1\")\n\n        assertNotNull(result)\n        assertEquals(\"Laptop\", result.name)\n\n        coVerify(exactly = 1) { mockApi.getProduct(\"1\") }\n    }\n\n    @Test\n    fun `getProduct should return null when product not found`() = runTest {\n        coEvery { mockApi.getProduct(\"999\") } throws Exception(\"Not found\")\n\n        val result = repository.getProduct(\"999\")\n\n        assertNull(result)\n    }\n\n    @Test\n    fun `createProduct should call API and cache result`() = runTest {\n        val newProduct = Product(\"3\", \"Keyboard\", 79.99, 30)\n\n        coEvery { mockApi.createProduct(newProduct) } returns newProduct\n\n        val result = repository.createProduct(newProduct)\n\n        assertTrue(result.isSuccess)\n        assertEquals(\"Keyboard\", result.getOrNull()?.name)\n\n        // Verify cached\n        val cached = repository.getProduct(\"3\")\n        assertNotNull(cached)\n        assertEquals(\"Keyboard\", cached.name)\n    }\n\n    @Test\n    fun `createProduct should return failure when API fails`() = runTest {\n        val newProduct = Product(\"3\", \"Keyboard\", 79.99, 30)\n\n        coEvery { mockApi.createProduct(newProduct) } throws Exception(\"Server error\")\n\n        val result = repository.createProduct(newProduct)\n\n        assertTrue(result.isFailure)\n    }\n\n    @Test\n    fun `updateProduct should update cache on success`() = runTest {\n        val updated = Product(\"1\", \"Gaming Laptop\", 1299.99, 5)\n\n        coEvery { mockApi.updateProduct(\"1\", updated) } returns updated\n\n        val result = repository.updateProduct(\"1\", updated)\n\n        assertTrue(result.isSuccess)\n        assertEquals(\"Gaming Laptop\", result.getOrNull()?.name)\n    }\n\n    @Test\n    fun `deleteProduct should remove from cache`() = runTest {\n        val product = Product(\"1\", \"Laptop\", 999.99, 10)\n\n        // Add to cache\n        coEvery { mockApi.getProduct(\"1\") } returns product\n        repository.getProduct(\"1\")\n\n        // Delete\n        coEvery { mockApi.deleteProduct(\"1\") } just Runs\n\n        val result = repository.deleteProduct(\"1\")\n\n        assertTrue(result.isSuccess)\n\n        // Verify removed from cache\n        coEvery { mockApi.getProduct(\"1\") } throws Exception(\"Not found\")\n        val cached = repository.getProduct(\"1\")\n        assertNull(cached)\n    }\n\n    @Test\n    fun `clearCache should remove all cached products`() = runTest {\n        val products = listOf(Product(\"1\", \"Laptop\", 999.99, 10))\n\n        coEvery { mockApi.getProducts() } returns products\n        repository.getProducts()\n\n        repository.clearCache()\n\n        coEvery { mockApi.getProduct(\"1\") } throws Exception(\"Not found\")\n        val cached = repository.getProduct(\"1\")\n        assertNull(cached)\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 2: Test a Compose Screen",
              "content": "\nCreate tests for a shopping cart screen.\n\n### Requirements\n\n1. **CartScreen Composable**:\n   - Displays list of cart items\n   - Shows total price\n   - Has \"Checkout\" button\n   - Can remove items\n\n2. **Tests**:\n   - Verify items are displayed\n   - Verify total is calculated correctly\n   - Test remove item functionality\n   - Test checkout button click\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 2",
              "content": "\n\n**Tests**:\n\n---\n\n",
              "code": "// src/androidTest/kotlin/com/example/ui/CartScreenTest.kt\nclass CartScreenTest {\n\n    @get:Rule\n    val composeTestRule = createComposeRule()\n\n    @Test\n    fun cartScreen_emptyCart_showsEmptyMessage() {\n        composeTestRule.setContent {\n            CartScreen(items = emptyList())\n        }\n\n        composeTestRule.onNodeWithTag(\"emptyMessage\")\n            .assertIsDisplayed()\n            .assertTextEquals(\"Your cart is empty\")\n    }\n\n    @Test\n    fun cartScreen_withItems_displaysAllItems() {\n        val items = listOf(\n            CartItem(\"1\", \"Laptop\", 999.99, 1),\n            CartItem(\"2\", \"Mouse\", 29.99, 2)\n        )\n\n        composeTestRule.setContent {\n            CartScreen(items = items)\n        }\n\n        composeTestRule.onNodeWithTag(\"cartItem-1\").assertIsDisplayed()\n        composeTestRule.onNodeWithTag(\"cartItem-2\").assertIsDisplayed()\n        composeTestRule.onNodeWithText(\"Laptop\").assertExists()\n        composeTestRule.onNodeWithText(\"Mouse\").assertExists()\n    }\n\n    @Test\n    fun cartScreen_calculatesCorrectTotal() {\n        val items = listOf(\n            CartItem(\"1\", \"Laptop\", 999.99, 1),\n            CartItem(\"2\", \"Mouse\", 29.99, 2)\n        )\n\n        composeTestRule.setContent {\n            CartScreen(items = items)\n        }\n\n        // Total: 999.99 + (29.99 * 2) = 1059.97\n        composeTestRule.onNodeWithTag(\"totalPrice\")\n            .assertTextContains(\"$1059.97\")\n    }\n\n    @Test\n    fun cartScreen_clickRemove_callsOnRemoveItem() {\n        val items = listOf(CartItem(\"1\", \"Laptop\", 999.99, 1))\n        var removedId: String? = null\n\n        composeTestRule.setContent {\n            CartScreen(\n                items = items,\n                onRemoveItem = { id -> removedId = id }\n            )\n        }\n\n        composeTestRule.onNodeWithTag(\"removeButton-1\").performClick()\n\n        assertEquals(\"1\", removedId)\n    }\n\n    @Test\n    fun cartScreen_clickCheckout_callsOnCheckout() {\n        val items = listOf(CartItem(\"1\", \"Laptop\", 999.99, 1))\n        var checkoutCalled = false\n\n        composeTestRule.setContent {\n            CartScreen(\n                items = items,\n                onCheckout = { checkoutCalled = true }\n            )\n        }\n\n        composeTestRule.onNodeWithTag(\"checkoutButton\").performClick()\n\n        assertTrue(checkoutCalled)\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 3: TDD - Build a Shopping Cart",
              "content": "\nUse TDD to build a shopping cart with these features:\n- Add items\n- Remove items\n- Calculate total\n- Apply discount codes\n\nWrite tests first, then implement!\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 3",
              "content": "\n**Tests First**:\n\n**Implementation**:\n\n---\n\n",
              "code": "data class Item(val name: String, val price: Double, val quantity: Int = 1)\n\nclass ShoppingCart {\n    private val items = mutableMapOf<String, Item>()\n    private var discountPercent = 0.0\n\n    fun addItem(name: String, price: Double) {\n        val existing = items[name]\n        if (existing != null) {\n            items[name] = existing.copy(quantity = existing.quantity + 1)\n        } else {\n            items[name] = Item(name, price, 1)\n        }\n    }\n\n    fun removeItem(name: String) {\n        items.remove(name)\n    }\n\n    fun getItemCount(name: String): Int {\n        return items[name]?.quantity ?: 0\n    }\n\n    fun getTotal(): Double {\n        val subtotal = items.values.sumOf { it.price * it.quantity }\n        return subtotal * (1 - discountPercent / 100)\n    }\n\n    fun applyDiscount(code: String): Result<Unit> {\n        if (items.isEmpty()) {\n            return Result.failure(Exception(\"Cannot apply discount to empty cart\"))\n        }\n\n        val discount = when (code) {\n            \"SAVE10\" -> 10.0\n            \"SAVE20\" -> 20.0\n            \"SAVE50\" -> 50.0\n            else -> return Result.failure(Exception(\"Invalid discount code\"))\n        }\n\n        discountPercent = discount\n        return Result.success(Unit)\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n### Career Impact\n\n**Job Requirements**:\n- 95% of backend/Android jobs require testing skills\n- \"Write unit tests\" appears in 87% of Kotlin job postings\n- Companies with good tests ship 46x more frequently\n\n**Salary Impact**:\n- Developers who write tests earn 15-20% more\n- Testing expertise = senior-level skill\n\n**Real Examples**:\n- **Airbnb**: Requires 80% code coverage\n- **Google**: All code changes need tests\n- **Spotify**: TDD is standard practice\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Checkpoint Quiz",
              "content": "\n### Question 1\nWhat's the recommended ratio in the testing pyramid?\n\nA) 70% unit, 20% integration, 10% E2E\nB) Equal distribution (33% each)\nC) 100% integration tests\nD) 10% unit, 90% E2E\n\n### Question 2\nWhat does MockK's `every` block do?\n\nA) Runs a test multiple times\nB) Defines the behavior of a mock\nC) Verifies a method was called\nD) Creates a real object\n\n### Question 3\nHow do you test a suspending function?\n\nA) Use `@Test suspend fun`\nB) Use `runBlocking`\nC) Use `runTest`\nD) Can't test suspending functions\n\n### Question 4\nWhat does `composeTestRule.onNodeWithTag(\"button\")` do?\n\nA) Creates a button\nB) Finds a composable with testTag(\"button\")\nC) Tags the current test\nD) Deletes a button\n\n### Question 5\nWhat's the first step in TDD?\n\nA) Write implementation\nB) Write a failing test\nC) Refactor code\nD) Deploy to production\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Answers",
              "content": "\n**Question 1: A) 70% unit, 20% integration, 10% E2E**\n\nThe testing pyramid recommends:\n- **Most**: Unit tests (fast, isolated)\n- **Some**: Integration tests\n- **Few**: E2E tests (slow, brittle)\n\n---\n\n**Question 2: B) Defines the behavior of a mock**\n\n\nTells the mock: \"When getUser(1) is called, return this user\"\n\n---\n\n**Question 3: C) Use `runTest`**\n\n\n`runTest` provides a coroutine scope for testing.\n\n---\n\n**Question 4: B) Finds a composable with testTag(\"button\")**\n\n\nTest tags help locate composables in tests.\n\n---\n\n**Question 5: B) Write a failing test**\n\nTDD cycle:\n1. **Red**: Write failing test\n2. **Green**: Write minimal code to pass\n3. **Refactor**: Improve code\n\n---\n\n",
              "code": "Button(modifier = Modifier.testTag(\"button\")) { }\n\ncomposeTestRule.onNodeWithTag(\"button\").performClick()",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "What You've Learned",
              "content": "\n‚úÖ Why testing is critical for professional development\n‚úÖ The testing pyramid and when to use each test type\n‚úÖ JUnit 5 fundamentals and parameterized tests\n‚úÖ Kotest for beautiful, Kotlin-idiomatic tests\n‚úÖ MockK for powerful mocking and verification\n‚úÖ Testing coroutines and flows with kotlinx-coroutines-test\n‚úÖ Testing Jetpack Compose UI components\n‚úÖ Test-driven development (TDD) workflow\n‚úÖ Measuring code coverage with JaCoCo\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Next Steps",
              "content": "\nIn **Lesson 7.3: Performance Optimization**, you'll learn:\n- Profiling tools to identify bottlenecks\n- Memory management and leak detection\n- Optimizing coroutines and flows\n- Compose recomposition optimization\n- Database query optimization\n- Network performance best practices\n\nGreat tests give you confidence to optimize fearlessly!\n\n---\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "7.3",
          "title": "Lesson 7.3: Performance Optimization",
          "moduleId": "module-07",
          "order": 3,
          "estimatedMinutes": 85,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 85 minutes\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "\n\"Premature optimization is the root of all evil\" - Donald Knuth\n\nBut **measured, strategic optimization** is the difference between a slow app that users delete and a fast app they love.\n\nIn this lesson, you'll master performance optimization for Kotlin applications:\n- ‚úÖ Profiling tools to identify bottlenecks\n- ‚úÖ Memory management and leak detection\n- ‚úÖ Coroutine performance optimization\n- ‚úÖ Jetpack Compose recomposition optimization\n- ‚úÖ Database query optimization\n- ‚úÖ Network performance best practices\n\nBy the end, you'll know how to build blazing-fast applications that delight users.\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "The Golden Rule of Optimization",
              "content": "\n### Measure First, Optimize Second\n\n**Wrong Approach**:\n\n**Right Approach**:\n\n**Why This Matters**:\n- 90% of execution time is spent in 10% of code\n- Optimizing the wrong code = wasted time\n- Profilers show you the **actual** bottlenecks\n\n---\n\n",
              "code": "// 1. Measure with profiler\n// 2. Find actual bottleneck (it's not where you think!)\n// 3. Optimize the bottleneck\n// 4. Measure again to verify improvement",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Profiling Tools",
              "content": "\n### Android Studio Profiler\n\n**CPU Profiler**:\n\nShows:\n- Which functions take the most time\n- Call stack and flame graphs\n- Thread activity\n\n**Example Output**:\n\n**Memory Profiler**:\n\nShows:\n- Memory allocation over time\n- Heap dumps\n- Memory leaks\n\n**Network Profiler**:\n\nShows:\n- Request/response times\n- Payload sizes\n- Connection duration\n\n### Ktor Server Profiling\n\n**Add Timing Plugin**:\n\n**Output**:\n\n---\n\n",
              "code": "GET /api/users - 45ms\nGET /api/products - 850ms ‚ö†Ô∏è SLOW!\nPOST /api/orders - 120ms",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Memory Management",
              "content": "\n### Detecting Memory Leaks\n\n**Common Leak: Activity Reference in ViewModel**:\n\n‚ùå **Bad**:\n\n‚úÖ **Good**:\n\n**Common Leak: Coroutine Not Cancelled**:\n\n‚ùå **Bad**:\n\n‚úÖ **Good**:\n\n**Better: Use lifecycleScope**:\n\n### Memory Leak Detection with LeakCanary\n\n\nLeakCanary automatically detects leaks and shows:\n- What object leaked\n- Reference path keeping it alive\n- Suggested fix\n\n---\n\n",
              "code": "// build.gradle.kts\ndependencies {\n    debugImplementation(\"com.squareup.leakcanary:leakcanary-android:2.13\")\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Coroutine Performance",
              "content": "\n### Dispatcher Selection\n\n**Wrong Dispatcher = Poor Performance**:\n\n‚ùå **Bad**:\n\n‚úÖ **Good**:\n\n**Dispatcher Guide**:\n\n### Avoiding Excessive Coroutine Creation\n\n‚ùå **Bad** (Creates 1000 coroutines):\n\n‚úÖ **Good** (Single coroutine):\n\n‚úÖ **Better** (Parallel processing with limit):\n\n### Flow Performance\n\n**Cold vs Hot Flows**:\n\n‚ùå **Bad** (Network call on every collect):\n\n‚úÖ **Good** (SharedFlow - single source):\n\n**Debouncing Search**:\n\n‚ùå **Bad** (API call on every keystroke):\n\n‚úÖ **Good** (Debounce 300ms):\n\n---\n\n",
              "code": "searchField.textAsFlow()\n    .debounce(300)\n    .distinctUntilChanged()\n    .collectLatest { query ->\n        viewModel.search(query)\n    }",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Jetpack Compose Optimization",
              "content": "\n### Recomposition Basics\n\n**What is Recomposition?**\n\nWhen state changes, Compose re-runs composables to update UI.\n\n**Problem**: Unnecessary recompositions = poor performance\n\n**Example**:\n\n### Optimization 1: Stable Parameters\n\n‚ùå **Bad** (Recomposes unnecessarily):\n\n‚úÖ **Good** (Only necessary recompositions):\n\n### Optimization 2: derivedStateOf\n\n‚ùå **Bad** (Recalculates on every recomposition):\n\n‚úÖ **Good** (Only recalculates when products change):\n\n### Optimization 3: LazyColumn Keys\n\n‚ùå **Bad** (Entire list recomposes):\n\n‚úÖ **Good** (Only changed items recompose):\n\n### Optimization 4: Immutable Collections\n\n\n‚úÖ **Good** (Compose knows it's immutable):\n\n### Measuring Recompositions\n\n\n---\n\n",
              "code": "@Composable\nfun LogCompositions(tag: String) {\n    val ref = remember { Ref(0) }\n    SideEffect {\n        ref.value++\n        Log.d(\"Recomposition\", \"$tag recomposed ${ref.value} times\")\n    }\n}\n\nclass Ref(var value: Int)\n\n@Composable\nfun MyScreen() {\n    LogCompositions(\"MyScreen\")\n\n    // Your content\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Database Optimization",
              "content": "\n### Query Optimization\n\n‚ùå **Bad** (N+1 queries):\n\n‚úÖ **Good** (Single query with JOIN):\n\n### Indexing\n\n‚ùå **Bad** (Full table scan):\n\n‚úÖ **Good** (Indexed):\n\n### Pagination\n\n‚ùå **Bad** (Load all 10,000 products):\n\n‚úÖ **Good** (Paging):\n\n### Batch Operations\n\n‚ùå **Bad** (Individual inserts):\n\n‚úÖ **Good** (Batch insert):\n\n---\n\n",
              "code": "@Insert\nsuspend fun insertAll(products: List<Product>)\n\n// Single transaction - much faster\ndatabase.productDao().insertAll(products)",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Network Optimization",
              "content": "\n### Response Caching\n\n**HTTP Caching with OkHttp**:\n\n**Cache Headers**:\n\n### Compression\n\n\n### Request Coalescing\n\n‚ùå **Bad** (Multiple identical requests):\n\n‚úÖ **Good** (Share single request):\n\n### Prefetching\n\n\n---\n\n",
              "code": "class ProductRepository {\n    private val cache = mutableMapOf<String, Product>()\n\n    suspend fun prefetchProducts(ids: List<String>) {\n        val uncachedIds = ids.filter { it !in cache }\n        if (uncachedIds.isEmpty()) return\n\n        val products = api.getProductsBatch(uncachedIds)\n        products.forEach { cache[it.id] = it }\n    }\n\n    suspend fun getProduct(id: String): Product {\n        return cache[id] ?: api.getProduct(id).also {\n            cache[id] = it\n        }\n    }\n}\n\n// Usage\nrepository.prefetchProducts(listOf(\"1\", \"2\", \"3\"))\n// Later...\nval product = repository.getProduct(\"1\") // Instant! (cached)",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 1: Optimize a Slow Screen",
              "content": "\nYou have a slow user list screen. Profile and optimize it.\n\n### Initial Code (Slow)\n\n\n### Performance Issues\n\n1. ‚ö†Ô∏è Entire list recomposes when search query changes\n2. ‚ö†Ô∏è No keys in LazyColumn\n3. ‚ö†Ô∏è `isUserOnline()` and `getUnreadCount()` called on every recomposition\n4. ‚ö†Ô∏è Images loaded from network on every recomposition\n5. ‚ö†Ô∏è ViewModel passed to composable (unstable parameter)\n\n---\n\n",
              "code": "@Composable\nfun UserListScreen(viewModel: UserViewModel) {\n    val users = viewModel.users.collectAsState()\n    val searchQuery = viewModel.searchQuery.collectAsState()\n\n    Column {\n        SearchBar(\n            query = searchQuery.value,\n            onQueryChange = { viewModel.updateSearchQuery(it) }\n        )\n\n        LazyColumn {\n            items(users.value) { user ->\n                UserCard(\n                    user = user,\n                    isOnline = viewModel.isUserOnline(user.id),\n                    messageCount = viewModel.getUnreadCount(user.id),\n                    onClick = { viewModel.selectUser(user) }\n                )\n            }\n        }\n    }\n}\n\n@Composable\nfun UserCard(\n    user: User,\n    isOnline: Boolean,\n    messageCount: Int,\n    onClick: () -> Unit\n) {\n    // Heavy image loading\n    val avatar = loadImageFromNetwork(user.avatarUrl)\n\n    Card(onClick = onClick) {\n        Row {\n            Image(bitmap = avatar, contentDescription = null)\n            Column {\n                Text(user.name)\n                Text(\"Unread: $messageCount\")\n                if (isOnline) {\n                    OnlineBadge()\n                }\n            }\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Solution 1",
              "content": "\n\n**Improvements**:\n1. ‚úÖ Stable parameters (`UserUiState`, lambda references)\n2. ‚úÖ Keys in LazyColumn\n3. ‚úÖ UI state pre-computed in ViewModel\n4. ‚úÖ Image loading with Coil (handles caching)\n5. ‚úÖ `derivedStateOf` for filtering\n6. ‚úÖ No ViewModel passed to composables\n\n---\n\n",
              "code": "@Stable\ndata class UserUiState(\n    val id: String,\n    val name: String,\n    val avatarUrl: String,\n    val isOnline: Boolean,\n    val unreadCount: Int\n)\n\n@Composable\nfun UserListScreen(viewModel: UserViewModel) {\n    val users by viewModel.usersUiState.collectAsState()\n    val searchQuery by viewModel.searchQuery.collectAsState()\n\n    Column {\n        SearchBar(\n            query = searchQuery,\n            onQueryChange = viewModel::updateSearchQuery\n        )\n\n        // derivedStateOf - only recalculate when users or query changes\n        val filteredUsers by remember {\n            derivedStateOf {\n                if (searchQuery.isBlank()) {\n                    users\n                } else {\n                    users.filter { it.name.contains(searchQuery, ignoreCase = true) }\n                }\n            }\n        }\n\n        UserList(\n            users = filteredUsers,\n            onUserClick = viewModel::selectUser\n        )\n    }\n}\n\n@Composable\nfun UserList(\n    users: List<UserUiState>,\n    onUserClick: (String) -> Unit\n) {\n    LazyColumn {\n        items(\n            items = users,\n            key = { it.id } // ‚úÖ Stable keys\n        ) { user ->\n            UserCard(\n                user = user,\n                onClick = { onUserClick(user.id) }\n            )\n        }\n    }\n}\n\n@Composable\nfun UserCard(\n    user: UserUiState,\n    onClick: () -> Unit\n) {\n    Card(onClick = onClick) {\n        Row {\n            // ‚úÖ Coil handles caching\n            AsyncImage(\n                model = user.avatarUrl,\n                contentDescription = null,\n                modifier = Modifier.size(48.dp)\n            )\n\n            Column {\n                Text(user.name)\n                Text(\"Unread: ${user.unreadCount}\")\n\n                if (user.isOnline) {\n                    OnlineBadge()\n                }\n            }\n        }\n    }\n}\n\nclass UserViewModel : ViewModel() {\n    private val _searchQuery = MutableStateFlow(\"\")\n    val searchQuery = _searchQuery.asStateFlow()\n\n    // Pre-compute UI state in ViewModel\n    val usersUiState: StateFlow<List<UserUiState>> = combine(\n        userRepository.users,\n        onlineStatusRepository.onlineUsers,\n        messageRepository.unreadCounts\n    ) { users, onlineIds, unreadCounts ->\n        users.map { user ->\n            UserUiState(\n                id = user.id,\n                name = user.name,\n                avatarUrl = user.avatarUrl,\n                isOnline = user.id in onlineIds,\n                unreadCount = unreadCounts[user.id] ?: 0\n            )\n        }\n    }.stateIn(\n        scope = viewModelScope,\n        started = SharingStarted.WhileSubscribed(5000),\n        initialValue = emptyList()\n    )\n\n    fun updateSearchQuery(query: String) {\n        _searchQuery.value = query\n    }\n\n    fun selectUser(userId: String) {\n        // Handle selection\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 2: Optimize Database Queries",
              "content": "\nOptimize this slow order fetching code.\n\n### Initial Code (Slow)\n\n\n---\n\n",
              "code": "@Dao\ninterface OrderDao {\n    @Query(\"SELECT * FROM orders\")\n    fun getAllOrders(): List<Order>\n\n    @Query(\"SELECT * FROM orders WHERE user_id = :userId\")\n    fun getOrdersByUser(userId: String): List<Order>\n}\n\n// Usage\nfun displayUserOrders(userId: String) {\n    val orders = orderDao.getOrdersByUser(userId)\n\n    orders.forEach { order ->\n        val user = userDao.getById(order.userId) // N+1 query!\n        val items = orderItemDao.getByOrderId(order.id) // N+1 query!\n\n        println(\"Order ${order.id} by ${user.name}: ${items.size} items\")\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Solution 2",
              "content": "\n\n---\n\n",
              "code": "// 1. Add indexes\n@Entity(\n    tableName = \"orders\",\n    indices = [\n        Index(value = [\"user_id\"]),\n        Index(value = [\"created_at\"])\n    ]\n)\ndata class Order(\n    @PrimaryKey val id: String,\n    val userId: String,\n    val totalAmount: Double,\n    val status: String,\n    val createdAt: Long\n)\n\n// 2. Create joined data class\ndata class OrderWithDetails(\n    @Embedded val order: Order,\n\n    @Relation(\n        parentColumn = \"user_id\",\n        entityColumn = \"id\"\n    )\n    val user: User,\n\n    @Relation(\n        parentColumn = \"id\",\n        entityColumn = \"order_id\"\n    )\n    val items: List<OrderItem>\n)\n\n// 3. Single query with JOIN\n@Dao\ninterface OrderDao {\n    @Transaction\n    @Query(\"SELECT * FROM orders WHERE user_id = :userId ORDER BY created_at DESC\")\n    fun getOrdersWithDetails(userId: String): List<OrderWithDetails>\n\n    // For pagination\n    @Transaction\n    @Query(\"SELECT * FROM orders WHERE user_id = :userId ORDER BY created_at DESC\")\n    fun getOrdersWithDetailsPaged(userId: String): PagingSource<Int, OrderWithDetails>\n}\n\n// Usage\nfun displayUserOrders(userId: String) {\n    val ordersWithDetails = orderDao.getOrdersWithDetails(userId) // Single query!\n\n    ordersWithDetails.forEach { orderDetail ->\n        println(\"Order ${orderDetail.order.id} by ${orderDetail.user.name}: ${orderDetail.items.size} items\")\n    }\n}\n\n// For large datasets, use paging\nfun getOrdersPaged(userId: String): Flow<PagingData<OrderWithDetails>> {\n    return Pager(\n        config = PagingConfig(pageSize = 20, enablePlaceholders = false),\n        pagingSourceFactory = { orderDao.getOrdersWithDetailsPaged(userId) }\n    ).flow\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 3: Optimize Network Calls",
              "content": "\nCreate an optimized image loading repository with caching and prefetching.\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 3",
              "content": "\n\n---\n\n",
              "code": "class ImageRepository(\n    private val api: ImageApi,\n    private val diskCache: DiskLruCache,\n    private val memoryCache: LruCache<String, Bitmap>\n) {\n    private val scope = CoroutineScope(Dispatchers.IO + SupervisorJob())\n\n    // In-flight requests to avoid duplicates\n    private val loadingImages = mutableMapOf<String, Deferred<Bitmap>>()\n\n    suspend fun loadImage(url: String): Bitmap? {\n        // 1. Check memory cache (fastest)\n        memoryCache.get(url)?.let { return it }\n\n        // 2. Check disk cache\n        diskCache.get(url)?.let { bytes ->\n            val bitmap = BitmapFactory.decodeByteArray(bytes, 0, bytes.size)\n            memoryCache.put(url, bitmap)\n            return bitmap\n        }\n\n        // 3. Coalesce network requests\n        return loadingImages[url]?.await() ?: run {\n            val deferred = scope.async {\n                downloadAndCache(url)\n            }\n            loadingImages[url] = deferred\n\n            try {\n                deferred.await().also {\n                    loadingImages.remove(url)\n                }\n            } catch (e: Exception) {\n                loadingImages.remove(url)\n                null\n            }\n        }\n    }\n\n    private suspend fun downloadAndCache(url: String): Bitmap {\n        val bytes = api.downloadImage(url)\n        val bitmap = BitmapFactory.decodeByteArray(bytes, 0, bytes.size)\n\n        // Cache in memory\n        memoryCache.put(url, bitmap)\n\n        // Cache on disk\n        diskCache.put(url, bytes)\n\n        return bitmap\n    }\n\n    fun prefetch(urls: List<String>) {\n        scope.launch {\n            urls.forEach { url ->\n                if (url !in memoryCache && url !in diskCache) {\n                    try {\n                        loadImage(url)\n                    } catch (e: Exception) {\n                        // Ignore prefetch errors\n                    }\n                }\n            }\n        }\n    }\n\n    fun clearCache() {\n        memoryCache.evictAll()\n        diskCache.delete()\n    }\n}\n\n// Usage\nclass ProductListViewModel(private val imageRepo: ImageRepository) : ViewModel() {\n    fun loadProducts(products: List<Product>) {\n        // Prefetch images for visible products\n        val imageUrls = products.take(10).map { it.imageUrl }\n        imageRepo.prefetch(imageUrls)\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n### Real-World Impact\n\n**Performance Statistics**:\n- 53% of users abandon apps that take > 3 seconds to load\n- 1-second delay = 7% reduction in conversions\n- Google ranks faster sites higher in search\n\n**Business Impact**:\n- **Amazon**: 100ms faster = 1% more revenue\n- **Pinterest**: 40% reduction in wait time = 15% more signups\n- **Shopify**: Faster stores convert 1.2x better\n\n**Career Impact**:\n- Performance optimization is a senior-level skill\n- Companies pay 20-30% more for engineers who can optimize\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Checkpoint Quiz",
              "content": "\n### Question 1\nWhat's the first step in performance optimization?\n\nA) Rewrite everything in C\nB) Profile to find bottlenecks\nC) Optimize all loops\nD) Remove all logging\n\n### Question 2\nWhich Dispatcher should you use for heavy calculations?\n\nA) Dispatchers.Main\nB) Dispatchers.IO\nC) Dispatchers.Default\nD) Dispatchers.Unconfined\n\n### Question 3\nHow do you prevent unnecessary Compose recompositions?\n\nA) Use var instead of mutableStateOf\nB) Use stable parameters and keys in LazyColumn\nC) Disable recomposition in settings\nD) Recomposition can't be prevented\n\n### Question 4\nWhat's the N+1 query problem?\n\nA) A query that returns N+1 rows\nB) Making N additional queries in a loop\nC) A query with N+1 joins\nD) A query error code\n\n### Question 5\nWhat does `derivedStateOf` do?\n\nA) Creates a new state\nB) Only recalculates when dependencies change\nC) Derives state from database\nD) Deletes old state\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Answers",
              "content": "\n**Question 1: B) Profile to find bottlenecks**\n\nAlways measure first:\n1. Profile with Android Studio Profiler\n2. Find the actual bottleneck\n3. Optimize that specific code\n4. Measure again to verify\n\n90% of time is in 10% of code - find that 10%!\n\n---\n\n**Question 2: C) Dispatchers.Default**\n\n\n---\n\n**Question 3: B) Use stable parameters and keys in LazyColumn**\n\n\n---\n\n**Question 4: B) Making N additional queries in a loop**\n\n\n---\n\n**Question 5: B) Only recalculates when dependencies change**\n\n\n---\n\n",
              "code": "val filteredItems by remember {\n    derivedStateOf {\n        items.filter { it.price > 100 }\n    }\n}\n// Only recalculates when 'items' changes",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "What You've Learned",
              "content": "\n‚úÖ The golden rule: measure first, optimize second\n‚úÖ Using Android Studio Profiler to find bottlenecks\n‚úÖ Memory leak detection and prevention\n‚úÖ Coroutine performance optimization (dispatchers, flow)\n‚úÖ Jetpack Compose recomposition optimization\n‚úÖ Database optimization (indexing, joins, paging)\n‚úÖ Network optimization (caching, compression, prefetching)\n‚úÖ Practical optimization exercises\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Next Steps",
              "content": "\nIn **Lesson 7.4: Security Best Practices**, you'll learn:\n- Secure coding practices\n- Input validation and sanitization\n- Encryption and hashing\n- API security (OAuth 2.0, JWT best practices)\n- Android security (KeyStore, ProGuard)\n- Common vulnerabilities (OWASP Top 10)\n\nFast apps are great, but secure apps are essential!\n\n---\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "7.4",
          "title": "Lesson 7.4: Security Best Practices",
          "moduleId": "module-07",
          "order": 4,
          "estimatedMinutes": 90,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 90 minutes\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "\nSecurity isn't optional - it's your responsibility as a developer.\n\nA single security vulnerability can:\n- Expose millions of user credentials\n- Cost companies millions in damages\n- Destroy user trust forever\n- End careers\n\nIn this lesson, you'll master security best practices for Kotlin applications:\n- ‚úÖ Secure coding principles\n- ‚úÖ Input validation and sanitization\n- ‚úÖ Encryption and hashing\n- ‚úÖ API security (OAuth 2.0, JWT)\n- ‚úÖ Android security (KeyStore, ProGuard/R8)\n- ‚úÖ OWASP Top 10 vulnerabilities\n\nBy the end, you'll build applications that protect user data and withstand attacks.\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "The Cost of Insecurity",
              "content": "\n### Real-World Breaches\n\n**Equifax (2017)**:\n- Vulnerability: Unpatched Apache Struts\n- Impact: 147 million records exposed\n- Cost: $1.4 billion in damages\n- Cause: Security neglect\n\n**Facebook (2019)**:\n- Vulnerability: Passwords stored in plaintext\n- Impact: 600 million passwords exposed\n- Cause: Not hashing passwords\n\n**Uber (2016)**:\n- Vulnerability: AWS keys in GitHub repository\n- Impact: 57 million users compromised\n- Cost: $148 million fine\n- Cause: Hardcoded secrets\n\n**The Pattern**: These weren't sophisticated attacks. They were basic security mistakes that could have been prevented.\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Secure Coding Principles",
              "content": "\n### Principle 1: Defense in Depth\n\nNever rely on a single security measure.\n\n‚ùå **Bad** (Single layer):\n\n‚úÖ **Good** (Multiple layers):\n\n### Principle 2: Least Privilege\n\nGrant minimum permissions necessary.\n\n‚ùå **Bad** (Admin for everyone):\n\n‚úÖ **Good** (Minimal permissions):\n\n### Principle 3: Fail Securely\n\nWhen errors occur, fail in a secure state.\n\n‚ùå **Bad** (Fails open):\n\n‚úÖ **Good** (Fails closed):\n\n---\n\n",
              "code": "fun checkAccess(userId: String, resourceId: String): Boolean {\n    return try {\n        val user = userService.getUser(userId) ?: return false\n        val resource = resourceService.getResource(resourceId) ?: return false\n        user.hasAccessTo(resource)\n    } catch (e: Exception) {\n        logger.error(\"Access check failed\", e)\n        // ‚úÖ Error = deny access\n        false\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Input Validation",
              "content": "\n### Never Trust User Input\n\n**Golden Rule**: All input is malicious until proven otherwise.\n\n### SQL Injection Prevention\n\n‚ùå **DANGER** (SQL Injection vulnerable):\n\n‚úÖ **Safe** (Parameterized queries):\n\n### XSS Prevention\n\n‚ùå **Bad** (XSS vulnerable):\n\n‚úÖ **Good** (Sanitized):\n\n### Email Validation\n\n‚ùå **Bad** (Weak validation):\n\n‚úÖ **Good** (Robust validation):\n\n### Path Traversal Prevention\n\n‚ùå **DANGER** (Path traversal):\n\n‚úÖ **Safe** (Validated path):\n\n---\n\n",
              "code": "fun getFile(filename: String): File? {\n    // Validate filename\n    if (filename.contains(\"..\") || filename.contains(\"/\")) {\n        logger.warn(\"Path traversal attempt: $filename\")\n        return null\n    }\n\n    val file = File(\"/uploads\", filename).canonicalFile\n    val uploadDir = File(\"/uploads\").canonicalFile\n\n    // Ensure file is within upload directory\n    if (!file.path.startsWith(uploadDir.path)) {\n        logger.warn(\"Path traversal detected: $filename\")\n        return null\n    }\n\n    return file\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Password Security",
              "content": "\n### Hashing with bcrypt\n\n‚ùå **NEVER** (Plaintext):\n\n‚ùå **BAD** (Simple hash):\n\n‚úÖ **GOOD** (bcrypt):\n\n### Password Strength Requirements\n\n\n---\n\n",
              "code": "object PasswordValidator {\n    data class ValidationResult(\n        val isValid: Boolean,\n        val errors: List<String>\n    )\n\n    fun validate(password: String): ValidationResult {\n        val errors = mutableListOf<String>()\n\n        if (password.length < 8) {\n            errors.add(\"Password must be at least 8 characters\")\n        }\n\n        if (!password.any { it.isUpperCase() }) {\n            errors.add(\"Password must contain an uppercase letter\")\n        }\n\n        if (!password.any { it.isLowerCase() }) {\n            errors.add(\"Password must contain a lowercase letter\")\n        }\n\n        if (!password.any { it.isDigit() }) {\n            errors.add(\"Password must contain a number\")\n        }\n\n        if (!password.any { \"!@#$%^&*()_+-=[]{}|;:,.<>?\".contains(it) }) {\n            errors.add(\"Password must contain a special character\")\n        }\n\n        // Check against common passwords\n        if (isCommonPassword(password)) {\n            errors.add(\"Password is too common\")\n        }\n\n        return ValidationResult(errors.isEmpty(), errors)\n    }\n\n    private fun isCommonPassword(password: String): Boolean {\n        val common = setOf(\n            \"password\", \"12345678\", \"qwerty\", \"abc123\",\n            \"password123\", \"admin\", \"letmein\"\n        )\n        return password.lowercase() in common\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "JWT Security",
              "content": "\n### Secure JWT Implementation\n\n‚ùå **Bad** (Insecure):\n\n‚úÖ **Good** (Secure):\n\n### Refresh Tokens\n\n\n---\n\n",
              "code": "@Entity\ndata class RefreshToken(\n    @PrimaryKey val id: String = UUID.randomUUID().toString(),\n    val userId: String,\n    val token: String,\n    val expiresAt: Long,\n    val createdAt: Long = System.currentTimeMillis()\n)\n\nobject TokenService {\n    private const val REFRESH_TOKEN_EXPIRATION = 7 * 24 * 3600000L // 7 days\n\n    fun generateTokenPair(user: User): TokenPair {\n        val accessToken = JwtConfig.generateToken(user)\n\n        val refreshToken = RefreshToken(\n            userId = user.id,\n            token = generateSecureRandomToken(),\n            expiresAt = System.currentTimeMillis() + REFRESH_TOKEN_EXPIRATION\n        )\n\n        refreshTokenRepository.save(refreshToken)\n\n        return TokenPair(accessToken, refreshToken.token)\n    }\n\n    suspend fun refreshAccessToken(refreshToken: String): String? {\n        val token = refreshTokenRepository.findByToken(refreshToken) ?: return null\n\n        if (token.expiresAt < System.currentTimeMillis()) {\n            refreshTokenRepository.delete(token.id)\n            return null\n        }\n\n        val user = userRepository.findById(token.userId) ?: return null\n\n        return JwtConfig.generateToken(user)\n    }\n\n    private fun generateSecureRandomToken(): String {\n        val bytes = ByteArray(32)\n        SecureRandom().nextBytes(bytes)\n        return bytes.joinToString(\"\") { \"%02x\".format(it) }\n    }\n}\n\ndata class TokenPair(\n    val accessToken: String,\n    val refreshToken: String\n)",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Android Security",
              "content": "\n### KeyStore for Secrets\n\n‚ùå **Bad** (Hardcoded secrets):\n\n‚úÖ **Good** (KeyStore):\n\n### ProGuard/R8 Configuration\n\n\n**proguard-rules.pro**:\n\n### Certificate Pinning\n\n\n---\n\n",
              "code": "// build.gradle.kts\ndependencies {\n    implementation(\"com.squareup.okhttp3:okhttp:4.12.0\")\n}\n\n// Certificate pinning\nval certificatePinner = CertificatePinner.Builder()\n    .add(\n        \"api.example.com\",\n        \"sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\"\n    )\n    .build()\n\nval client = OkHttpClient.Builder()\n    .certificatePinner(certificatePinner)\n    .build()\n\n// Get SHA256 hash:\n// openssl s_client -connect api.example.com:443 | openssl x509 -pubkey -noout | openssl pkey -pubin -outform der | openssl dgst -sha256 -binary | openssl enc -base64",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "OWASP Top 10",
              "content": "\n### 1. Broken Access Control\n\n‚ùå **Bad**:\n\n‚úÖ **Good**:\n\n### 2. Cryptographic Failures\n\n‚úÖ **Use HTTPS everywhere**:\n\n### 3. Injection\n\n‚úÖ **Always use parameterized queries** (shown earlier)\n\n### 4. Insecure Design\n\n‚úÖ **Security by design**:\n\n### 5. Security Misconfiguration\n\n‚úÖ **Secure defaults**:\n\n---\n\n",
              "code": "// application.conf\nktor {\n    deployment {\n        port = 8080\n        watch = []  # Disable auto-reload in production\n    }\n    application {\n        modules = [ com.example.ApplicationKt.module ]\n    }\n}\n\nsecurity {\n    ssl {\n        enabled = true\n        keyStore = ${?SSL_KEY_STORE}\n        keyStorePassword = ${?SSL_KEY_STORE_PASSWORD}\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 1: Secure User Registration",
              "content": "\nBuild a secure user registration system.\n\n### Requirements\n\n1. **Password Requirements**:\n   - Minimum 12 characters\n   - Uppercase, lowercase, number, special char\n   - Not in common password list\n\n2. **Email Validation**:\n   - Valid format\n   - Domain verification (MX record check)\n   - Unique in database\n\n3. **Security Features**:\n   - Hash passwords with bcrypt (cost 12)\n   - Email verification required\n   - Rate limiting (5 attempts per hour per IP)\n   - CAPTCHA on repeated failures\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 1",
              "content": "\n\n---\n\n",
              "code": "// Password validator\nobject PasswordValidator {\n    private val commonPasswords = setOf(\n        \"password123\", \"qwerty123\", \"admin123\",\n        // ... load from file\n    )\n\n    fun validate(password: String): ValidationResult {\n        val errors = mutableListOf<String>()\n\n        if (password.length < 12) {\n            errors.add(\"Password must be at least 12 characters\")\n        }\n\n        if (!password.any { it.isUpperCase() }) {\n            errors.add(\"Must contain uppercase letter\")\n        }\n\n        if (!password.any { it.isLowerCase() }) {\n            errors.add(\"Must contain lowercase letter\")\n        }\n\n        if (!password.any { it.isDigit() }) {\n            errors.add(\"Must contain number\")\n        }\n\n        if (!password.any { \"!@#$%^&*()\".contains(it) }) {\n            errors.add(\"Must contain special character\")\n        }\n\n        if (password.lowercase() in commonPasswords) {\n            errors.add(\"Password is too common\")\n        }\n\n        return ValidationResult(errors.isEmpty(), errors)\n    }\n}\n\n// Email validator with DNS check\nobject EmailValidator {\n    fun validate(email: String): ValidationResult {\n        val errors = mutableListOf<String>()\n\n        if (!basicValidation(email)) {\n            errors.add(\"Invalid email format\")\n            return ValidationResult(false, errors)\n        }\n\n        val domain = email.substringAfter(\"@\")\n        if (!hasMXRecord(domain)) {\n            errors.add(\"Email domain does not exist\")\n        }\n\n        return ValidationResult(errors.isEmpty(), errors)\n    }\n\n    private fun basicValidation(email: String): Boolean {\n        val pattern = Regex(\"^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}$\")\n        return email.matches(pattern)\n    }\n\n    private fun hasMXRecord(domain: String): Boolean {\n        return try {\n            val attributes = InitialDirContext().getAttributes(\n                \"dns:/$domain\",\n                arrayOf(\"MX\")\n            )\n            attributes.get(\"MX\") != null\n        } catch (e: Exception) {\n            false\n        }\n    }\n}\n\n// Rate limiter\nclass RateLimiter(private val maxAttempts: Int, private val windowMs: Long) {\n    private val attempts = ConcurrentHashMap<String, MutableList<Long>>()\n\n    fun isAllowed(key: String): Boolean {\n        val now = System.currentTimeMillis()\n        val userAttempts = attempts.getOrPut(key) { mutableListOf() }\n\n        // Remove old attempts\n        userAttempts.removeIf { it < now - windowMs }\n\n        if (userAttempts.size >= maxAttempts) {\n            return false\n        }\n\n        userAttempts.add(now)\n        return true\n    }\n}\n\n// Registration service\nclass RegistrationService(\n    private val userRepository: UserRepository,\n    private val emailService: EmailService,\n    private val rateLimiter: RateLimiter\n) {\n    suspend fun register(\n        email: String,\n        password: String,\n        ipAddress: String\n    ): Result<User> {\n        // Rate limiting\n        if (!rateLimiter.isAllowed(ipAddress)) {\n            return Result.failure(RateLimitException(\"Too many registration attempts\"))\n        }\n\n        // Validate email\n        val emailValidation = EmailValidator.validate(email)\n        if (!emailValidation.isValid) {\n            return Result.failure(ValidationException(emailValidation.errors))\n        }\n\n        // Check uniqueness\n        if (userRepository.existsByEmail(email)) {\n            return Result.failure(ValidationException(\"Email already registered\"))\n        }\n\n        // Validate password\n        val passwordValidation = PasswordValidator.validate(password)\n        if (!passwordValidation.isValid) {\n            return Result.failure(ValidationException(passwordValidation.errors))\n        }\n\n        // Hash password\n        val passwordHash = BCrypt.hashpw(password, BCrypt.gensalt(12))\n\n        // Create user (unverified)\n        val user = User(\n            id = UUID.randomUUID().toString(),\n            email = email,\n            passwordHash = passwordHash,\n            emailVerified = false,\n            createdAt = System.currentTimeMillis()\n        )\n\n        userRepository.save(user)\n\n        // Send verification email\n        val verificationToken = generateVerificationToken(user.id)\n        emailService.sendVerificationEmail(email, verificationToken)\n\n        return Result.success(user)\n    }\n\n    private fun generateVerificationToken(userId: String): String {\n        val token = UUID.randomUUID().toString()\n        // Save token with expiration (24 hours)\n        return token\n    }\n}\n\ndata class ValidationResult(val isValid: Boolean, val errors: List<String>)",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 2: Implement API Rate Limiting",
              "content": "\nCreate a rate limiting middleware for Ktor.\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 2",
              "content": "\n\n---\n\n",
              "code": "class RateLimitPlugin(private val config: Configuration) {\n    class Configuration {\n        var maxRequests: Int = 100\n        var windowMs: Long = 60000 // 1 minute\n        var keyExtractor: (ApplicationCall) -> String = { call ->\n            call.request.origin.remoteHost\n        }\n    }\n\n    companion object Feature : ApplicationPlugin<Application, Configuration, RateLimitPlugin> {\n        override val key = AttributeKey<RateLimitPlugin>(\"RateLimit\")\n\n        private val rateLimitData = ConcurrentHashMap<String, RateLimitInfo>()\n\n        override fun install(\n            pipeline: Application,\n            configure: Configuration.() -> Unit\n        ): RateLimitPlugin {\n            val config = Configuration().apply(configure)\n            val plugin = RateLimitPlugin(config)\n\n            pipeline.intercept(ApplicationCallPipeline.Plugins) {\n                val key = config.keyExtractor(call)\n                val now = System.currentTimeMillis()\n\n                val info = rateLimitData.getOrPut(key) {\n                    RateLimitInfo(mutableListOf(), now)\n                }\n\n                synchronized(info) {\n                    // Clean old requests\n                    info.requests.removeIf { it < now - config.windowMs }\n\n                    if (info.requests.size >= config.maxRequests) {\n                        call.response.headers.append(\"X-RateLimit-Limit\", config.maxRequests.toString())\n                        call.response.headers.append(\"X-RateLimit-Remaining\", \"0\")\n                        call.response.headers.append(\"Retry-After\", \"60\")\n\n                        call.respond(HttpStatusCode.TooManyRequests, mapOf(\n                            \"error\" to \"Rate limit exceeded\",\n                            \"limit\" to config.maxRequests,\n                            \"window\" to \"${config.windowMs / 1000}s\"\n                        ))\n                        finish()\n                        return@intercept\n                    }\n\n                    info.requests.add(now)\n\n                    call.response.headers.append(\"X-RateLimit-Limit\", config.maxRequests.toString())\n                    call.response.headers.append(\n                        \"X-RateLimit-Remaining\",\n                        (config.maxRequests - info.requests.size).toString()\n                    )\n                }\n            }\n\n            return plugin\n        }\n    }\n\n    private data class RateLimitInfo(\n        val requests: MutableList<Long>,\n        val windowStart: Long\n    )\n}\n\n// Usage\nfun Application.module() {\n    install(RateLimitPlugin) {\n        maxRequests = 100\n        windowMs = 60000 // 1 minute\n\n        keyExtractor = { call ->\n            // Use authenticated user ID if available, else IP\n            call.principal<UserPrincipal>()?.id\n                ?: call.request.origin.remoteHost\n        }\n    }\n\n    routing {\n        get(\"/api/data\") {\n            call.respond(\"Hello!\")\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 3: Secure File Upload",
              "content": "\nCreate a secure file upload endpoint.\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 3",
              "content": "\n\n---\n\n",
              "code": "class FileUploadService(\n    private val uploadDir: File,\n    private val maxFileSize: Long = 10 * 1024 * 1024, // 10 MB\n    private val allowedExtensions: Set<String> = setOf(\"jpg\", \"png\", \"pdf\")\n) {\n    init {\n        if (!uploadDir.exists()) {\n            uploadDir.mkdirs()\n        }\n    }\n\n    suspend fun upload(\n        file: MultiPartData,\n        userId: String\n    ): Result<UploadedFile> {\n        var uploadedFile: UploadedFile? = null\n        var tempFile: File? = null\n\n        try {\n            file.forEachPart { part ->\n                when (part) {\n                    is PartData.FileItem -> {\n                        val fileName = part.originalFileName ?: return@forEachPart\n\n                        // Validate filename\n                        if (!isValidFilename(fileName)) {\n                            return Result.failure(ValidationException(\"Invalid filename\"))\n                        }\n\n                        // Validate extension\n                        val extension = fileName.substringAfterLast(\".\", \"\")\n                        if (extension.lowercase() !in allowedExtensions) {\n                            return Result.failure(\n                                ValidationException(\"File type not allowed. Allowed: $allowedExtensions\")\n                            )\n                        }\n\n                        // Generate safe filename\n                        val safeFilename = \"${UUID.randomUUID()}.${extension.lowercase()}\"\n                        tempFile = File(uploadDir, safeFilename)\n\n                        var size = 0L\n                        tempFile!!.outputStream().use { output ->\n                            part.streamProvider().use { input ->\n                                val buffer = ByteArray(8192)\n                                var bytesRead: Int\n\n                                while (input.read(buffer).also { bytesRead = it } != -1) {\n                                    size += bytesRead\n\n                                    if (size > maxFileSize) {\n                                        return Result.failure(\n                                            ValidationException(\"File too large. Max: ${maxFileSize / 1024 / 1024}MB\")\n                                        )\n                                    }\n\n                                    output.write(buffer, 0, bytesRead)\n                                }\n                            }\n                        }\n\n                        // Validate file type (magic numbers)\n                        if (!isValidFileType(tempFile!!, extension)) {\n                            tempFile!!.delete()\n                            return Result.failure(ValidationException(\"File content doesn't match extension\"))\n                        }\n\n                        // Scan for malware (integrate with antivirus)\n                        if (containsMalware(tempFile!!)) {\n                            tempFile!!.delete()\n                            return Result.failure(SecurityException(\"Malware detected\"))\n                        }\n\n                        uploadedFile = UploadedFile(\n                            id = UUID.randomUUID().toString(),\n                            originalFilename = fileName,\n                            storedFilename = safeFilename,\n                            extension = extension,\n                            size = size,\n                            uploadedBy = userId,\n                            uploadedAt = System.currentTimeMillis()\n                        )\n                    }\n                    else -> {}\n                }\n                part.dispose()\n            }\n\n            return uploadedFile?.let { Result.success(it) }\n                ?: Result.failure(Exception(\"No file uploaded\"))\n\n        } catch (e: Exception) {\n            tempFile?.delete()\n            return Result.failure(e)\n        }\n    }\n\n    private fun isValidFilename(filename: String): Boolean {\n        // No path traversal\n        if (filename.contains(\"..\") || filename.contains(\"/\") || filename.contains(\"\\\\\")) {\n            return false\n        }\n\n        // No special characters\n        if (!filename.matches(Regex(\"^[a-zA-Z0-9._-]+$\"))) {\n            return false\n        }\n\n        return true\n    }\n\n    private fun isValidFileType(file: File, expectedExtension: String): Boolean {\n        val bytes = file.inputStream().use { it.readNBytes(12) }\n\n        return when (expectedExtension.lowercase()) {\n            \"jpg\", \"jpeg\" -> bytes.take(3).toByteArray().contentEquals(\n                byteArrayOf(0xFF.toByte(), 0xD8.toByte(), 0xFF.toByte())\n            )\n            \"png\" -> bytes.take(8).toByteArray().contentEquals(\n                byteArrayOf(0x89.toByte(), 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A)\n            )\n            \"pdf\" -> bytes.take(4).toByteArray().contentEquals(\n                byteArrayOf(0x25, 0x50, 0x44, 0x46) // %PDF\n            )\n            else -> false\n        }\n    }\n\n    private fun containsMalware(file: File): Boolean {\n        // Integrate with ClamAV or similar\n        // For now, return false\n        return false\n    }\n}\n\ndata class UploadedFile(\n    val id: String,\n    val originalFilename: String,\n    val storedFilename: String,\n    val extension: String,\n    val size: Long,\n    val uploadedBy: String,\n    val uploadedAt: Long\n)\n\n// Ktor route\nfun Route.fileUpload(fileUploadService: FileUploadService) {\n    post(\"/upload\") {\n        val principal = call.principal<UserPrincipal>()\n            ?: return@post call.respond(HttpStatusCode.Unauthorized)\n\n        val multipart = call.receiveMultipart()\n\n        val result = fileUploadService.upload(multipart, principal.id)\n\n        result.fold(\n            onSuccess = { uploadedFile ->\n                call.respond(HttpStatusCode.Created, uploadedFile)\n            },\n            onFailure = { error ->\n                when (error) {\n                    is ValidationException -> call.respond(\n                        HttpStatusCode.BadRequest,\n                        mapOf(\"error\" to error.message)\n                    )\n                    is SecurityException -> call.respond(\n                        HttpStatusCode.Forbidden,\n                        mapOf(\"error\" to error.message)\n                    )\n                    else -> call.respond(\n                        HttpStatusCode.InternalServerError,\n                        mapOf(\"error\" to \"Upload failed\")\n                    )\n                }\n            }\n        )\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n### The Stakes\n\n**Data Breaches Cost**:\n- Average cost: $4.45 million\n- Customer churn: 60% after breach\n- Legal penalties: GDPR fines up to 4% of revenue\n\n**Career Impact**:\n- Security-aware developers earn 25% more\n- Companies require security knowledge\n- One breach can end a career\n\n**User Trust**:\n- 87% won't use an app after a breach\n- Trust takes years to build, seconds to destroy\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Checkpoint Quiz",
              "content": "\n### Question 1\nWhy should you NEVER store passwords in plaintext?\n\nA) It takes up too much space\nB) If database is compromised, all passwords are exposed\nC) It's slower than hashing\nD) It's not compatible with databases\n\n### Question 2\nWhat is the N+1 query problem related to in security?\n\nA) It's a type of SQL injection\nB) It creates performance issues that can be exploited for DoS\nC) It allows unauthorized access\nD) It's not a security issue\n\n### Question 3\nWhat's the purpose of certificate pinning?\n\nA) Faster HTTPS connections\nB) Prevents man-in-the-middle attacks\nC) Reduces app size\nD) Improves SEO\n\n### Question 4\nWhat should you do when security validation fails?\n\nA) Grant access anyway\nB) Fail securely (deny access)\nC) Log the user out\nD) Restart the app\n\n### Question 5\nWhy use bcrypt instead of SHA-256 for passwords?\n\nA) bcrypt is faster\nB) bcrypt includes salt and is designed to be slow\nC) SHA-256 is deprecated\nD) bcrypt produces smaller hashes\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Answers",
              "content": "\n**Question 1: B) If database is compromised, all passwords are exposed**\n\nStoring plaintext passwords = catastrophic breach:\n- Attackers get all passwords\n- Users reuse passwords across sites\n- One breach = compromise everywhere\n\nAlways hash passwords with bcrypt!\n\n---\n\n**Question 2: B) Creates performance issues that can be exploited for DoS**\n\nN+1 queries = performance vulnerability:\n- Attacker requests large dataset\n- Triggers thousands of queries\n- Server becomes unresponsive (DoS)\n\nSolution: Use JOINs and optimize queries\n\n---\n\n**Question 3: B) Prevents man-in-the-middle attacks**\n\nCertificate pinning ensures:\n- App only trusts specific certificates\n- Can't be fooled by fake certificates\n- Prevents attackers intercepting traffic\n\n---\n\n**Question 4: B) Fail securely (deny access)**\n\nWhen in doubt, deny:\n- Error in authentication? Deny\n- Exception in authorization? Deny\n- Can't verify request? Deny\n\nNever fail open!\n\n---\n\n**Question 5: B) bcrypt includes salt and is designed to be slow**\n\nbcrypt advantages:\n- Automatically salts (unique hash per password)\n- Configurable cost (slower = harder to crack)\n- Designed for passwords (SHA-256 is not)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "What You've Learned",
              "content": "\n‚úÖ Why security is critical (real breach examples)\n‚úÖ Secure coding principles (defense in depth, least privilege, fail securely)\n‚úÖ Input validation and sanitization (SQL injection, XSS, path traversal)\n‚úÖ Password security (bcrypt hashing, strength validation)\n‚úÖ JWT security (proper signing, expiration, refresh tokens)\n‚úÖ Android security (KeyStore, ProGuard, certificate pinning)\n‚úÖ OWASP Top 10 vulnerabilities and how to prevent them\n‚úÖ Practical security implementations (registration, rate limiting, file upload)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Next Steps",
              "content": "\nIn **Lesson 7.5: CI/CD and DevOps**, you'll learn:\n- Continuous Integration with GitHub Actions\n- Automated testing in CI/CD pipelines\n- Build automation with Gradle\n- Code quality tools (ktlint, detekt)\n- Docker for backend applications\n- Publishing Android apps to Play Store\n\nSecure code is worthless if you can't deploy it reliably!\n\n---\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "7.5",
          "title": "Lesson 7.5: CI/CD and DevOps",
          "moduleId": "module-07",
          "order": 5,
          "estimatedMinutes": 85,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 85 minutes\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "\n\"It works on my machine\" is no longer acceptable in professional software development.\n\n**CI/CD (Continuous Integration/Continuous Deployment)** is the practice of:\n- Automatically building and testing code on every commit\n- Deploying to production multiple times per day\n- Catching bugs before they reach users\n- Shipping features faster with confidence\n\nIn this lesson, you'll master:\n- ‚úÖ GitHub Actions for CI/CD\n- ‚úÖ Automated testing pipelines\n- ‚úÖ Build automation with Gradle\n- ‚úÖ Code quality tools (ktlint, detekt)\n- ‚úÖ Docker for backend apps\n- ‚úÖ Publishing Android apps\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Why CI/CD Matters",
              "content": "\n### The Manual Deployment Nightmare\n\n**Without CI/CD**:\n\n**Time**: 2-4 hours per deployment\n**Frequency**: Once per week (too risky to do more)\n**Errors**: Common (human mistakes)\n\n**With CI/CD**:\n\n**Time**: 5-10 minutes\n**Frequency**: 10+ times per day\n**Errors**: Rare (automated, consistent)\n\n### Real-World Impact\n\n**Companies Using CI/CD**:\n- **Amazon**: Deploys every 11.7 seconds\n- **Netflix**: Deploys 4,000+ times per day\n- **Google**: 5,500 deployments per day\n\n**Benefits**:\n- 46x more frequent deployments\n- 96 hours faster lead time (idea ‚Üí production)\n- 5x lower failure rate\n- 24x faster recovery time\n\n---\n\n",
              "code": "Developer writes code\n‚Üì\nPush to GitHub\n‚Üì\nCI automatically:\n  ‚úì Builds app\n  ‚úì Runs all tests\n  ‚úì Checks code quality\n  ‚úì Deploys to staging\n  ‚úì Runs integration tests\n  ‚úì Deploys to production\n‚Üì\nDone! (5-10 minutes)",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "GitHub Actions Fundamentals",
              "content": "\n### What is GitHub Actions?\n\nGitHub Actions is a CI/CD platform that runs workflows when events occur in your repository.\n\n**Events**: Push, pull request, release, schedule, manual trigger\n**Runners**: Ubuntu, Windows, macOS virtual machines\n**Actions**: Reusable workflow steps\n\n### Basic Workflow\n\n**.github/workflows/build.yml**:\n\n**What happens**:\n1. Code is checked out\n2. JDK 17 is installed\n3. Gradle builds the project\n4. Tests run\n5. Test results are uploaded (even if tests fail)\n\n---\n\n",
              "code": "name: Build and Test\n\non:\n  push:\n    branches: [ main, develop ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Set up JDK 17\n        uses: actions/setup-java@v4\n        with:\n          java-version: '17'\n          distribution: 'temurin'\n\n      - name: Grant execute permission for gradlew\n        run: chmod +x gradlew\n\n      - name: Build with Gradle\n        run: ./gradlew build\n\n      - name: Run tests\n        run: ./gradlew test\n\n      - name: Upload test results\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: test-results\n          path: build/test-results/",
              "language": "yaml"
            },
            {
              "type": "THEORY",
              "title": "Android CI/CD Pipeline",
              "content": "\n### Complete Android Workflow\n\n**.github/workflows/android.yml**:\n\n---\n\n",
              "code": "name: Android CI/CD\n\non:\n  push:\n    branches: [ main, develop ]\n  pull_request:\n    branches: [ main ]\n  release:\n    types: [ published ]\n\nenv:\n  JAVA_VERSION: '17'\n\njobs:\n  lint:\n    name: Code Quality Check\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up JDK\n        uses: actions/setup-java@v4\n        with:\n          java-version: ${{ env.JAVA_VERSION }}\n          distribution: 'temurin'\n\n      - name: Cache Gradle packages\n        uses: actions/cache@v3\n        with:\n          path: |\n            ~/.gradle/caches\n            ~/.gradle/wrapper\n          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}\n          restore-keys: |\n            ${{ runner.os }}-gradle-\n\n      - name: Run ktlint\n        run: ./gradlew ktlintCheck\n\n      - name: Run detekt\n        run: ./gradlew detekt\n\n      - name: Upload detekt report\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: detekt-report\n          path: build/reports/detekt/\n\n  test:\n    name: Unit Tests\n    runs-on: ubuntu-latest\n    needs: lint\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up JDK\n        uses: actions/setup-java@v4\n        with:\n          java-version: ${{ env.JAVA_VERSION }}\n          distribution: 'temurin'\n\n      - name: Cache Gradle\n        uses: actions/cache@v3\n        with:\n          path: |\n            ~/.gradle/caches\n            ~/.gradle/wrapper\n          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*') }}\n\n      - name: Run unit tests\n        run: ./gradlew test\n\n      - name: Generate test coverage report\n        run: ./gradlew jacocoTestReport\n\n      - name: Upload coverage to Codecov\n        uses: codecov/codecov-action@v3\n        with:\n          files: build/reports/jacoco/test/jacocoTestReport.xml\n          fail_ci_if_error: true\n\n      - name: Upload test results\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: test-results\n          path: build/test-results/\n\n  build:\n    name: Build APK\n    runs-on: ubuntu-latest\n    needs: test\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up JDK\n        uses: actions/setup-java@v4\n        with:\n          java-version: ${{ env.JAVA_VERSION }}\n          distribution: 'temurin'\n\n      - name: Decode keystore\n        if: github.event_name == 'release'\n        run: |\n          echo \"${{ secrets.KEYSTORE_BASE64 }}\" | base64 --decode > keystore.jks\n\n      - name: Build debug APK\n        if: github.event_name != 'release'\n        run: ./gradlew assembleDebug\n\n      - name: Build release APK\n        if: github.event_name == 'release'\n        run: ./gradlew assembleRelease\n        env:\n          KEYSTORE_PASSWORD: ${{ secrets.KEYSTORE_PASSWORD }}\n          KEY_ALIAS: ${{ secrets.KEY_ALIAS }}\n          KEY_PASSWORD: ${{ secrets.KEY_PASSWORD }}\n\n      - name: Upload APK\n        uses: actions/upload-artifact@v4\n        with:\n          name: app-apk\n          path: app/build/outputs/apk/**/*.apk\n\n  deploy:\n    name: Deploy to Play Store\n    runs-on: ubuntu-latest\n    needs: build\n    if: github.event_name == 'release'\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Download APK\n        uses: actions/download-artifact@v4\n        with:\n          name: app-apk\n\n      - name: Deploy to Play Store\n        uses: r0adkll/upload-google-play@v1\n        with:\n          serviceAccountJsonPlainText: ${{ secrets.PLAY_STORE_SERVICE_ACCOUNT }}\n          packageName: com.example.app\n          releaseFiles: app/build/outputs/apk/release/app-release.apk\n          track: production",
              "language": "yaml"
            },
            {
              "type": "THEORY",
              "title": "Backend (Ktor) CI/CD Pipeline",
              "content": "\n**.github/workflows/ktor.yml**:\n\n---\n\n",
              "code": "name: Ktor Backend CI/CD\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    services:\n      postgres:\n        image: postgres:15\n        env:\n          POSTGRES_PASSWORD: testpass\n          POSTGRES_DB: testdb\n        options: >-\n          --health-cmd pg_isready\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n        ports:\n          - 5432:5432\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up JDK 17\n        uses: actions/setup-java@v4\n        with:\n          java-version: '17'\n          distribution: 'temurin'\n\n      - name: Run tests\n        run: ./gradlew test\n        env:\n          DB_HOST: localhost\n          DB_PORT: 5432\n          DB_NAME: testdb\n          DB_USER: postgres\n          DB_PASSWORD: testpass\n\n      - name: Generate coverage report\n        run: ./gradlew jacocoTestReport\n\n      - name: Upload coverage\n        uses: codecov/codecov-action@v3\n\n  build:\n    runs-on: ubuntu-latest\n    needs: test\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up JDK 17\n        uses: actions/setup-java@v4\n        with:\n          java-version: '17'\n          distribution: 'temurin'\n\n      - name: Build fat JAR\n        run: ./gradlew shadowJar\n\n      - name: Upload JAR\n        uses: actions/upload-artifact@v4\n        with:\n          name: app-jar\n          path: build/libs/*-all.jar\n\n  docker:\n    runs-on: ubuntu-latest\n    needs: build\n    if: github.ref == 'refs/heads/main'\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v3\n\n      - name: Login to Docker Hub\n        uses: docker/login-action@v3\n        with:\n          username: ${{ secrets.DOCKER_USERNAME }}\n          password: ${{ secrets.DOCKER_PASSWORD }}\n\n      - name: Build and push\n        uses: docker/build-push-action@v5\n        with:\n          context: .\n          push: true\n          tags: |\n            myusername/my-app:latest\n            myusername/my-app:${{ github.sha }}\n          cache-from: type=registry,ref=myusername/my-app:latest\n          cache-to: type=inline\n\n  deploy:\n    runs-on: ubuntu-latest\n    needs: docker\n    if: github.ref == 'refs/heads/main'\n\n    steps:\n      - name: Deploy to production\n        uses: appleboy/ssh-action@v1.0.0\n        with:\n          host: ${{ secrets.DEPLOY_HOST }}\n          username: ${{ secrets.DEPLOY_USER }}\n          key: ${{ secrets.DEPLOY_SSH_KEY }}\n          script: |\n            docker pull myusername/my-app:latest\n            docker stop my-app || true\n            docker rm my-app || true\n            docker run -d \\\n              --name my-app \\\n              -p 8080:8080 \\\n              -e DB_HOST=${{ secrets.DB_HOST }} \\\n              -e DB_PASSWORD=${{ secrets.DB_PASSWORD }} \\\n              myusername/my-app:latest",
              "language": "yaml"
            },
            {
              "type": "THEORY",
              "title": "Build Automation with Gradle",
              "content": "\n### Multi-Module Setup\n\n**settings.gradle.kts**:\n\n**Root build.gradle.kts**:\n\n### Custom Gradle Tasks\n\n**build.gradle.kts**:\n\n---\n\n",
              "code": "tasks.register(\"deployToStaging\") {\n    group = \"deployment\"\n    description = \"Deploy application to staging environment\"\n\n    dependsOn(\"test\", \"shadowJar\")\n\n    doLast {\n        exec {\n            commandLine(\n                \"scp\",\n                \"build/libs/app-all.jar\",\n                \"user@staging-server:/opt/app/\"\n            )\n        }\n\n        exec {\n            commandLine(\n                \"ssh\",\n                \"user@staging-server\",\n                \"systemctl restart app\"\n            )\n        }\n    }\n}\n\ntasks.register(\"generateReleaseNotes\") {\n    group = \"documentation\"\n    description = \"Generate release notes from git commits\"\n\n    doLast {\n        val output = ByteArrayOutputStream()\n        exec {\n            commandLine(\"git\", \"log\", \"--pretty=format:%s\", \"HEAD~10..HEAD\")\n            standardOutput = output\n        }\n\n        val releaseNotes = output.toString()\n        file(\"RELEASE_NOTES.md\").writeText(\"# Release Notes\\n\\n$releaseNotes\")\n        println(\"Generated RELEASE_NOTES.md\")\n    }\n}\n\ntasks.register(\"checkDependencyUpdates\") {\n    group = \"verification\"\n    description = \"Check for dependency updates\"\n\n    doLast {\n        exec {\n            commandLine(\"./gradlew\", \"dependencyUpdates\")\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Quality Tools",
              "content": "\n### ktlint Configuration\n\n**.editorconfig**:\n\n**Run ktlint**:\n\n### detekt Configuration\n\n**detekt.yml**:\n\n**Run detekt**:\n\n---\n\n",
              "code": "./gradlew detekt",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Docker for Backend",
              "content": "\n### Dockerfile\n\n**Dockerfile**:\n\n### docker-compose.yml\n\n\n**.env**:\n\n**Run with Docker Compose**:\n\n---\n\n",
              "code": "docker-compose up -d\ndocker-compose logs -f app\ndocker-compose down",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Publishing Android Apps",
              "content": "\n### Signing Configuration\n\n**app/build.gradle.kts**:\n\n### Generate Keystore\n\n\n### Prepare for Play Store\n\n1. **Version Code & Name**:\n\n2. **App Bundle**:\n\nOutput: `app/build/outputs/bundle/release/app-release.aab`\n\n3. **Upload to Play Console**:\n   - Create app listing\n   - Upload app bundle\n   - Fill store listing (title, description, screenshots)\n   - Set pricing & distribution\n   - Submit for review\n\n---\n\n",
              "code": "./gradlew bundleRelease",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Exercise 1: Set Up Complete Android CI/CD",
              "content": "\nCreate a GitHub Actions workflow that:\n1. Runs ktlint and detekt\n2. Runs unit tests with coverage\n3. Builds debug APK for PRs\n4. Builds signed release APK for releases\n5. Uploads to GitHub releases\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 1",
              "content": "\n**.github/workflows/android-ci-cd.yml**:\n\n---\n\n",
              "code": "name: Android CI/CD\n\non:\n  push:\n    branches: [ main, develop ]\n  pull_request:\n    branches: [ main ]\n  release:\n    types: [ published ]\n\nenv:\n  JAVA_VERSION: '17'\n\njobs:\n  code-quality:\n    name: Code Quality\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up JDK\n        uses: actions/setup-java@v4\n        with:\n          java-version: ${{ env.JAVA_VERSION }}\n          distribution: 'temurin'\n\n      - name: Cache Gradle\n        uses: actions/cache@v3\n        with:\n          path: |\n            ~/.gradle/caches\n            ~/.gradle/wrapper\n          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*') }}\n          restore-keys: ${{ runner.os }}-gradle-\n\n      - name: Run ktlint\n        run: ./gradlew ktlintCheck\n\n      - name: Run detekt\n        run: ./gradlew detekt\n\n      - name: Upload detekt report\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: detekt-report\n          path: build/reports/detekt/\n\n      - name: Comment PR with detekt results\n        if: github.event_name == 'pull_request'\n        uses: actions/github-script@v7\n        with:\n          script: |\n            const fs = require('fs');\n            const report = fs.readFileSync('build/reports/detekt/detekt.txt', 'utf8');\n            github.rest.issues.createComment({\n              issue_number: context.issue.number,\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              body: `## Detekt Report\\n\\`\\`\\`\\n${report}\\n\\`\\`\\``\n            });\n\n  test:\n    name: Unit Tests\n    runs-on: ubuntu-latest\n    needs: code-quality\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up JDK\n        uses: actions/setup-java@v4\n        with:\n          java-version: ${{ env.JAVA_VERSION }}\n          distribution: 'temurin'\n\n      - name: Cache Gradle\n        uses: actions/cache@v3\n        with:\n          path: |\n            ~/.gradle/caches\n            ~/.gradle/wrapper\n          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*') }}\n\n      - name: Run tests\n        run: ./gradlew test\n\n      - name: Generate coverage report\n        run: ./gradlew jacocoTestReport\n\n      - name: Upload coverage to Codecov\n        uses: codecov/codecov-action@v3\n        with:\n          files: build/reports/jacoco/test/jacocoTestReport.xml\n\n      - name: Comment PR with coverage\n        if: github.event_name == 'pull_request'\n        uses: actions/github-script@v7\n        with:\n          script: |\n            const fs = require('fs');\n            const xml = fs.readFileSync('build/reports/jacoco/test/jacocoTestReport.xml', 'utf8');\n            // Parse coverage percentage from XML\n            github.rest.issues.createComment({\n              issue_number: context.issue.number,\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              body: `## Test Coverage\\nSee full report in artifacts.`\n            });\n\n  build-debug:\n    name: Build Debug APK\n    runs-on: ubuntu-latest\n    needs: test\n    if: github.event_name == 'pull_request'\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up JDK\n        uses: actions/setup-java@v4\n        with:\n          java-version: ${{ env.JAVA_VERSION }}\n          distribution: 'temurin'\n\n      - name: Build debug APK\n        run: ./gradlew assembleDebug\n\n      - name: Upload APK\n        uses: actions/upload-artifact@v4\n        with:\n          name: debug-apk\n          path: app/build/outputs/apk/debug/app-debug.apk\n\n  build-release:\n    name: Build Release APK\n    runs-on: ubuntu-latest\n    needs: test\n    if: github.event_name == 'release'\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up JDK\n        uses: actions/setup-java@v4\n        with:\n          java-version: ${{ env.JAVA_VERSION }}\n          distribution: 'temurin'\n\n      - name: Decode keystore\n        run: echo \"${{ secrets.KEYSTORE_BASE64 }}\" | base64 --decode > keystore.jks\n\n      - name: Build release APK\n        run: ./gradlew assembleRelease\n        env:\n          KEYSTORE_PATH: keystore.jks\n          KEYSTORE_PASSWORD: ${{ secrets.KEYSTORE_PASSWORD }}\n          KEY_ALIAS: ${{ secrets.KEY_ALIAS }}\n          KEY_PASSWORD: ${{ secrets.KEY_PASSWORD }}\n\n      - name: Upload to GitHub Release\n        uses: actions/upload-release-asset@v1\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        with:\n          upload_url: ${{ github.event.release.upload_url }}\n          asset_path: app/build/outputs/apk/release/app-release.apk\n          asset_name: app-release.apk\n          asset_content_type: application/vnd.android.package-archive",
              "language": "yaml"
            },
            {
              "type": "THEORY",
              "title": "Exercise 2: Create Docker Setup for Ktor",
              "content": "\nCreate a complete Docker setup for a Ktor backend with PostgreSQL.\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 2",
              "content": "\n**Dockerfile**:\n\n**docker-compose.yml**:\n\n**nginx.conf**:\n\n**Makefile**:\n\n**Usage**:\n\n---\n\n",
              "code": "make build\nmake up\nmake logs\nmake down",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Exercise 3: Automated Release Process",
              "content": "\nCreate a workflow that automatically:\n1. Bumps version number\n2. Generates changelog\n3. Creates GitHub release\n4. Deploys to production\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 3",
              "content": "\n**.github/workflows/release.yml**:\n\n---\n\n",
              "code": "name: Automated Release\n\non:\n  workflow_dispatch:\n    inputs:\n      version_bump:\n        description: 'Version bump type'\n        required: true\n        type: choice\n        options:\n          - patch\n          - minor\n          - major\n\njobs:\n  release:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          fetch-depth: 0\n          token: ${{ secrets.GITHUB_TOKEN }}\n\n      - name: Set up JDK\n        uses: actions/setup-java@v4\n        with:\n          java-version: '17'\n          distribution: 'temurin'\n\n      - name: Get current version\n        id: current_version\n        run: |\n          VERSION=$(grep \"versionName\" app/build.gradle.kts | sed 's/.*\"\\(.*\\)\".*/\\1/')\n          echo \"version=$VERSION\" >> $GITHUB_OUTPUT\n\n      - name: Bump version\n        id: bump_version\n        run: |\n          CURRENT=\"${{ steps.current_version.outputs.version }}\"\n          IFS='.' read -ra PARTS <<< \"$CURRENT\"\n          MAJOR=${PARTS[0]}\n          MINOR=${PARTS[1]}\n          PATCH=${PARTS[2]}\n\n          case \"${{ github.event.inputs.version_bump }}\" in\n            major)\n              MAJOR=$((MAJOR + 1))\n              MINOR=0\n              PATCH=0\n              ;;\n            minor)\n              MINOR=$((MINOR + 1))\n              PATCH=0\n              ;;\n            patch)\n              PATCH=$((PATCH + 1))\n              ;;\n          esac\n\n          NEW_VERSION=\"$MAJOR.$MINOR.$PATCH\"\n          echo \"new_version=$NEW_VERSION\" >> $GITHUB_OUTPUT\n\n      - name: Update version in build.gradle.kts\n        run: |\n          sed -i 's/versionName = \".*\"/versionName = \"${{ steps.bump_version.outputs.new_version }}\"/' app/build.gradle.kts\n\n      - name: Generate changelog\n        id: changelog\n        run: |\n          PREVIOUS_TAG=$(git describe --tags --abbrev=0)\n          CHANGELOG=$(git log ${PREVIOUS_TAG}..HEAD --pretty=format:\"- %s\")\n          echo \"changelog<<EOF\" >> $GITHUB_OUTPUT\n          echo \"$CHANGELOG\" >> $GITHUB_OUTPUT\n          echo \"EOF\" >> $GITHUB_OUTPUT\n\n      - name: Commit version bump\n        run: |\n          git config user.name \"GitHub Actions\"\n          git config user.email \"actions@github.com\"\n          git add app/build.gradle.kts\n          git commit -m \"chore: bump version to ${{ steps.bump_version.outputs.new_version }}\"\n          git push\n\n      - name: Create GitHub Release\n        uses: actions/create-release@v1\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        with:\n          tag_name: v${{ steps.bump_version.outputs.new_version }}\n          release_name: Release ${{ steps.bump_version.outputs.new_version }}\n          body: |\n            ## What's Changed\n            ${{ steps.changelog.outputs.changelog }}\n\n            **Full Changelog**: https://github.com/${{ github.repository }}/compare/v${{ steps.current_version.outputs.version }}...v${{ steps.bump_version.outputs.new_version }}\n          draft: false\n          prerelease: false\n\n      - name: Build release APK\n        run: ./gradlew assembleRelease\n        env:\n          KEYSTORE_PATH: keystore.jks\n          KEYSTORE_PASSWORD: ${{ secrets.KEYSTORE_PASSWORD }}\n          KEY_ALIAS: ${{ secrets.KEY_ALIAS }}\n          KEY_PASSWORD: ${{ secrets.KEY_PASSWORD }}\n\n      - name: Deploy to production\n        run: |\n          # Your deployment logic here\n          echo \"Deploying version ${{ steps.bump_version.outputs.new_version }}\"",
              "language": "yaml"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n### Business Impact\n\n**Deployment Frequency**:\n- Without CI/CD: 1x per week\n- With CI/CD: 10x per day\n- Result: 50x faster time-to-market\n\n**Quality**:\n- Automated tests catch 80% of bugs before production\n- Code quality tools prevent technical debt\n- Consistent builds eliminate \"works on my machine\"\n\n**Developer Productivity**:\n- No manual deployment steps\n- Immediate feedback on code quality\n- More time for features, less for debugging\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Checkpoint Quiz",
              "content": "\n### Question 1\nWhat does CI/CD stand for?\n\nA) Code Integration / Code Deployment\nB) Continuous Integration / Continuous Deployment\nC) Constant Improvement / Constant Development\nD) Central Integration / Central Deployment\n\n### Question 2\nWhat's the main benefit of automated testing in CI/CD?\n\nA) Faster builds\nB) Smaller APKs\nC) Catching bugs before they reach production\nD) Better code formatting\n\n### Question 3\nWhat is Docker used for?\n\nA) Compiling Kotlin code\nB) Packaging applications in containers\nC) Writing tests\nD) Designing UI\n\n### Question 4\nWhat does ktlint do?\n\nA) Compiles Kotlin code\nB) Runs tests\nC) Checks and formats code style\nD) Deploys applications\n\n### Question 5\nWhy use Gradle caching in CI/CD?\n\nA) To save disk space\nB) To speed up builds by reusing dependencies\nC) To improve code quality\nD) To reduce APK size\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Answers",
              "content": "\n**Question 1: B) Continuous Integration / Continuous Deployment**\n\n- **CI**: Automatically build and test on every commit\n- **CD**: Automatically deploy to production\n\nBenefits: Faster releases, fewer bugs, happier developers\n\n---\n\n**Question 2: C) Catching bugs before they reach production**\n\nAutomated tests in CI:\n- Run on every commit\n- Catch regressions immediately\n- Prevent broken code from merging\n- Save time and money\n\n---\n\n**Question 3: B) Packaging applications in containers**\n\nDocker containers:\n- Include app + all dependencies\n- Run consistently everywhere\n- Easy to deploy and scale\n- Isolated from host system\n\n---\n\n**Question 4: C) Checks and formats code style**\n\nktlint enforces:\n- Consistent code formatting\n- Kotlin style guide\n- Team coding standards\n- Prevents \"style wars\"\n\n---\n\n**Question 5: B) To speed up builds by reusing dependencies**\n\nGradle caching:\n- Downloads dependencies once\n- Reuses on subsequent builds\n- 5-10x faster builds\n- Less network usage\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "What You've Learned",
              "content": "\n‚úÖ Why CI/CD is essential for modern development\n‚úÖ GitHub Actions for automated builds and tests\n‚úÖ Complete Android CI/CD pipeline\n‚úÖ Complete Ktor backend CI/CD pipeline\n‚úÖ Build automation with Gradle\n‚úÖ Code quality tools (ktlint, detekt)\n‚úÖ Docker for containerized deployment\n‚úÖ Publishing Android apps to Play Store\n‚úÖ Automated release processes\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Next Steps",
              "content": "\nIn **Lesson 7.6: Cloud Deployment**, you'll learn:\n- Deploying Ktor apps to AWS, GCP, Heroku\n- Database hosting and management\n- Environment configuration\n- SSL/TLS setup\n- Scaling strategies\n- Cost optimization\n\nYour CI/CD pipeline is ready - now let's deploy to the cloud!\n\n---\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "7.6",
          "title": "Lesson 7.6: Cloud Deployment",
          "moduleId": "module-07",
          "order": 6,
          "estimatedMinutes": 80,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 80 minutes\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "\nYour application is built, tested, and containerized. Now it's time to deploy to the cloud and serve millions of users worldwide!\n\nIn this lesson, you'll master cloud deployment for Kotlin applications:\n- ‚úÖ Deploying Ktor apps to AWS, Google Cloud, Heroku\n- ‚úÖ Database hosting (PostgreSQL, MongoDB)\n- ‚úÖ Environment configuration and secrets management\n- ‚úÖ SSL/TLS certificates for HTTPS\n- ‚úÖ Load balancing and scaling\n- ‚úÖ Cost optimization strategies\n\nBy the end, you'll confidently deploy production-ready applications to the cloud.\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Cloud Platform Comparison",
              "content": "\n### AWS vs Google Cloud vs Heroku\n\n| Feature | AWS | Google Cloud (GCP) | Heroku |\n|---------|-----|-------------------|--------|\n| **Ease of Use** | ‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |\n| **Pricing** | Pay-as-you-go | Pay-as-you-go | Free tier + plans |\n| **Best For** | Enterprise, flexibility | Kubernetes, ML | Startups, prototypes |\n| **Learning Curve** | Steep | Medium | Easy |\n| **Kotlin Support** | ‚úÖ EC2, ECS, Lambda | ‚úÖ Compute Engine, Cloud Run | ‚úÖ Native |\n\n**Recommendation**:\n- **Learning/Prototype**: Heroku (easiest)\n- **Production/Scale**: AWS or GCP (most powerful)\n- **Kubernetes**: GCP (best K8s integration)\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Heroku Deployment (Easiest)",
              "content": "\n### Why Heroku?\n\n- ‚úÖ Deploy in 5 minutes\n- ‚úÖ Free tier available\n- ‚úÖ Automatic HTTPS\n- ‚úÖ Built-in database hosting\n- ‚úÖ Zero DevOps knowledge needed\n\n### Deploy Ktor to Heroku\n\n**1. Create Procfile**:\n\n**2. Update build.gradle.kts**:\n\n**3. Create app.json** (optional):\n\n**4. Deploy**:\n\n**5. Configure port** (Heroku provides PORT env var):\n\n**Your app is live at**: `https://my-ktor-app.herokuapp.com`\n\n---\n\n",
              "code": "// Application.kt\nfun main() {\n    val port = System.getenv(\"PORT\")?.toInt() ?: 8080\n    embeddedServer(Netty, port = port, host = \"0.0.0.0\") {\n        module()\n    }.start(wait = true)\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "AWS Deployment",
              "content": "\n### Option 1: AWS Elastic Beanstalk (Easiest AWS)\n\n**1. Install AWS CLI**:\n\n**2. Install Elastic Beanstalk CLI**:\n\n**3. Initialize EB**:\n\n**4. Create Dockerfile** (if not exists):\n\n**5. Create .ebextensions/options.config**:\n\n**6. Deploy**:\n\n### Option 2: AWS ECS (Container Service)\n\n**1. Create ECR repository**:\n\n**2. Build and push Docker image**:\n\n**3. Create task definition** (task-definition.json):\n\n**4. Create ECS service**:\n\n---\n\n",
              "code": "# Create cluster\naws ecs create-cluster --cluster-name my-app-cluster\n\n# Register task definition\naws ecs register-task-definition --cli-input-json file://task-definition.json\n\n# Create service\naws ecs create-service \\\n  --cluster my-app-cluster \\\n  --service-name my-app-service \\\n  --task-definition my-app \\\n  --desired-count 2 \\\n  --launch-type FARGATE",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Google Cloud Deployment",
              "content": "\n### Option 1: Cloud Run (Easiest GCP)\n\n**1. Install gcloud CLI**:\n\n**2. Build and deploy**:\n\n**Your app is live at**: `https://my-app-HASH-uc.a.run.app`\n\n### Option 2: Google Kubernetes Engine (GKE)\n\n**1. Create Kubernetes cluster**:\n\n**2. Build and push image**:\n\n**3. Create deployment.yaml**:\n\n**4. Deploy to Kubernetes**:\n\n---\n\n",
              "code": "# Apply deployment\nkubectl apply -f deployment.yaml\n\n# Get external IP\nkubectl get service my-app-service\n\n# Scale deployment\nkubectl scale deployment my-app --replicas=5\n\n# Update image\nkubectl set image deployment/my-app my-app=gcr.io/YOUR_PROJECT_ID/my-app:v2",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Database Hosting",
              "content": "\n### PostgreSQL on Heroku\n\n\n**Connect from Ktor**:\n\n### Amazon RDS\n\n**1. Create PostgreSQL instance**:\n\n**2. Connect from application**:\n\n### Google Cloud SQL\n\n**1. Create instance**:\n\n**2. Create database**:\n\n**3. Connect from Cloud Run**:\n\n---\n\n",
              "code": "gcloud run deploy my-app \\\n  --add-cloudsql-instances=PROJECT_ID:REGION:my-app-db \\\n  --set-env-vars INSTANCE_CONNECTION_NAME=PROJECT_ID:REGION:my-app-db",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "SSL/TLS Certificates",
              "content": "\n### Heroku (Automatic)\n\nHeroku provides HTTPS automatically!\n\n### AWS Certificate Manager\n\n**1. Request certificate**:\n\n**2. Validate domain** (add DNS records provided by AWS)\n\n**3. Attach to Load Balancer**:\n\n### Let's Encrypt with Certbot\n\n**For self-hosted servers**:\n\n**Configure Ktor for HTTPS**:\n\n---\n\n",
              "code": "fun main() {\n    val keyStoreFile = File(\"/etc/letsencrypt/live/myapp.com/keystore.jks\")\n    val keyStore = KeyStore.getInstance(keyStoreFile, \"password\".toCharArray())\n\n    embeddedServer(Netty, environment = applicationEngineEnvironment {\n        connector {\n            port = 80\n        }\n        sslConnector(\n            keyStore = keyStore,\n            keyAlias = \"myapp\",\n            keyStorePassword = { \"password\".toCharArray() },\n            privateKeyPassword = { \"password\".toCharArray() }\n        ) {\n            port = 443\n            keyStorePath = keyStoreFile\n        }\n        module {\n            module()\n        }\n    }).start(wait = true)\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Environment Configuration",
              "content": "\n### application.conf\n\n\n### Secrets Management\n\n**AWS Secrets Manager**:\n\n**Google Secret Manager**:\n\n---\n\n",
              "code": "import com.google.cloud.secretmanager.v1.SecretManagerServiceClient\n\nfun getSecret(projectId: String, secretId: String): String {\n    SecretManagerServiceClient.create().use { client ->\n        val name = \"projects/$projectId/secrets/$secretId/versions/latest\"\n        val response = client.accessSecretVersion(name)\n        return response.payload.data.toStringUtf8()\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Load Balancing and Scaling",
              "content": "\n### Horizontal Scaling\n\n**AWS Auto Scaling**:\n\n**Google Cloud Run** (automatic):\n\n### Vertical Scaling\n\n**Change instance size**:\n\n---\n\n",
              "code": "# AWS\naws ec2 modify-instance-attribute \\\n  --instance-id i-xxxxx \\\n  --instance-type t3.large\n\n# GCP\ngcloud compute instances set-machine-type INSTANCE_NAME \\\n  --machine-type n1-standard-2",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Exercise 1: Deploy to Heroku",
              "content": "\nDeploy a Ktor backend to Heroku with PostgreSQL.\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 1",
              "content": "\n**1. Project setup**:\n\n**Procfile**:\n\n**build.gradle.kts**:\n\n**src/main/kotlin/com/example/Application.kt**:\n\n**2. Deploy**:\n\n**3. Verify deployment**:\n\n---\n\n",
              "code": "curl https://my-ktor-app.herokuapp.com/\n# Output: Hello from Heroku!\n\ncurl https://my-ktor-app.herokuapp.com/health\n# Output: OK",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Exercise 2: Deploy to AWS with Docker",
              "content": "\nDeploy a containerized Ktor app to AWS ECS.\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 2",
              "content": "\n**1. Create Dockerfile**:\n\n**2. Push to ECR**:\n\n**3. Create ECS task definition**:\n\n**4. Deploy to ECS**:\n\n---\n\n",
              "code": "# Create cluster\naws ecs create-cluster --cluster-name my-app-cluster\n\n# Register task definition\naws ecs register-task-definition --cli-input-json file://task-definition.json\n\n# Create service with load balancer\naws ecs create-service \\\n  --cluster my-app-cluster \\\n  --service-name my-ktor-service \\\n  --task-definition my-ktor-app \\\n  --desired-count 2 \\\n  --launch-type FARGATE \\\n  --network-configuration \"awsvpcConfiguration={subnets=[subnet-xxxxx],securityGroups=[sg-xxxxx],assignPublicIp=ENABLED}\" \\\n  --load-balancers \"targetGroupArn=arn:aws:elasticloadbalancing:...,containerName=my-ktor-app,containerPort=8080\"",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Exercise 3: Set Up Auto-Scaling",
              "content": "\nConfigure auto-scaling for your cloud deployment.\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 3",
              "content": "\n**Heroku**:\n\n**AWS ECS**:\n\n**scaling-policy.json**:\n\n**Google Cloud Run** (automatic!):\n\n---\n\n",
              "code": "gcloud run deploy my-app \\\n  --min-instances 2 \\\n  --max-instances 10 \\\n  --cpu-throttling \\\n  --concurrency 100",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n### Production Reality\n\n**Without Cloud Deployment**:\n- Apps run on your laptop\n- Users can't access\n- No scalability\n- No reliability\n\n**With Cloud Deployment**:\n- Accessible worldwide 24/7\n- Auto-scales to handle traffic\n- 99.9% uptime guarantee\n- Professional infrastructure\n\n### Cost Comparison\n\n**Small App (10K users)**:\n- Heroku: $7-25/month\n- AWS: $10-30/month\n- GCP: $10-30/month\n\n**Medium App (100K users)**:\n- Heroku: $50-200/month\n- AWS: $50-150/month (more optimized)\n- GCP: $50-150/month\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Checkpoint Quiz",
              "content": "\n### Question 1\nWhich cloud platform is easiest for beginners?\n\nA) AWS\nB) Google Cloud\nC) Heroku\nD) Azure\n\n### Question 2\nWhat protocol should production APIs use?\n\nA) HTTP\nB) HTTPS\nC) FTP\nD) Either HTTP or HTTPS\n\n### Question 3\nWhat is horizontal scaling?\n\nA) Adding more CPU to one server\nB) Adding more servers\nC) Upgrading RAM\nD) Buying faster disks\n\n### Question 4\nWhy use environment variables for secrets?\n\nA) Faster performance\nB) Keep secrets out of code\nC) Reduce file size\nD) Better formatting\n\n### Question 5\nWhat does a load balancer do?\n\nA) Compiles code faster\nB) Distributes traffic across multiple servers\nC) Stores database backups\nD) Monitors server health\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Answers",
              "content": "\n**Question 1: C) Heroku**\n\nHeroku is designed for simplicity:\n- Deploy with `git push heroku main`\n- Automatic HTTPS\n- Built-in database\n- No server management\n\nAWS/GCP are more powerful but complex.\n\n---\n\n**Question 2: B) HTTPS**\n\nHTTPS is mandatory for production:\n- Encrypts data in transit\n- Prevents man-in-the-middle attacks\n- Required by browsers\n- Improves SEO\n\nHTTP is only for local development.\n\n---\n\n**Question 3: B) Adding more servers**\n\nScaling types:\n- **Horizontal**: Add more servers (better)\n- **Vertical**: Bigger server (limited)\n\nHorizontal scaling = unlimited capacity\n\n---\n\n**Question 4: B) Keep secrets out of code**\n\nEnvironment variables:\n- Don't commit secrets to Git\n- Different values per environment\n- Easy to rotate\n- More secure\n\nNever hardcode secrets!\n\n---\n\n**Question 5: B) Distributes traffic across multiple servers**\n\nLoad balancers:\n- Distribute requests evenly\n- Health check servers\n- Remove failed servers\n- Enable horizontal scaling\n\nEssential for high availability.\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "What You've Learned",
              "content": "\n‚úÖ Deploying Ktor apps to Heroku (easiest)\n‚úÖ Deploying to AWS (Elastic Beanstalk, ECS)\n‚úÖ Deploying to Google Cloud (Cloud Run, GKE)\n‚úÖ Database hosting (PostgreSQL on cloud platforms)\n‚úÖ SSL/TLS certificates for HTTPS\n‚úÖ Environment configuration and secrets management\n‚úÖ Load balancing and auto-scaling\n‚úÖ Cost optimization strategies\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Next Steps",
              "content": "\nIn **Lesson 7.7: Monitoring and Analytics**, you'll learn:\n- Application logging strategies\n- Error tracking (Sentry, Firebase Crashlytics)\n- Analytics (Firebase Analytics, Mixpanel)\n- Performance monitoring\n- APM tools\n- User feedback integration\n\nYour app is deployed - now let's monitor it!\n\n---\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "7.7",
          "title": "Lesson 7.7: Monitoring and Analytics",
          "moduleId": "module-07",
          "order": 7,
          "estimatedMinutes": 75,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 75 minutes\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "\nDeploying your app is just the beginning. The real question is: **How is it performing in production?**\n\nWithout monitoring, you're flying blind:\n- ‚ùå Users experience crashes, you don't know\n- ‚ùå APIs are slow, no alerts\n- ‚ùå Features are unused, wasted effort\n- ‚ùå Servers are down, customers leave\n\nIn this lesson, you'll master production monitoring:\n- ‚úÖ Application logging strategies\n- ‚úÖ Error tracking (Sentry, Firebase Crashlytics)\n- ‚úÖ Analytics (Firebase Analytics, Mixpanel)\n- ‚úÖ Performance monitoring (APM)\n- ‚úÖ Alerting and incident response\n- ‚úÖ User feedback integration\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Why Monitoring Matters",
              "content": "\n### The Cost of Ignorance\n\n**Real Examples**:\n\n**Case 1: Silent Failures**\n- E-commerce site payment API failing\n- 20% of checkout attempts fail\n- Company loses $50K before noticing\n- Customers blame themselves, leave negative reviews\n\n**Case 2: Performance Degradation**\n- App becomes 5x slower over 2 weeks\n- Users complain on social media\n- No internal alerts\n- 30% user churn before fix\n\n**Case 3: Feature Waste**\n- Team builds complex search feature\n- 6 weeks of development\n- Analytics show 0.1% adoption\n- Could have built something users wanted\n\n### The Power of Data\n\n**With Proper Monitoring**:\n- Detect issues in seconds, not days\n- Fix bugs before users complain\n- Build features users actually use\n- Make data-driven decisions\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Application Logging",
              "content": "\n### Logging Levels\n\n\n**When to Use Each Level**:\n- **ERROR**: Exceptions, failures, critical issues\n- **WARN**: Potential problems, validation failures\n- **INFO**: Important business events (user signup, purchase)\n- **DEBUG**: Detailed execution flow (development only)\n- **TRACE**: Very detailed (rarely used)\n\n### Structured Logging\n\n‚ùå **Bad** (String concatenation):\n\n‚úÖ **Good** (Structured):\n\n### Logback Configuration\n\n**src/main/resources/logback.xml**:\n\n---\n\n",
              "code": "<configuration>\n    <appender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\">\n        <encoder class=\"net.logstash.logback.encoder.LogstashEncoder\">\n            <includeCallerData>true</includeCallerData>\n        </encoder>\n    </appender>\n\n    <appender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n        <file>logs/application.log</file>\n        <rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\">\n            <fileNamePattern>logs/application-%d{yyyy-MM-dd}.log</fileNamePattern>\n            <maxHistory>30</maxHistory>\n        </rollingPolicy>\n        <encoder class=\"net.logstash.logback.encoder.LogstashEncoder\"/>\n    </appender>\n\n    <!-- Application logs -->\n    <logger name=\"com.example\" level=\"INFO\"/>\n\n    <!-- Third-party logs (less verbose) -->\n    <logger name=\"org.jetbrains.exposed\" level=\"WARN\"/>\n    <logger name=\"io.ktor\" level=\"INFO\"/>\n\n    <root level=\"INFO\">\n        <appender-ref ref=\"CONSOLE\"/>\n        <appender-ref ref=\"FILE\"/>\n    </root>\n</configuration>",
              "language": "xml"
            },
            {
              "type": "EXPERIMENT",
              "title": "Error Tracking with Sentry",
              "content": "\n### Why Sentry?\n\n- ‚úÖ Captures all exceptions automatically\n- ‚úÖ Groups similar errors together\n- ‚úÖ Shows stack traces with context\n- ‚úÖ Email/Slack alerts on new errors\n- ‚úÖ Tracks error frequency and trends\n\n### Backend (Ktor) Integration\n\n\n**Initialize Sentry**:\n\n**Manual Error Capture**:\n\n### Android (Crashlytics) Integration\n\n\n**Initialize in Application**:\n\n**Log Custom Errors**:\n\n---\n\n",
              "code": "try {\n    processOrder(order)\n} catch (e: Exception) {\n    FirebaseCrashlytics.getInstance().apply {\n        log(\"Processing order: ${order.id}\")\n        setCustomKey(\"order_id\", order.id)\n        setCustomKey(\"order_total\", order.total)\n        recordException(e)\n    }\n    throw e\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Analytics",
              "content": "\n### Firebase Analytics (Android)\n\n**Track Events**:\n\n**User Properties**:\n\n### Mixpanel (Cross-Platform)\n\n\n**Initialize and Track**:\n\n### Backend Analytics\n\n**Custom Analytics Service**:\n\n---\n\n",
              "code": "import kotlinx.coroutines.launch\nimport kotlinx.coroutines.CoroutineScope\n\nclass AnalyticsService(\n    private val database: Database,\n    private val scope: CoroutineScope\n) {\n    suspend fun trackEvent(\n        userId: String?,\n        event: String,\n        properties: Map<String, Any> = emptyMap()\n    ) {\n        scope.launch {\n            try {\n                database.transaction {\n                    AnalyticsEvents.insert {\n                        it[AnalyticsEvents.userId] = userId\n                        it[AnalyticsEvents.event] = event\n                        it[AnalyticsEvents.properties] = Json.encodeToString(properties)\n                        it[AnalyticsEvents.timestamp] = System.currentTimeMillis()\n                        it[AnalyticsEvents.ipAddress] = getCurrentIpAddress()\n                        it[AnalyticsEvents.userAgent] = getCurrentUserAgent()\n                    }\n                }\n            } catch (e: Exception) {\n                logger.error(\"Failed to track event\", e)\n            }\n        }\n    }\n\n    suspend fun getDailyActiveUsers(days: Int = 30): List<DailyStats> {\n        return database.transaction {\n            AnalyticsEvents\n                .select { AnalyticsEvents.timestamp greaterEq (System.currentTimeMillis() - days * 24 * 3600000) }\n                .groupBy { it[AnalyticsEvents.timestamp] / (24 * 3600000) }\n                .map { (day, events) ->\n                    DailyStats(\n                        date = Date(day * 24 * 3600000),\n                        activeUsers = events.map { it[AnalyticsEvents.userId] }.toSet().size,\n                        eventCount = events.size\n                    )\n                }\n        }\n    }\n\n    suspend fun getPopularFeatures(limit: Int = 10): List<FeatureStats> {\n        return database.transaction {\n            AnalyticsEvents\n                .select { AnalyticsEvents.event eq \"feature_used\" }\n                .groupBy { Json.decodeFromString<Map<String, String>>(it[AnalyticsEvents.properties])[\"feature_name\"] }\n                .map { (feature, events) ->\n                    FeatureStats(\n                        feature = feature ?: \"unknown\",\n                        usageCount = events.size,\n                        uniqueUsers = events.map { it[AnalyticsEvents.userId] }.toSet().size\n                    )\n                }\n                .sortedByDescending { it.usageCount }\n                .take(limit)\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Performance Monitoring (APM)",
              "content": "\n### New Relic Integration\n\n\n**newrelic.yml**:\n\n**Custom Metrics**:\n\n### Custom Performance Tracking\n\n\n---\n\n",
              "code": "class PerformanceMonitor {\n    private val metrics = ConcurrentHashMap<String, MutableList<Long>>()\n\n    fun track(operation: String, block: () -> Unit) {\n        val start = System.nanoTime()\n        try {\n            block()\n        } finally {\n            val duration = (System.nanoTime() - start) / 1_000_000 // ms\n            metrics.getOrPut(operation) { mutableListOf() }.add(duration)\n        }\n    }\n\n    suspend fun <T> trackSuspend(operation: String, block: suspend () -> T): T {\n        val start = System.nanoTime()\n        try {\n            return block()\n        } finally {\n            val duration = (System.nanoTime() - start) / 1_000_000\n            metrics.getOrPut(operation) { mutableListOf() }.add(duration)\n        }\n    }\n\n    fun getStats(operation: String): PerformanceStats? {\n        val durations = metrics[operation] ?: return null\n\n        return PerformanceStats(\n            operation = operation,\n            count = durations.size,\n            avgMs = durations.average(),\n            minMs = durations.minOrNull() ?: 0,\n            maxMs = durations.maxOrNull() ?: 0,\n            p95Ms = durations.sorted()[durations.size * 95 / 100],\n            p99Ms = durations.sorted()[durations.size * 99 / 100]\n        )\n    }\n\n    fun getAllStats(): Map<String, PerformanceStats> {\n        return metrics.keys.associateWith { getStats(it)!! }\n    }\n}\n\n// Usage\nval monitor = PerformanceMonitor()\n\nmonitor.track(\"database_query\") {\n    userRepository.findAll()\n}\n\nval user = monitor.trackSuspend(\"api_call\") {\n    apiClient.getUser(userId)\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Alerting",
              "content": "\n### Alert Configuration (Example: PagerDuty)\n\n\n### Health Check Endpoint\n\n\n---\n\n",
              "code": "fun Route.healthCheck(\n    database: Database,\n    redis: RedisClient\n) {\n    get(\"/health\") {\n        val status = mutableMapOf<String, Any>()\n\n        // Check database\n        val dbHealthy = try {\n            database.transaction {\n                exec(\"SELECT 1\") { }\n                true\n            }\n        } catch (e: Exception) {\n            status[\"database_error\"] = e.message ?: \"Unknown\"\n            false\n        }\n\n        // Check Redis\n        val redisHealthy = try {\n            redis.ping()\n            true\n        } catch (e: Exception) {\n            status[\"redis_error\"] = e.message ?: \"Unknown\"\n            false\n        }\n\n        status[\"database\"] = if (dbHealthy) \"healthy\" else \"unhealthy\"\n        status[\"redis\"] = if (redisHealthy) \"healthy\" else \"unhealthy\"\n        status[\"status\"] = if (dbHealthy && redisHealthy) \"healthy\" else \"unhealthy\"\n        status[\"timestamp\"] = System.currentTimeMillis()\n\n        val statusCode = if (dbHealthy && redisHealthy) {\n            HttpStatusCode.OK\n        } else {\n            HttpStatusCode.ServiceUnavailable\n        }\n\n        call.respond(statusCode, status)\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 1: Implement Complete Logging",
              "content": "\nAdd structured logging to a service with proper levels.\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 1",
              "content": "\n\n---\n\n",
              "code": "import org.slf4j.LoggerFactory\nimport net.logstash.logback.argument.StructuredArguments.*\n\nclass OrderService(\n    private val orderRepository: OrderRepository,\n    private val paymentService: PaymentService,\n    private val inventoryService: InventoryService\n) {\n    private val logger = LoggerFactory.getLogger(OrderService::class.java)\n\n    suspend fun createOrder(userId: String, items: List<OrderItem>): Order {\n        logger.info(\n            \"Creating order\",\n            keyValue(\"userId\", userId),\n            keyValue(\"itemCount\", items.size)\n        )\n\n        // Validate inventory\n        logger.debug(\"Checking inventory for ${items.size} items\")\n\n        items.forEach { item ->\n            val available = inventoryService.checkStock(item.productId, item.quantity)\n            if (!available) {\n                logger.warn(\n                    \"Insufficient inventory\",\n                    keyValue(\"productId\", item.productId),\n                    keyValue(\"requested\", item.quantity)\n                )\n                throw InsufficientInventoryException(item.productId)\n            }\n        }\n\n        // Calculate total\n        val total = items.sumOf { it.price * it.quantity }\n        logger.debug(\"Order total calculated: $$total\")\n\n        // Create order\n        val order = try {\n            orderRepository.create(\n                userId = userId,\n                items = items,\n                total = total,\n                status = OrderStatus.PENDING\n            )\n        } catch (e: SQLException) {\n            logger.error(\n                \"Database error creating order\",\n                e,\n                keyValue(\"userId\", userId)\n            )\n            throw e\n        }\n\n        logger.info(\n            \"Order created\",\n            keyValue(\"orderId\", order.id),\n            keyValue(\"total\", total),\n            keyValue(\"status\", order.status)\n        )\n\n        // Process payment\n        try {\n            logger.info(\"Processing payment for order ${order.id}\")\n            paymentService.charge(userId, total, order.id)\n\n            orderRepository.updateStatus(order.id, OrderStatus.PAID)\n\n            logger.info(\n                \"Payment successful\",\n                keyValue(\"orderId\", order.id),\n                keyValue(\"amount\", total)\n            )\n        } catch (e: PaymentException) {\n            logger.error(\n                \"Payment failed\",\n                e,\n                keyValue(\"orderId\", order.id),\n                keyValue(\"userId\", userId),\n                keyValue(\"amount\", total),\n                keyValue(\"errorCode\", e.errorCode)\n            )\n\n            orderRepository.updateStatus(order.id, OrderStatus.PAYMENT_FAILED)\n            throw e\n        }\n\n        // Reserve inventory\n        try {\n            items.forEach { item ->\n                inventoryService.reserve(item.productId, item.quantity, order.id)\n            }\n\n            logger.info(\n                \"Inventory reserved\",\n                keyValue(\"orderId\", order.id)\n            )\n        } catch (e: Exception) {\n            logger.error(\n                \"Inventory reservation failed\",\n                e,\n                keyValue(\"orderId\", order.id)\n            )\n            // Rollback payment\n            paymentService.refund(order.id)\n            throw e\n        }\n\n        logger.info(\n            \"Order processed successfully\",\n            keyValue(\"orderId\", order.id),\n            keyValue(\"userId\", userId),\n            keyValue(\"total\", total),\n            keyValue(\"itemCount\", items.size)\n        )\n\n        return order\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 2: Set Up Error Tracking",
              "content": "\nIntegrate Sentry with custom context.\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 2",
              "content": "\n\n---\n\n",
              "code": "import io.sentry.Sentry\nimport io.sentry.SentryEvent\nimport io.sentry.SentryLevel\nimport io.sentry.protocol.User\n\nobject SentryManager {\n    fun init(dsn: String, environment: String) {\n        Sentry.init { options ->\n            options.dsn = dsn\n            options.environment = environment\n            options.release = System.getenv(\"VERSION\") ?: \"dev\"\n            options.tracesSampleRate = 1.0\n\n            options.setBeforeSend { event, hint ->\n                // Add custom tags to all events\n                event.setTag(\"server_region\", System.getenv(\"REGION\") ?: \"us-east-1\")\n                event.setTag(\"deployment\", System.getenv(\"DEPLOYMENT_ID\") ?: \"local\")\n                event\n            }\n        }\n    }\n\n    fun captureException(\n        exception: Throwable,\n        userId: String? = null,\n        extras: Map<String, Any> = emptyMap(),\n        tags: Map<String, String> = emptyMap()\n    ) {\n        Sentry.captureException(exception) { scope ->\n            // Set user\n            userId?.let {\n                scope.user = User().apply {\n                    id = it\n                }\n            }\n\n            // Add extras\n            extras.forEach { (key, value) ->\n                scope.setExtra(key, value)\n            }\n\n            // Add tags\n            tags.forEach { (key, value) ->\n                scope.setTag(key, value)\n            }\n\n            // Add breadcrumbs\n            scope.addBreadcrumb(\"Exception captured: ${exception.message}\")\n        }\n    }\n\n    fun captureMessage(\n        message: String,\n        level: SentryLevel = SentryLevel.INFO,\n        extras: Map<String, Any> = emptyMap()\n    ) {\n        Sentry.captureMessage(message, level) { scope ->\n            extras.forEach { (key, value) ->\n                scope.setExtra(key, value)\n            }\n        }\n    }\n\n    fun addBreadcrumb(message: String, category: String = \"default\") {\n        Sentry.addBreadcrumb(message, category)\n    }\n}\n\n// Usage in service\nclass PaymentService {\n    fun processPayment(orderId: String, amount: Double): PaymentResult {\n        SentryManager.addBreadcrumb(\"Starting payment processing\", \"payment\")\n\n        try {\n            val result = stripeClient.charge(amount)\n\n            SentryManager.addBreadcrumb(\"Payment successful\", \"payment\")\n\n            return result\n        } catch (e: StripeException) {\n            SentryManager.captureException(\n                exception = e,\n                extras = mapOf(\n                    \"order_id\" to orderId,\n                    \"amount\" to amount,\n                    \"stripe_error_code\" to e.code\n                ),\n                tags = mapOf(\n                    \"payment_provider\" to \"stripe\",\n                    \"error_type\" to \"payment_failed\"\n                )\n            )\n            throw PaymentException(\"Payment failed\", e)\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Exercise 3: Create Analytics Dashboard",
              "content": "\nBuild a simple analytics dashboard showing key metrics.\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Solution 3",
              "content": "\n\n---\n\n",
              "code": "// API endpoints for analytics\nfun Route.analyticsRoutes(analyticsService: AnalyticsService) {\n    authenticate(\"jwt\") {\n        get(\"/api/analytics/daily-active-users\") {\n            val days = call.parameters[\"days\"]?.toIntOrNull() ?: 30\n            val stats = analyticsService.getDailyActiveUsers(days)\n            call.respond(stats)\n        }\n\n        get(\"/api/analytics/popular-features\") {\n            val limit = call.parameters[\"limit\"]?.toIntOrNull() ?: 10\n            val features = analyticsService.getPopularFeatures(limit)\n            call.respond(features)\n        }\n\n        get(\"/api/analytics/user-retention\") {\n            val cohortDate = call.parameters[\"cohort\"]\n                ?: throw BadRequestException(\"Cohort date required\")\n\n            val retention = analyticsService.getUserRetention(cohortDate)\n            call.respond(retention)\n        }\n\n        get(\"/api/analytics/conversion-funnel\") {\n            val funnel = analyticsService.getConversionFunnel()\n            call.respond(funnel)\n        }\n    }\n}\n\n// Analytics queries\nclass AnalyticsService(private val database: Database) {\n    suspend fun getConversionFunnel(): ConversionFunnel {\n        return database.transaction {\n            val signups = AnalyticsEvents\n                .select { AnalyticsEvents.event eq \"sign_up\" }\n                .count()\n\n            val productViews = AnalyticsEvents\n                .select { AnalyticsEvents.event eq \"view_product\" }\n                .groupBy { it[AnalyticsEvents.userId] }\n                .count()\n\n            val addedToCart = AnalyticsEvents\n                .select { AnalyticsEvents.event eq \"add_to_cart\" }\n                .groupBy { it[AnalyticsEvents.userId] }\n                .count()\n\n            val purchases = AnalyticsEvents\n                .select { AnalyticsEvents.event eq \"purchase\" }\n                .groupBy { it[AnalyticsEvents.userId] }\n                .count()\n\n            ConversionFunnel(\n                steps = listOf(\n                    FunnelStep(\"Sign Up\", signups, 100.0),\n                    FunnelStep(\"View Product\", productViews, (productViews.toDouble() / signups * 100)),\n                    FunnelStep(\"Add to Cart\", addedToCart, (addedToCart.toDouble() / signups * 100)),\n                    FunnelStep(\"Purchase\", purchases, (purchases.toDouble() / signups * 100))\n                ),\n                conversionRate = (purchases.toDouble() / signups * 100)\n            )\n        }\n    }\n\n    suspend fun getUserRetention(cohortDate: String): RetentionStats {\n        // Implementation for cohort analysis\n        // Returns percentage of users still active after N days\n        return database.transaction {\n            // Complex query...\n            RetentionStats(/*...*/)\n        }\n    }\n}\n\ndata class ConversionFunnel(\n    val steps: List<FunnelStep>,\n    val conversionRate: Double\n)\n\ndata class FunnelStep(\n    val name: String,\n    val count: Long,\n    val percentageOfTotal: Double\n)",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n### Real Impact\n\n**Error Tracking Saves Money**:\n- Sentry detected payment bug in 2 minutes\n- Fixed before 10 users affected\n- Prevented $10K in lost revenue\n\n**Analytics Drives Decisions**:\n- Data showed 80% of users never use advanced features\n- Simplified UI increased retention 25%\n- Focused development on high-impact features\n\n**Monitoring Prevents Outages**:\n- Alert on high error rate (> 1%)\n- Team notified in 30 seconds\n- Fixed before significant impact\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Checkpoint Quiz",
              "content": "\n### Question 1\nWhat logging level should you use for business events like \"User purchased product\"?\n\nA) DEBUG\nB) INFO\nC) WARN\nD) ERROR\n\n### Question 2\nWhat does Sentry do?\n\nA) Monitors server CPU usage\nB) Tracks and reports application errors\nC) Analyzes user behavior\nD) Optimizes database queries\n\n### Question 3\nWhy use structured logging (JSON) instead of plain text?\n\nA) Looks prettier\nB) Takes less disk space\nC) Easier to parse and analyze\nD) Required by law\n\n### Question 4\nWhat is an APM tool?\n\nA) Application Performance Monitoring\nB) Advanced Payment Method\nC) Automated Project Manager\nD) API Protocol Manager\n\n### Question 5\nWhat should a /health endpoint return when the database is down?\n\nA) 200 OK\nB) 404 Not Found\nC) 503 Service Unavailable\nD) 500 Internal Server Error\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Answers",
              "content": "\n**Question 1: B) INFO**\n\nLogging levels:\n- **ERROR**: Exceptions, failures\n- **WARN**: Potential issues\n- **INFO**: Important business events ‚úÖ\n- **DEBUG**: Detailed execution (dev only)\n\nBusiness events = INFO level\n\n---\n\n**Question 2: B) Tracks and reports application errors**\n\nSentry:\n- Captures all exceptions\n- Groups similar errors\n- Shows stack traces\n- Sends alerts\n- Tracks error trends\n\nEssential for production apps!\n\n---\n\n**Question 3: C) Easier to parse and analyze**\n\nJSON logs enable:\n- Searching by field\n- Aggregation and counting\n- Automated analysis\n- Integration with log tools\n\nText logs are hard to parse.\n\n---\n\n**Question 4: A) Application Performance Monitoring**\n\nAPM tools (New Relic, Datadog):\n- Track request times\n- Monitor database queries\n- Identify bottlenecks\n- Alert on slow performance\n\n---\n\n**Question 5: C) 503 Service Unavailable**\n\nHealth check status codes:\n- **200 OK**: All systems healthy\n- **503 Service Unavailable**: Critical dependency down ‚úÖ\n- **500**: Code error (not appropriate here)\n\nLoad balancers remove unhealthy instances.\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "What You've Learned",
              "content": "\n‚úÖ Structured logging strategies with logback\n‚úÖ Error tracking with Sentry and Firebase Crashlytics\n‚úÖ Analytics with Firebase Analytics and Mixpanel\n‚úÖ Performance monitoring (APM)\n‚úÖ Health checks and alerting\n‚úÖ Building analytics dashboards\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Next Steps",
              "content": "\nIn **Lesson 7.8: Final Capstone - Full Stack E-Commerce Platform**, you'll build:\n- Complete production-ready application\n- Backend: Ktor REST API + PostgreSQL\n- Android app with Jetpack Compose\n- Full features: products, cart, checkout, orders\n- Authentication, testing, CI/CD, deployment\n- Monitoring and analytics\n\nTime to put everything together! üöÄ\n\n---\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "7.8",
          "title": "Lesson 7.8: Final Capstone - Full Stack E-Commerce Platform",
          "moduleId": "module-07",
          "order": 8,
          "estimatedMinutes": 30,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Estimated Time**: 12-16 hours\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Congratulations! üéâ",
              "content": "\nYou've completed all 7 parts of the Kotlin Training Course! You've learned:\n- Part 1: Kotlin fundamentals\n- Part 2: Object-oriented programming\n- Part 3: Functional programming and coroutines\n- Part 4: Collections and advanced features\n- Part 5: Backend development with Ktor\n- Part 6: Android development with Jetpack Compose\n- Part 7: Advanced topics (KMP, testing, security, deployment)\n\nNow it's time to prove your mastery by building a **complete, production-ready, full-stack e-commerce platform**!\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Project Overview: ShopKotlin",
              "content": "\n**ShopKotlin** is a modern e-commerce platform with:\n\n### Backend (Ktor)\n- RESTful API\n- PostgreSQL database\n- JWT authentication\n- Product catalog management\n- Shopping cart\n- Order processing\n- Payment integration (Stripe)\n- Admin panel\n- Comprehensive testing\n- CI/CD pipeline\n- Cloud deployment\n- Monitoring and analytics\n\n### Android App (Jetpack Compose)\n- Beautiful Material Design 3 UI\n- Product browsing and search\n- Shopping cart\n- User authentication\n- Order tracking\n- Offline support\n- Push notifications\n- Analytics\n\n### Full Feature Set\n- ‚úÖ User registration and login\n- ‚úÖ Product catalog with categories\n- ‚úÖ Product search and filtering\n- ‚úÖ Shopping cart management\n- ‚úÖ Checkout with payment\n- ‚úÖ Order history\n- ‚úÖ Admin dashboard\n- ‚úÖ Inventory management\n- ‚úÖ Real-time order tracking\n- ‚úÖ Email notifications\n- ‚úÖ Analytics dashboard\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Architecture Overview",
              "content": "\n\n---\n\n",
              "code": "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ                      Client Applications                     ‚îÇ\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ   Android App            ‚îÇ   Web Admin Dashboard            ‚îÇ\n‚îÇ   (Jetpack Compose)      ‚îÇ   (React/Vue - Optional)         ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                           ‚îÇ\n                           ‚ñº\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ                     API Gateway / Load Balancer             ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                           ‚îÇ\n                           ‚ñº\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ                    Ktor Backend API                          ‚îÇ\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê            ‚îÇ\n‚îÇ  ‚îÇ   Auth     ‚îÇ  ‚îÇ  Products  ‚îÇ  ‚îÇ   Orders   ‚îÇ            ‚îÇ\n‚îÇ  ‚îÇ  Service   ‚îÇ  ‚îÇ  Service   ‚îÇ  ‚îÇ  Service   ‚îÇ            ‚îÇ\n‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò            ‚îÇ\n‚îÇ                                                              ‚îÇ\n‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê            ‚îÇ\n‚îÇ  ‚îÇ  Payment   ‚îÇ  ‚îÇ   Email    ‚îÇ  ‚îÇ Analytics  ‚îÇ            ‚îÇ\n‚îÇ  ‚îÇ  Service   ‚îÇ  ‚îÇ  Service   ‚îÇ  ‚îÇ  Service   ‚îÇ            ‚îÇ\n‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò            ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                           ‚îÇ\n                           ‚ñº\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ                      Data Layer                              ‚îÇ\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ   PostgreSQL     ‚îÇ      Redis       ‚îÇ     File Storage      ‚îÇ\n‚îÇ   (Primary DB)   ‚îÇ     (Cache)      ‚îÇ   (S3/CloudStorage)   ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Phase 1: Project Setup (1-2 hours)",
              "content": "\n### Backend Project Structure\n\n\n### build.gradle.kts (Backend)\n\n\n### Android Project Structure\n\n\n---\n\n",
              "code": "shopkotlin-android/\n‚îú‚îÄ‚îÄ app/\n‚îÇ   ‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main/\n‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ kotlin/com/shopkotlin/\n‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ MainActivity.kt\n‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ShopKotlinApp.kt\n‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ui/\n‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ screens/\n‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth/\n‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ home/\n‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ product/\n‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cart/\n‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ orders/\n‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/\n‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ theme/\n‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ data/\n‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api/\n‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ database/\n‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ repository/\n‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ models/\n‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ domain/\n‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ usecases/\n‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ di/\n‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ AndroidManifest.xml\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ test/\n‚îÇ   ‚îî‚îÄ‚îÄ build.gradle.kts\n‚îî‚îÄ‚îÄ build.gradle.kts",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Phase 2: Backend Development (4-6 hours)",
              "content": "\n### 2.1 Database Schema\n\n\n### 2.2 Models\n\n\n### 2.3 Core Services\n\n\n### 2.4 API Routes\n\n\n---\n\n",
              "code": "// src/main/kotlin/com/shopkotlin/routes/productRoutes.kt\npackage com.shopkotlin.routes\n\nimport com.shopkotlin.services.ProductService\nimport io.ktor.server.application.*\nimport io.ktor.server.response.*\nimport io.ktor.server.routing.*\nimport io.ktor.http.*\n\nfun Route.productRoutes(productService: ProductService) {\n    route(\"/api/products\") {\n        get {\n            val category = call.parameters[\"category\"]\n            val search = call.parameters[\"search\"]\n            val featured = call.parameters[\"featured\"]?.toBoolean()\n            val limit = call.parameters[\"limit\"]?.toIntOrNull() ?: 50\n            val offset = call.parameters[\"offset\"]?.toIntOrNull() ?: 0\n\n            val products = when {\n                search != null -> productService.search(search, limit, offset)\n                category != null -> productService.getByCategory(category, limit, offset)\n                featured == true -> productService.getFeatured(limit)\n                else -> productService.getAll(limit, offset)\n            }\n\n            call.respond(ApiResponse(success = true, data = products))\n        }\n\n        get(\"/{id}\") {\n            val id = call.parameters[\"id\"]\n                ?: return@get call.respond(\n                    HttpStatusCode.BadRequest,\n                    ApiResponse<Unit>(success = false, message = \"Product ID required\")\n                )\n\n            val product = productService.getById(id)\n                ?: return@get call.respond(\n                    HttpStatusCode.NotFound,\n                    ApiResponse<Unit>(success = false, message = \"Product not found\")\n                )\n\n            call.respond(ApiResponse(success = true, data = product))\n        }\n    }\n\n    route(\"/api/categories\") {\n        get {\n            val categories = productService.getAllCategories()\n            call.respond(ApiResponse(success = true, data = categories))\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Phase 3: Android App Development (4-6 hours)",
              "content": "\n### 3.1 API Client\n\n\n### 3.2 Product Screen\n\n\n### 3.3 Cart ViewModel\n\n\n---\n\n",
              "code": "// app/src/main/kotlin/com/shopkotlin/ui/screens/cart/CartViewModel.kt\npackage com.shopkotlin.ui.screens.cart\n\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport com.shopkotlin.data.repository.CartRepository\nimport com.shopkotlin.models.CartItem\nimport kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.launch\n\nclass CartViewModel(\n    private val cartRepository: CartRepository\n) : ViewModel() {\n\n    private val _cartItems = MutableStateFlow<List<CartItem>>(emptyList())\n    val cartItems: StateFlow<List<CartItem>> = _cartItems.asStateFlow()\n\n    val totalAmount: StateFlow<Double> = cartItems.map { items ->\n        items.sumOf { it.product.price * it.quantity }\n    }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), 0.0)\n\n    init {\n        loadCart()\n    }\n\n    private fun loadCart() {\n        viewModelScope.launch {\n            cartRepository.getCartItems().collect { items ->\n                _cartItems.value = items\n            }\n        }\n    }\n\n    fun updateQuantity(productId: String, quantity: Int) {\n        viewModelScope.launch {\n            if (quantity <= 0) {\n                cartRepository.removeFromCart(productId)\n            } else {\n                cartRepository.updateQuantity(productId, quantity)\n            }\n        }\n    }\n\n    fun removeItem(productId: String) {\n        viewModelScope.launch {\n            cartRepository.removeFromCart(productId)\n        }\n    }\n\n    fun clearCart() {\n        viewModelScope.launch {\n            cartRepository.clearCart()\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Phase 4: Testing (2-3 hours)",
              "content": "\n### Backend Tests\n\n\n### Android Tests\n\n\n---\n\n",
              "code": "// app/src/test/kotlin/com/shopkotlin/CartViewModelTest.kt\npackage com.shopkotlin\n\nimport app.cash.turbine.test\nimport com.shopkotlin.data.repository.CartRepository\nimport com.shopkotlin.models.*\nimport com.shopkotlin.ui.screens.cart.CartViewModel\nimport io.mockk.*\nimport kotlinx.coroutines.flow.flowOf\nimport kotlinx.coroutines.test.*\nimport org.junit.jupiter.api.Test\nimport kotlin.test.assertEquals\n\nclass CartViewModelTest {\n\n    private val cartRepository = mockk<CartRepository>()\n    private val viewModel = CartViewModel(cartRepository)\n\n    @Test\n    fun `cart items should be loaded on init`() = runTest {\n        // Arrange\n        val cartItems = listOf(\n            CartItem(product = mockk(), quantity = 2)\n        )\n\n        coEvery { cartRepository.getCartItems() } returns flowOf(cartItems)\n\n        // Act\n        viewModel.cartItems.test {\n            val items = awaitItem()\n\n            // Assert\n            assertEquals(cartItems, items)\n        }\n    }\n\n    @Test\n    fun `updateQuantity should call repository`() = runTest {\n        coEvery { cartRepository.updateQuantity(any(), any()) } just Runs\n\n        viewModel.updateQuantity(\"product1\", 5)\n\n        coVerify { cartRepository.updateQuantity(\"product1\", 5) }\n    }\n\n    @Test\n    fun `totalAmount should sum all items`() = runTest {\n        val product1 = mockk<Product> {\n            every { price } returns 10.0\n        }\n        val product2 = mockk<Product> {\n            every { price } returns 20.0\n        }\n\n        val cartItems = listOf(\n            CartItem(product1, 2), // 20.0\n            CartItem(product2, 3)  // 60.0\n        )\n\n        coEvery { cartRepository.getCartItems() } returns flowOf(cartItems)\n\n        viewModel.totalAmount.test {\n            val total = awaitItem()\n            assertEquals(80.0, total, 0.01)\n        }\n    }\n}",
              "language": "kotlin"
            },
            {
              "type": "THEORY",
              "title": "Phase 5: CI/CD Pipeline (1-2 hours)",
              "content": "\n### GitHub Actions Workflow\n\n\n---\n\n",
              "code": "# .github/workflows/ci-cd.yml\nname: ShopKotlin CI/CD\n\non:\n  push:\n    branches: [ main, develop ]\n  pull_request:\n    branches: [ main ]\n\nenv:\n  JAVA_VERSION: '17'\n\njobs:\n  backend-test:\n    name: Backend Tests\n    runs-on: ubuntu-latest\n\n    services:\n      postgres:\n        image: postgres:15\n        env:\n          POSTGRES_PASSWORD: testpass\n          POSTGRES_DB: shopkotlin_test\n        options: >-\n          --health-cmd pg_isready\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n        ports:\n          - 5432:5432\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up JDK\n        uses: actions/setup-java@v4\n        with:\n          java-version: ${{ env.JAVA_VERSION }}\n          distribution: 'temurin'\n\n      - name: Run backend tests\n        run: |\n          cd shopkotlin-backend\n          ./gradlew test\n\n      - name: Upload coverage\n        uses: codecov/codecov-action@v3\n        with:\n          files: shopkotlin-backend/build/reports/jacoco/test/jacocoTestReport.xml\n\n  backend-build:\n    name: Build Backend\n    needs: backend-test\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up JDK\n        uses: actions/setup-java@v4\n        with:\n          java-version: ${{ env.JAVA_VERSION }}\n          distribution: 'temurin'\n\n      - name: Build JAR\n        run: |\n          cd shopkotlin-backend\n          ./gradlew shadowJar\n\n      - name: Build Docker image\n        run: |\n          cd shopkotlin-backend\n          docker build -t shopkotlin-backend:latest .\n\n      - name: Push to registry (main only)\n        if: github.ref == 'refs/heads/main'\n        run: |\n          echo \"${{ secrets.DOCKER_PASSWORD }}\" | docker login -u \"${{ secrets.DOCKER_USERNAME }}\" --password-stdin\n          docker tag shopkotlin-backend:latest ${{ secrets.DOCKER_USERNAME }}/shopkotlin-backend:latest\n          docker push ${{ secrets.DOCKER_USERNAME }}/shopkotlin-backend:latest\n\n  android-test:\n    name: Android Tests\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up JDK\n        uses: actions/setup-java@v4\n        with:\n          java-version: ${{ env.JAVA_VERSION }}\n          distribution: 'temurin'\n\n      - name: Run unit tests\n        run: |\n          cd shopkotlin-android\n          ./gradlew test\n\n  android-build:\n    name: Build Android APK\n    needs: android-test\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up JDK\n        uses: actions/setup-java@v4\n        with:\n          java-version: ${{ env.JAVA_VERSION }}\n          distribution: 'temurin'\n\n      - name: Build debug APK\n        run: |\n          cd shopkotlin-android\n          ./gradlew assembleDebug\n\n      - name: Upload APK\n        uses: actions/upload-artifact@v4\n        with:\n          name: app-debug\n          path: shopkotlin-android/app/build/outputs/apk/debug/app-debug.apk\n\n  deploy:\n    name: Deploy to Production\n    needs: [backend-build, android-build]\n    if: github.ref == 'refs/heads/main'\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Deploy to Heroku\n        uses: akhileshns/heroku-deploy@v3.12.14\n        with:\n          heroku_api_key: ${{ secrets.HEROKU_API_KEY }}\n          heroku_app_name: \"shopkotlin-api\"\n          heroku_email: ${{ secrets.HEROKU_EMAIL }}\n          appdir: \"shopkotlin-backend\"",
              "language": "yaml"
            },
            {
              "type": "THEORY",
              "title": "Phase 6: Deployment (1-2 hours)",
              "content": "\n### Docker Setup\n\n**shopkotlin-backend/Dockerfile**:\n\n**docker-compose.yml**:\n\n---\n\n",
              "code": "version: '3.8'\n\nservices:\n  backend:\n    build: ./shopkotlin-backend\n    ports:\n      - \"8080:8080\"\n    environment:\n      - DB_HOST=db\n      - DB_PORT=5432\n      - DB_NAME=shopkotlin\n      - DB_USER=shopkotlin\n      - DB_PASSWORD=${DB_PASSWORD}\n      - JWT_SECRET=${JWT_SECRET}\n      - STRIPE_API_KEY=${STRIPE_API_KEY}\n    depends_on:\n      db:\n        condition: service_healthy\n\n  db:\n    image: postgres:15-alpine\n    environment:\n      - POSTGRES_DB=shopkotlin\n      - POSTGRES_USER=shopkotlin\n      - POSTGRES_PASSWORD=${DB_PASSWORD}\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n    healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready -U shopkotlin\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n\n  nginx:\n    image: nginx:alpine\n    ports:\n      - \"80:80\"\n      - \"443:443\"\n    volumes:\n      - ./nginx.conf:/etc/nginx/nginx.conf:ro\n      - ./ssl:/etc/nginx/ssl:ro\n    depends_on:\n      - backend\n\nvolumes:\n  postgres_data:",
              "language": "yaml"
            },
            {
              "type": "THEORY",
              "title": "Extension Challenges",
              "content": "\nOnce you've completed the core project, challenge yourself with these extensions:\n\n### 1. Advanced Features\n- ‚≠ê Product reviews and ratings\n- ‚≠ê Wishlist functionality\n- ‚≠ê Order tracking with real-time updates\n- ‚≠ê Coupon/discount codes\n- ‚≠ê Product recommendations (ML-based)\n- ‚≠ê Multi-currency support\n\n### 2. Mobile Enhancements\n- ‚≠ê Offline mode with Room database\n- ‚≠ê Push notifications for order updates\n- ‚≠ê Biometric authentication\n- ‚≠ê Dark mode\n- ‚≠ê Animations and transitions\n- ‚≠ê Widget for quick access\n\n### 3. Admin Features\n- ‚≠ê Admin dashboard (web or mobile)\n- ‚≠ê Inventory management\n- ‚≠ê Sales analytics\n- ‚≠ê User management\n- ‚≠ê Product CRUD operations\n\n### 4. Technical Improvements\n- ‚≠ê GraphQL instead of REST\n- ‚≠ê gRPC for mobile-backend communication\n- ‚≠ê Redis caching layer\n- ‚≠ê Elasticsearch for advanced search\n- ‚≠ê WebSockets for real-time features\n- ‚≠ê Rate limiting and DDoS protection\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Submission Checklist",
              "content": "\nBefore submitting, ensure you have:\n\n**Backend**:\n- [ ] All API endpoints working\n- [ ] JWT authentication implemented\n- [ ] PostgreSQL database setup\n- [ ] Stripe payment integration\n- [ ] Unit tests with 70%+ coverage\n- [ ] Integration tests for main flows\n- [ ] Docker container working\n- [ ] Deployed to cloud (Heroku/AWS/GCP)\n- [ ] Environment variables configured\n- [ ] Logging and error tracking (Sentry)\n\n**Android**:\n- [ ] All screens implemented\n- [ ] API integration complete\n- [ ] Authentication flow working\n- [ ] Cart and checkout functional\n- [ ] Order history displayed\n- [ ] Unit tests for ViewModels\n- [ ] UI tests for critical flows\n- [ ] APK built successfully\n- [ ] App runs on physical device\n\n**DevOps**:\n- [ ] CI/CD pipeline configured\n- [ ] Automated tests running\n- [ ] Docker images building\n- [ ] Deployment automated\n- [ ] Monitoring setup\n\n**Documentation**:\n- [ ] README with setup instructions\n- [ ] API documentation\n- [ ] Architecture diagrams\n- [ ] Environment setup guide\n- [ ] Deployment guide\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Final Thoughts",
              "content": "\nCongratulations on completing the Kotlin Training Course! üéâüéâüéâ\n\nYou've built a **production-ready, full-stack e-commerce platform** using:\n- Kotlin (backend and Android)\n- Ktor (REST API)\n- PostgreSQL (database)\n- Jetpack Compose (modern Android UI)\n- JWT authentication\n- Stripe payments\n- Docker (containerization)\n- GitHub Actions (CI/CD)\n- Cloud deployment\n\n### You've Mastered:\n‚úÖ Kotlin fundamentals and advanced features\n‚úÖ Backend development with Ktor\n‚úÖ Android development with Jetpack Compose\n‚úÖ Database design and optimization\n‚úÖ API design and security\n‚úÖ Testing strategies (unit, integration, UI)\n‚úÖ DevOps practices (CI/CD, Docker)\n‚úÖ Cloud deployment\n‚úÖ Performance optimization\n‚úÖ Security best practices\n‚úÖ Monitoring and analytics\n\n### What's Next?\n\n**1. Enhance Your Project**:\n- Add the extension challenges\n- Deploy to production\n- Get real users\n- Collect feedback\n\n**2. Build Your Portfolio**:\n- Showcase ShopKotlin on GitHub\n- Write blog posts about your learnings\n- Create a portfolio website\n- Share on LinkedIn\n\n**3. Continue Learning**:\n- Explore Kotlin Multiplatform in depth\n- Learn Compose Multiplatform (desktop, web)\n- Study microservices architecture\n- Master Kubernetes and cloud-native development\n\n**4. Join the Community**:\n- Contribute to open-source Kotlin projects\n- Join Kotlin Slack/Discord communities\n- Attend Kotlin conferences (KotlinConf)\n- Share your knowledge through teaching\n\n### You're Ready!\n\nYou now have the skills to:\n- Build production Android apps\n- Develop scalable backend APIs\n- Work at modern tech companies\n- Start your own projects\n- Mentor other developers\n\n**The journey doesn't end here - it's just beginning!**\n\nKeep coding, keep learning, and most importantly, keep building amazing things with Kotlin! üöÄ\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Resources",
              "content": "\n### Official Documentation\n- [Kotlin Official Docs](https://kotlinlang.org/docs/home.html)\n- [Ktor Documentation](https://ktor.io/docs/)\n- [Jetpack Compose](https://developer.android.com/jetpack/compose)\n- [Exposed ORM](https://github.com/JetBrains/Exposed/wiki)\n\n### Community\n- [Kotlin Slack](https://surveys.jetbrains.com/s3/kotlin-slack-sign-up)\n- [r/Kotlin](https://www.reddit.com/r/Kotlin/)\n- [Kotlin Blog](https://blog.jetbrains.com/kotlin/)\n- [Android Developers](https://developer.android.com/)\n\n### Books\n- \"Kotlin in Action\" by Dmitry Jemerov\n- \"Head First Kotlin\" by Dawn Griffiths\n- \"Effective Kotlin\" by Marcin Moskala\n\n### Courses\n- [Kotlin for Java Developers (Coursera)](https://www.coursera.org/learn/kotlin-for-java-developers)\n- [Android Basics with Compose](https://developer.android.com/courses/android-basics-compose/course)\n\n---\n\n**Thank you for completing this course! We believe in you! üí™**\n\n---\n\n"
            }
          ],
          "challenges": []
        }
      ],
      "quizzes": [
        {
          "id": "part7-quiz-7.1",
          "title": "Full-Stack Integration Quiz",
          "description": "Knowledge check for Full-Stack Integration Quiz",
          "moduleId": "module-07",
          "passingScore": 70,
          "estimatedMinutes": 20,
          "questions": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "7.1.q1",
              "title": "What is full-stack development?",
              "description": "What is full-stack development?",
              "options": [
                "Only frontend development",
                "Only backend development",
                "Development of both frontend and backend",
                "Database administration"
              ],
              "correctAnswer": 2,
              "explanation": "Full-stack development involves working on both the frontend (UI) and backend (server) parts of an application."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "7.1.q2",
              "title": "How do frontend and backend communicate?",
              "description": "How do frontend and backend communicate?",
              "options": [
                "Direct file access",
                "Through HTTP requests to APIs",
                "Email",
                "Database only"
              ],
              "correctAnswer": 1,
              "explanation": "Frontend communicates with backend through HTTP requests to API endpoints (REST, GraphQL, etc.)."
            },
            {
              "type": "TRUE_FALSE",
              "id": "7.1.q3",
              "title": "Authentication tokens should be stored securely on the frontend.",
              "description": "Authentication tokens should be stored securely on the frontend.",
              "question": "Authentication tokens should be stored securely on the frontend.",
              "correctAnswer": true,
              "explanation": "True. Store tokens securely (localStorage, sessionStorage, or httpOnly cookies) and transmit over HTTPS."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "7.1.q4",
              "title": "What is the purpose of the Authorization header?",
              "description": "What is the purpose of the Authorization header?",
              "options": [
                "To specify content type",
                "To send authentication credentials to the server",
                "To set cookies",
                "To compress data"
              ],
              "correctAnswer": 1,
              "explanation": "The Authorization header is used to send authentication tokens/credentials to the backend."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "7.1.q5",
              "title": "In a typical full-stack architecture, where should business logic primarily reside?",
              "description": "In a typical full-stack architecture, where should business logic primarily reside?",
              "options": [
                "Only in the frontend",
                "Only in the backend",
                "Backend (with validation on both sides)",
                "In the database"
              ],
              "correctAnswer": 2,
              "explanation": "Business logic should primarily be in the backend for security, with frontend validation for UX."
            },
            {
              "type": "TRUE_FALSE",
              "id": "7.1.q6",
              "title": "You should validate user input on both frontend and backend.",
              "description": "You should validate user input on both frontend and backend.",
              "question": "You should validate user input on both frontend and backend.",
              "correctAnswer": true,
              "explanation": "True. Frontend validation improves UX, but backend validation is essential for security."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "7.1.q7",
              "title": "What is a JWT token used for?",
              "description": "What is a JWT token used for?",
              "options": [
                "Styling",
                "Routing",
                "Stateless authentication",
                "Database queries"
              ],
              "correctAnswer": 2,
              "explanation": "JWT (JSON Web Token) is used for stateless authentication between client and server."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "7.1.q8",
              "title": "Which layer is responsible for data persistence?",
              "description": "Which layer is responsible for data persistence?",
              "options": [
                "Frontend",
                "Backend with database",
                "Browser cache",
                "CDN"
              ],
              "correctAnswer": 1,
              "explanation": "The backend with its database is responsible for persisting data permanently."
            },
            {
              "type": "TRUE_FALSE",
              "id": "7.1.q9",
              "title": "A well-designed API should be versioned (e.g., /api/v1/users).",
              "description": "A well-designed API should be versioned (e.g., /api/v1/users).",
              "question": "A well-designed API should be versioned (e.g., /api/v1/users).",
              "correctAnswer": true,
              "explanation": "True. API versioning allows you to make breaking changes without affecting existing clients."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "7.1.q10",
              "title": "What is the typical flow when a user logs in?",
              "description": "What is the typical flow when a user logs in?",
              "options": [
                "Frontend stores password -> calls backend",
                "User enters credentials -> backend validates -> returns token -> frontend stores token",
                "Backend generates random password",
                "Frontend directly accesses database"
              ],
              "correctAnswer": 1,
              "explanation": "Login flow: User enters credentials ‚Üí Backend validates ‚Üí Backend returns token ‚Üí Frontend stores token for future requests."
            }
          ]
        }
      ]
    }
  ],
  "metadata": {
    "version": "2.0.0",
    "lastUpdated": "2025-11-14",
    "author": "Code Tutor",
    "interactiveElements": {
      "totalLessons": 69,
      "totalChallenges": 45,
      "totalQuizzes": 26,
      "totalQuestions": 107
    }
  }
}