{
  "type": "FREE_CODING",
  "id": "lesson-11-04-challenge-01",
  "title": "Practice Challenge",
  "description": "Apply what you've learned in this interactive coding challenge.",
  "instructions": "Build a TODO API with Dependency Injection!\n\n1. Create 'TodoItem' class (Id, Title, IsCompleted)\n\n2. Create 'ITodoRepository' interface:\n   - List<TodoItem> GetAll()\n   - TodoItem? GetById(int id)\n   - void Add(TodoItem item)\n   - void Update(int id, TodoItem item)\n   - void Delete(int id)\n\n3. Create 'TodoRepository' class implementing ITodoRepository:\n   - Use in-memory List<TodoItem>\n   - Implement all methods\n\n4. Register with DI: builder.Services.AddSingleton<ITodoRepository, TodoRepository>()\n\n5. Create endpoints that inject ITodoRepository:\n   - GET /api/todos\n   - GET /api/todos/{id}\n   - POST /api/todos\n   - PUT /api/todos/{id}\n   - DELETE /api/todos/{id}\n\n6. Print \"DI-based Todo API Ready!\"",
  "language": "csharp",
  "testCases": [
    {
      "id": "test-1",
      "description": "Output should contain \"DI-based\"",
      "expectedOutput": "DI-based",
      "isVisible": true
    },
    {
      "id": "test-2",
      "description": "Output should contain \"Todo API\"",
      "expectedOutput": "Todo API",
      "isVisible": true
    },
    {
      "id": "test-3",
      "description": "Output should contain \"Ready\"",
      "expectedOutput": "Ready",
      "isVisible": true
    }
  ],
  "hints": [
    {
      "level": 1,
      "text": "Define interface with methods. Implement in class. Register: 'builder.Services.AddSingleton<IInterface, Implementation>()'. Inject: add as parameter '(IInterface service) => ...'."
    },
    {
      "level": 2,
      "text": "Registering after builder.Build(): Must register services BEFORE 'var app = builder.Build()'! After Build(), it's too late. Services go in 'builder.Services', not 'app'."
    },
    {
      "level": 3,
      "text": "Using implementation type in endpoints: Inject INTERFACE, not implementation! Use '(IRepository repo)' not '(Repository repo)'. Interface = flexibility!"
    },
    {
      "level": 4,
      "text": "Wrong lifetime choice: Singleton = one instance forever (careful with state!). Scoped = per request (good for DB contexts). Transient = every time (safe but overhead)."
    },
    {
      "level": 5,
      "text": "Forgetting to register: If you inject IService but didn't register it, you get runtime error: 'Unable to resolve service'. Must register in builder.Services first!"
    }
  ],
  "commonMistakes": [
    {
      "mistake": "Registering after builder.Build()",
      "consequence": "Must register services BEFORE 'var app = builder.Build()'! After Build(), it's too late. Services go in 'builder.Services', not 'app'.",
      "correction": "Review the correct syntax and best practices for this concept."
    },
    {
      "mistake": "Using implementation type in endpoints",
      "consequence": "Inject INTERFACE, not implementation! Use '(IRepository repo)' not '(Repository repo)'. Interface = flexibility!",
      "correction": "Review the correct syntax and best practices for this concept."
    },
    {
      "mistake": "Wrong lifetime choice",
      "consequence": "Singleton = one instance forever (careful with state!). Scoped = per request (good for DB contexts). Transient = every time (safe but overhead).",
      "correction": "Review the correct syntax and best practices for this concept."
    },
    {
      "mistake": "Forgetting to register",
      "consequence": "If you inject IService but didn't register it, you get runtime error: 'Unable to resolve service'. Must register in builder.Services first!",
      "correction": "Review the correct syntax and best practices for this concept."
    },
    {
      "mistake": "Captive Dependencies (CRITICAL!)",
      "consequence": "Injecting a Scoped service into a Singleton creates a 'captive dependency' - the Scoped service becomes effectively Singleton! Example: If DbContext (Scoped) is injected into a Singleton service, the SAME DbContext instance is reused across ALL requests, causing data corruption, stale data, and threading issues!",
      "correction": "Never inject Scoped services into Singletons! Either: (1) Make both Scoped, (2) Inject IServiceScopeFactory into Singleton and create scope manually, or (3) Use AddDbContextFactory instead of AddDbContext."
    }
  ],
  "difficulty": "advanced"
}