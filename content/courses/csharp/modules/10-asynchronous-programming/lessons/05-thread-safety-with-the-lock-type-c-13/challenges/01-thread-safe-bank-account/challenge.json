{
  "type": "FREE_CODING",
  "id": "lesson-10-05-challenge-01",
  "title": "Thread-Safe Bank Account",
  "description": "Build a thread-safe bank account using the C# 13 Lock type.",
  "instructions": "Create a thread-safe BankAccount class!\n\n1. Create 'BankAccount' class with:\n   - private decimal _balance field\n   - private readonly Lock _lock field (C# 13 Lock type)\n   - public decimal Balance property (thread-safe read)\n   - public void Deposit(decimal amount) method (thread-safe)\n   - public bool Withdraw(decimal amount) method (thread-safe, return false if insufficient funds)\n\n2. In main code:\n   - Create account with initial balance of 1000\n   - Start 10 tasks that each deposit 100 (total +1000)\n   - Start 10 tasks that each withdraw 50 (total -500)\n   - Wait for all tasks\n   - Print final balance (should be 1500)\n\nUse 'lock (_lock)' or '_lock.EnterScope()' to protect critical sections!",
  "language": "csharp",
  "testCases": [
    {
      "id": "test-1",
      "description": "Output should contain initial balance",
      "expectedOutput": "Initial balance",
      "isVisible": true
    },
    {
      "id": "test-2",
      "description": "Output should contain deposit operations",
      "expectedOutput": "Deposited",
      "isVisible": true
    },
    {
      "id": "test-3",
      "description": "Output should contain final balance",
      "expectedOutput": "Final balance",
      "isVisible": true
    },
    {
      "id": "test-4",
      "description": "Final balance should be 1500",
      "expectedOutput": "1500",
      "isVisible": true
    }
  ],
  "hints": [
    {
      "level": 1,
      "text": "Lock syntax: 'lock (_lock) { /* code */ }'. All reads AND writes to _balance must be inside lock blocks. The Lock type is in System.Threading namespace."
    },
    {
      "level": 2,
      "text": "EnterScope alternative: 'using (_lock.EnterScope()) { /* code */ }'. The lock is automatically released when the using block exits, even if exception occurs."
    },
    {
      "level": 3,
      "text": "Don't forget the Balance getter! Reading _balance outside a lock can return stale/torn values. ALWAYS protect shared mutable state, even for reads."
    },
    {
      "level": 4,
      "text": "Withdraw check-then-act: The balance check AND subtraction must be in the SAME lock block. If you check outside, another thread might withdraw between check and action!"
    }
  ],
  "commonMistakes": [
    {
      "mistake": "Not locking read operations",
      "consequence": "Reading shared state without lock can return stale or torn (partially updated) values! Always lock both reads AND writes to shared mutable state.",
      "correction": "Wrap the Balance getter in lock (_lock) { return _balance; }"
    },
    {
      "mistake": "Check-then-act outside single lock",
      "consequence": "If you check balance in one lock block and withdraw in another, the balance could change between check and action! This is a classic race condition.",
      "correction": "Put the entire check-and-withdraw logic in a single lock block: lock (_lock) { if (_balance >= amount) { _balance -= amount; } }"
    },
    {
      "mistake": "Using old object lock syntax in C# 13",
      "consequence": "While 'object _lock = new()' still works, it misses compiler optimizations and doesn't clearly communicate intent. The Lock type is purpose-built for synchronization.",
      "correction": "Use 'private readonly Lock _lock = new();' in C# 13+ for cleaner code and better performance."
    },
    {
      "mistake": "Locking on 'this' or public objects",
      "consequence": "External code could lock on the same object, causing deadlocks! Never lock on 'this', typeof(Type), or public fields. Always use private lock objects.",
      "correction": "Always use: 'private readonly Lock _lock = new();' - private and readonly ensures only your code can use it."
    }
  ],
  "difficulty": "intermediate",
  "roslynCompatibility": "c#12-fallback"
}