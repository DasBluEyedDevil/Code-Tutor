{
  "type": "FREE_CODING",
  "id": "lesson-15-02-challenge-01",
  "title": "Practice Challenge",
  "description": "Apply what you've learned in this interactive coding challenge.",
  "instructions": "Create tests with mocks for an OrderService!\n\n1. Define interfaces:\n   - IInventoryService: bool CheckStock(string productId, int quantity)\n   - IPaymentService: bool ProcessPayment(decimal amount)\n\n2. Create OrderService class:\n   - Constructor takes IInventoryService and IPaymentService\n   - Method: PlaceOrder(string productId, int quantity, decimal price)\n   - Returns true if stock available AND payment succeeds\n   - Returns false if no stock OR payment fails\n\n3. Write tests using Moq:\n   - Test successful order (stock OK, payment OK)\n   - Test failed order (no stock)\n   - Test failed order (payment fails)\n   - Verify each service was called correctly\n\nUse Setup(), Returns(), Verify()!",
  "language": "csharp",
  "testCases": [
    {
      "id": "test-1",
      "description": "Output should contain test definitions",
      "expectedOutput": "OrderService",
      "isVisible": true
    },
    {
      "id": "test-2",
      "description": "Output should mention mocks",
      "expectedOutput": "mock",
      "isVisible": true
    }
  ],
  "hints": [
    {
      "level": 1,
      "text": "Create mock: 'var mock = new Mock<IInterface>()'. Get instance: 'mock.Object'."
    },
    {
      "level": 2,
      "text": "Setup returns: 'mock.Setup(x => x.Method(args)).Returns(value)'. Use It.IsAny<T>() for any argument."
    },
    {
      "level": 3,
      "text": "Verify calls: 'mock.Verify(x => x.Method(args), Times.Once)'. Use Times.Never to verify NOT called."
    },
    {
      "level": 4,
      "text": "Test failure paths too! When stock fails, payment should NOT be called (Times.Never)."
    },
    {
      "level": 5,
      "text": "It.Is<T>(predicate) for conditional matching: 'It.Is<decimal>(x => x > 0)' matches positive decimals."
    }
  ],
  "commonMistakes": [
    {
      "mistake": "Forgetting mock.Object",
      "consequence": "Passing 'mock' instead of 'mock.Object' to constructor! Mock<T> is the wrapper, .Object is the actual instance that implements T.",
      "correction": "Always use mock.Object when injecting: 'new Service(mock.Object)' not 'new Service(mock)'."
    },
    {
      "mistake": "Over-mocking",
      "consequence": "Mocking everything including simple classes! Mocks add complexity. Only mock: external services, I/O, slow operations, things with side effects.",
      "correction": "Don't mock simple value objects or classes with no dependencies. Only mock interfaces/abstractions for external concerns."
    },
    {
      "mistake": "Setup without matching arguments",
      "consequence": "Setup(x => x.Method(5)).Returns(true) but calling Method(10)! The mock returns default (false), test fails mysteriously.",
      "correction": "Ensure Setup arguments match what code actually passes. Use It.IsAny<T>() when argument doesn't matter."
    },
    {
      "mistake": "Not verifying important calls",
      "consequence": "Test passes but critical method was never called! Setup returns values but Verify confirms calls actually happened.",
      "correction": "Use Verify() for important side effects: 'mockRepo.Verify(r => r.Save(user), Times.Once)'. Especially for void methods!"
    }
  ],
  "difficulty": "advanced"
}