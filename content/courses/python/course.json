{
  "id": "python",
  "language": "python",
  "title": "Python Full-Stack Development",
  "description": "Master Python from fundamentals to full-stack development with 80+ interactive lessons, coding challenges, and quizzes.",
  "difficulty": "beginner",
  "estimatedHours": 26,
  "prerequisites": [],
  "modules": [
    {
      "id": "module-01",
      "title": "Module 1",
      "description": "Python programming fundamentals - Module 1",
      "difficulty": "beginner",
      "estimatedHours": 0,
      "lessons": [],
      "quizzes": [
        {
          "id": "quiz-01",
          "title": "Module 1 Quiz: The Absolute Basics",
          "description": "Test your understanding of Python fundamentals: print(), input(), variables, and f-strings.",
          "moduleId": "module-01",
          "passingScore": 70,
          "estimatedMinutes": 10,
          "questions": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-01-q0",
              "title": "What does the `print()` function do in Python?",
              "description": "What does the `print()` function do in Python?",
              "options": [
                "It displays text or information on the screen",
                "It saves information to a file",
                "It asks the user for input",
                "It performs mathematical calculations"
              ],
              "correctAnswer": 0,
              "explanation": "`print()` is used to display (or 'output') information to the user. Think of it as making the computer 'speak' or show something on the screen."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-01-q1",
              "title": "Which of the following is the correct way to display the text 'Hello, World!' in Python?",
              "description": "Which of the following is the correct way to display the text 'Hello, World!' in Python?",
              "options": [
                "print(Hello, World!)",
                "print('Hello, World!')",
                "Print('Hello, World!')",
                "PRINT('Hello, World!')"
              ],
              "correctAnswer": 1,
              "explanation": "The correct answer is `print('Hello, World!')`. The text must be in quotation marks (either single or double), and 'print' must be lowercase because Python is case-sensitive."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-01-q2",
              "title": "What is the purpose of quotation marks around text in Python?",
              "description": "What is the purpose of quotation marks around text in Python?",
              "options": [
                "They make the text bold",
                "They tell Python that this is text (a string), not a command",
                "They are optional and don't affect the code",
                "They make the program run faster"
              ],
              "correctAnswer": 1,
              "explanation": "Quotation marks (either `\"\"` or `''`) tell Python to treat what's inside as literal text (called a 'string'), not as a command or variable name."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-01-q3",
              "title": "What does the `#` symbol do in Python code?",
              "description": "What does the `#` symbol do in Python code?",
              "options": [
                "It starts a new line",
                "It creates a comment that Python ignores",
                "It multiplies numbers",
                "It ends a print statement"
              ],
              "correctAnswer": 1,
              "explanation": "The `#` symbol creates a comment. Everything after it on that line is ignored by Python. Comments are notes for humans to explain what the code does."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-01-q4",
              "title": "What does `input()` do?",
              "description": "What does `input()` do?",
              "options": [
                "It displays text on the screen",
                "It pauses the program and waits for the user to type something and press Enter",
                "It deletes the user's previous answer",
                "It generates a random number"
              ],
              "correctAnswer": 1,
              "explanation": "`input()` pauses your program and waits for the user to type a response and press Enter. It's like asking a question and waiting for an answer."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-01-q5",
              "title": "What is a variable in Python?",
              "description": "What is a variable in Python?",
              "options": [
                "A type of error message",
                "A labeled storage box that holds information you can use later",
                "A special Python keyword",
                "A way to print text"
              ],
              "correctAnswer": 1,
              "explanation": "A variable is like a labeled box where you can store information (like a name, number, or answer) and use it later in your program. Example: `name = 'Alex'`"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-01-q6",
              "title": "What will this code display?\n`age = 25\nprint('Age:', age)`",
              "description": "What will this code display?\n`age = 25\nprint('Age:', age)`",
              "options": [
                "Age: age",
                "Age: 25",
                "25",
                "It will cause an error"
              ],
              "correctAnswer": 1,
              "explanation": "It will display `Age: 25`. Python prints the text 'Age:' followed by the value stored in the variable `age`, which is 25."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-01-q7",
              "title": "What's the difference between `print(5 + 3)` and `print('5 + 3')`?",
              "description": "What's the difference between `print(5 + 3)` and `print('5 + 3')`?",
              "options": [
                "There is no difference",
                "The first calculates and shows 8; the second shows the text '5 + 3'",
                "The first shows '5 + 3'; the second shows 8",
                "Both cause errors"
              ],
              "correctAnswer": 1,
              "explanation": "`print(5 + 3)` calculates the math and displays `8`. `print('5 + 3')` treats it as text and displays `5 + 3`. Quotes make it text; no quotes make it code to execute."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-01-q8",
              "title": "What does `'=' * 20` create in Python?",
              "description": "What does `'=' * 20` create in Python?",
              "options": [
                "The number 20",
                "An error message",
                "A string with 20 equal signs: ====================",
                "The text '= * 20'"
              ],
              "correctAnswer": 2,
              "explanation": "In Python, you can multiply a string by a number to repeat it. `'=' * 20` creates a string with 20 equal signs: `====================`. Great for creating decorative lines!"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-01-q9",
              "title": "What's the purpose of the `f` in `f'Hello, {name}!'`?",
              "description": "What's the purpose of the `f` in `f'Hello, {name}!'`?",
              "options": [
                "It makes the text italic",
                "It tells Python this is a formatted string that can include variables in curly braces",
                "It's a typo and should be removed",
                "It makes the program run faster"
              ],
              "correctAnswer": 1,
              "explanation": "The `f` before a string makes it an f-string (formatted string). This allows you to insert variable values directly into the string using `{variable_name}`. It's cleaner than using lots of commas!"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-01-q10",
              "title": "What's wrong with this code?\n`age = input('How old are you? ')\nfuture_age = age + 10\nprint(future_age)`",
              "description": "What's wrong with this code?\n`age = input('How old are you? ')\nfuture_age = age + 10\nprint(future_age)`",
              "options": [
                "Nothing, it will work perfectly",
                "You can't add 10 to a string; you need int(age) + 10",
                "The variable name 'age' is not allowed",
                "You can't use input() and print() in the same program"
              ],
              "correctAnswer": 1,
              "explanation": "`input()` always returns a string (text), even if the user types a number. You must convert it with `int()` before doing math: `future_age = int(age) + 10`"
            },
            {
              "type": "TRUE_FALSE",
              "id": "quiz-01-q11",
              "title": "True or False: Python is case-sensitive, so `print` and `Print` are different things.",
              "description": "True or False: Python is case-sensitive, so `print` and `Print` are different things.",
              "question": "True or False: Python is case-sensitive, so `print` and `Print` are different things.",
              "correctAnswer": true,
              "explanation": "True! Python is case-sensitive. `print()` is the correct function name; `Print()` or `PRINT()` will cause an error because Python doesn't recognize them."
            },
            {
              "type": "CODE_OUTPUT",
              "id": "quiz-01-q12",
              "title": "What will this code display?\n`name = 'Alex'\nprint(f'Hello, {name}!')`",
              "description": "What will this code display?\n`name = 'Alex'\nprint(f'Hello, {name}!')`",
              "code": "name = 'Alex'\nprint(f'Hello, {name}!')",
              "language": "python",
              "correctOutput": "1",
              "explanation": "The output is `Hello, Alex!`. The f-string replaces `{name}` with the value stored in the `name` variable, which is 'Alex'."
            },
            {
              "type": "TRUE_FALSE",
              "id": "quiz-01-q13",
              "title": "True or False: Comments (lines starting with #) make your code run faster.",
              "description": "True or False: Comments (lines starting with #) make your code run faster.",
              "question": "True or False: Comments (lines starting with #) make your code run faster.",
              "correctAnswer": false,
              "explanation": "False! Comments are completely ignored by Python when it runs your code. They don't affect speed at all. Their purpose is to help humans understand the code, not to change how it runs."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-01-q14",
              "title": "What's the best practice for creating an input prompt?",
              "description": "What's the best practice for creating an input prompt?",
              "options": [
                "input('Enter name:')",
                "input('Enter name: ')",
                "input('Enter name')",
                "All of the above are equally good"
              ],
              "correctAnswer": 1,
              "explanation": "The best practice is `input('Enter name: ')` with a space after the colon. This makes the user's input appear cleanly separated from the prompt, improving readability."
            }
          ]
        }
      ]
    },
    {
      "id": "module-02",
      "title": "Module 2",
      "description": "Python programming fundamentals - Module 2",
      "difficulty": "beginner",
      "estimatedHours": 0,
      "lessons": [],
      "quizzes": [
        {
          "id": "quiz-02",
          "title": "Module 2 Quiz: Variables, Data Types & Operators",
          "description": "Test your understanding of variables, data types, type conversion, and operators. You need 13/18 correct (70%) to pass.",
          "moduleId": "module-02",
          "passingScore": 70,
          "estimatedMinutes": 15,
          "questions": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-02-q1",
              "title": "Which of the following is a valid variable name in Python?",
              "description": "Which of the following is a valid variable name in Python?",
              "options": [
                "my-variable",
                "2nd_place",
                "user_age",
                "for"
              ],
              "correctAnswer": 2,
              "explanation": "Option C (user_age) is correct. Variable names can contain letters, numbers, and underscores, but cannot start with a number (eliminates B), cannot contain hyphens (eliminates A), and cannot be Python keywords like 'for' (eliminates D)."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-02-q2",
              "title": "What data type is the value True?",
              "description": "What data type is the value True?",
              "options": [
                "string",
                "integer",
                "boolean",
                "float"
              ],
              "correctAnswer": 2,
              "explanation": "True (and False) are boolean values. Booleans represent true/false, yes/no, on/off conditions and are fundamental to decision-making in programs."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-02-q3",
              "title": "What will this code print?\n\nx = \"10\"\ny = \"5\"\nprint(x + y)",
              "description": "What will this code print?\n\nx = \"10\"\ny = \"5\"\nprint(x + y)",
              "options": [
                "15",
                "105",
                "\"105\"",
                "Error"
              ],
              "correctAnswer": 1,
              "explanation": "The output is \"105\" (not 15). Since both x and y are strings (text in quotes), the + operator concatenates (joins) them together rather than adding them mathematically. String + String = combined string."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-02-q4",
              "title": "Which function checks the data type of a variable?",
              "description": "Which function checks the data type of a variable?",
              "options": [
                "check()",
                "datatype()",
                "type()",
                "typeof()"
              ],
              "correctAnswer": 2,
              "explanation": "The type() function returns the data type of a variable. For example, type(5) returns <class 'int'> and type(\"hello\") returns <class 'str'>."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-02-q5",
              "title": "What will this code output?\n\nprice = 19.99\nprint(type(price))",
              "description": "What will this code output?\n\nprice = 19.99\nprint(type(price))",
              "options": [
                "<class 'int'>",
                "<class 'float'>",
                "<class 'str'>",
                "19.99"
              ],
              "correctAnswer": 1,
              "explanation": "19.99 is a decimal number, so Python stores it as a float. The type() function will return <class 'float'>. Any number with a decimal point is automatically a float."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-02-q6",
              "title": "What happens when you try to run this code?\n\nage = int(\"twenty-five\")",
              "description": "What happens when you try to run this code?\n\nage = int(\"twenty-five\")",
              "options": [
                "age becomes 25",
                "age becomes \"25\"",
                "ValueError occurs",
                "age becomes 0"
              ],
              "correctAnswer": 2,
              "explanation": "You get a ValueError! The int() function can only convert strings that contain actual digits like \"25\". It cannot convert word representations of numbers like \"twenty-five\". Always convert strings that look like numbers: \"123\" works, \"one hundred\" doesn't."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-02-q7",
              "title": "What's the correct way to convert user input to a decimal number?",
              "description": "What's the correct way to convert user input to a decimal number?",
              "options": [
                "num = input(\"Enter number: \")",
                "num = int(input(\"Enter number: \"))",
                "num = float(input(\"Enter number: \"))",
                "num = str(input(\"Enter number: \"))"
              ],
              "correctAnswer": 2,
              "explanation": "Use float(input(...)) to convert user input to a decimal number. The input() function always returns a string, so we need float() to convert it. Option B (int) only handles whole numbers, and Option A leaves it as a string."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-02-q8",
              "title": "What will this code print?\n\nresult = 15 // 4\nprint(result)",
              "description": "What will this code print?\n\nresult = 15 // 4\nprint(result)",
              "options": [
                "3.75",
                "3",
                "4",
                "3.0"
              ],
              "correctAnswer": 1,
              "explanation": "Floor division (//) gives only the whole number part: 15 ÷ 4 = 3.75, but // drops the decimal, giving us 3. Regular division (/) would give 3.75, but // gives only whole pieces."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-02-q9",
              "title": "What does the modulo operator (%) return?\n\nresult = 17 % 5",
              "description": "What does the modulo operator (%) return?\n\nresult = 17 % 5",
              "options": [
                "The quotient (3.4)",
                "The whole number quotient (3)",
                "The remainder (2)",
                "An error"
              ],
              "correctAnswer": 2,
              "explanation": "The modulo (%) operator returns the remainder after division. 17 ÷ 5 = 3 with 2 left over. So 17 % 5 = 2. This is perfect for finding leftovers, checking if numbers are even/odd, or converting units."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-02-q10",
              "title": "What will this code output?\n\nprint(2 ** 3)",
              "description": "What will this code output?\n\nprint(2 ** 3)",
              "options": [
                "6",
                "5",
                "8",
                "9"
              ],
              "correctAnswer": 2,
              "explanation": "The ** operator is exponentiation (power). 2 ** 3 means 2 × 2 × 2 = 8. Don't confuse ** with * (multiplication): 2 * 3 = 6, but 2 ** 3 = 8."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-02-q11",
              "title": "What's the result of this expression?\n\nresult = 10 - 2 * 3",
              "description": "What's the result of this expression?\n\nresult = 10 - 2 * 3",
              "options": [
                "24",
                "4",
                "16",
                "0"
              ],
              "correctAnswer": 1,
              "explanation": "Python follows PEMDAS (order of operations). Multiplication happens before subtraction: 2 * 3 = 6, then 10 - 6 = 4. If you wanted 24, you'd need parentheses: (10 - 2) * 3."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-02-q12",
              "title": "Which line will cause an error?",
              "description": "Which line will cause an error?",
              "options": [
                "x = int(\"42\")",
                "y = float(\"3.14\")",
                "z = int(\"3.14\")",
                "w = str(42)"
              ],
              "correctAnswer": 2,
              "explanation": "Option C causes a ValueError! int() cannot directly convert a decimal string like \"3.14\" to an integer. You'd need int(float(\"3.14\")) to do it in two steps, or just use \"3\" instead of \"3.14\". All other conversions are valid."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-02-q13",
              "title": "What's the difference between / and // operators?",
              "description": "What's the difference between / and // operators?",
              "options": [
                "They do the same thing",
                "/ gives decimals, // gives whole numbers only",
                "/ is faster than //",
                "// only works with even numbers"
              ],
              "correctAnswer": 1,
              "explanation": "/ (regular division) always returns a float with decimals, even for even divisions: 10 / 2 = 5.0. // (floor division) returns only the whole number part: 10 // 2 = 5 (integer). Use / for precise calculations, // when you only need whole pieces."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-02-q14",
              "title": "What data type does input() always return?",
              "description": "What data type does input() always return?",
              "options": [
                "Integer",
                "Float",
                "String",
                "It depends on what the user types"
              ],
              "correctAnswer": 2,
              "explanation": "input() ALWAYS returns a string, regardless of what the user types. Even if they type \"123\", you get the string \"123\", not the number 123. This is why we need int() or float() to convert it to a number for calculations."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-02-q15",
              "title": "How do you check if a number is even using the modulo operator?",
              "description": "How do you check if a number is even using the modulo operator?",
              "options": [
                "number / 2 == 0",
                "number // 2 == 0",
                "number % 2 == 0",
                "number ** 2 == 0"
              ],
              "correctAnswer": 2,
              "explanation": "A number is even if it has NO remainder when divided by 2. So number % 2 == 0 checks this. For example: 10 % 2 = 0 (even), but 11 % 2 = 1 (odd). The modulo operator is perfect for checking divisibility."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-02-q16",
              "title": "What will this code output?\n\nname = \"Python\"\nversion = 3\nprint(type(name), type(version))",
              "description": "What will this code output?\n\nname = \"Python\"\nversion = 3\nprint(type(name), type(version))",
              "options": [
                "<class 'str'> <class 'str'>",
                "<class 'int'> <class 'int'>",
                "<class 'str'> <class 'int'>",
                "Python 3"
              ],
              "correctAnswer": 2,
              "explanation": "name is a string (text in quotes) and version is an integer (whole number with no quotes). So type(name) returns <class 'str'> and type(version) returns <class 'int'>."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-02-q17",
              "title": "In a calculator program, why would you use float() for numbers instead of int()?",
              "description": "In a calculator program, why would you use float() for numbers instead of int()?",
              "options": [
                "float() is faster than int()",
                "float() can handle both whole numbers and decimals",
                "int() doesn't work with input()",
                "You should always use int() instead"
              ],
              "correctAnswer": 1,
              "explanation": "float() can handle both 5 and 5.5, while int() only handles whole numbers. For a calculator, users might enter 19.99 or 3.14, so float() is more flexible. Plus, float() can still handle whole numbers: float(\"5\") works fine and gives 5.0."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-02-q18",
              "title": "What will happen if you run this code?\n\nresult = \"5\" * 3\nprint(result)",
              "description": "What will happen if you run this code?\n\nresult = \"5\" * 3\nprint(result)",
              "options": [
                "15",
                "8",
                "\"555\"",
                "Error"
              ],
              "correctAnswer": 2,
              "explanation": "When you multiply a string by a number, Python repeats the string! \"5\" * 3 gives \"555\" (the string \"5\" repeated 3 times). This is different from 5 * 3 (without quotes), which would give 15. String multiplication is actually useful for creating patterns or separators!"
            }
          ]
        }
      ]
    },
    {
      "id": "module-03",
      "title": "Module 3",
      "description": "Python programming fundamentals - Module 3",
      "difficulty": "beginner",
      "estimatedHours": 0,
      "lessons": [],
      "quizzes": [
        {
          "id": "quiz-03",
          "title": "Module 3 Quiz: Making Decisions (Conditionals)",
          "description": "Test your understanding of Boolean logic, conditional statements, and decision-making in Python. You need 14/20 correct (70%) to pass.",
          "moduleId": "module-03",
          "passingScore": 70,
          "estimatedMinutes": 15,
          "questions": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-03-q1",
              "title": "What are the only two Boolean values in Python?",
              "description": "What are the only two Boolean values in Python?",
              "options": [
                "true and false",
                "TRUE and FALSE",
                "True and False",
                "1 and 0"
              ],
              "correctAnswer": 2,
              "explanation": "True and False (capitalized!) are the only Boolean values in Python. Python is case-sensitive, so 'true', 'TRUE', or 'false' will cause errors. While True equals 1 and False equals 0 internally, the Boolean values themselves are True and False."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-03-q2",
              "title": "What will this expression evaluate to?\n\nTrue and False or True",
              "description": "What will this expression evaluate to?\n\nTrue and False or True",
              "options": [
                "True",
                "False",
                "Error",
                "None"
              ],
              "correctAnswer": 0,
              "explanation": "The result is True. Following operator precedence, 'and' is evaluated first: (True and False) = False. Then 'or' is evaluated: False or True = True. Remember: 'and' has higher precedence than 'or'."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-03-q3",
              "title": "Which operator checks if two values are equal?",
              "description": "Which operator checks if two values are equal?",
              "options": [
                "=",
                "==",
                "===",
                "equals"
              ],
              "correctAnswer": 1,
              "explanation": "The == operator checks equality and returns True or False. The = operator is for assignment (making a variable equal to a value). Python doesn't use === (that's JavaScript)."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-03-q4",
              "title": "What's wrong with this code?\n\nif age >= 18\n    print(\"Adult\")",
              "description": "What's wrong with this code?\n\nif age >= 18\n    print(\"Adult\")",
              "options": [
                "Nothing is wrong",
                "Missing colon after condition",
                "Wrong indentation",
                "Using >= instead of >"
              ],
              "correctAnswer": 1,
              "explanation": "The colon (:) after the if condition is mandatory in Python. The correct syntax is 'if age >= 18:'. The indentation is actually correct (the print is indented), and >= is the right operator for 'greater than or equal to'."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-03-q5",
              "title": "What will this code output?\n\nage = 15\n\nif age >= 18:\n    print(\"Adult\")\n\nprint(\"Done\")",
              "description": "What will this code output?\n\nage = 15\n\nif age >= 18:\n    print(\"Adult\")\n\nprint(\"Done\")",
              "options": [
                "Adult\nDone",
                "Done",
                "Adult",
                "Nothing"
              ],
              "correctAnswer": 1,
              "explanation": "Only 'Done' prints. Since age (15) is not >= 18, the condition is False, so 'Adult' never prints. However, 'Done' is not indented, so it's not part of the if block - it always runs."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-03-q6",
              "title": "What's the purpose of the else statement?",
              "description": "What's the purpose of the else statement?",
              "options": [
                "To check another condition",
                "To execute code when the if condition is False",
                "To add comments to code",
                "To end the if statement"
              ],
              "correctAnswer": 1,
              "explanation": "The else statement executes code when the if condition is False. It provides an alternative path. Note: else doesn't check a condition - it automatically handles all cases where the if was False."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-03-q7",
              "title": "What's wrong with this code?\n\nif score >= 90:\n    print(\"A\")\nelse score >= 80:\n    print(\"B\")",
              "description": "What's wrong with this code?\n\nif score >= 90:\n    print(\"A\")\nelse score >= 80:\n    print(\"B\")",
              "options": [
                "Nothing is wrong",
                "Should use elif instead of else",
                "else cannot have a condition",
                "Both B and C are correct"
              ],
              "correctAnswer": 3,
              "explanation": "Both B and C are correct! The else keyword cannot have a condition - you can't write 'else score >= 80:'. When you need to check another condition, you must use elif (else if): 'elif score >= 80:'. This is one of the most common mistakes beginners make!"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-03-q8",
              "title": "In an if-elif-else chain, how many blocks can execute?",
              "description": "In an if-elif-else chain, how many blocks can execute?",
              "options": [
                "All of them",
                "Exactly one",
                "At least one",
                "None of them"
              ],
              "correctAnswer": 1,
              "explanation": "Exactly ONE block executes in an if-elif-else chain (or zero if there's no else and all conditions are False). Python checks from top to bottom and stops at the first True condition, skipping all remaining elif/else blocks. This is called 'first match wins'."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-03-q9",
              "title": "What will this code output?\n\nscore = 95\n\nif score >= 60:\n    print(\"Pass\")\nelif score >= 90:\n    print(\"Excellent\")",
              "description": "What will this code output?\n\nscore = 95\n\nif score >= 60:\n    print(\"Pass\")\nelif score >= 90:\n    print(\"Excellent\")",
              "options": [
                "Pass",
                "Excellent",
                "Pass\nExcellent",
                "Error"
              ],
              "correctAnswer": 0,
              "explanation": "Only 'Pass' prints. Even though score >= 90 is also True, Python stops at the FIRST match (score >= 60), executes that block, and skips all remaining elif blocks. Order matters in elif chains! This should be: if score >= 90 (check highest first), then elif score >= 60."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-03-q10",
              "title": "Which is the correct order for checking grade ranges?",
              "description": "Which is the correct order for checking grade ranges?",
              "options": [
                "if score >= 60, elif >= 70, elif >= 80, elif >= 90",
                "if score >= 90, elif >= 80, elif >= 70, elif >= 60",
                "Order doesn't matter",
                "Use else for all ranges"
              ],
              "correctAnswer": 1,
              "explanation": "Option B is correct: check from highest to lowest (most specific to most general). If you check >= 60 first, a score of 95 would match and you'd never check the higher grades. Always order elif chains from most restrictive to least restrictive."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-03-q11",
              "title": "What does the 'not' operator do?",
              "description": "What does the 'not' operator do?",
              "options": [
                "Combines two conditions",
                "Checks inequality",
                "Reverses True to False and vice versa",
                "Stops code execution"
              ],
              "correctAnswer": 2,
              "explanation": "The 'not' operator reverses Boolean values: 'not True' becomes False, and 'not False' becomes True. For example, 'not is_raining' is True when is_raining is False."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-03-q12",
              "title": "What's the result of: 10 > 5 and 3 < 2",
              "description": "What's the result of: 10 > 5 and 3 < 2",
              "options": [
                "True",
                "False",
                "10",
                "Error"
              ],
              "correctAnswer": 1,
              "explanation": "The result is False. Breaking it down: 10 > 5 is True, and 3 < 2 is False. For 'and' to return True, BOTH conditions must be True. Since one is False, the entire expression is False."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-03-q13",
              "title": "What's the result of: False or False or True",
              "description": "What's the result of: False or False or True",
              "options": [
                "True",
                "False",
                "Error",
                "None"
              ],
              "correctAnswer": 0,
              "explanation": "The result is True. With 'or', at least ONE condition must be True for the result to be True. Even though the first two are False, the third one is True, so the entire expression evaluates to True."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-03-q14",
              "title": "How many spaces should the inner code have in a nested if?\n\nif outer:\n    if inner:\n        action",
              "description": "How many spaces should the inner code have in a nested if?\n\nif outer:\n    if inner:\n        action",
              "options": [
                "4 spaces",
                "6 spaces",
                "8 spaces",
                "12 spaces"
              ],
              "correctAnswer": 2,
              "explanation": "The innermost code needs 8 spaces total. The first if adds 4 spaces, the nested if adds another 4 spaces. Each level of nesting adds 4 more spaces (Level 0 = 0, Level 1 = 4, Level 2 = 8, Level 3 = 12, etc.)."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-03-q15",
              "title": "When should you use nested if statements instead of 'and'?",
              "description": "When should you use nested if statements instead of 'and'?",
              "options": [
                "Always use nesting",
                "When you need different actions at each level",
                "When checking two conditions",
                "Never use nesting"
              ],
              "correctAnswer": 1,
              "explanation": "Use nested if when you need different actions at each decision level. For example, checking login status first, then checking user role to show different dashboards. Use 'and' when both conditions are equal requirements for a single outcome."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-03-q16",
              "title": "What's the difference between these?\n\nA: if x > 10:\n     if y > 5:\n         action\n\nB: if x > 10 and y > 5:\n     action",
              "description": "What's the difference between these?\n\nA: if x > 10:\n     if y > 5:\n         action\n\nB: if x > 10 and y > 5:\n     action",
              "options": [
                "A is correct, B is wrong",
                "B is correct, A is wrong",
                "Both produce the same result for this case",
                "Neither will work"
              ],
              "correctAnswer": 2,
              "explanation": "Both produce the same result in this case - action only runs if both conditions are True. However, B is simpler and more concise when you just need to check both conditions for one action. Use A when you need different actions at each level."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-03-q17",
              "title": "What's wrong with this code?\n\nif age >= 18:\n    print(\"Adult\")\n    else:\n        print(\"Minor\")",
              "description": "What's wrong with this code?\n\nif age >= 18:\n    print(\"Adult\")\n    else:\n        print(\"Minor\")",
              "options": [
                "Nothing is wrong",
                "else is indented too much",
                "Missing colon after else",
                "else should be elif"
              ],
              "correctAnswer": 1,
              "explanation": "The else is indented too much. The else keyword must be at the SAME indentation level as its matching if statement. The else should have 0 spaces (same as if), not 4 spaces."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-03-q18",
              "title": "Which expression checks if a number is NOT equal to 10?",
              "description": "Which expression checks if a number is NOT equal to 10?",
              "options": [
                "number !== 10",
                "number != 10",
                "number <> 10",
                "not number == 10"
              ],
              "correctAnswer": 1,
              "explanation": "The != operator checks 'not equal to' in Python. Option D (not number == 10) also works but is more verbose. Options A and C use syntax from other languages that doesn't work in Python."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-03-q19",
              "title": "What will this code output?\n\nif True:\n    print(\"A\")\n    print(\"B\")\nprint(\"C\")",
              "description": "What will this code output?\n\nif True:\n    print(\"A\")\n    print(\"B\")\nprint(\"C\")",
              "options": [
                "A",
                "A\nB",
                "A\nB\nC",
                "C"
              ],
              "correctAnswer": 2,
              "explanation": "All three lines print! The if condition is True, so both 'A' and 'B' (which are indented and part of the if block) execute. Then 'C' prints because it's not indented - it's not part of the if block and always runs."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-03-q20",
              "title": "What's the best practice for deep nesting?",
              "description": "What's the best practice for deep nesting?",
              "options": [
                "Nest as deeply as needed, no limit",
                "Never use nesting",
                "Keep nesting to 2-3 levels max for readability",
                "Always use 5+ levels"
              ],
              "correctAnswer": 2,
              "explanation": "Best practice is to keep nesting to 2-3 levels maximum for readability. Deeper nesting becomes hard to follow and maintain. If you need more levels, consider using logical operators (and/or) or refactoring into functions (which you'll learn in Module 6)."
            }
          ]
        }
      ]
    },
    {
      "id": "module-04",
      "title": "Module 4",
      "description": "Python programming fundamentals - Module 4",
      "difficulty": "beginner",
      "estimatedHours": 0,
      "lessons": [],
      "quizzes": [
        {
          "id": "quiz-04",
          "title": "Module 4 Quiz: Loops - Repetition Made Easy",
          "description": "Test your mastery of while loops, for loops, loop control (break/continue/pass), nested loops, and practical loop applications. You need 14/20 correct (70%) to pass.",
          "moduleId": "module-04",
          "passingScore": 70,
          "estimatedMinutes": 15,
          "questions": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-04-q1",
              "title": "What are the three essential parts of a while loop?",
              "description": "What are the three essential parts of a while loop?",
              "options": [
                "start, middle, end",
                "initialize, condition, update",
                "input, process, output",
                "declaration, execution, termination"
              ],
              "correctAnswer": 1,
              "explanation": "Every while loop needs three parts: (1) Initialize the control variable before the loop, (2) Condition to check each iteration, (3) Update the variable inside the loop to eventually make the condition False. Forgetting the update causes infinite loops!"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-04-q2",
              "title": "What will this code output?\n\ncount = 5\nwhile count > 0:\n    print(count)\n    count = count - 1",
              "description": "What will this code output?\n\ncount = 5\nwhile count > 0:\n    print(count)\n    count = count - 1",
              "options": [
                "5 4 3 2 1",
                "5 4 3 2 1 0",
                "4 3 2 1 0",
                "Infinite loop"
              ],
              "correctAnswer": 0,
              "explanation": "The loop starts with count=5. It prints 5, then decrements to 4. This continues (4, 3, 2, 1). When count becomes 0, the condition 'count > 0' is False, so the loop stops. Zero is NOT printed because the loop exits before that print happens."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-04-q3",
              "title": "What causes an infinite loop?",
              "description": "What causes an infinite loop?",
              "options": [
                "Using while instead of for",
                "Forgetting to update the loop variable",
                "Using a condition that's initially True",
                "Having too many iterations"
              ],
              "correctAnswer": 1,
              "explanation": "Infinite loops happen when you forget to update the loop variable, so the condition never becomes False. For example: 'count = 1; while count < 10: print(count)' loops forever because count never changes. Always update your loop variable!"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-04-q4",
              "title": "What does range(5) generate?",
              "description": "What does range(5) generate?",
              "options": [
                "1, 2, 3, 4, 5",
                "0, 1, 2, 3, 4",
                "0, 1, 2, 3, 4, 5",
                "5, 4, 3, 2, 1"
              ],
              "correctAnswer": 1,
              "explanation": "range(5) generates 0, 1, 2, 3, 4 - it starts at 0 by default and stops BEFORE 5. This is called 'exclusive end' - the stop value is never included. To get 1-5, use range(1, 6)."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-04-q5",
              "title": "What's the difference between range(5) and range(1, 6)?",
              "description": "What's the difference between range(5) and range(1, 6)?",
              "options": [
                "They're identical",
                "range(5) is 0-4, range(1,6) is 1-5",
                "range(5) is 1-5, range(1,6) is 1-6",
                "range(1,6) includes 6"
              ],
              "correctAnswer": 1,
              "explanation": "range(5) generates 0, 1, 2, 3, 4 (starts at 0, stops before 5). range(1, 6) generates 1, 2, 3, 4, 5 (starts at 1, stops before 6). Both produce 5 numbers, but range(1, 6) is shifted up by 1."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-04-q6",
              "title": "How do you create a countdown from 5 to 1 using range()?",
              "description": "How do you create a countdown from 5 to 1 using range()?",
              "options": [
                "range(5, 1)",
                "range(5, 0, -1)",
                "range(1, 5, -1)",
                "range(-5, -1)"
              ],
              "correctAnswer": 1,
              "explanation": "range(5, 0, -1) generates 5, 4, 3, 2, 1. The format is range(start, stop, step). Start at 5, stop before 0, step by -1 (count down). You MUST include the negative step, otherwise range() produces nothing (can't count up from 5 to 0)."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-04-q7",
              "title": "What does the 'break' statement do?",
              "description": "What does the 'break' statement do?",
              "options": [
                "Pauses the loop temporarily",
                "Skips to the next iteration",
                "Exits the loop immediately",
                "Stops the entire program"
              ],
              "correctAnswer": 2,
              "explanation": "'break' exits the loop immediately, skipping any remaining iterations. For example, searching a list: once you find what you're looking for, break exits early rather than checking the rest. It ONLY exits the loop, not the entire program."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-04-q8",
              "title": "What does the 'continue' statement do?",
              "description": "What does the 'continue' statement do?",
              "options": [
                "Exits the loop",
                "Skips the rest of the current iteration and jumps to the next",
                "Resumes a paused loop",
                "Repeats the current iteration"
              ],
              "correctAnswer": 1,
              "explanation": "'continue' skips the rest of the current iteration and jumps directly to the next iteration. For example, 'if x % 2 == 0: continue; print(x)' skips even numbers - when continue runs, it jumps back to the loop start without executing print(x)."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-04-q9",
              "title": "What will this code print?\n\nfor num in range(1, 6):\n    if num == 3:\n        continue\n    print(num)",
              "description": "What will this code print?\n\nfor num in range(1, 6):\n    if num == 3:\n        continue\n    print(num)",
              "options": [
                "1 2 3 4 5",
                "1 2 4 5",
                "3",
                "1 2"
              ],
              "correctAnswer": 1,
              "explanation": "The loop iterates 1, 2, 3, 4, 5. When num is 3, 'continue' skips the rest of that iteration (including print), so 3 doesn't print. All other numbers (1, 2, 4, 5) print normally. Output: 1 2 4 5."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-04-q10",
              "title": "When does the 'else' clause after a for loop execute?",
              "description": "When does the 'else' clause after a for loop execute?",
              "options": [
                "Always after the loop",
                "Only if the loop encounters a break",
                "Only if the loop completes without break",
                "Never - for loops can't have else"
              ],
              "correctAnswer": 2,
              "explanation": "The else clause after a for/while loop only executes if the loop completes normally (without encountering break). If break exits early, else is skipped. This is useful for search: 'else' means 'not found'. It's Python's unique feature - most languages don't have loop else!"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-04-q11",
              "title": "What will this code output?\n\nfor i in range(3):\n    if i == 5:\n        break\nelse:\n    print('Done')",
              "description": "What will this code output?\n\nfor i in range(3):\n    if i == 5:\n        break\nelse:\n    print('Done')",
              "options": [
                "Nothing",
                "Done",
                "0 1 2 Done",
                "Error"
              ],
              "correctAnswer": 1,
              "explanation": "'Done' prints. The loop runs 0, 1, 2 (i never equals 5, so break never executes). Since the loop completes normally without break, the else clause runs and prints 'Done'."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-04-q12",
              "title": "What's the purpose of 'pass' in a loop?",
              "description": "What's the purpose of 'pass' in a loop?",
              "options": [
                "Skips to next iteration like continue",
                "Exits the loop like break",
                "Does nothing - placeholder for empty code block",
                "Passes control to outer loop"
              ],
              "correctAnswer": 2,
              "explanation": "'pass' does literally nothing - it's a placeholder for syntactically required but empty code blocks. For example: 'if error: pass' means 'if there's an error, do nothing (I'll implement this later)'. It's useful during development or when you want to explicitly ignore a condition."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-04-q13",
              "title": "How many times will 'X' print?\n\nfor i in range(4):\n    for j in range(3):\n        print('X')",
              "description": "How many times will 'X' print?\n\nfor i in range(4):\n    for j in range(3):\n        print('X')",
              "options": [
                "4",
                "3",
                "7",
                "12"
              ],
              "correctAnswer": 3,
              "explanation": "Nested loops multiply iterations: outer (4 times) × inner (3 times each) = 12 total. The outer loop runs 4 times, and for EACH of those 4 iterations, the inner loop runs completely (3 times). Total: 4 × 3 = 12."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-04-q14",
              "title": "What will this nested loop output?\n\nfor row in range(2):\n    for col in range(3):\n        print('*', end='')\n    print()",
              "description": "What will this nested loop output?\n\nfor row in range(2):\n    for col in range(3):\n        print('*', end='')\n    print()",
              "options": [
                "******",
                "***\n***",
                "**\n**\n**",
                "*\n*\n*\n*\n*\n*"
              ],
              "correctAnswer": 1,
              "explanation": "The outer loop runs 2 times (2 rows). For each row, the inner loop prints 3 stars without newlines (end=''). Then print() adds a newline AFTER each row. Result: 2 rows of 3 stars each (*** on one line, then *** on the next line)."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-04-q15",
              "title": "In nested loops, what does 'break' affect?",
              "description": "In nested loops, what does 'break' affect?",
              "options": [
                "Exits all nested loops",
                "Exits only the innermost loop it's in",
                "Exits the outermost loop",
                "Exits the program"
              ],
              "correctAnswer": 1,
              "explanation": "'break' ONLY exits the loop it's directly inside (the innermost loop). The outer loop continues normally. To break out of multiple loops, you need a flag variable or use a function with return. This is a common source of bugs!"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-04-q16",
              "title": "What's the best loop choice for 'run until user types quit'?",
              "description": "What's the best loop choice for 'run until user types quit'?",
              "options": [
                "for loop with large range",
                "while True with break on quit",
                "while input != 'quit'",
                "Nested for loops"
              ],
              "correctAnswer": 1,
              "explanation": "'while True' with a break on quit is the standard pattern for indefinite loops (loops that run until a specific event). It's clearer than 'while input != quit' which requires awkward initialization. Pattern: while True → get input → if quit: break → process."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-04-q17",
              "title": "How do you validate user input with a loop?",
              "description": "How do you validate user input with a loop?",
              "options": [
                "for i in range(3): get_input()",
                "while True:\n&nbsp;&nbsp;try:\n&nbsp;&nbsp;&nbsp;&nbsp;value = int(input())\n&nbsp;&nbsp;&nbsp;&nbsp;break\n&nbsp;&nbsp;except:\n&nbsp;&nbsp;&nbsp;&nbsp;continue",
                "if input() == valid: continue",
                "while input() != valid: pass"
              ],
              "correctAnswer": 1,
              "explanation": "Option B is correct: 'while True' loop that tries to convert input, breaks on success, continues on failure. This pattern keeps prompting until valid input. try/except catches invalid conversions (like int('abc')), and continue loops back to ask again."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-04-q18",
              "title": "What's an accumulator in a loop?",
              "description": "What's an accumulator in a loop?",
              "options": [
                "A variable that stores the loop counter",
                "A variable that builds up a result across iterations",
                "The condition that controls the loop",
                "Another name for the loop variable"
              ],
              "correctAnswer": 1,
              "explanation": "An accumulator is a variable that builds up a result across loop iterations. Common examples: total (sum), count (counter), product (multiplication), max/min (tracking). Pattern: initialize before loop (total = 0), update in loop (total = total + value), use after loop (average = total / count)."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-04-q19",
              "title": "When should you use a for loop instead of while?",
              "description": "When should you use a for loop instead of while?",
              "options": [
                "When you know exactly how many iterations you need",
                "When the condition is complex",
                "When you need an infinite loop",
                "for and while are interchangeable always"
              ],
              "correctAnswer": 0,
              "explanation": "Use 'for' when you know the number of iterations in advance (iterate 10 times, process each item in a list). Use 'while' when iterations depend on a condition that might change unpredictably (loop until user quits, until value > 100). for = count-based, while = condition-based."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-04-q20",
              "title": "What's wrong with this code?\n\nfor i in range(5):\n    total = 0\n    total = total + i\nprint(total)",
              "description": "What's wrong with this code?\n\nfor i in range(5):\n    total = 0\n    total = total + i\nprint(total)",
              "options": [
                "Nothing is wrong",
                "total is reset to 0 each iteration",
                "range(5) should be range(1, 6)",
                "Missing break statement"
              ],
              "correctAnswer": 1,
              "explanation": "The bug: 'total = 0' is INSIDE the loop, so it resets to 0 every iteration! You never accumulate anything. Fix: Move 'total = 0' BEFORE the loop. This is a very common mistake with accumulators - initialize outside, update inside."
            }
          ]
        }
      ]
    },
    {
      "id": "module-05",
      "title": "Module 5",
      "description": "Python programming fundamentals - Module 5",
      "difficulty": "beginner",
      "estimatedHours": 0,
      "lessons": [],
      "quizzes": [
        {
          "id": "quiz-05",
          "title": "Module 5 Quiz: Lists & Tuples",
          "description": "Test your mastery of lists, tuples, slicing, list methods, and list comprehensions. You need 14/20 correct (70%) to pass.",
          "moduleId": "module-05",
          "passingScore": 70,
          "estimatedMinutes": 15,
          "questions": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-05-q1",
              "title": "What is the index of the first item in a Python list?",
              "description": "What is the index of the first item in a Python list?",
              "options": [
                "1",
                "0",
                "-1",
                "First"
              ],
              "correctAnswer": 1,
              "explanation": "The first item is at index 0. Python uses zero-based indexing, meaning indices start at 0, not 1. This is true for all sequences (lists, tuples, strings). Remember: index 0 = first, index 1 = second, etc."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-05-q2",
              "title": "How do you access the last item of a list without knowing its length?",
              "description": "How do you access the last item of a list without knowing its length?",
              "options": [
                "my_list[last]",
                "my_list[end]",
                "my_list[-1]",
                "my_list[len(my_list)]"
              ],
              "correctAnswer": 2,
              "explanation": "my_list[-1] accesses the last item. Negative indices count from the end: -1 is last, -2 is second to last, etc. my_list[len(my_list)] would cause an IndexError because indices go from 0 to len-1, not len."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-05-q3",
              "title": "What does this code do?\n\nfruits = ['Apple', 'Banana']\nfruits.append('Cherry')",
              "description": "What does this code do?\n\nfruits = ['Apple', 'Banana']\nfruits.append('Cherry')",
              "options": [
                "Replaces 'Banana' with 'Cherry'",
                "Adds 'Cherry' to the beginning",
                "Adds 'Cherry' to the end",
                "Creates a new list"
              ],
              "correctAnswer": 2,
              "explanation": "append() adds an item to the END of the list. After this code, fruits = ['Apple', 'Banana', 'Cherry']. append() is the most common way to add items to lists and always adds to the end."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-05-q4",
              "title": "What's the difference between remove() and pop()?\n\nnums = [1, 2, 3, 4]",
              "description": "What's the difference between remove() and pop()?\n\nnums = [1, 2, 3, 4]",
              "options": [
                "No difference, they're the same",
                "remove() takes a value, pop() takes an index",
                "pop() returns the removed item, remove() doesn't",
                "Both B and C are correct"
              ],
              "correctAnswer": 3,
              "explanation": "Both B and C are correct! remove(value) finds and removes the first occurrence of a VALUE (nums.remove(3) removes the 3). pop(index) or pop() removes by POSITION and RETURNS the removed item (item = nums.pop(2) removes index 2 and stores it in item)."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-05-q5",
              "title": "What will this code print?\n\nresult = nums.sort()\nprint(result)",
              "description": "What will this code print?\n\nresult = nums.sort()\nprint(result)",
              "options": [
                "The sorted list",
                "None",
                "The original list",
                "Error"
              ],
              "correctAnswer": 1,
              "explanation": "This prints None! sort() modifies the list IN PLACE and returns None (not the sorted list). After this, nums is sorted, but result is None. This is a very common mistake. If you want a sorted copy, use: result = sorted(nums)."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-05-q6",
              "title": "What does this slice return?\n\nnums = [0, 1, 2, 3, 4, 5]\nresult = nums[1:4]",
              "description": "What does this slice return?\n\nnums = [0, 1, 2, 3, 4, 5]\nresult = nums[1:4]",
              "options": [
                "[1, 2, 3, 4]",
                "[1, 2, 3]",
                "[0, 1, 2, 3]",
                "[2, 3, 4]"
              ],
              "correctAnswer": 1,
              "explanation": "The result is [1, 2, 3]. In slice notation [start:stop], start is inclusive but stop is EXCLUSIVE. So [1:4] gets indices 1, 2, 3 - index 4 is NOT included. This is one of the most important rules of slicing!"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-05-q7",
              "title": "How do you get the last 3 items of a list?",
              "description": "How do you get the last 3 items of a list?",
              "options": [
                "my_list[3:]",
                "my_list[-3:]",
                "my_list[:3]",
                "my_list[:-3]"
              ],
              "correctAnswer": 1,
              "explanation": "my_list[-3:] gets the last 3 items. The -3 starts at the third item from the end, and omitting the stop means 'go to the end'. my_list[3:] would get from index 3 to end (not necessarily last 3). my_list[:3] gets first 3."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-05-q8",
              "title": "What does nums[::-1] do?",
              "description": "What does nums[::-1] do?",
              "options": [
                "Deletes all items",
                "Reverses the list",
                "Gets every other item",
                "Creates an error"
              ],
              "correctAnswer": 1,
              "explanation": "nums[::-1] reverses the list! The -1 step means 'go backwards'. Starting from the end (default when step is negative), going to the beginning (default), stepping by -1 gives you all items in reverse order. This is the Pythonic way to reverse!"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-05-q9",
              "title": "What's the difference between lists and tuples?",
              "description": "What's the difference between lists and tuples?",
              "options": [
                "Lists use [], tuples use ()",
                "Lists are mutable, tuples are immutable",
                "Tuples are faster and use less memory",
                "All of the above"
              ],
              "correctAnswer": 3,
              "explanation": "All of the above! Lists use square brackets [] and are mutable (can be changed). Tuples use parentheses () and are immutable (cannot be changed after creation). Tuples are also faster and use less memory. Use tuples for fixed data, lists for data that changes."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-05-q10",
              "title": "What happens when you try to modify a tuple?\n\ncoords = (10, 20)\ncoords[0] = 30",
              "description": "What happens when you try to modify a tuple?\n\ncoords = (10, 20)\ncoords[0] = 30",
              "options": [
                "The tuple is modified successfully",
                "A new tuple is created",
                "TypeError: tuple object does not support item assignment",
                "The change is silently ignored"
              ],
              "correctAnswer": 2,
              "explanation": "You get a TypeError because tuples are immutable - they cannot be modified after creation. You can't change, add, or remove items. If you need to 'modify' a tuple, you must create a new one. This immutability is the key difference from lists."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-05-q11",
              "title": "What's the correct syntax for a single-item tuple?",
              "description": "What's the correct syntax for a single-item tuple?",
              "options": [
                "(42)",
                "(42,)",
                "[42]",
                "tuple(42)"
              ],
              "correctAnswer": 1,
              "explanation": "The correct answer is (42,) with a trailing comma. Without the comma, (42) is just an integer wrapped in parentheses. The comma is what makes it a tuple! This is a very common mistake. For multiple items the comma is between items, but for one item it must trail."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-05-q12",
              "title": "What does this code do?\n\na = 5\nb = 10\na, b = b, a",
              "description": "What does this code do?\n\na = 5\nb = 10\na, b = b, a",
              "options": [
                "Creates a syntax error",
                "Sets both to 10",
                "Swaps the values of a and b",
                "Creates a tuple"
              ],
              "correctAnswer": 2,
              "explanation": "This swaps the values! a becomes 10 and b becomes 5. This works through tuple packing/unpacking: b, a creates the tuple (10, 5), then a, b = unpacks it. This is the Pythonic way to swap variables in one line!"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-05-q13",
              "title": "What does this list comprehension create?\n\n[x * 2 for x in range(5)]",
              "description": "What does this list comprehension create?\n\n[x * 2 for x in range(5)]",
              "options": [
                "[0, 1, 2, 3, 4]",
                "[0, 2, 4, 6, 8]",
                "[2, 4, 6, 8, 10]",
                "[1, 2, 3, 4, 5]"
              ],
              "correctAnswer": 1,
              "explanation": "The result is [0, 2, 4, 6, 8]. range(5) generates 0, 1, 2, 3, 4, and each is multiplied by 2. So: 0*2=0, 1*2=2, 2*2=4, 3*2=6, 4*2=8. List comprehensions transform each item according to the expression."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-05-q14",
              "title": "What's the difference between these two?\n\nA: [x for x in nums if x > 0]\nB: [x if x > 0 else 0 for x in nums]",
              "description": "What's the difference between these two?\n\nA: [x for x in nums if x > 0]\nB: [x if x > 0 else 0 for x in nums]",
              "options": [
                "They're identical",
                "A filters items, B transforms all items",
                "A transforms, B filters",
                "Neither will work"
              ],
              "correctAnswer": 1,
              "explanation": "A filters (keeps only positive numbers, removes others). B transforms ALL items: positive numbers stay as-is, but non-positive become 0. The 'if' at the END (A) is a filter. The 'if-else' BEFORE the 'for' (B) is a conditional expression transforming every item."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-05-q15",
              "title": "Which comprehension gets only even numbers from 0-9?",
              "description": "Which comprehension gets only even numbers from 0-9?",
              "options": [
                "[x for x in range(10)]",
                "[x for x in range(10) if x % 2 == 0]",
                "[x if x % 2 == 0 for x in range(10)]",
                "[x % 2 == 0 for x in range(10)]"
              ],
              "correctAnswer": 1,
              "explanation": "Option B is correct: [x for x in range(10) if x % 2 == 0]. The 'if' at the end filters, keeping only items where x % 2 == 0 (even numbers). Result: [0, 2, 4, 6, 8]. Option C would cause a syntax error (if without else)."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-05-q16",
              "title": "What does this do?\n\nflat = [num for row in matrix for num in row]",
              "description": "What does this do?\n\nflat = [num for row in matrix for num in row]",
              "options": [
                "Creates a syntax error",
                "Flattens a 2D list into a 1D list",
                "Creates a 2D list",
                "Transposes the matrix"
              ],
              "correctAnswer": 1,
              "explanation": "This flattens a 2D list! For a matrix [[1,2], [3,4]], this produces [1, 2, 3, 4]. Read as: 'For each row in matrix, for each num in row, take num'. It's a nested comprehension that extracts all values from nested lists."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-05-q17",
              "title": "What will this output?\n\nwords = ['hi', 'hello', 'hey']\nlengths = [len(word) for word in words]\nprint(lengths)",
              "description": "What will this output?\n\nwords = ['hi', 'hello', 'hey']\nlengths = [len(word) for word in words]\nprint(lengths)",
              "options": [
                "['hi', 'hello', 'hey']",
                "[2, 5, 3]",
                "8",
                "3"
              ],
              "correctAnswer": 1,
              "explanation": "This prints [2, 5, 3]. The comprehension creates a new list where each item is the LENGTH of the corresponding word. len('hi')=2, len('hello')=5, len('hey')=3. This is a common pattern: transform list items using a function."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-05-q18",
              "title": "What's wrong with using list comprehensions for side effects?\n\n[print(x) for x in numbers]",
              "description": "What's wrong with using list comprehensions for side effects?\n\n[print(x) for x in numbers]",
              "options": [
                "Nothing is wrong",
                "Creates a wasteful list of None values",
                "print() doesn't work in comprehensions",
                "Syntax error"
              ],
              "correctAnswer": 1,
              "explanation": "Option B is correct: it creates a wasteful list of None values (since print() returns None). List comprehensions are for CREATING lists, not for side effects like printing. For side effects, use a regular for loop: 'for x in numbers: print(x)'."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-05-q19",
              "title": "For a list of 5 items, what is the last valid positive index?",
              "description": "For a list of 5 items, what is the last valid positive index?",
              "options": [
                "5",
                "4",
                "6",
                "-1"
              ],
              "correctAnswer": 1,
              "explanation": "The last valid positive index is 4 (len(list) - 1 = 5 - 1 = 4). Indices go from 0 to 4 for a 5-item list. Index 5 would cause IndexError. Note: -1 is also valid and refers to the last item, but the question asks for positive index."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-05-q20",
              "title": "When should you use a tuple instead of a list?",
              "description": "When should you use a tuple instead of a list?",
              "options": [
                "When data won't change",
                "For dictionary keys",
                "For faster iteration",
                "All of the above"
              ],
              "correctAnswer": 3,
              "explanation": "All of the above! Use tuples when: (1) Data is fixed and won't change (coordinates, RGB values), (2) You need it as a dictionary key (only immutable types can be keys), (3) Performance matters (tuples are faster and use less memory). Lists are for data that changes, tuples for fixed data."
            }
          ]
        }
      ]
    },
    {
      "id": "module-06",
      "title": "Module 6",
      "description": "Python programming fundamentals - Module 6",
      "difficulty": "intermediate",
      "estimatedHours": 0,
      "lessons": [],
      "quizzes": [
        {
          "id": "quiz-06",
          "title": "Module 6 Quiz: Functions",
          "description": "Test your mastery of functions: function basics, parameters, return values, scope, default/keyword arguments, lambda functions, and built-in functions. You need 14/20 correct (70%) to pass.",
          "moduleId": "module-06",
          "passingScore": 70,
          "estimatedMinutes": 15,
          "questions": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-06-q1",
              "title": "What is the correct syntax to define a function named 'calculate' in Python?",
              "description": "What is the correct syntax to define a function named 'calculate' in Python?",
              "options": [
                "function calculate():",
                "def calculate():",
                "func calculate:",
                "define calculate():"
              ],
              "correctAnswer": 1,
              "explanation": "Use 'def calculate():' to define a function. 'def' is the keyword for defining functions, followed by the function name, parentheses (even if empty), and a colon. The function body must be indented."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-06-q2",
              "title": "What happens when you define a function but don't call it?\n\ndef greet():\n    print('Hello')",
              "description": "What happens when you define a function but don't call it?\n\ndef greet():\n    print('Hello')",
              "options": [
                "The function code runs immediately",
                "Python stores the function but doesn't execute it",
                "You get an error",
                "The function is automatically called once"
              ],
              "correctAnswer": 1,
              "explanation": "When you define a function, Python stores it in memory but doesn't execute it. The code inside only runs when you explicitly CALL the function using 'greet()'. Defining is like writing a recipe, calling is like cooking it."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-06-q3",
              "title": "What's the difference between parameters and arguments?",
              "description": "What's the difference between parameters and arguments?",
              "options": [
                "They're the same thing",
                "Parameters are in the definition, arguments are values passed when calling",
                "Parameters are for strings, arguments are for numbers",
                "Arguments are in the definition, parameters are when calling"
              ],
              "correctAnswer": 1,
              "explanation": "PARAMETERS are variables in the function DEFINITION (def greet(name):). ARGUMENTS are the actual VALUES passed when CALLING (greet('Alice')). Think: parameters are placeholders, arguments are the real data that fills them."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-06-q4",
              "title": "What does this function return?\n\ndef calculate(x):\n    result = x * 3\n    print(result)\n\nvalue = calculate(5)",
              "description": "What does this function return?\n\ndef calculate(x):\n    result = x * 3\n    print(result)\n\nvalue = calculate(5)",
              "options": [
                "15",
                "None",
                "5",
                "Error"
              ],
              "correctAnswer": 1,
              "explanation": "This function returns None because there's no 'return' statement! It PRINTS 15 to the screen, but 'value' will be None. Functions without 'return' automatically return None. To fix: add 'return result' at the end."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-06-q5",
              "title": "What is the scope of a variable created inside a function?",
              "description": "What is the scope of a variable created inside a function?",
              "options": [
                "Global - accessible everywhere",
                "Local - only inside that function",
                "Module - accessible in the whole file",
                "Protected - needs special access"
              ],
              "correctAnswer": 1,
              "explanation": "Variables created INSIDE a function have LOCAL scope - they only exist inside that function and disappear when it returns. They can't be accessed from outside. This prevents functions from interfering with each other's variables."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-06-q6",
              "title": "What happens if you assign to a variable inside a function that has the same name as a global variable?",
              "description": "What happens if you assign to a variable inside a function that has the same name as a global variable?",
              "options": [
                "You modify the global variable",
                "You get a syntax error",
                "You create a new local variable that shadows the global",
                "Python asks which one you meant"
              ],
              "correctAnswer": 2,
              "explanation": "You create a NEW LOCAL variable that SHADOWS (hides) the global one. Inside the function, you'll use the local version. The global variable remains unchanged. This is Python's default behavior to protect globals from accidental modification."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-06-q7",
              "title": "When does a local variable's lifetime end?",
              "description": "When does a local variable's lifetime end?",
              "options": [
                "When the program ends",
                "When the function returns",
                "After 60 seconds",
                "When you explicitly delete it"
              ],
              "correctAnswer": 1,
              "explanation": "Local variables die (are removed from memory) when the function RETURNS. They're created when the function is called and destroyed when it ends. This automatic cleanup is a benefit of local scope - Python manages the memory for you."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-06-q8",
              "title": "What does this function call do?\n\ndef greet(name, greeting='Hello'):\n    print(f'{greeting}, {name}!')\n\ngreet('Alice')",
              "description": "What does this function call do?\n\ndef greet(name, greeting='Hello'):\n    print(f'{greeting}, {name}!')\n\ngreet('Alice')",
              "options": [
                "Causes an error - missing argument",
                "Prints 'Hello, Alice!'",
                "Prints ', Alice!'",
                "Prints 'greeting, Alice!'"
              ],
              "correctAnswer": 1,
              "explanation": "Prints 'Hello, Alice!' because 'greeting' has a DEFAULT value of 'Hello'. When you don't provide a value for 'greeting', Python uses the default. Default arguments make parameters optional with sensible fallback values."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-06-q9",
              "title": "Which function call is INVALID?\n\ndef create_user(name, email, age=18):\n    pass",
              "description": "Which function call is INVALID?\n\ndef create_user(name, email, age=18):\n    pass",
              "options": [
                "create_user('Alice', 'a@email.com')",
                "create_user('Alice', 'a@email.com', 25)",
                "create_user(name='Alice', email='a@email.com')",
                "create_user('Alice', age=25)"
              ],
              "correctAnswer": 3,
              "explanation": "Option D is INVALID because it's missing the REQUIRED parameter 'email'. 'name' and 'email' have no defaults so they're required. 'age' has a default so it's optional. You must provide all required parameters when calling."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-06-q10",
              "title": "What happens if you use a positional argument after a keyword argument?\n\ngreet(name='Alice', 'Hi')",
              "description": "What happens if you use a positional argument after a keyword argument?\n\ngreet(name='Alice', 'Hi')",
              "options": [
                "It works fine",
                "SyntaxError - positional after keyword",
                "The keyword is ignored",
                "Both become keyword arguments"
              ],
              "correctAnswer": 1,
              "explanation": "You get a SyntaxError! Once you use a keyword argument (name='Alice'), ALL following arguments must also be keyword arguments. You can't go back to positional. Rule: positional arguments must come BEFORE keyword arguments."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-06-q11",
              "title": "Why should you avoid using an empty list [] as a default argument?",
              "description": "Why should you avoid using an empty list [] as a default argument?",
              "options": [
                "It causes a syntax error",
                "Lists can't be default arguments",
                "The same list object is shared across all function calls",
                "It makes the function slower"
              ],
              "correctAnswer": 2,
              "explanation": "The SAME list object is shared across ALL calls! Mutable defaults (lists, dicts) are created ONCE when the function is defined, not each time it's called. Data from previous calls persists, causing bugs. Use 'None' as default and create a new list inside the function."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-06-q12",
              "title": "What is a lambda function?",
              "description": "What is a lambda function?",
              "options": [
                "A function from the Lambda library",
                "An anonymous function defined in a single expression",
                "A faster version of regular functions",
                "A function that can only take one parameter"
              ],
              "correctAnswer": 1,
              "explanation": "A lambda is an ANONYMOUS (unnamed) function defined in a SINGLE EXPRESSION. It's a shortcut for simple functions: 'lambda x: x * 2' is equivalent to 'def func(x): return x * 2'. Use for simple operations, especially with map/filter/sorted."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-06-q13",
              "title": "What's the correct lambda function to double a number?",
              "description": "What's the correct lambda function to double a number?",
              "options": [
                "lambda x: x * 2",
                "lambda: x * 2",
                "lambda x return x * 2",
                "lambda (x): x * 2"
              ],
              "correctAnswer": 0,
              "explanation": "The correct syntax is 'lambda x: x * 2'. Format: lambda parameters: expression. No parentheses around parameter, no 'return' keyword (it's implicit), just a colon and the expression. The result is automatically returned."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-06-q14",
              "title": "What does map() do?\n\nnumbers = [1, 2, 3]\nresult = list(map(lambda x: x * 2, numbers))",
              "description": "What does map() do?\n\nnumbers = [1, 2, 3]\nresult = list(map(lambda x: x * 2, numbers))",
              "options": [
                "Filters items that match a condition",
                "Applies a function to every item in the list",
                "Sorts the list",
                "Finds the maximum value"
              ],
              "correctAnswer": 1,
              "explanation": "map() APPLIES A FUNCTION to EVERY ITEM in a list. Here, it doubles each number: [1, 2, 3] becomes [2, 4, 6]. It's like a list comprehension: [x * 2 for x in numbers]. Returns a map object, so use list() to convert."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-06-q15",
              "title": "What does filter() do?\n\nnumbers = [1, 2, 3, 4, 5]\nresult = list(filter(lambda x: x > 3, numbers))",
              "description": "What does filter() do?\n\nnumbers = [1, 2, 3, 4, 5]\nresult = list(filter(lambda x: x > 3, numbers))",
              "options": [
                "[1, 2, 3]",
                "[4, 5]",
                "[True, True, False, False, False]",
                "[2, 3, 4, 5, 6]"
              ],
              "correctAnswer": 1,
              "explanation": "filter() KEEPS ONLY items where the function returns True. The lambda 'x > 3' is True for 4 and 5, so result is [4, 5]. It doesn't transform items (that's map's job), just decides which to keep. Like: [x for x in numbers if x > 3]."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-06-q16",
              "title": "What does the 'key' parameter do in sorted()?\n\nwords = ['apple', 'pie', 'banana']\nsorted(words, key=lambda w: len(w))",
              "description": "What does the 'key' parameter do in sorted()?\n\nwords = ['apple', 'pie', 'banana']\nsorted(words, key=lambda w: len(w))",
              "options": [
                "Filters words that don't match",
                "Determines what value to compare when sorting",
                "Encrypts the words",
                "Reverses the sorting order"
              ],
              "correctAnswer": 1,
              "explanation": "The 'key' parameter specifies what VALUE to COMPARE when sorting. Here, 'lambda w: len(w)' extracts the length, so words are sorted by length: ['pie', 'apple', 'banana'] (3, 5, 6 chars). Without key, it would sort alphabetically."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-06-q17",
              "title": "When should you use a lambda function instead of def?",
              "description": "When should you use a lambda function instead of def?",
              "options": [
                "Always - lambdas are better",
                "For simple, one-expression functions used once",
                "For complex functions with multiple statements",
                "Never - def is always better"
              ],
              "correctAnswer": 1,
              "explanation": "Use lambda for SIMPLE, ONE-EXPRESSION functions used ONCE (especially with map/filter/sorted). Use 'def' for: complex logic, multiple statements, functions needing docstrings, or functions used in many places. Lambda = quick and simple, def = reusable and documented."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-06-q18",
              "title": "What can't a lambda function do that a regular function can?",
              "description": "What can't a lambda function do that a regular function can?",
              "options": [
                "Take parameters",
                "Return values",
                "Have multiple statements and docstrings",
                "Be assigned to a variable"
              ],
              "correctAnswer": 2,
              "explanation": "Lambda functions are LIMITED to a SINGLE EXPRESSION - they can't have multiple statements, assignments, docstrings, or explicit 'return'. Regular functions can have all of these. Both can take parameters, return values, and be assigned to variables."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-06-q19",
              "title": "What should a professional function include?",
              "description": "What should a professional function include?",
              "options": [
                "Just a name and some code",
                "A descriptive name, docstring, validation, and meaningful return value",
                "Only a return statement",
                "Global variables for sharing data"
              ],
              "correctAnswer": 1,
              "explanation": "Professional functions need: (1) Clear descriptive name, (2) Comprehensive docstring explaining purpose/parameters/returns, (3) Input validation for edge cases, (4) Meaningful return values. This makes functions reusable, maintainable, testable, and easy to understand."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-06-q20",
              "title": "What does 'if __name__ == \"__main__\":' do?",
              "description": "What does 'if __name__ == \"__main__\":' do?",
              "options": [
                "Checks if the function name is 'main'",
                "Code only runs when file is executed directly, not when imported",
                "Creates a main function",
                "Required for all Python programs"
              ],
              "correctAnswer": 1,
              "explanation": "Code inside 'if __name__ == \"__main__\":' only runs when the file is EXECUTED DIRECTLY (python file.py), NOT when imported as a module. Perfect for test code - the functions are available for import, but tests don't run automatically. Not required, but very useful."
            }
          ]
        }
      ]
    },
    {
      "id": "module-07",
      "title": "Module 7",
      "description": "Python programming fundamentals - Module 7",
      "difficulty": "intermediate",
      "estimatedHours": 0,
      "lessons": [],
      "quizzes": [
        {
          "id": "quiz-07",
          "title": "Module 7 Quiz: Dictionaries & Sets",
          "description": "Test your mastery of dictionaries and sets: creating, accessing, methods, nested structures, sets, and comprehensions. You need 14/20 correct (70%) to pass.",
          "moduleId": "module-07",
          "passingScore": 70,
          "estimatedMinutes": 15,
          "questions": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-07-q1",
              "title": "What is the correct syntax to create a dictionary with key 'name' and value 'Alice'?",
              "description": "What is the correct syntax to create a dictionary with key 'name' and value 'Alice'?",
              "options": [
                "person = ['name': 'Alice']",
                "person = {'name': 'Alice'}",
                "person = ('name': 'Alice')",
                "person = name: 'Alice'"
              ],
              "correctAnswer": 1,
              "explanation": "Use CURLY BRACES {} with key:value pairs: person = {'name': 'Alice'}. Square brackets [] are for lists, parentheses () are for tuples. The colon : separates key from value in dictionaries."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-07-q2",
              "title": "What does dict.get('key', 'default') return if 'key' doesn't exist?",
              "description": "What does dict.get('key', 'default') return if 'key' doesn't exist?",
              "options": [
                "Raises KeyError",
                "Returns None",
                "Returns 'default'",
                "Returns an empty string"
              ],
              "correctAnswer": 2,
              "explanation": "Returns 'default' if the key doesn't exist. This is the safe way to access dictionary values without risking KeyError. Without the second argument, .get() would return None. It NEVER raises KeyError - that's the point!"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-07-q3",
              "title": "Which method adds all items from one dictionary to another?",
              "description": "Which method adds all items from one dictionary to another?",
              "options": [
                ".add()",
                ".update()",
                ".merge()",
                ".append()"
              ],
              "correctAnswer": 1,
              "explanation": ".update() merges dictionaries. dict1.update(dict2) adds all key-value pairs from dict2 into dict1. If keys exist, values are overwritten. .add() is for sets, .append() is for lists, and .merge() doesn't exist."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-07-q4",
              "title": "What does dict.pop('key', default) do?",
              "description": "What does dict.pop('key', default) do?",
              "options": [
                "Returns the value only",
                "Removes the key and returns its value",
                "Removes the key but doesn't return anything",
                "Creates a new key"
              ],
              "correctAnswer": 1,
              "explanation": ".pop() REMOVES the key from the dictionary AND RETURNS its value. It's two operations in one: remove + get. If key doesn't exist and default is provided, returns default without error. If no default and key missing, raises KeyError."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-07-q5",
              "title": "How do you iterate over both keys and values in a dictionary?",
              "description": "How do you iterate over both keys and values in a dictionary?",
              "options": [
                "for key, value in dict:",
                "for key, value in dict.items():",
                "for key, value in dict.pairs():",
                "for key, value in dict.keys(), dict.values():"
              ],
              "correctAnswer": 1,
              "explanation": "Use .items(): for key, value in dict.items():. This returns (key, value) tuples that you can unpack. .pairs() doesn't exist, and option D doesn't work syntactically. .items() is the standard way to loop over dictionaries."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-07-q6",
              "title": "How do you access a nested dictionary value?\ndata = {'user': {'name': 'Alice', 'age': 25}}",
              "description": "How do you access a nested dictionary value?\ndata = {'user': {'name': 'Alice', 'age': 25}}",
              "options": [
                "data['user.name']",
                "data['user']['name']",
                "data.user.name",
                "data['user', 'name']"
              ],
              "correctAnswer": 1,
              "explanation": "Use CHAINED BRACKETS: data['user']['name']. First bracket gets the inner dictionary, second bracket gets the value from that dictionary. Navigate level by level with separate brackets, not dots or comma syntax."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-07-q7",
              "title": "What's the safe way to access deeply nested values?\nuser = {'contact': {'email': 'test@example.com'}}",
              "description": "What's the safe way to access deeply nested values?\nuser = {'contact': {'email': 'test@example.com'}}",
              "options": [
                "user['contact']['phone']",
                "user.get('contact').get('phone')",
                "user.get('contact', {}).get('phone', 'N/A')",
                "user['contact'].get('phone', 'N/A')"
              ],
              "correctAnswer": 2,
              "explanation": "Chain .get() with defaults: user.get('contact', {}).get('phone', 'N/A'). If 'contact' doesn't exist, returns {}, then .get('phone') on that returns 'N/A'. This NEVER crashes. Options A and D crash if keys missing. Option B crashes if .get('contact') returns None."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-07-q8",
              "title": "What makes a set different from a list?",
              "description": "What makes a set different from a list?",
              "options": [
                "Sets are faster",
                "Sets only store unique items and have no order",
                "Sets can only store numbers",
                "Sets are immutable"
              ],
              "correctAnswer": 1,
              "explanation": "Sets store UNIQUE items (no duplicates) and have NO ORDER (can't index). Lists allow duplicates and maintain order. Both are mutable. Sets can store any immutable type (not just numbers). The uniqueness and lack of order are the key differences."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-07-q9",
              "title": "How do you create an empty set?",
              "description": "How do you create an empty set?",
              "options": [
                "empty = {}",
                "empty = set()",
                "empty = []",
                "empty = ()"
              ],
              "correctAnswer": 1,
              "explanation": "Use set() to create an empty set. {} creates an empty DICTIONARY (not set!), [] creates a list, () creates a tuple. This is a common gotcha - {} is ambiguous, so Python treats it as a dict."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-07-q10",
              "title": "What does set1 & set2 do?",
              "description": "What does set1 & set2 do?",
              "options": [
                "Combines all items from both sets (union)",
                "Returns items in BOTH sets (intersection)",
                "Returns items in set1 but not set2 (difference)",
                "Creates an error"
              ],
              "correctAnswer": 1,
              "explanation": "The & operator returns the INTERSECTION - items in BOTH sets. If set1 = {1, 2, 3} and set2 = {2, 3, 4}, then set1 & set2 = {2, 3}. Use | for union, - for difference."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-07-q11",
              "title": "What does set1 | set2 do?",
              "description": "What does set1 | set2 do?",
              "options": [
                "Returns items in both sets (intersection)",
                "Returns items in set1 but not set2 (difference)",
                "Returns all items from both sets (union)",
                "Divides the sets"
              ],
              "correctAnswer": 2,
              "explanation": "The | operator returns the UNION - ALL items from BOTH sets (no duplicates). If set1 = {1, 2} and set2 = {2, 3}, then set1 | set2 = {1, 2, 3}. Use & for intersection, - for difference."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-07-q12",
              "title": "What does set1 - set2 do?",
              "description": "What does set1 - set2 do?",
              "options": [
                "Combines all items",
                "Returns items in both sets",
                "Returns items in set1 but NOT in set2",
                "Subtracts the values"
              ],
              "correctAnswer": 2,
              "explanation": "The - operator returns the DIFFERENCE - items in set1 that are NOT in set2. If set1 = {1, 2, 3} and set2 = {2, 3, 4}, then set1 - set2 = {1}. Note: set1 - set2 ≠ set2 - set1!"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-07-q13",
              "title": "What's the difference between .remove() and .discard() for sets?",
              "description": "What's the difference between .remove() and .discard() for sets?",
              "options": [
                "They're the same",
                ".remove() raises error if item doesn't exist, .discard() doesn't",
                ".discard() is faster",
                ".remove() works on lists only"
              ],
              "correctAnswer": 1,
              "explanation": ".remove() raises KeyError if item doesn't exist. .discard() silently does nothing if item missing. Both remove items from sets. Use .discard() when you're not sure if item exists, .remove() when you expect it to be there."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-07-q14",
              "title": "What does this dictionary comprehension create?\n{x: x**2 for x in range(4)}",
              "description": "What does this dictionary comprehension create?\n{x: x**2 for x in range(4)}",
              "options": [
                "{0, 1, 4, 9}",
                "[0, 1, 4, 9]",
                "{0: 0, 1: 1, 2: 4, 3: 9}",
                "{'x': 'x**2'}"
              ],
              "correctAnswer": 2,
              "explanation": "Creates a DICTIONARY with keys 0-3 mapped to their squares: {0: 0, 1: 1, 2: 4, 3: 9}. The key:value format makes it a dict comprehension. Option A would be a set (no colons), B would be a list (uses [])."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-07-q15",
              "title": "What's the difference between {x*2 for x in nums} and {x: x*2 for x in nums}?",
              "description": "What's the difference between {x*2 for x in nums} and {x: x*2 for x in nums}?",
              "options": [
                "They're the same",
                "First creates a set, second creates a dict",
                "First creates a list, second creates a dict",
                "Both create dicts"
              ],
              "correctAnswer": 1,
              "explanation": "First creates a SET {2, 4, 6...} (single expression), second creates a DICT {1: 2, 2: 4, 3: 6...} (key:value pairs). The COLON : is what distinguishes dict comprehensions from set comprehensions. Both use curly braces {}."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-07-q16",
              "title": "How do you filter a dictionary using comprehension?\nscores = {'Alice': 85, 'Bob': 55, 'Carol': 92}",
              "description": "How do you filter a dictionary using comprehension?\nscores = {'Alice': 85, 'Bob': 55, 'Carol': 92}",
              "options": [
                "{k: v for k, v in scores if v >= 60}",
                "{k: v for k, v in scores.items() if v >= 60}",
                "{k, v for k, v in scores.items() if v >= 60}",
                "{scores if v >= 60}"
              ],
              "correctAnswer": 1,
              "explanation": "Use .items() with if condition: {k: v for k, v in scores.items() if v >= 60}. Must use .items() to get key-value pairs. Option A is missing .items(), option C is missing the colon, option D is nonsense."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-07-q17",
              "title": "What does this set comprehension do?\n{len(word) for word in ['hi', 'hello', 'hi']}",
              "description": "What does this set comprehension do?\n{len(word) for word in ['hi', 'hello', 'hi']}",
              "options": [
                "Creates {2, 5, 2}",
                "Creates {2, 5}",
                "Creates [2, 5, 2]",
                "Creates an error"
              ],
              "correctAnswer": 1,
              "explanation": "Creates {2, 5} - a SET of unique lengths. Even though 'hi' appears twice (length 2), sets automatically remove duplicates. Result contains only unique values: 2 and 5. Not a list (would need []), and sets don't store duplicates."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-07-q18",
              "title": "When should you use a traditional loop instead of a comprehension?",
              "description": "When should you use a traditional loop instead of a comprehension?",
              "options": [
                "Never - comprehensions are always better",
                "When logic is complex or you need side effects (like printing)",
                "When you have more than 5 items",
                "When you want it to run slower"
              ],
              "correctAnswer": 1,
              "explanation": "Use traditional loops when logic is COMPLEX or you need SIDE EFFECTS (printing, modifying external variables). Comprehensions are for simple, clean transformations/filters. If it becomes hard to read or requires multiple lines, use a loop instead. Readability > brevity!"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-07-q19",
              "title": "What's the best data structure for storing tags for a contact where each tag should only appear once?",
              "description": "What's the best data structure for storing tags for a contact where each tag should only appear once?",
              "options": [
                "List",
                "Dictionary",
                "Set",
                "Tuple"
              ],
              "correctAnswer": 2,
              "explanation": "A SET is best for tags because: (1) enforces uniqueness (no duplicate tags), (2) order doesn't matter for tags, (3) fast membership testing ('work' in tags). Lists allow duplicates, dicts need key:value pairs, tuples are immutable."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-07-q20",
              "title": "How would you invert a dictionary (swap keys and values)?",
              "description": "How would you invert a dictionary (swap keys and values)?",
              "options": [
                "dict.invert()",
                "{v: k for k, v in dict.items()}",
                "{k: v.reverse() for k, v in dict.items()}",
                "dict[::-1]"
              ],
              "correctAnswer": 1,
              "explanation": "Use dict comprehension with swapped positions: {v: k for k, v in dict.items()}. This creates a new dict where original values become keys and original keys become values. .invert() doesn't exist, .reverse() is for lists, and slicing doesn't work on dicts."
            }
          ]
        }
      ]
    },
    {
      "id": "module-08",
      "title": "Module 8",
      "description": "Python programming fundamentals - Module 8",
      "difficulty": "intermediate",
      "estimatedHours": 4,
      "lessons": [
        {
          "id": "08_01",
          "title": "Introduction to Exceptions and Error Handling",
          "moduleId": "module-08",
          "order": 1,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Concept: Catching a Falling Vase",
              "content": "Imagine you're juggling expensive vases. Without preparation, if you drop one, it SHATTERS on the floor and the show ends. But what if you placed soft pillows on the floor? The vase might still fall (error happens), but instead of shattering (program crash), it lands safely on the pillow (error is caught and handled), and you can keep juggling (program continues).\n\nThis is **error handling**. Errors WILL happen (users type wrong input, files don't exist, networks fail). The question is: does your program crash spectacularly, or does it catch the error gracefully and continue?\n\n**Real-world scenario:** You're running an ATM program. A user types 'abc' instead of a number for withdrawal amount. Without error handling, the ATM crashes and displays a cryptic error. WITH error handling, it shows \"Please enter a valid number\" and lets them try again. Which would you prefer?"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example: The Crash vs. The Catch",
              "content": "The try block contains code that might fail. If an error occurs, instead of crashing, Python jumps to the matching except block and runs that code instead. The program continues after the except block!",
              "code": "# WITHOUT ERROR HANDLING - Program crashes!\nprint(\"=== Without Error Handling ===\")\nprint(\"Enter your age:\")\n# If user types 'twenty' instead of 20, this crashes:\n# age = int(input())  # Commented to prevent crash in example\n# print(f\"You are {age} years old\")\nprint(\"Program would crash here if user typed 'twenty'\\n\")\n\n# WITH ERROR HANDLING - Program handles it gracefully!\nprint(\"=== With Error Handling ===\")\nprint(\"Enter your age:\")\n\ntry:\n    # This is the \"risky\" code that might fail\n    age_input = \"twenty\"  # Simulating user typing 'twenty'\n    age = int(age_input)  # This will cause an error!\n    print(f\"You are {age} years old\")\nexcept ValueError:\n    # This code runs if the error happens\n    print(\"Oops! That's not a valid number.\")\n    print(\"Please enter your age as a number (e.g., 25)\")\n    age = 25  # Set a default or ask again\n\nprint(\"Program continues running!\")\nprint(f\"Age set to: {age}\")\n\n# Another example: Division by zero\nprint(\"\\n=== Division Example ===\")\n\ntry:\n    result = 10 / 0  # This will cause a ZeroDivisionError!\n    print(f\"Result: {result}\")\nexcept ZeroDivisionError:\n    print(\"Cannot divide by zero!\")\n    print(\"Setting result to 0\")\n    result = 0\n\nprint(f\"Final result: {result}\")\nprint(\"Program finished successfully!\")",
              "language": "python"
            },
            {
              "type": "ANALOGY",
              "title": "Syntax Breakdown: The Safety Net Structure",
              "content": "**Basic try/except structure:**\n```\ntry:\n    # Code that might cause an error\n    risky_operation()\nexcept ErrorType:\n    # Code that runs if that specific error happens\n    handle_the_error()\n```\n\n**The flow:**\n1. Python tries to run code in the `try` block\n2. If NO error: except block is skipped, program continues\n3. If error happens: Python immediately jumps to the matching `except` block\n4. After except block finishes: program continues normally\n\n**Key terms explained:**\n- **Exception:** Python's technical term for an error that happens while the program runs (not a syntax error)\n- **ValueError:** A type of exception that happens when you try to convert invalid data (like \"abc\" to an integer)\n- **ZeroDivisionError:** Exception when dividing by zero\n- **try block:** The \"risky\" code you want to protect\n- **except block:** The \"safety net\" that catches the error\n\n**Syntax errors vs. Exceptions:**\n- **Syntax Error:** Code written wrong (missing colon, wrong indentation). Python won't even start running.\n- **Exception:** Code is written correctly, but something goes wrong during execution (file doesn't exist, network fails, wrong data type). This is what try/except handles.\n\n**Example:**\n```python\nif True  # Syntax error - missing colon, won't run at all\n\nint(\"abc\")  # Valid syntax, but raises ValueError exception when it runs\n```"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "- **Exceptions are runtime errors** that happen when code runs (not syntax errors). Without handling, they crash your program.\n- **try/except blocks** let you catch exceptions and handle them gracefully instead of crashing. The program continues running after the except block.\n- **try block** contains risky code that might fail. **except block** contains the code to run if an error occurs.\n- **Always specify the exception type** in except blocks (like ValueError, ZeroDivisionError). Don't use bare except: clauses.\n- **Common exceptions:** ValueError (invalid data conversion), ZeroDivisionError (dividing by zero), TypeError (wrong data type).\n- **Error handling makes programs robust** - they can handle unexpected situations without crashing, providing better user experience.\n- **The flow:** Try runs first → if error, jump to except → after except, program continues normally. If no error, except is skipped entirely."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "08_01-challenge-3",
              "title": "Interactive Exercise: Build a Safe Number Converter",
              "description": "Create a program that asks the user for a number and converts it safely. If they enter invalid input, give them a friendly message and use a default value of 0.\n\n**Your task:**\n1. Create a try/except block\n2. Try to convert user input to an integer\n3. If it fails (ValueError), print a helpful message\n4. Use a default value of 0 if conversion fails\n5. Print the final number\n\n**Starter code:**",
              "instructions": "Create a program that asks the user for a number and converts it safely. If they enter invalid input, give them a friendly message and use a default value of 0.\n\n**Your task:**\n1. Create a try/except block\n2. Try to convert user input to an integer\n3. If it fails (ValueError), print a helpful message\n4. Use a default value of 0 if conversion fails\n5. Print the final number\n\n**Starter code:**",
              "starterCode": "# Safe number converter\nprint(\"Enter a number:\")\nuser_input = \"not a number\"  # Simulate user input\n\n# TODO: Add try block here\n# TODO: Try to convert user_input to an integer\nnumber = ???\n\n# TODO: Add except ValueError block here\n# TODO: Print helpful message and set number = 0\n\nprint(f\"The number is: {number}\")",
              "solution": "",
              "language": "python",
              "testCases": [
                {
                  "description": "Code runs without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use try: followed by number = int(user_input), then except ValueError: with a friendly message and number = 0."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "08_02",
          "title": "Try/Except/Finally Blocks - Complete Error Handling",
          "moduleId": "module-08",
          "order": 2,
          "estimatedMinutes": 30,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Concept: The Complete Safety Protocol",
              "content": "Imagine you're a lab scientist handling dangerous chemicals:\n\n**TRY:** You attempt the experiment (risky operation)\n**EXCEPT:** If something goes wrong (chemical spills), you have specific protocols for each type of emergency (fire = fire extinguisher, spill = neutralizer)\n**ELSE:** If the experiment succeeds without incident, you record the successful results\n**FINALLY:** No matter what happened (success or disaster), you ALWAYS wash your hands, turn off equipment, and lock the lab before leaving\n\nThe **finally block** is the key new concept here. It runs NO MATTER WHAT - whether the try succeeded, failed, or even if you return early. It's for cleanup code that MUST happen.\n\n**Real-world scenarios:**\n- Opening a file: Finally block ensures the file is closed, even if reading fails\n- Database connection: Finally ensures disconnection, even if query fails\n- Network request: Finally ensures connection is closed properly\n\nThink of finally as the \"no matter what\" code - code so important it runs even if the program is about to crash or return."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example: The Complete Structure",
              "content": "The complete structure:\n1. **try**: Attempt the risky operation\n2. **except**: Handle specific errors (can have multiple except blocks)\n3. **else**: Runs ONLY if no exception occurred (optional)\n4. **finally**: Runs NO MATTER WHAT - even if there's a return statement (optional but powerful)\n\nNotice how finally runs even when we return early in the except blocks!",
              "code": "# Example 1: File handling with finally\nprint(\"=== File Handling Example ===\")\n\nfile_opened = False\ntry:\n    print(\"Attempting to read file...\")\n    # Simulating file operations\n    filename = \"data.txt\"\n    print(f\"Opening {filename}\")\n    file_opened = True\n    \n    # Simulate processing - this might fail!\n    # Uncomment next line to simulate an error:\n    # raise ValueError(\"Data format error!\")\n    \n    print(\"Processing file data...\")\n    print(\"File processed successfully!\")\n    \nexcept FileNotFoundError:\n    print(\"ERROR: File not found!\")\n    print(\"Please check the filename and try again.\")\n    \nexcept ValueError as e:\n    print(f\"ERROR: Invalid data in file: {e}\")\n    print(\"File may be corrupted.\")\n    \nelse:\n    # This runs ONLY if NO exception occurred\n    print(\"SUCCESS: All operations completed without errors!\")\n    print(\"Ready to use the data.\")\n    \nfinally:\n    # This runs NO MATTER WHAT - success, error, or return\n    print(\"\\n--- CLEANUP (Finally block) ---\")\n    if file_opened:\n        print(\"Closing file...\")\n        print(\"File closed successfully.\")\n    print(\"Cleanup complete!\")\n    print(\"--- End of operation ---\\n\")\n\n# Example 2: Division with complete error handling\nprint(\"=== Division Calculator ===\")\n\ndef safe_divide(a, b):\n    result = None\n    try:\n        print(f\"Attempting to divide {a} by {b}\")\n        result = a / b\n        \n    except ZeroDivisionError:\n        print(\"ERROR: Cannot divide by zero!\")\n        return None\n        \n    except TypeError:\n        print(\"ERROR: Both values must be numbers!\")\n        return None\n        \n    else:\n        # Runs only if division succeeded\n        print(f\"Division successful: {a} / {b} = {result}\")\n        \n    finally:\n        # Runs no matter what - even if we returned early!\n        print(\"[Finally: Logging this operation to system]\")\n        \n    return result\n\n# Test cases\nprint(\"Test 1: Normal division\")\nresult1 = safe_divide(10, 2)\nprint(f\"Result: {result1}\\n\")\n\nprint(\"Test 2: Division by zero\")\nresult2 = safe_divide(10, 0)\nprint(f\"Result: {result2}\\n\")\n\nprint(\"Test 3: Invalid type\")\nresult3 = safe_divide(10, \"two\")\nprint(f\"Result: {result3}\")",
              "language": "python"
            },
            {
              "type": "ANALOGY",
              "title": "Syntax Breakdown: The Four Parts",
              "content": "**Complete try/except/else/finally structure:**\n```python\ntry:\n    # Risky code that might fail\n    risky_operation()\n    \nexcept SpecificError1:\n    # Handle this specific error\n    handle_error_1()\n    \nexcept SpecificError2:\n    # Handle a different error\n    handle_error_2()\n    \nelse:\n    # Runs ONLY if NO exception occurred\n    success_operations()\n    \nfinally:\n    # Runs NO MATTER WHAT\n    cleanup_code()\n```\n\n**When each part runs:**\n\n**try block:**\n- ALWAYS runs first\n- Stops at the first exception\n\n**except blocks:**\n- Run ONLY if an exception occurs in try\n- Python checks each except block in order\n- Only the FIRST matching except runs\n- Can have multiple except blocks for different errors\n\n**else block (optional):**\n- Runs ONLY if try completed WITHOUT any exception\n- Doesn't run if an exception occurred\n- Good for \"success-only\" code\n- Must come after except blocks, before finally\n\n**finally block (optional):**\n- Runs NO MATTER WHAT happens\n- Runs after try succeeds\n- Runs after except handles error\n- Runs even if there's a return statement\n- Runs even if a new exception occurs\n- Perfect for cleanup: closing files, releasing resources, logging\n\n**Multiple except blocks syntax:**\n```python\nexcept ValueError:\n    # Handle ValueError\n    \nexcept ZeroDivisionError:\n    # Handle ZeroDivisionError\n    \nexcept (TypeError, KeyError):  # Multiple in one block\n    # Handle either TypeError or KeyError\n```\n\n**Capturing the exception object:**\n```python\nexcept ValueError as e:\n    print(f\"Error details: {e}\")\n    # 'e' contains the exception object with error info\n```"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "- **Complete structure order:** try → except(s) → else (optional) → finally (optional). This order is mandatory.\n- **Multiple except blocks** let you handle different exceptions differently. Python checks them in order and runs the first match.\n- **else block** runs ONLY if try completed without any exception. Perfect for 'success-only' operations.\n- **finally block** runs NO MATTER WHAT - success, error, return, break, or continue. Guaranteed to execute.\n- **Use finally for cleanup:** Closing files, releasing resources, logging, disconnecting from databases - anything that MUST happen.\n- **Capture exception details** with 'as': except ValueError as e: lets you access the error message and details.\n- **Finally runs even with return:** If you return in try or except, finally still runs before the function actually returns.\n- **Common exception types:** IndexError (list index out of range), TypeError (wrong type), ValueError (wrong value), FileNotFoundError (file doesn't exist)."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "08_02-challenge-3",
              "title": "Interactive Exercise: Build a Safe List Accessor",
              "description": "Create a function that safely accesses a list element by index. Handle multiple types of errors:\n- IndexError if index is out of range\n- TypeError if index is not an integer\n- Use else block to print success message\n- Use finally block to log the attempt\n\n**Your task:**\n1. Create a try block that accesses the list at the given index\n2. Add except block for IndexError\n3. Add except block for TypeError\n4. Add else block for successful access\n5. Add finally block to log the attempt\n\n**Test with:** my_list = [10, 20, 30, 40, 50]\n\n**Starter code:**",
              "instructions": "Create a function that safely accesses a list element by index. Handle multiple types of errors:\n- IndexError if index is out of range\n- TypeError if index is not an integer\n- Use else block to print success message\n- Use finally block to log the attempt\n\n**Your task:**\n1. Create a try block that accesses the list at the given index\n2. Add except block for IndexError\n3. Add except block for TypeError\n4. Add else block for successful access\n5. Add finally block to log the attempt\n\n**Test with:** my_list = [10, 20, 30, 40, 50]\n\n**Starter code:**",
              "starterCode": "def safe_get_item(items, index):\n    result = None\n    \n    # TODO: Add try block\n    # TODO: Try to access items[index]\n    \n    # TODO: Add except IndexError block\n    # Print error message and return None\n    \n    # TODO: Add except TypeError block\n    # Print error message and return None\n    \n    # TODO: Add else block\n    # Print success message\n    \n    # TODO: Add finally block\n    # Print log message about the attempt\n    \n    return result\n\n# Test cases\nmy_list = [10, 20, 30, 40, 50]\nprint(safe_get_item(my_list, 2))   # Valid index\nprint(safe_get_item(my_list, 10))  # Out of range\nprint(safe_get_item(my_list, \"a\")) # Wrong type",
              "solution": "",
              "language": "python",
              "testCases": [
                {
                  "description": "Code runs without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Structure: try → access items[index] → except IndexError → except TypeError → else → finally. Remember to set result in the try block!"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "08_03",
          "title": "Exception Types and Handling Multiple Exceptions",
          "moduleId": "module-08",
          "order": 3,
          "estimatedMinutes": 30,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Concept: Emergency Response Teams",
              "content": "Imagine a hospital emergency room with specialized teams:\n\n**Specific Teams (Specific Exceptions):**\n- Heart attack → Cardiology team (ValueError)\n- Broken bone → Orthopedics team (IndexError)\n- Poisoning → Toxicology team (TypeError)\n- Burn → Burn unit (ZeroDivisionError)\n\n**General Team (General Exception):**\n- Unknown emergency → General ER doctors (Exception)\n\nYou want the RIGHT team for each emergency. If someone has a heart attack, you call cardiology (catch ValueError), not the general ER (catch Exception). But if you don't know what's wrong, the general ER can help (catch Exception as a fallback).\n\n**Exception Hierarchy** works like hospital departments:\n- **Exception** is the general ER (catches almost everything)\n- **ValueError, TypeError, IndexError** are specialized teams (catch specific problems)\n\nPython has MANY built-in exception types, each for a specific situation. Using the right one makes your error handling precise and your debugging easier.\n\n**Best practice:** Catch specific exceptions you expect (ValueError, FileNotFoundError), not the general Exception class (except as a last resort)."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example: Common Exception Types in Action",
              "content": "Each exception type represents a specific category of error. By catching specific exceptions, you can provide tailored error messages and recovery strategies. The function demonstrates how a single try block can have multiple except blocks to handle different error scenarios.",
              "code": "# Demonstrating common Python exception types\nprint(\"=== Common Exception Types ===\")\n\n# 1. ValueError - Wrong value, right type\nprint(\"\\n1. ValueError Example:\")\ntry:\n    number = int(\"not_a_number\")  # String to int, but invalid format\nexcept ValueError as e:\n    print(f\"ValueError caught: {e}\")\n    print(\"Cause: Trying to convert invalid string to integer\\n\")\n\n# 2. TypeError - Wrong type entirely\nprint(\"2. TypeError Example:\")\ntry:\n    result = \"hello\" + 5  # Can't add string and integer\nexcept TypeError as e:\n    print(f\"TypeError caught: {e}\")\n    print(\"Cause: Incompatible types in operation\\n\")\n\n# 3. IndexError - List index out of range\nprint(\"3. IndexError Example:\")\ntry:\n    my_list = [1, 2, 3]\n    item = my_list[10]  # Only indices 0-2 exist\nexcept IndexError as e:\n    print(f\"IndexError caught: {e}\")\n    print(\"Cause: Accessing index that doesn't exist\\n\")\n\n# 4. KeyError - Dictionary key doesn't exist\nprint(\"4. KeyError Example:\")\ntry:\n    person = {\"name\": \"Alice\", \"age\": 25}\n    email = person[\"email\"]  # Key 'email' doesn't exist\nexcept KeyError as e:\n    print(f\"KeyError caught: {e}\")\n    print(\"Cause: Accessing dictionary key that doesn't exist\\n\")\n\n# 5. ZeroDivisionError - Division by zero\nprint(\"5. ZeroDivisionError Example:\")\ntry:\n    result = 10 / 0\nexcept ZeroDivisionError as e:\n    print(f\"ZeroDivisionError caught: {e}\")\n    print(\"Cause: Attempting to divide by zero\\n\")\n\n# 6. FileNotFoundError - File doesn't exist\nprint(\"6. FileNotFoundError Example:\")\ntry:\n    with open(\"nonexistent_file.txt\", \"r\") as f:\n        content = f.read()\nexcept FileNotFoundError as e:\n    print(f\"FileNotFoundError caught: {e}\")\n    print(\"Cause: Trying to open a file that doesn't exist\\n\")\n\n# 7. AttributeError - Object doesn't have that attribute\nprint(\"7. AttributeError Example:\")\ntry:\n    my_list = [1, 2, 3]\n    my_list.append_all([4, 5])  # Method doesn't exist\nexcept AttributeError as e:\n    print(f\"AttributeError caught: {e}\")\n    print(\"Cause: Calling a method/attribute that doesn't exist\\n\")\n\n# Handling MULTIPLE exception types\nprint(\"=== Handling Multiple Exceptions ===\")\n\ndef process_user_input(user_input, index):\n    \"\"\"Process input with multiple exception handling.\"\"\"\n    numbers = [10, 20, 30, 40, 50]\n    \n    try:\n        # Multiple things can go wrong here!\n        num = int(user_input)  # ValueError if input not a number\n        result = numbers[num]  # IndexError if num out of range\n        division = result / index  # ZeroDivisionError if index is 0\n        return division\n        \n    except ValueError:\n        print(f\"Error: '{user_input}' is not a valid number\")\n        return None\n        \n    except IndexError:\n        print(f\"Error: Index {num} out of range (0-{len(numbers)-1})\")\n        return None\n        \n    except ZeroDivisionError:\n        print(\"Error: Cannot divide by zero\")\n        return None\n\nprint(\"\\nTest 1: Valid input\")\nresult1 = process_user_input(\"2\", 5)\nprint(f\"Result: {result1}\\n\")\n\nprint(\"Test 2: Invalid number format\")\nresult2 = process_user_input(\"abc\", 5)\nprint(f\"Result: {result2}\\n\")\n\nprint(\"Test 3: Index out of range\")\nresult3 = process_user_input(\"10\", 5)\nprint(f\"Result: {result3}\\n\")\n\nprint(\"Test 4: Division by zero\")\nresult4 = process_user_input(\"2\", 0)\nprint(f\"Result: {result4}\")",
              "language": "python"
            },
            {
              "type": "ANALOGY",
              "title": "Syntax Breakdown: Exception Handling Patterns",
              "content": "**Common Built-in Exception Types:**\n\n1. **ValueError:** Correct type, wrong value\n   - int(\"abc\") - can't convert to integer\n   - float(\"not_a_number\")\n   \n2. **TypeError:** Wrong type for operation\n   - \"hello\" + 5 - can't add string and int\n   - len(42) - len() expects iterable, not int\n   \n3. **IndexError:** Sequence index out of range\n   - my_list[100] - index doesn't exist\n   - Works with lists, tuples, strings\n   \n4. **KeyError:** Dictionary key doesn't exist\n   - person[\"email\"] - key not in dict\n   - Use .get() to avoid this\n   \n5. **ZeroDivisionError:** Division or modulo by zero\n   - 10 / 0\n   - 10 % 0\n   \n6. **FileNotFoundError:** File doesn't exist\n   - open(\"missing.txt\")\n   \n7. **AttributeError:** Object lacks attribute/method\n   - \"hello\".non_existent_method()\n   \n8. **NameError:** Variable not defined\n   - print(undefined_variable)\n\n**Handling Multiple Exceptions - Three Patterns:**\n\n**Pattern 1: Separate except blocks (different handling)**\n```python\ntry:\n    risky_code()\nexcept ValueError:\n    handle_value_error()\nexcept TypeError:\n    handle_type_error()\nexcept IndexError:\n    handle_index_error()\n```\n\n**Pattern 2: Multiple exceptions, same handling**\n```python\ntry:\n    risky_code()\nexcept (ValueError, TypeError, IndexError):\n    # Handle all three the same way\n    handle_error()\n```\n\n**Pattern 3: Specific first, general fallback**\n```python\ntry:\n    risky_code()\nexcept ValueError:\n    handle_value_error()  # Specific\nexcept TypeError:\n    handle_type_error()   # Specific\nexcept Exception as e:\n    handle_unknown_error(e)  # General fallback\n```\n\n**Exception Hierarchy (simplified):**\n```\nBaseException\n├── Exception (catch most errors)\n│   ├── ValueError\n│   ├── TypeError\n│   ├── IndexError\n│   ├── KeyError\n│   ├── ZeroDivisionError\n│   ├── FileNotFoundError\n│   ├── AttributeError\n│   └── ... many more\n├── KeyboardInterrupt (Ctrl+C)\n└── SystemExit (sys.exit())\n```\n\n**Best Practices:**\n- Catch SPECIFIC exceptions you expect (ValueError, FileNotFoundError)\n- Order except blocks from SPECIFIC to GENERAL\n- Avoid bare except: (catches everything, even Ctrl+C!)\n- Use Exception as a last-resort fallback, not the primary catch"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "- **Common exceptions:** ValueError (wrong value), TypeError (wrong type), IndexError (list index), KeyError (dict key), ZeroDivisionError, FileNotFoundError, AttributeError (missing attribute/method).\n- **Catch specific exceptions** you expect, not the generic Exception class. Specific catches make debugging easier and handling more precise.\n- **Multiple except blocks:** Use separate blocks for different exception types when you need different handling for each.\n- **Group exceptions:** Use except (ValueError, TypeError) when you want the same handling for multiple exception types.\n- **Order matters:** Put specific exceptions BEFORE general ones. Python checks except blocks in order and uses the first match.\n- **Use 'as e' to capture exception details:** except ValueError as e: lets you access the error message and other useful information.\n- **Avoid bare except:** except Exception catches almost everything; except: catches EVERYTHING including Ctrl+C. Both hide bugs and make debugging hard.\n- **Exception hierarchy:** Exception is the parent class of most errors. Catching it catches all its children (ValueError, TypeError, etc.)."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "08_03-challenge-3",
              "title": "Interactive Exercise: Build a Multi-Exception Data Processor",
              "description": "Create a function that processes a dictionary of user data safely. The function should:\n1. Accept a dictionary and a key name\n2. Get the value for that key (might not exist → KeyError)\n3. Convert the value to uppercase (might not be a string → AttributeError)\n4. Extract the first character (might be empty string → IndexError)\n5. Return the character, or None if any error occurs\n\nHandle all three exception types separately with specific error messages.\n\n**Your task:**\n\n**Test data:**\n```python\nuser1 = {\"name\": \"Alice\", \"role\": \"admin\"}\nuser2 = {\"name\": \"Bob\"}  # Missing 'role'\nuser3 = {\"name\": \"Carol\", \"role\": 12345}  # role is int, not string\nuser4 = {\"name\": \"Dave\", \"role\": \"\"}  # Empty string\n```\n\n**Starter code:**",
              "instructions": "Create a function that processes a dictionary of user data safely. The function should:\n1. Accept a dictionary and a key name\n2. Get the value for that key (might not exist → KeyError)\n3. Convert the value to uppercase (might not be a string → AttributeError)\n4. Extract the first character (might be empty string → IndexError)\n5. Return the character, or None if any error occurs\n\nHandle all three exception types separately with specific error messages.\n\n**Your task:**\n\n**Test data:**\n```python\nuser1 = {\"name\": \"Alice\", \"role\": \"admin\"}\nuser2 = {\"name\": \"Bob\"}  # Missing 'role'\nuser3 = {\"name\": \"Carol\", \"role\": 12345}  # role is int, not string\nuser4 = {\"name\": \"Dave\", \"role\": \"\"}  # Empty string\n```\n\n**Starter code:**",
              "starterCode": "def get_first_letter(user_dict, key):\n    \"\"\"Safely extract first letter of a dictionary value.\"\"\"\n    \n    # TODO: Add try block\n    # TODO: Get the value from dictionary using user_dict[key]\n    # TODO: Convert to uppercase using .upper()\n    # TODO: Get first character using [0]\n    \n    # TODO: Add except KeyError block\n    # Print message: \"Key not found\"\n    \n    # TODO: Add except AttributeError block\n    # Print message: \"Value is not a string\"\n    \n    # TODO: Add except IndexError block\n    # Print message: \"Value is empty\"\n    \n    # Return None or the character\n    return None\n\n# Test cases\nuser1 = {\"name\": \"Alice\", \"role\": \"admin\"}\nuser2 = {\"name\": \"Bob\"}\nuser3 = {\"name\": \"Carol\", \"role\": 12345}\nuser4 = {\"name\": \"Dave\", \"role\": \"\"}\n\nprint(get_first_letter(user1, \"role\"))  # Should work\nprint(get_first_letter(user2, \"role\"))  # KeyError\nprint(get_first_letter(user3, \"role\"))  # AttributeError\nprint(get_first_letter(user4, \"role\"))  # IndexError",
              "solution": "",
              "language": "python",
              "testCases": [
                {
                  "description": "Code runs without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use three separate except blocks: except KeyError, except AttributeError, except IndexError. Each should print a specific message and return None."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "08_04",
          "title": "Raising Exceptions and Creating Custom Exceptions",
          "moduleId": "module-08",
          "order": 4,
          "estimatedMinutes": 35,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Concept: Activating the Fire Alarm",
              "content": "So far, we've been CATCHING exceptions (responding to the alarm when it goes off). But what about RAISING exceptions (pressing the fire alarm button yourself)?\n\n**Why would you raise an exception?**\n\nImagine you're a security guard checking IDs at a club:\n- Someone shows a fake ID → You raise an alarm (raise ValueError)\n- Someone is under 21 → You raise an alarm (raise ValueError)\n- Someone is on the banned list → You raise a CUSTOM alarm (raise BannedPersonError)\n\nYou're not waiting for something to break - you're actively detecting a problem and **signaling it** by raising an exception.\n\n**Real-world code scenarios:**\n\n1. **Validation:** Age is negative → raise ValueError(\"Age cannot be negative\")\n2. **Business rules:** Withdrawal exceeds balance → raise InsufficientFundsError(\"Not enough money\")\n3. **Preconditions:** Function requires positive number but got zero → raise ValueError(\"Expected positive number\")\n\n**Custom Exceptions** are like creating your own fire alarm sounds:\n- Standard alarm: ValueError, TypeError (built-in)\n- Custom alarm: InsufficientFundsError, InvalidPasswordError (your own)\n\nCustom exceptions make your code self-documenting: except InsufficientFundsError: is clearer than except ValueError: in a banking app.\n\n**Exception vs. Return Value:**\n- **Return error value:** User enters wrong password → return False (expected, common)\n- **Raise exception:** Credit card number has letters → raise ValueError (unexpected, exceptional)\n\nRule of thumb: If the error is EXCEPTIONAL (shouldn't normally happen), raise an exception. If it's EXPECTED (users often get it wrong), return a value."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example: Raising Exceptions",
              "content": "The code demonstrates:\n1. **Raising built-in exceptions** with raise ValueError() when validation fails\n2. **Custom exception classes** that inherit from Exception for domain-specific errors\n3. **Re-raising exceptions** with bare raise to pass the exception up after logging\n\nCustom exceptions make error handling more specific and self-documenting.",
              "code": "# Example 1: Raising built-in exceptions\nprint(\"=== Raising Built-in Exceptions ===\")\n\ndef calculate_discount(price, discount_percent):\n    \"\"\"Calculate discounted price with validation.\"\"\"\n    \n    # Validate price\n    if price < 0:\n        raise ValueError(\"Price cannot be negative\")\n    \n    # Validate discount\n    if discount_percent < 0 or discount_percent > 100:\n        raise ValueError(\"Discount must be between 0 and 100\")\n    \n    # If validations pass, calculate discount\n    discount_amount = price * (discount_percent / 100)\n    final_price = price - discount_amount\n    return final_price\n\n# Valid usage\nprint(\"Test 1: Valid values\")\ntry:\n    result = calculate_discount(100, 20)\n    print(f\"$100 with 20% discount = ${result}\\n\")\nexcept ValueError as e:\n    print(f\"Error: {e}\\n\")\n\n# Invalid price\nprint(\"Test 2: Negative price\")\ntry:\n    result = calculate_discount(-50, 20)\n    print(f\"Result: ${result}\\n\")\nexcept ValueError as e:\n    print(f\"Error: {e}\\n\")\n\n# Invalid discount\nprint(\"Test 3: Invalid discount\")\ntry:\n    result = calculate_discount(100, 150)\n    print(f\"Result: ${result}\\n\")\nexcept ValueError as e:\n    print(f\"Error: {e}\\n\")\n\n# Example 2: Creating custom exceptions\nprint(\"=== Custom Exception Classes ===\")\n\n# Define custom exception\nclass InsufficientFundsError(Exception):\n    \"\"\"Raised when account has insufficient funds for withdrawal.\"\"\"\n    pass\n\nclass AccountLockedError(Exception):\n    \"\"\"Raised when attempting to access a locked account.\"\"\"\n    pass\n\nclass BankAccount:\n    \"\"\"Simple bank account with custom exceptions.\"\"\"\n    \n    def __init__(self, balance=0):\n        self.balance = balance\n        self.is_locked = False\n    \n    def withdraw(self, amount):\n        \"\"\"Withdraw money with validation.\"\"\"\n        \n        # Check if account is locked\n        if self.is_locked:\n            raise AccountLockedError(\"Account is locked. Contact bank.\")\n        \n        # Validate amount\n        if amount <= 0:\n            raise ValueError(\"Withdrawal amount must be positive\")\n        \n        # Check sufficient funds\n        if amount > self.balance:\n            raise InsufficientFundsError(\n                f\"Insufficient funds. Balance: ${self.balance}, \"\n                f\"Requested: ${amount}\"\n            )\n        \n        # Process withdrawal\n        self.balance -= amount\n        return self.balance\n    \n    def lock_account(self):\n        \"\"\"Lock the account.\"\"\"\n        self.is_locked = True\n\n# Test custom exceptions\naccount = BankAccount(balance=1000)\n\nprint(\"Test 1: Valid withdrawal\")\ntry:\n    new_balance = account.withdraw(200)\n    print(f\"Withdrew $200. New balance: ${new_balance}\\n\")\nexcept (InsufficientFundsError, AccountLockedError, ValueError) as e:\n    print(f\"Error: {e}\\n\")\n\nprint(\"Test 2: Insufficient funds\")\ntry:\n    new_balance = account.withdraw(5000)\n    print(f\"New balance: ${new_balance}\\n\")\nexcept InsufficientFundsError as e:\n    print(f\"Error: {e}\\n\")\n\nprint(\"Test 3: Locked account\")\naccount.lock_account()\ntry:\n    new_balance = account.withdraw(100)\n    print(f\"New balance: ${new_balance}\\n\")\nexcept AccountLockedError as e:\n    print(f\"Error: {e}\\n\")\n\n# Example 3: Re-raising exceptions\nprint(\"=== Re-raising Exceptions ===\")\n\ndef process_transaction(account, amount):\n    \"\"\"Process transaction with logging.\"\"\"\n    try:\n        account.withdraw(amount)\n        print(f\"Transaction successful: ${amount}\")\n    except InsufficientFundsError as e:\n        print(f\"[LOG] Failed transaction: {e}\")\n        raise  # Re-raise the same exception\n\naccount2 = BankAccount(balance=100)\ntry:\n    process_transaction(account2, 200)\nexcept InsufficientFundsError:\n    print(\"Transaction declined at higher level\")",
              "language": "python"
            },
            {
              "type": "ANALOGY",
              "title": "Syntax Breakdown: Raising and Creating Exceptions",
              "content": "**Raising Built-in Exceptions:**\n\n```python\n# Basic syntax\nraise ExceptionType(\"Error message\")\n\n# Examples\nraise ValueError(\"Age cannot be negative\")\nraise TypeError(\"Expected string, got int\")\nraise FileNotFoundError(\"Config file not found\")\n\n# Without message (less helpful)\nraise ValueError()\n```\n\n**Creating Custom Exception Classes:**\n\n**Basic custom exception:**\n```python\nclass MyCustomError(Exception):\n    \"\"\"Description of when this error occurs.\"\"\"\n    pass  # No additional code needed\n\n# Usage\nraise MyCustomError(\"Something specific went wrong\")\n```\n\n**Custom exception with default message:**\n```python\nclass InsufficientFundsError(Exception):\n    \"\"\"Raised when account balance is too low.\"\"\"\n    def __init__(self, balance, amount):\n        self.balance = balance\n        self.amount = amount\n        message = f\"Insufficient funds: ${balance} < ${amount}\"\n        super().__init__(message)\n\n# Usage\nraise InsufficientFundsError(balance=100, amount=200)\n```\n\n**Exception hierarchy for related errors:**\n```python\nclass BankError(Exception):\n    \"\"\"Base exception for all bank errors.\"\"\"\n    pass\n\nclass InsufficientFundsError(BankError):\n    \"\"\"Not enough money.\"\"\"\n    pass\n\nclass AccountLockedError(BankError):\n    \"\"\"Account is locked.\"\"\"\n    pass\n\n# Can catch all bank errors:\ntry:\n    do_banking()\nexcept BankError:  # Catches both children\n    handle_bank_error()\n\n# Or catch specific ones:\nexcept InsufficientFundsError:\n    handle_insufficient_funds()\n```\n\n**Re-raising Exceptions:**\n\n**Bare raise (re-raises the same exception):**\n```python\ntry:\n    risky_operation()\nexcept ValueError as e:\n    log_error(e)  # Log it\n    raise  # Re-raise the original exception\n```\n\n**Raising a different exception:**\n```python\ntry:\n    risky_operation()\nexcept ValueError as e:\n    # Convert to custom exception\n    raise CustomError(f\"Failed: {e}\")\n```\n\n**When to Raise Exceptions:**\n\n✅ **DO raise exceptions when:**\n- Input validation fails (negative age, invalid email)\n- Preconditions not met (function expects positive number, got zero)\n- Business rules violated (withdrawal exceeds limit)\n- Unrecoverable errors (file corrupted, database connection lost)\n\n❌ **DON'T raise exceptions when:**\n- Result could be legitimately empty (search returns 0 results)\n- User input is commonly wrong (wrong password)\n- You can return a sentinel value (None, False, -1)\n- It's an expected alternate flow (user cancels operation)\n\n**Guideline:** Exceptions are for EXCEPTIONAL cases, not control flow."
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "- **Raise exceptions** with raise ExceptionType('message') when validation fails or preconditions aren't met. Always include a descriptive message.\n- **Custom exceptions** are classes that inherit from Exception. Use them for domain-specific errors: class MyError(Exception): pass\n- **Exception hierarchy** lets you group related exceptions. Create a base exception and inherit from it: class BankError(Exception), then class InsufficientFundsError(BankError).\n- **Re-raise exceptions** with bare raise (not raise e) to preserve the original stack trace. Useful for logging then re-raising.\n- **Use exceptions for exceptional cases** (validation failures, violated preconditions). Use return values for expected alternate flows (search returns no results).\n- **Exception messages should be actionable:** Include what went wrong, expected vs. actual values, and how to fix it.\n- **Custom exceptions make code self-documenting:** except InsufficientFundsError is clearer than except ValueError in a banking app.\n- **Don't use exceptions for control flow:** They're slower than if/else and make code harder to understand. Save them for truly exceptional situations."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "08_04-challenge-3",
              "title": "Interactive Exercise: Build a Password Validator",
              "description": "Create a password validator that raises custom exceptions for different validation failures:\n\n**Requirements:**\n- Password must be at least 8 characters → raise TooShortError\n- Password must contain at least one digit → raise NoDigitError  \n- Password must contain at least one uppercase letter → raise NoUppercaseError\n- If all validations pass, return True\n\n**Your task:**\n1. Create three custom exception classes\n2. Create a validate_password() function\n3. Raise appropriate exceptions when validation fails\n4. Test with various passwords\n\n**Starter code:**",
              "instructions": "Create a password validator that raises custom exceptions for different validation failures:\n\n**Requirements:**\n- Password must be at least 8 characters → raise TooShortError\n- Password must contain at least one digit → raise NoDigitError  \n- Password must contain at least one uppercase letter → raise NoUppercaseError\n- If all validations pass, return True\n\n**Your task:**\n1. Create three custom exception classes\n2. Create a validate_password() function\n3. Raise appropriate exceptions when validation fails\n4. Test with various passwords\n\n**Starter code:**",
              "starterCode": "# TODO: Create custom exception classes\nclass TooShortError(Exception):\n    \"\"\"Password is too short.\"\"\"\n    pass\n\n# TODO: Create NoDigitError class\n\n# TODO: Create NoUppercaseError class\n\ndef validate_password(password):\n    \"\"\"Validate password and raise exceptions on failure.\"\"\"\n    \n    # TODO: Check length (< 8 chars)\n    # Raise TooShortError with helpful message\n    \n    # TODO: Check for at least one digit\n    # Use: any(char.isdigit() for char in password)\n    # Raise NoDigitError if no digits found\n    \n    # TODO: Check for at least one uppercase letter\n    # Use: any(char.isupper() for char in password)\n    # Raise NoUppercaseError if no uppercase found\n    \n    # If all checks pass\n    return True\n\n# Test cases\ntest_passwords = [\n    \"SecurePass123\",  # Valid\n    \"short\",          # Too short\n    \"nouppercase123\", # No uppercase\n    \"NODIGITS\",       # No digit\n]\n\nfor pwd in test_passwords:\n    try:\n        if validate_password(pwd):\n            print(f\"✓ '{pwd}' is valid\")\n    except (TooShortError, NoDigitError, NoUppercaseError) as e:\n        print(f\"✗ '{pwd}': {e}\")",
              "solution": "",
              "language": "python",
              "testCases": [
                {
                  "description": "Code runs without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Create each exception class with pass. In validate_password, use if len(password) < 8: raise TooShortError(...). Use any() with generator expressions to check for digits and uppercase."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "08_05",
          "title": "Input Validation and Defensive Programming",
          "moduleId": "module-08",
          "order": 5,
          "estimatedMinutes": 30,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Concept: The Bouncer at the Door",
              "content": "Imagine you're a bouncer at an exclusive club. Do you:\n\n**A) Let everyone in and deal with problems later?** (No validation)\n- Drunk people start fights → chaos\n- Underage people drink → legal problems  \n- Result: Club gets shut down\n\n**B) Check EVERYTHING at the door?** (Input validation)\n- ID check → Prevent underage entry\n- Sobriety check → Prevent drunk people\n- Dress code check → Maintain standards\n- Result: Safe, enjoyable club\n\nThis is **defensive programming** - assume EVERYTHING can go wrong, and guard against it.\n\n**Two Philosophies:**\n\n**LBYL (Look Before You Leap):**\n\"Check ID before letting them in\"\n```python\nif age >= 21:  # Check first\n    serve_drink()  # Then act\nelse:\n    deny_entry()\n```\n\n**EAFP (Easier to Ask Forgiveness than Permission):**\n\"Let them order, catch the error if they're underage\"\n```python\ntry:\n    serve_drink()  # Try it\nexcept UnderageError:  # Handle error\n    deny_entry()\n```\n\n**Python prefers EAFP** for many situations (it's more Pythonic), but **validation is still crucial**.\n\n**Real-world scenarios:**\n\n1. **User registration:**\n   - Validate email format, password strength, age\n   - Don't just trust user input!\n\n2. **API endpoints:**\n   - Validate all request parameters\n   - Check data types, ranges, required fields\n\n3. **File processing:**\n   - Validate file exists, correct format, not too large\n   - Don't assume file is perfect\n\n**Defensive programming checklist:**\n- ✅ Validate ALL user input (never trust it)\n- ✅ Check types (is it an int when you expect int?)\n- ✅ Check ranges (is age between 0-120?)\n- ✅ Check formats (is email valid? Is date parseable?)\n- ✅ Provide helpful error messages (tell users what's wrong)\n- ✅ Have fallback values when appropriate"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example: Input Validation Patterns",
              "content": "The code demonstrates:\n1. **Step-by-step validation** (check empty, type, range)\n2. **EAFP vs. LBYL** approaches (Python prefers EAFP)\n3. **Comprehensive validation** with helpful error messages\n4. **Type checking** with isinstance()\n5. **Range validation** to ensure values are reasonable\n6. **Defensive programming** that assumes inputs are wrong until proven right",
              "code": "# Example 1: Basic input validation\nprint(\"=== Basic Input Validation ===\")\n\ndef get_age_from_user(user_input):\n    \"\"\"Validate and convert age input.\"\"\"\n    \n    # Step 1: Check if input is empty\n    if not user_input or user_input.strip() == \"\":\n        raise ValueError(\"Age cannot be empty\")\n    \n    # Step 2: Try to convert to integer\n    try:\n        age = int(user_input.strip())\n    except ValueError:\n        raise ValueError(f\"Age must be a number, got '{user_input}'\")\n    \n    # Step 3: Validate range\n    if age < 0:\n        raise ValueError(f\"Age cannot be negative (got {age})\")\n    if age > 120:\n        raise ValueError(f\"Age seems unrealistic (got {age})\")\n    \n    return age\n\n# Test cases\ntest_inputs = [\"25\", \"  30  \", \"\", \"abc\", \"-5\", \"200\"]\n\nfor test_input in test_inputs:\n    print(f\"\\nInput: '{test_input}'\")\n    try:\n        age = get_age_from_user(test_input)\n        print(f\"  ✓ Valid age: {age}\")\n    except ValueError as e:\n        print(f\"  ✗ Invalid: {e}\")\n\n# Example 2: EAFP vs LBYL\nprint(\"\\n\\n=== EAFP vs LBYL Comparison ===\")\n\nmy_dict = {\"name\": \"Alice\", \"age\": 25}\n\n# LBYL (Look Before You Leap)\nprint(\"\\nLBYL approach:\")\nif \"email\" in my_dict:\n    email = my_dict[\"email\"]\n    print(f\"Email: {email}\")\nelse:\n    print(\"No email found\")\n    email = \"no-email@example.com\"\n\nprint(f\"Result: {email}\")\n\n# EAFP (Easier to Ask Forgiveness than Permission) - More Pythonic!\nprint(\"\\nEAFP approach:\")\ntry:\n    email = my_dict[\"email\"]\n    print(f\"Email: {email}\")\nexcept KeyError:\n    print(\"No email found\")\n    email = \"no-email@example.com\"\n\nprint(f\"Result: {email}\")\n\n# Or even better - using .get() for simple cases\nprint(\"\\nBest approach (for dicts):\")\nemail = my_dict.get(\"email\", \"no-email@example.com\")\nprint(f\"Result: {email}\")\n\n# Example 3: Comprehensive validation function\nprint(\"\\n\\n=== Comprehensive Email Validation ===\")\n\ndef validate_email(email):\n    \"\"\"Validate email with multiple checks.\"\"\"\n    \n    # Check 1: Not empty\n    if not email or not email.strip():\n        return False, \"Email cannot be empty\"\n    \n    email = email.strip()\n    \n    # Check 2: Contains @\n    if \"@\" not in email:\n        return False, \"Email must contain @\"\n    \n    # Check 3: Has content before and after @\n    parts = email.split(\"@\")\n    if len(parts) != 2:\n        return False, \"Email must have exactly one @\"\n    \n    local, domain = parts\n    \n    if not local:\n        return False, \"Email must have content before @\"\n    if not domain:\n        return False, \"Email must have content after @\"\n    \n    # Check 4: Domain has a dot\n    if \".\" not in domain:\n        return False, \"Domain must contain a dot (e.g., gmail.com)\"\n    \n    # Check 5: Domain parts are not empty\n    domain_parts = domain.split(\".\")\n    if any(part == \"\" for part in domain_parts):\n        return False, \"Domain parts cannot be empty\"\n    \n    # All checks passed!\n    return True, \"Valid email\"\n\n# Test email validation\ntest_emails = [\n    \"alice@example.com\",\n    \"bob@company.co.uk\",\n    \"\",\n    \"no-at-sign.com\",\n    \"@example.com\",\n    \"user@\",\n    \"user@@example.com\",\n    \"user@nodot\",\n    \"user@example.\",\n]\n\nfor email in test_emails:\n    is_valid, message = validate_email(email)\n    status = \"✓\" if is_valid else \"✗\"\n    print(f\"{status} '{email}': {message}\")\n\n# Example 4: Defensive programming in practice\nprint(\"\\n\\n=== Defensive Programming Example ===\")\n\ndef calculate_discount(price, discount_percent=0, coupon_code=None):\n    \"\"\"Calculate price with discount - defensive version.\"\"\"\n    \n    # Validate price\n    if not isinstance(price, (int, float)):\n        raise TypeError(f\"Price must be a number, got {type(price).__name__}\")\n    if price < 0:\n        raise ValueError(f\"Price cannot be negative (got {price})\")\n    \n    # Validate discount percent\n    if not isinstance(discount_percent, (int, float)):\n        raise TypeError(f\"Discount must be a number, got {type(discount_percent).__name__}\")\n    if not 0 <= discount_percent <= 100:\n        raise ValueError(f\"Discount must be 0-100% (got {discount_percent})\")\n    \n    # Validate coupon code (optional)\n    if coupon_code is not None and not isinstance(coupon_code, str):\n        raise TypeError(\"Coupon code must be a string\")\n    \n    # Apply discount\n    discount_amount = price * (discount_percent / 100)\n    discounted_price = price - discount_amount\n    \n    # Apply coupon if provided\n    if coupon_code:\n        coupon_code = coupon_code.strip().upper()\n        if coupon_code == \"SAVE10\":\n            discounted_price *= 0.9  # Extra 10% off\n            print(f\"  Coupon '{coupon_code}' applied: -10%\")\n    \n    return round(discounted_price, 2)\n\n# Test defensive function\nprint(\"\\nTest 1: Valid inputs\")\ntry:\n    result = calculate_discount(100, 20, \"SAVE10\")\n    print(f\"  Final price: ${result}\\n\")\nexcept (TypeError, ValueError) as e:\n    print(f\"  Error: {e}\\n\")\n\nprint(\"Test 2: Invalid price type\")\ntry:\n    result = calculate_discount(\"100\", 20)\n    print(f\"  Final price: ${result}\\n\")\nexcept (TypeError, ValueError) as e:\n    print(f\"  Error: {e}\\n\")\n\nprint(\"Test 3: Invalid discount range\")\ntry:\n    result = calculate_discount(100, 150)\n    print(f\"  Final price: ${result}\\n\")\nexcept (TypeError, ValueError) as e:\n    print(f\"  Error: {e}\\n\")\n\nprint(\"Test 4: Invalid coupon type\")\ntry:\n    result = calculate_discount(100, 20, 12345)\n    print(f\"  Final price: ${result}\\n\")\nexcept (TypeError, ValueError) as e:\n    print(f\"  Error: {e}\\n\")",
              "language": "python"
            },
            {
              "type": "ANALOGY",
              "title": "Syntax Breakdown: Validation Patterns",
              "content": "**Input Validation Checklist:**\n\n**1. Check for empty/null:**\n```python\nif not value or value.strip() == \"\":\n    raise ValueError(\"Input cannot be empty\")\n```\n\n**2. Type validation:**\n```python\n# Check if value is the right type\nif not isinstance(value, int):\n    raise TypeError(f\"Expected int, got {type(value).__name__}\")\n\n# Accept multiple types\nif not isinstance(price, (int, float)):\n    raise TypeError(\"Price must be a number\")\n```\n\n**3. Range validation:**\n```python\n# Check numeric range\nif not 0 <= age <= 120:\n    raise ValueError(f\"Age must be 0-120, got {age}\")\n\n# Check string length\nif len(password) < 8:\n    raise ValueError(\"Password must be at least 8 characters\")\n```\n\n**4. Format validation:**\n```python\n# Email contains @\nif \"@\" not in email:\n    raise ValueError(\"Invalid email format\")\n\n# String is numeric\nif not value.isdigit():\n    raise ValueError(\"Must contain only digits\")\n```\n\n**5. Sanitization (clean the input):**\n```python\n# Remove whitespace\nvalue = value.strip()\n\n# Convert to lowercase for comparison\nvalue = value.lower()\n\n# Remove dangerous characters\nvalue = value.replace(\";\", \"\").replace(\"--\", \"\")\n```\n\n**EAFP vs LBYL:**\n\n**LBYL (Look Before You Leap):**\n```python\n# Check condition first, then act\nif key in dictionary:\n    value = dictionary[key]\nelse:\n    value = default\n\nif os.path.exists(filename):\n    with open(filename) as f:\n        data = f.read()\n```\n\n**EAFP (Easier to Ask Forgiveness than Permission):**\n```python\n# Try it, handle errors if they occur\ntry:\n    value = dictionary[key]\nexcept KeyError:\n    value = default\n\ntry:\n    with open(filename) as f:\n        data = f.read()\nexcept FileNotFoundError:\n    data = None\n```\n\n**When to use each:**\n\n**Use LBYL when:**\n- Simple conditions (if key in dict)\n- Readability matters more than performance\n- You want to avoid exceptions in common cases\n\n**Use EAFP when:**\n- The success case is more common than failure\n- Race conditions possible (file might be deleted between check and use)\n- More Pythonic (\"ask forgiveness\")\n\n**Defensive Programming Best Practices:**\n\n```python\ndef robust_function(param1, param2=None):\n    \"\"\"Template for defensive programming.\"\"\"\n    \n    # 1. Validate all parameters\n    if param1 is None:\n        raise ValueError(\"param1 is required\")\n    \n    if not isinstance(param1, str):\n        raise TypeError(\"param1 must be a string\")\n    \n    # 2. Sanitize input\n    param1 = param1.strip()\n    \n    # 3. Check business rules\n    if len(param1) < 3:\n        raise ValueError(\"param1 must be at least 3 characters\")\n    \n    # 4. Handle optional parameters\n    if param2 is None:\n        param2 = default_value\n    \n    # 5. Use try/except for risky operations\n    try:\n        result = risky_operation(param1)\n    except SomeError as e:\n        # Log and handle\n        logger.error(f\"Operation failed: {e}\")\n        return None\n    \n    return result\n```\n\n**Type hints (Python 3.5+) help with validation:**\n```python\ndef process_user(name: str, age: int) -> dict:\n    \"\"\"Type hints document expected types.\"\"\"\n    # Still need runtime validation!\n    if not isinstance(name, str):\n        raise TypeError(\"name must be str\")\n    return {\"name\": name, \"age\": age}\n```"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "- **Always validate user input** - never trust it! Check type, format, range, and empty/null values before using input.\n- **Defensive programming:** Assume everything can go wrong. Validate parameters, check types, handle edge cases, provide defaults.\n- **Validation order:** (1) Check not None/empty, (2) Check type with isinstance(), (3) Sanitize (strip, lower), (4) Check format/range.\n- **EAFP (Easier to Ask Forgiveness than Permission)** is more Pythonic than LBYL. Try the operation, catch exceptions if they occur.\n- **LBYL (Look Before You Leap)** is okay for simple checks (if key in dict:) where readability matters more than performance.\n- **Type checking:** Use isinstance(value, type) to check types. Can check multiple types: isinstance(x, (int, float)).\n- **Provide actionable error messages:** Tell users what's wrong, what's expected, and what they provided. 'Age must be 13-120, got 10' beats 'Invalid age'.\n- **Sanitize input:** Use .strip() to remove whitespace, .lower() for case-insensitive comparison. But DON'T strip passwords!\n- **Range validation:** Always check numeric ranges (0 <= age <= 120), string lengths (3 <= len(username) <= 20), and limits."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "08_05-challenge-3",
              "title": "Interactive Exercise: Build a User Registration Validator",
              "description": "Create a user registration validator that checks:\n1. **Username:** 3-20 characters, alphanumeric only, not empty\n2. **Email:** Valid format (contains @ and .)\n3. **Age:** Integer between 13-120\n4. **Password:** At least 8 characters\n\nReturn True if all valid, raise appropriate exceptions if any validation fails.\n\n**Your task:**\nImplement validate_registration() with comprehensive validation.\n\n**Starter code:**",
              "instructions": "Create a user registration validator that checks:\n1. **Username:** 3-20 characters, alphanumeric only, not empty\n2. **Email:** Valid format (contains @ and .)\n3. **Age:** Integer between 13-120\n4. **Password:** At least 8 characters\n\nReturn True if all valid, raise appropriate exceptions if any validation fails.\n\n**Your task:**\nImplement validate_registration() with comprehensive validation.\n\n**Starter code:**",
              "starterCode": "def validate_registration(username, email, age, password):\n    \"\"\"Validate user registration data.\"\"\"\n    \n    # TODO: Validate username\n    # - Not empty (after stripping)\n    # - 3-20 characters\n    # - Only letters and numbers (use .isalnum())\n    \n    # TODO: Validate email\n    # - Not empty\n    # - Contains @\n    # - Contains . after @\n    \n    # TODO: Validate age\n    # - Is an integer (isinstance)\n    # - Between 13-120\n    \n    # TODO: Validate password\n    # - Not empty\n    # - At least 8 characters\n    \n    return True\n\n# Test cases\ntest_cases = [\n    (\"alice123\", \"alice@example.com\", 25, \"SecurePass123\"),  # Valid\n    (\"\", \"alice@example.com\", 25, \"SecurePass123\"),  # Empty username\n    (\"ab\", \"alice@example.com\", 25, \"SecurePass123\"),  # Short username\n    (\"alice123\", \"invalid-email\", 25, \"SecurePass123\"),  # Invalid email\n    (\"alice123\", \"alice@example.com\", 10, \"SecurePass123\"),  # Too young\n    (\"alice123\", \"alice@example.com\", 25, \"short\"),  # Short password\n]\n\nfor i, (user, email, age, pwd) in enumerate(test_cases, 1):\n    print(f\"\\nTest {i}: user='{user}', email='{email}', age={age}\")\n    try:\n        if validate_registration(user, email, age, pwd):\n            print(\"  ✓ Registration valid\")\n    except (ValueError, TypeError) as e:\n        print(f\"  ✗ {e}\")",
              "solution": "",
              "language": "python",
              "testCases": [
                {
                  "description": "Code runs without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use if not username.strip(): for empty check, if not 3 <= len(username) <= 20: for length, if not username.isalnum(): for alphanumeric check. Similar pattern for other fields."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "08_06",
          "title": "Mini-Project: Robust Calculator with Complete Error Handling",
          "moduleId": "module-08",
          "order": 6,
          "estimatedMinutes": 45,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Project Overview: The Unbreakable Calculator",
              "content": "**The Challenge:** Build a calculator that NEVER crashes, no matter what the user does.\n\n**Real-world scenario:** You're building a calculator for a critical system (medical device, aircraft control, financial trading). It CANNOT crash. Users might:\n- Type letters instead of numbers\n- Divide by zero\n- Enter empty input\n- Use invalid operations\n- Provide huge numbers that cause overflow\n- Enter malformed expressions\n\nYour calculator must handle ALL of these gracefully, showing helpful error messages and letting users try again.\n\n**What you'll build:**\n\n1. **Basic Calculator Functions:**\n   - Add, subtract, multiply, divide\n   - Power, square root, modulo\n\n2. **Advanced Features:**\n   - Expression evaluation (\"2 + 3 * 4\")\n   - Memory storage (store results)\n   - Calculation history\n\n3. **Error Handling:**\n   - Custom exceptions for calculator-specific errors\n   - Input validation for all operations\n   - Safe expression evaluation\n   - Graceful error recovery\n\n4. **Defensive Programming:**\n   - Type checking\n   - Range validation\n   - Clear error messages\n   - Finally blocks for cleanup\n\n**Project structure:**\n- Custom exception classes\n- Calculator class with validated methods\n- Interactive REPL (Read-Eval-Print Loop)\n- Comprehensive error handling throughout\n\nThis project demonstrates production-level code that's robust, maintainable, and user-friendly."
            },
            {
              "type": "EXAMPLE",
              "title": "Complete Implementation: Robust Calculator",
              "content": "This production-ready calculator demonstrates:\n\n**1. Custom Exception Hierarchy:**\n- Base `CalculatorError` for all calculator errors\n- Specific exceptions for each error type\n- Clear, descriptive error messages\n\n**2. Comprehensive Validation:**\n- Type checking with `isinstance()`\n- Range validation (no infinity, NaN)\n- Defensive programming throughout\n\n**3. Error Handling Patterns:**\n- Try/except for risky operations\n- Finally for cleanup (logging)\n- EAFP approach where appropriate\n\n**4. User-Friendly Features:**\n- Clear error messages\n- Calculation history\n- Memory storage\n- Interactive REPL\n\n**5. Production-Level Code:**\n- Type hints for documentation\n- Docstrings for all methods\n- Proper exception hierarchy\n- Edge case handling",
              "code": "\"\"\"Robust Calculator with Comprehensive Error Handling\n\nA production-ready calculator that handles all possible errors gracefully.\nDemonstrates: custom exceptions, validation, defensive programming, EAFP.\n\"\"\"\n\nimport math\nfrom typing import List, Tuple\n\n# ============================================================================\n# Custom Exception Classes\n# ============================================================================\n\nclass CalculatorError(Exception):\n    \"\"\"Base exception for all calculator errors.\"\"\"\n    pass\n\nclass InvalidOperationError(CalculatorError):\n    \"\"\"Raised when an invalid operation is requested.\"\"\"\n    pass\n\nclass InvalidNumberError(CalculatorError):\n    \"\"\"Raised when input cannot be converted to a number.\"\"\"\n    pass\n\nclass DivisionByZeroError(CalculatorError):\n    \"\"\"Raised when attempting to divide by zero.\"\"\"\n    pass\n\nclass NegativeSquareRootError(CalculatorError):\n    \"\"\"Raised when attempting square root of negative number.\"\"\"\n    pass\n\n# ============================================================================\n# Calculator Class\n# ============================================================================\n\nclass RobustCalculator:\n    \"\"\"Calculator with comprehensive error handling.\"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize calculator with memory and history.\"\"\"\n        self.memory = 0.0\n        self.history: List[Tuple[str, float]] = []\n        self.operations = {\n            'add': self.add,\n            'subtract': self.subtract,\n            'multiply': self.multiply,\n            'divide': self.divide,\n            'power': self.power,\n            'sqrt': self.square_root,\n            'modulo': self.modulo,\n        }\n    \n    def _validate_number(self, value, param_name=\"value\"):\n        \"\"\"Validate that value is a number.\n        \n        Args:\n            value: Value to validate\n            param_name: Name for error messages\n            \n        Returns:\n            float: Validated number\n            \n        Raises:\n            InvalidNumberError: If value is not a number\n        \"\"\"\n        if not isinstance(value, (int, float)):\n            raise InvalidNumberError(\n                f\"{param_name} must be a number, got {type(value).__name__}\"\n            )\n        \n        # Check for infinity and NaN\n        if math.isinf(value):\n            raise InvalidNumberError(f\"{param_name} cannot be infinity\")\n        if math.isnan(value):\n            raise InvalidNumberError(f\"{param_name} cannot be NaN\")\n        \n        return float(value)\n    \n    def _record_operation(self, operation: str, result: float):\n        \"\"\"Record operation in history.\"\"\"\n        self.history.append((operation, result))\n        # Keep only last 10 operations\n        if len(self.history) > 10:\n            self.history.pop(0)\n    \n    def add(self, a, b):\n        \"\"\"Add two numbers.\"\"\"\n        a = self._validate_number(a, \"first number\")\n        b = self._validate_number(b, \"second number\")\n        result = a + b\n        self._record_operation(f\"{a} + {b}\", result)\n        return result\n    \n    def subtract(self, a, b):\n        \"\"\"Subtract b from a.\"\"\"\n        a = self._validate_number(a, \"first number\")\n        b = self._validate_number(b, \"second number\")\n        result = a - b\n        self._record_operation(f\"{a} - {b}\", result)\n        return result\n    \n    def multiply(self, a, b):\n        \"\"\"Multiply two numbers.\"\"\"\n        a = self._validate_number(a, \"first number\")\n        b = self._validate_number(b, \"second number\")\n        result = a * b\n        self._record_operation(f\"{a} * {b}\", result)\n        return result\n    \n    def divide(self, a, b):\n        \"\"\"Divide a by b.\n        \n        Raises:\n            DivisionByZeroError: If b is zero\n        \"\"\"\n        a = self._validate_number(a, \"dividend\")\n        b = self._validate_number(b, \"divisor\")\n        \n        if b == 0:\n            raise DivisionByZeroError(\n                \"Cannot divide by zero. Please enter a non-zero divisor.\"\n            )\n        \n        result = a / b\n        self._record_operation(f\"{a} / {b}\", result)\n        return result\n    \n    def power(self, base, exponent):\n        \"\"\"Raise base to exponent.\"\"\"\n        base = self._validate_number(base, \"base\")\n        exponent = self._validate_number(exponent, \"exponent\")\n        \n        try:\n            result = base ** exponent\n            # Check for overflow\n            if math.isinf(result):\n                raise InvalidNumberError(\n                    f\"Result too large: {base}^{exponent} causes overflow\"\n                )\n            self._record_operation(f\"{base} ^ {exponent}\", result)\n            return result\n        except OverflowError:\n            raise InvalidNumberError(\n                f\"Result too large: {base}^{exponent} causes overflow\"\n            )\n    \n    def square_root(self, number):\n        \"\"\"Calculate square root.\n        \n        Raises:\n            NegativeSquareRootError: If number is negative\n        \"\"\"\n        number = self._validate_number(number, \"number\")\n        \n        if number < 0:\n            raise NegativeSquareRootError(\n                f\"Cannot calculate square root of negative number: {number}. \"\n                f\"Use complex numbers for this operation.\"\n            )\n        \n        result = math.sqrt(number)\n        self._record_operation(f\"sqrt({number})\", result)\n        return result\n    \n    def modulo(self, a, b):\n        \"\"\"Calculate a modulo b.\n        \n        Raises:\n            DivisionByZeroError: If b is zero\n        \"\"\"\n        a = self._validate_number(a, \"dividend\")\n        b = self._validate_number(b, \"divisor\")\n        \n        if b == 0:\n            raise DivisionByZeroError(\n                \"Cannot perform modulo with zero divisor\"\n            )\n        \n        result = a % b\n        self._record_operation(f\"{a} % {b}\", result)\n        return result\n    \n    def store_memory(self, value):\n        \"\"\"Store value in memory.\"\"\"\n        value = self._validate_number(value, \"memory value\")\n        self.memory = value\n        return value\n    \n    def recall_memory(self):\n        \"\"\"Recall value from memory.\"\"\"\n        return self.memory\n    \n    def clear_memory(self):\n        \"\"\"Clear memory.\"\"\"\n        self.memory = 0.0\n    \n    def show_history(self):\n        \"\"\"Show calculation history.\"\"\"\n        if not self.history:\n            return \"No calculation history\"\n        \n        result = \"\\nCalculation History (last 10):\\n\"\n        result += \"-\" * 40 + \"\\n\"\n        for i, (operation, value) in enumerate(self.history, 1):\n            result += f\"{i}. {operation} = {value}\\n\"\n        return result\n    \n    def clear_history(self):\n        \"\"\"Clear calculation history.\"\"\"\n        self.history.clear()\n\n# ============================================================================\n# Interactive Calculator REPL\n# ============================================================================\n\ndef safe_float_input(prompt):\n    \"\"\"Safely get a float from user.\n    \n    Args:\n        prompt: Prompt to display\n        \n    Returns:\n        float: Validated number\n        \n    Raises:\n        InvalidNumberError: If input is not a valid number\n        ValueError: If input is empty\n    \"\"\"\n    user_input = input(prompt).strip()\n    \n    if not user_input:\n        raise ValueError(\"Input cannot be empty\")\n    \n    try:\n        return float(user_input)\n    except ValueError:\n        raise InvalidNumberError(\n            f\"'{user_input}' is not a valid number. Please enter a numeric value.\"\n        )\n\ndef run_calculator():\n    \"\"\"Run the interactive calculator.\"\"\"\n    calc = RobustCalculator()\n    \n    print(\"=\"*50)\n    print(\"  ROBUST CALCULATOR - Error Handling Demo\")\n    print(\"=\"*50)\n    print(\"\\nAvailable operations:\")\n    print(\"  add, subtract, multiply, divide\")\n    print(\"  power, sqrt, modulo\")\n    print(\"  memory, recall, clear-memory\")\n    print(\"  history, clear-history\")\n    print(\"  quit\\n\")\n    \n    while True:\n        try:\n            # Get operation\n            print(\"-\" * 50)\n            operation = input(\"\\nEnter operation (or 'quit' to exit): \").strip().lower()\n            \n            if not operation:\n                print(\"❌ Please enter an operation\")\n                continue\n            \n            if operation in ('quit', 'exit', 'q'):\n                print(\"\\n👋 Thanks for using Robust Calculator!\")\n                break\n            \n            # Handle special operations\n            if operation == 'history':\n                print(calc.show_history())\n                continue\n            \n            if operation == 'clear-history':\n                calc.clear_history()\n                print(\"✓ History cleared\")\n                continue\n            \n            if operation == 'recall':\n                print(f\"Memory: {calc.recall_memory()}\")\n                continue\n            \n            if operation == 'clear-memory':\n                calc.clear_memory()\n                print(\"✓ Memory cleared\")\n                continue\n            \n            # Operations requiring one operand\n            if operation == 'sqrt':\n                num = safe_float_input(\"Enter number: \")\n                result = calc.square_root(num)\n                print(f\"\\n✓ sqrt({num}) = {result}\")\n                continue\n            \n            if operation == 'memory':\n                value = safe_float_input(\"Enter value to store: \")\n                calc.store_memory(value)\n                print(f\"✓ Stored {value} in memory\")\n                continue\n            \n            # Operations requiring two operands\n            if operation in calc.operations:\n                a = safe_float_input(\"Enter first number: \")\n                b = safe_float_input(\"Enter second number: \")\n                \n                result = calc.operations[operation](a, b)\n                print(f\"\\n✓ Result: {result}\")\n            else:\n                raise InvalidOperationError(\n                    f\"Unknown operation '{operation}'. \"\n                    f\"Type an operation name from the list above.\"\n                )\n        \n        except InvalidNumberError as e:\n            print(f\"\\n❌ Invalid Number: {e}\")\n        except DivisionByZeroError as e:\n            print(f\"\\n❌ Division Error: {e}\")\n        except NegativeSquareRootError as e:\n            print(f\"\\n❌ Math Error: {e}\")\n        except InvalidOperationError as e:\n            print(f\"\\n❌ Invalid Operation: {e}\")\n        except ValueError as e:\n            print(f\"\\n❌ Input Error: {e}\")\n        except CalculatorError as e:\n            print(f\"\\n❌ Calculator Error: {e}\")\n        except KeyboardInterrupt:\n            print(\"\\n\\n👋 Calculator interrupted. Goodbye!\")\n            break\n        except Exception as e:\n            print(f\"\\n❌ Unexpected Error: {e}\")\n            print(\"Please report this bug!\")\n        finally:\n            # Always runs - could be used for logging\n            pass\n\n# ============================================================================\n# Demo and Tests\n# ============================================================================\n\nprint(\"=\" * 60)\nprint(\"DEMO: Testing Robust Calculator\")\nprint(\"=\" * 60)\n\ncalc = RobustCalculator()\n\nprint(\"\\n1. Valid Operations:\")\nprint(f\"   10 + 5 = {calc.add(10, 5)}\")\nprint(f\"   20 - 8 = {calc.subtract(20, 8)}\")\nprint(f\"   6 * 7 = {calc.multiply(6, 7)}\")\nprint(f\"   15 / 3 = {calc.divide(15, 3)}\")\nprint(f\"   2 ^ 8 = {calc.power(2, 8)}\")\nprint(f\"   sqrt(16) = {calc.square_root(16)}\")\n\nprint(\"\\n2. Error Handling:\")\n\ntry:\n    calc.divide(10, 0)\nexcept DivisionByZeroError as e:\n    print(f\"   ✓ Caught division by zero: {e}\")\n\ntry:\n    calc.square_root(-4)\nexcept NegativeSquareRootError as e:\n    print(f\"   ✓ Caught negative sqrt: {e}\")\n\ntry:\n    calc.add(\"hello\", 5)\nexcept InvalidNumberError as e:\n    print(f\"   ✓ Caught invalid number: {e}\")\n\ntry:\n    calc.power(10, 1000)  # Huge number\nexcept InvalidNumberError as e:\n    print(f\"   ✓ Caught overflow: {e}\")\n\nprint(\"\\n3. Memory and History:\")\ncalc.store_memory(42)\nprint(f\"   Stored: {calc.recall_memory()}\")\nprint(f\"   {calc.show_history()}\")\n\nprint(\"\\n✓ All error handling working correctly!\")\nprint(\"\\nTo run interactive calculator, call run_calculator()\")",
              "language": "python"
            },
            {
              "type": "ANALOGY",
              "title": "Code Architecture Breakdown",
              "content": "**Exception Hierarchy:**\n```\nCalculatorError (base)\n├── InvalidOperationError\n├── InvalidNumberError\n├── DivisionByZeroError\n└── NegativeSquareRootError\n```\n\nBenefits:\n- Can catch all calculator errors with `except CalculatorError`\n- Can catch specific errors separately\n- Clear error types for debugging\n\n**Validation Pattern (used throughout):**\n```python\ndef operation(self, param):\n    # 1. Validate input\n    param = self._validate_number(param, \"param_name\")\n    \n    # 2. Check business rules\n    if param == 0:\n        raise DivisionByZeroError(\"...\")\n    \n    # 3. Perform operation\n    result = do_calculation(param)\n    \n    # 4. Record for history\n    self._record_operation(\"...\", result)\n    \n    # 5. Return result\n    return result\n```\n\n**Error Handling in REPL:**\n```python\nwhile True:\n    try:\n        # Get user input\n        # Validate\n        # Execute operation\n        # Display result\n    except SpecificError1 as e:\n        # Handle gracefully\n    except SpecificError2 as e:\n        # Handle gracefully\n    except Exception as e:\n        # Unexpected errors\n    finally:\n        # Always cleanup\n```\n\nBenefits:\n- User never sees crashes\n- Specific errors get specific messages\n- Unexpected errors are logged\n- Calculator keeps running\n\n**Defensive Programming Checklist (applied throughout):**\n\n✅ **Every input validated:**\n- Type check: `isinstance(value, (int, float))`\n- Range check: `if b == 0: raise DivisionByZeroError`\n- Special values: Check for infinity, NaN\n\n✅ **Clear error messages:**\n- What went wrong: \"Cannot divide by zero\"\n- What was expected: \"Please enter a non-zero divisor\"\n- How to fix it: Actionable guidance\n\n✅ **Edge cases handled:**\n- Division by zero\n- Square root of negative\n- Overflow (numbers too large)\n- Invalid types\n- Empty input\n\n✅ **Graceful degradation:**\n- Error occurs → Show message → Let user try again\n- History preserved even after errors\n- Memory preserved\n\n**Why This Is Production-Ready:**\n\n1. **Never crashes** - all errors caught\n2. **Clear feedback** - users know what went wrong\n3. **Maintainable** - clear structure, documented\n4. **Testable** - each function isolated\n5. **Extensible** - easy to add new operations\n6. **User-friendly** - helpful messages, history, memory\n\nThis is how professional developers write robust code."
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "- **Production code never crashes.** Use comprehensive error handling to catch and recover from all possible errors gracefully.\n- **Custom exception hierarchies** make error handling precise and code self-documenting. Create a base exception class and specific subclasses.\n- **Validate everything.** Never trust user input. Check type, range, format, and edge cases before processing.\n- **Clear error messages are essential.** Tell users what went wrong, what was expected, and how to fix it. Vague errors frustrate users.\n- **Use try/except/finally** for risky operations. Finally ensures cleanup happens even if errors occur.\n- **Defensive programming mindset:** Assume everything can fail. Guard against it with validation, error handling, and fallbacks.\n- **EAFP (try/except) vs LBYL (if/check):** Python prefers EAFP, but use what makes sense for your situation.\n- **Separate concerns:** Validation logic, business logic, error handling, and UI should be separate. Makes code testable and maintainable.\n- **Document your code** with docstrings, type hints, and comments. Future you (and other developers) will thank you.\n- **Test error cases** as thoroughly as success cases. Error handling code needs testing too!\n- **Security matters:** When using dangerous functions like eval(), validate and sanitize input thoroughly. Use whitelists, not blacklists."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "08_06-challenge-3",
              "title": "Your Challenge: Extend the Calculator",
              "description": "**Challenge 1: Add Scientific Functions**\n\nAdd these operations to the calculator:\n1. `log(number, base)` - Logarithm with base (default base 10)\n2. `sin(angle)` - Sine (angle in degrees)\n3. `cos(angle)` - Cosine (angle in degrees)\n\nRequirements:\n- Validate inputs (log of negative raises error)\n- Convert degrees to radians for sin/cos\n- Handle edge cases\n- Add to history\n- Update interactive menu\n\n**Challenge 2: Expression Evaluator**\n\nAdd ability to evaluate expressions like \"2 + 3 * 4\":\n- Use `eval()` CAREFULLY with validation\n- Only allow numbers and operators\n- Prevent code injection\n- Handle syntax errors\n\n**Challenge 3: Persistent History**\n\nSave calculation history to a file:\n- Use try/except/finally for file operations\n- Handle FileNotFoundError\n- Create file if doesn't exist\n- Load history on startup\n- Save on exit\n\n**Starter code for Challenge 1:**",
              "instructions": "**Challenge 1: Add Scientific Functions**\n\nAdd these operations to the calculator:\n1. `log(number, base)` - Logarithm with base (default base 10)\n2. `sin(angle)` - Sine (angle in degrees)\n3. `cos(angle)` - Cosine (angle in degrees)\n\nRequirements:\n- Validate inputs (log of negative raises error)\n- Convert degrees to radians for sin/cos\n- Handle edge cases\n- Add to history\n- Update interactive menu\n\n**Challenge 2: Expression Evaluator**\n\nAdd ability to evaluate expressions like \"2 + 3 * 4\":\n- Use `eval()` CAREFULLY with validation\n- Only allow numbers and operators\n- Prevent code injection\n- Handle syntax errors\n\n**Challenge 3: Persistent History**\n\nSave calculation history to a file:\n- Use try/except/finally for file operations\n- Handle FileNotFoundError\n- Create file if doesn't exist\n- Load history on startup\n- Save on exit\n\n**Starter code for Challenge 1:**",
              "starterCode": "import math\n\nclass RobustCalculator:\n    # ... (previous code) ...\n    \n    def logarithm(self, number, base=10):\n        \"\"\"Calculate logarithm.\n        \n        Args:\n            number: Number to calculate log of\n            base: Logarithm base (default 10)\n            \n        Raises:\n            InvalidNumberError: If number <= 0 or base <= 0\n        \"\"\"\n        # TODO: Validate number and base\n        # TODO: Check number > 0 (can't log negative or zero)\n        # TODO: Check base > 0 and base != 1\n        # TODO: Calculate using math.log(number, base)\n        # TODO: Record in history\n        # TODO: Return result\n        pass\n    \n    def sine(self, angle_degrees):\n        \"\"\"Calculate sine (angle in degrees).\n        \n        Args:\n            angle_degrees: Angle in degrees\n            \n        Returns:\n            float: Sine of angle\n        \"\"\"\n        # TODO: Validate angle\n        # TODO: Convert to radians: math.radians(angle_degrees)\n        # TODO: Calculate: math.sin(angle_radians)\n        # TODO: Record in history\n        # TODO: Return result\n        pass\n    \n    def cosine(self, angle_degrees):\n        \"\"\"Calculate cosine (angle in degrees).\"\"\"\n        # TODO: Similar to sine\n        pass",
              "solution": "",
              "language": "python",
              "testCases": [
                {
                  "description": "Code runs without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "For logarithm: check if number <= 0: raise InvalidNumberError('Log requires positive number'). For sin/cos: angle_rad = math.radians(angle), then math.sin(angle_rad). Don't forget to record in history!"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        }
      ],
      "quizzes": [
        {
          "id": "quiz-08",
          "title": "Module 8 Quiz: Error Handling & Defensive Programming",
          "description": "Test your mastery of error handling: exceptions, try/except/finally, custom exceptions, input validation, and defensive programming. You need 14/20 correct (70%) to pass.",
          "moduleId": "module-08",
          "passingScore": 70,
          "estimatedMinutes": 15,
          "questions": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-08-q1",
              "title": "What happens when an exception occurs in a try block?",
              "description": "What happens when an exception occurs in a try block?",
              "options": [
                "The program crashes immediately",
                "Python jumps to the matching except block",
                "The try block restarts from the beginning",
                "Python ignores the error and continues"
              ],
              "correctAnswer": 1,
              "explanation": "When an exception occurs in a try block, Python immediately stops executing the try block and jumps to the first matching except block. This prevents the program from crashing and allows you to handle the error gracefully."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-08-q2",
              "title": "What is the correct order for try/except/else/finally blocks?",
              "description": "What is the correct order for try/except/else/finally blocks?",
              "options": [
                "try → else → except → finally",
                "try → except → finally → else",
                "try → except → else → finally",
                "The order doesn't matter"
              ],
              "correctAnswer": 2,
              "explanation": "The mandatory order is: try → except(s) → else (optional) → finally (optional). Python enforces this order - any other arrangement will cause a SyntaxError. The else block must come after all except blocks and before finally."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-08-q3",
              "title": "When does the finally block execute?",
              "description": "When does the finally block execute?",
              "options": [
                "Only if the try block succeeds",
                "Only if an exception occurs",
                "Always, no matter what happens",
                "Only if there's a return statement"
              ],
              "correctAnswer": 2,
              "explanation": "The finally block ALWAYS executes, no matter what - whether the try succeeds, an exception occurs, or there's a return/break/continue statement. This makes it perfect for cleanup code like closing files or releasing resources."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-08-q4",
              "title": "When does the else block in try/except/else run?",
              "description": "When does the else block in try/except/else run?",
              "options": [
                "Always, no matter what",
                "Only if an exception occurs",
                "Only if NO exception occurs in the try block",
                "Only if finally runs"
              ],
              "correctAnswer": 2,
              "explanation": "The else block runs ONLY if the try block completes successfully without any exception. If any exception occurs, the else block is skipped entirely. It's useful for code that should only run on success."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-08-q5",
              "title": "What exception is raised when you try to convert 'abc' to an integer with int('abc')?",
              "description": "What exception is raised when you try to convert 'abc' to an integer with int('abc')?",
              "options": [
                "TypeError",
                "ValueError",
                "ConversionError",
                "SyntaxError"
              ],
              "correctAnswer": 1,
              "explanation": "int('abc') raises a ValueError because 'abc' cannot be converted to an integer. ValueError is raised when a function receives an argument of the correct type (string) but with an inappropriate value (not numeric)."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-08-q6",
              "title": "What exception does accessing a list index that doesn't exist raise?",
              "description": "What exception does accessing a list index that doesn't exist raise?",
              "options": [
                "KeyError",
                "IndexError",
                "ValueError",
                "AttributeError"
              ],
              "correctAnswer": 1,
              "explanation": "Accessing a list, tuple, or string index that is out of range raises IndexError. KeyError is for dictionaries, ValueError is for wrong values, and AttributeError is for missing attributes/methods."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-08-q7",
              "title": "How do you catch multiple exception types with the same handler?",
              "description": "How do you catch multiple exception types with the same handler?",
              "options": [
                "except ValueError or TypeError:",
                "except (ValueError, TypeError):",
                "except ValueError, TypeError:",
                "except ValueError and TypeError:"
              ],
              "correctAnswer": 1,
              "explanation": "Use a tuple with parentheses: except (ValueError, TypeError):. This catches both ValueError and TypeError with the same handling code. The parentheses are required in Python 3 to distinguish from the old Python 2 syntax."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-08-q8",
              "title": "Why should you order except blocks from specific to general?",
              "description": "Why should you order except blocks from specific to general?",
              "options": [
                "It runs faster",
                "It's required by Python syntax",
                "Python checks in order and uses the first match, so general exceptions would catch everything",
                "It doesn't matter what order you use"
              ],
              "correctAnswer": 2,
              "explanation": "Python checks except blocks in order and uses the first match. If you put except Exception: first (general), it catches all exceptions, and specific blocks below it never run. Always put specific exceptions first (ValueError, TypeError), general ones last (Exception)."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-08-q9",
              "title": "What is the correct syntax to raise a ValueError with a message?",
              "description": "What is the correct syntax to raise a ValueError with a message?",
              "options": [
                "throw ValueError('message')",
                "raise ValueError('message')",
                "error ValueError('message')",
                "ValueError.raise('message')"
              ],
              "correctAnswer": 1,
              "explanation": "Use raise ExceptionType('message') to raise an exception in Python. The raise keyword is followed by the exception class with an optional message. Note: 'throw' is used in other languages like Java, not Python."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-08-q10",
              "title": "How do you create a custom exception class?",
              "description": "How do you create a custom exception class?",
              "options": [
                "class MyError: pass",
                "class MyError(Exception): pass",
                "class MyError extends Exception: pass",
                "def MyError(Exception): pass"
              ],
              "correctAnswer": 1,
              "explanation": "Custom exceptions must inherit from Exception (or a subclass): class MyError(Exception): pass. This makes Python recognize it as an exception type. The pass keyword means the class has no additional code beyond inheriting from Exception."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-08-q11",
              "title": "When should you use exceptions instead of return values?",
              "description": "When should you use exceptions instead of return values?",
              "options": [
                "Always - exceptions are better than return values",
                "For control flow in loops",
                "For exceptional, unexpected errors (validation failures, violated preconditions)",
                "For expected alternate flows like 'user not found'"
              ],
              "correctAnswer": 2,
              "explanation": "Use exceptions for exceptional, unexpected situations (validation failures, violated preconditions, unrecoverable errors). Use return values for expected alternate flows (search returns 0 results, user enters wrong password). Exceptions are for when something goes wrong, not normal program logic."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-08-q12",
              "title": "What's the difference between raise and raise e when re-raising an exception?",
              "description": "What's the difference between raise and raise e when re-raising an exception?",
              "options": [
                "They're exactly the same",
                "raise preserves the original stack trace, raise e creates a new exception",
                "raise e is faster",
                "raise doesn't work, must use raise e"
              ],
              "correctAnswer": 1,
              "explanation": "Bare raise preserves the original exception with its full stack trace, showing where it originally occurred. raise e creates a new exception at the current location, losing the original context. Always use bare raise to re-raise and preserve debugging information."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-08-q13",
              "title": "What does EAFP stand for and what does it mean?",
              "description": "What does EAFP stand for and what does it mean?",
              "options": [
                "Execute And Fix Programming - run code and fix errors later",
                "Easier to Ask Forgiveness than Permission - try it, handle errors if they occur",
                "Error And Failure Prevention - prevent all possible errors",
                "Evaluate All Function Parameters - validate all inputs"
              ],
              "correctAnswer": 1,
              "explanation": "EAFP (Easier to Ask Forgiveness than Permission) means trying an operation and handling exceptions if they occur, rather than checking conditions first. This is the Pythonic approach: try: dict[key] except KeyError: handle() instead of if key in dict: value = dict[key]."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-08-q14",
              "title": "What should you do BEFORE checking the length of a string from user input?",
              "description": "What should you do BEFORE checking the length of a string from user input?",
              "options": [
                "Convert it to lowercase",
                "Check if it's None and strip whitespace",
                "Check if it contains numbers",
                "Nothing - check length first"
              ],
              "correctAnswer": 1,
              "explanation": "Always check if the string is None and strip whitespace BEFORE checking length. Calling len() on None causes an error. Also, '   ' has length 3 but is effectively empty. Validation order: check None → strip → check empty → check length → check format."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-08-q15",
              "title": "Why validate types with isinstance() before performing operations?",
              "description": "Why validate types with isinstance() before performing operations?",
              "options": [
                "It makes code run faster",
                "It prevents TypeError exceptions when operations are performed on wrong types",
                "It's required by Python syntax",
                "It automatically converts types"
              ],
              "correctAnswer": 1,
              "explanation": "Validating types with isinstance() prevents TypeError exceptions. For example, if age is string '25' and you try age < 0, Python raises TypeError. Check isinstance(age, int) first to ensure it's a number before comparing. Always validate types before type-specific operations."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-08-q16",
              "title": "What's the benefit of using a custom exception hierarchy (base class with specific subclasses)?",
              "description": "What's the benefit of using a custom exception hierarchy (base class with specific subclasses)?",
              "options": [
                "It makes exceptions run faster",
                "It's required for all projects",
                "You can catch all related errors with one except, or specific errors separately",
                "It makes raising exceptions easier"
              ],
              "correctAnswer": 2,
              "explanation": "Exception hierarchies provide flexibility: catch all related errors with except BaseError: or catch specific ones with except SpecificError:. Example: except CalculatorError: catches all calculator errors (InsufficientFunds, InvalidOperation, etc.), while except InsufficientFundsError: catches only that specific error."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-08-q17",
              "title": "Why should you avoid using bare except: clauses?",
              "description": "Why should you avoid using bare except: clauses?",
              "options": [
                "They run slower",
                "They only catch some errors",
                "They catch ALL exceptions including system errors, which can hide bugs",
                "They don't work in Python 3"
              ],
              "correctAnswer": 2,
              "explanation": "Bare except: catches EVERY exception, including KeyboardInterrupt (Ctrl+C) and SystemExit, making it impossible to stop the program normally. This hides bugs and makes debugging hard. Always specify the exception type you want to catch: except ValueError:, except TypeError:, etc."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-08-q18",
              "title": "What's the correct way to validate that a password is not empty?",
              "description": "What's the correct way to validate that a password is not empty?",
              "options": [
                "if password.strip():",
                "if password: (without stripping)",
                "if len(password) > 0:",
                "if password is not None:"
              ],
              "correctAnswer": 1,
              "explanation": "For passwords, check if password: WITHOUT stripping, because leading/trailing spaces might be intentional and part of the password. Don't strip passwords! For usernames and display text, strip first then check. Also verify password is not None first if it could be None."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-08-q19",
              "title": "When using eval() to evaluate user expressions, what's the most important security measure?",
              "description": "When using eval() to evaluate user expressions, what's the most important security measure?",
              "options": [
                "Convert to lowercase first",
                "Validate with a whitelist of allowed characters and restrict the namespace",
                "Only use it with numbers",
                "Always catch exceptions"
              ],
              "correctAnswer": 1,
              "explanation": "When using eval(): (1) Validate input with whitelist of allowed characters, (2) Block dangerous keywords ('import', '__'), (3) Restrict namespace: eval(expr, {'__builtins__': {}}, {}). This prevents code injection. Just catching exceptions isn't enough - malicious code could still execute before raising an exception."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-08-q20",
              "title": "What's the main purpose of defensive programming?",
              "description": "What's the main purpose of defensive programming?",
              "options": [
                "To make programs run faster",
                "To write less code",
                "To assume everything can fail and guard against it with validation and error handling",
                "To avoid using try/except blocks"
              ],
              "correctAnswer": 2,
              "explanation": "Defensive programming means assuming everything CAN fail and proactively guarding against it. Validate all inputs (type, range, format), handle all possible errors, provide clear error messages, and have fallback values. The goal is to write robust code that never crashes and handles unexpected situations gracefully."
            }
          ]
        }
      ]
    },
    {
      "id": "module-09",
      "title": "Module 9",
      "description": "Python programming fundamentals - Module 9",
      "difficulty": "intermediate",
      "estimatedHours": 4,
      "lessons": [
        {
          "id": "09_01",
          "title": "Reading and Writing Text Files",
          "moduleId": "module-09",
          "order": 1,
          "estimatedMinutes": 30,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Concept: Your Program's Filing Cabinet",
              "content": "Until now, all your data disappeared when your program ended. Variables, lists, dictionaries - gone! Like writing on a whiteboard that gets erased every time you leave the room.\n\n**Files are permanent storage** - like writing in a notebook instead of on a whiteboard. Data stays even after your program ends.\n\n**Real-world analogy: A Filing Cabinet**\n\nOpening a file is like opening a filing cabinet drawer:\n\n**READ mode ('r'):** Open drawer to READ documents\n- You can look at the contents\n- You CANNOT add or change anything\n- If the drawer (file) doesn't exist → Error!\n\n**WRITE mode ('w'):** Open drawer to WRITE new documents\n- You can add content\n- WARNING: Erases everything that was there before (starts fresh)\n- If drawer doesn't exist → Creates it automatically\n\n**APPEND mode ('a'):** Open drawer to ADD MORE documents\n- You can add content to the END\n- Keeps existing content (doesn't erase)\n- If drawer doesn't exist → Creates it\n\n**Common operations:**\n\n1. **Reading a file:**\n   - Open filing cabinet ('r' mode)\n   - Read the documents (read() or readlines())\n   - Close filing cabinet\n\n2. **Writing a file:**\n   - Open filing cabinet ('w' mode)\n   - Write your documents (write())\n   - Close filing cabinet (IMPORTANT - saves changes!)\n\n**Critical rule:** Always CLOSE files when done! Like closing the filing cabinet drawer. If you don't close it, changes might not be saved, and other programs can't access the file.\n\nPython has a better way (context managers with `with`) that auto-closes files, which we'll learn in the next lesson."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example: Reading and Writing Files",
              "content": "Key concepts:\n1. **open(filename, mode)** opens a file and returns a file object\n2. **read()** reads entire file as one string\n3. **readline()** reads one line at a time\n4. **readlines()** reads all lines into a list\n5. **write(string)** writes content (must include \\n for new lines)\n6. **close()** MUST be called to save changes and free resources\n7. **File modes:** 'r' (read), 'w' (write/overwrite), 'a' (append)\n\nWithout close(), changes may not be saved!",
              "code": "# Example 1: Writing to a file\nprint(\"=== Writing to a File ===\")\n\n# Open file in WRITE mode (creates if doesn't exist, overwrites if exists)\nfile = open(\"greeting.txt\", \"w\")\n\n# Write content (note: must add \\n for new lines yourself)\nfile.write(\"Hello, World!\\n\")\nfile.write(\"Welcome to Python file handling.\\n\")\nfile.write(\"This is line 3.\\n\")\n\n# MUST close the file to save changes!\nfile.close()\n\nprint(\"✓ Created greeting.txt\\n\")\n\n# Example 2: Reading an entire file\nprint(\"=== Reading Entire File ===\")\n\n# Open file in READ mode\nfile = open(\"greeting.txt\", \"r\")\n\n# Read all content at once\ncontent = file.read()\nprint(\"Content:\")\nprint(content)\n\n# Close the file\nfile.close()\nprint(\"✓ File closed\\n\")\n\n# Example 3: Reading line by line\nprint(\"=== Reading Line by Line ===\")\n\nfile = open(\"greeting.txt\", \"r\")\n\n# readline() reads ONE line at a time\nline1 = file.readline()\nline2 = file.readline()\nline3 = file.readline()\n\nprint(f\"Line 1: {line1.strip()}\")  # .strip() removes \\n\nprint(f\"Line 2: {line2.strip()}\")\nprint(f\"Line 3: {line3.strip()}\")\n\nfile.close()\nprint(\"\")\n\n# Example 4: Reading all lines into a list\nprint(\"=== Reading All Lines as List ===\")\n\nfile = open(\"greeting.txt\", \"r\")\n\n# readlines() returns a list of all lines\nlines = file.readlines()\nprint(f\"Number of lines: {len(lines)}\")\n\nfor i, line in enumerate(lines, 1):\n    print(f\"  {i}. {line.strip()}\")\n\nfile.close()\nprint(\"\")\n\n# Example 5: Appending to a file\nprint(\"=== Appending to a File ===\")\n\n# APPEND mode - adds to end without erasing existing content\nfile = open(\"greeting.txt\", \"a\")\n\nfile.write(\"This line was appended.\\n\")\nfile.write(\"So was this one!\\n\")\n\nfile.close()\n\nprint(\"✓ Appended content\\n\")\n\n# Read updated file\nprint(\"=== Updated File Content ===\")\nfile = open(\"greeting.txt\", \"r\")\nprint(file.read())\nfile.close()\n\n# Example 6: Common file modes\nprint(\"=== File Modes Reference ===\")\nprint(\"'r'  - Read (default). File must exist.\")\nprint(\"'w'  - Write. Creates file or OVERWRITES existing.\")\nprint(\"'a'  - Append. Creates file or adds to end.\")\nprint(\"'r+' - Read and Write. File must exist.\")\nprint(\"'w+' - Write and Read. Creates or overwrites.\")\nprint(\"'a+' - Append and Read. Creates or adds to end.\")\nprint(\"\")\n\n# Example 7: Error handling with files\nprint(\"=== Error Handling ===\")\n\ntry:\n    file = open(\"nonexistent.txt\", \"r\")\n    content = file.read()\n    file.close()\nexcept FileNotFoundError:\n    print(\"❌ Error: File 'nonexistent.txt' does not exist!\")\n    print(\"   Use 'w' or 'a' mode to create it, or check the filename.\")\n\nprint(\"\\n✓ Program continues despite error\")",
              "language": "python"
            },
            {
              "type": "ANALOGY",
              "title": "Syntax Breakdown: File Operations",
              "content": "**Opening Files:**\n```python\n# Basic syntax\nfile_object = open(filename, mode)\n\n# Examples\nfile = open(\"data.txt\", \"r\")   # Read mode\nfile = open(\"output.txt\", \"w\") # Write mode\nfile = open(\"log.txt\", \"a\")    # Append mode\n```\n\n**Reading Methods:**\n\n**read() - Read entire file as one string:**\n```python\nfile = open(\"file.txt\", \"r\")\ncontent = file.read()  # \"Line 1\\nLine 2\\nLine 3\\n\"\nfile.close()\n```\n\n**readline() - Read one line at a time:**\n```python\nfile = open(\"file.txt\", \"r\")\nline1 = file.readline()  # \"Line 1\\n\"\nline2 = file.readline()  # \"Line 2\\n\"\nfile.close()\n```\n\n**readlines() - Read all lines into a list:**\n```python\nfile = open(\"file.txt\", \"r\")\nlines = file.readlines()  # [\"Line 1\\n\", \"Line 2\\n\", \"Line 3\\n\"]\nfile.close()\n```\n\n**Iterating over file lines (memory efficient):**\n```python\nfile = open(\"file.txt\", \"r\")\nfor line in file:  # Reads one line at a time\n    print(line.strip())\nfile.close()\n```\n\n**Writing Methods:**\n\n**write() - Write a string:**\n```python\nfile = open(\"file.txt\", \"w\")\nfile.write(\"Hello\\n\")  # Must add \\n yourself!\nfile.write(\"World\\n\")\nfile.close()\n```\n\n**writelines() - Write a list of strings:**\n```python\nfile = open(\"file.txt\", \"w\")\nlines = [\"Line 1\\n\", \"Line 2\\n\", \"Line 3\\n\"]\nfile.writelines(lines)  # Doesn't add \\n automatically!\nfile.close()\n```\n\n**File Modes Quick Reference:**\n\n| Mode | Description | Creates File? | Overwrites? |\n|------|-------------|---------------|-------------|\n| 'r'  | Read only   | No (error)    | N/A         |\n| 'w'  | Write       | Yes           | YES         |\n| 'a'  | Append      | Yes           | No          |\n| 'r+' | Read+Write  | No (error)    | No          |\n| 'w+' | Write+Read  | Yes           | YES         |\n| 'a+' | Append+Read | Yes           | No          |\n\n**Important notes:**\n\n1. **Always close files:** file.close() or use `with` (next lesson)\n\n2. **Write mode ('w') overwrites:** All existing content is DELETED!\n\n3. **Read mode requires file exists:** FileNotFoundError if not found\n\n4. **Line endings:** write() doesn't add \\n automatically - you must add it\n\n5. **strip() removes \\n:** When reading lines, use .strip() to remove newline characters\n\n**Common pattern for reading:**\n```python\ntry:\n    file = open(\"data.txt\", \"r\")\n    content = file.read()\n    file.close()\nexcept FileNotFoundError:\n    print(\"File not found!\")\n```\n\n**Common pattern for writing:**\n```python\nfile = open(\"output.txt\", \"w\")\nfile.write(\"Line 1\\n\")\nfile.write(\"Line 2\\n\")\nfile.close()  # IMPORTANT: Saves changes!\n```"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "- **Files persist data** beyond program execution. Unlike variables, file content stays after the program ends.\n- **open(filename, mode)** opens a file. Returns a file object you can read from or write to.\n- **Always close files** with file.close() to save changes and free resources. Without closing, changes may not be saved!\n- **Read methods:** read() (entire file as string), readline() (one line), readlines() (list of lines), or iterate with for line in file:\n- **Write method:** write(string) writes content. Must add \\n yourself for new lines! write() doesn't add it automatically.\n- **File modes:** 'r' (read, file must exist), 'w' (write, OVERWRITES existing), 'a' (append, adds to end without erasing).\n- **'w' mode is destructive:** Opens in write mode ERASES all existing content! Use 'a' to add without erasing.\n- **Handle FileNotFoundError** when reading files that might not exist. Use try/except for robust code.\n- **strip() removes \\n:** When reading lines, use line.strip() to remove trailing newline characters.\n- **Next lesson:** Context managers with 'with' statement - a better way that auto-closes files!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "09_01-challenge-3",
              "title": "Interactive Exercise: Build a Simple Note-Taking App",
              "description": "Create a simple note-taking application that can:\n1. Write a new note to \"notes.txt\" (overwrite existing)\n2. Add a note to \"notes.txt\" (append without erasing)\n3. Read and display all notes from \"notes.txt\"\n4. Handle FileNotFoundError if file doesn't exist when reading\n\n**Your task:**\nImplement three functions: write_note(), append_note(), and read_notes()\n\n**Starter code:**",
              "instructions": "Create a simple note-taking application that can:\n1. Write a new note to \"notes.txt\" (overwrite existing)\n2. Add a note to \"notes.txt\" (append without erasing)\n3. Read and display all notes from \"notes.txt\"\n4. Handle FileNotFoundError if file doesn't exist when reading\n\n**Your task:**\nImplement three functions: write_note(), append_note(), and read_notes()\n\n**Starter code:**",
              "starterCode": "def write_note(note):\n    \"\"\"Write a new note (overwrites existing notes).\"\"\"\n    # TODO: Open notes.txt in WRITE mode\n    # TODO: Write the note (add \\n at the end)\n    # TODO: Close the file\n    pass\n\ndef append_note(note):\n    \"\"\"Add a note to existing notes.\"\"\"\n    # TODO: Open notes.txt in APPEND mode\n    # TODO: Write the note (add \\n at the end)\n    # TODO: Close the file\n    pass\n\ndef read_notes():\n    \"\"\"Read and return all notes.\"\"\"\n    try:\n        # TODO: Open notes.txt in READ mode\n        # TODO: Read all content\n        # TODO: Close the file\n        # TODO: Return the content\n        pass\n    except FileNotFoundError:\n        return \"No notes found. Create a note first!\"\n\n# Test your functions\nprint(\"=== Testing Note App ===\")\n\n# Test 1: Write a new note\nprint(\"\\n1. Writing first note...\")\nwrite_note(\"Remember to buy milk\")\nprint(\"✓ Note written\")\n\n# Test 2: Read notes\nprint(\"\\n2. Reading notes...\")\nprint(read_notes())\n\n# Test 3: Append more notes\nprint(\"3. Adding more notes...\")\nappend_note(\"Call dentist tomorrow\")\nappend_note(\"Finish Python homework\")\nprint(\"✓ Notes added\")\n\n# Test 4: Read all notes\nprint(\"\\n4. Reading all notes...\")\nprint(read_notes())",
              "solution": "",
              "language": "python",
              "testCases": [
                {
                  "description": "Code runs without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "For write_note: open('notes.txt', 'w'), file.write(note + '\\n'), file.close(). For append_note: use 'a' mode. For read_notes: use 'r' mode and file.read()."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "09_02",
          "title": "Context Managers and the with Statement",
          "moduleId": "module-09",
          "order": 2,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Concept: The Self-Closing Door",
              "content": "Remember how you must manually call file.close()? What if you forget? What if an error occurs before you close the file? The file stays open (resource leak)!\n\n**The Problem with Manual Closing:**\n\n```python\nfile = open(\"data.txt\", \"r\")\ncontent = file.read()\n# Oh no! Error here before close()\nfile.close()  # This never runs!\n```\n\nIf an error occurs before close(), the file stays open forever (or until program ends).\n\n**Real-world analogy: Self-Closing Doors**\n\nRegular file handling is like a manual door:\n- You open it\n- You use the room\n- You MUST remember to close it\n- If you forget or something goes wrong, door stays open\n\n**Context managers (with statement)** are like self-closing doors:\n- You open the door (enter the room)\n- You use the room\n- Door AUTOMATICALLY closes when you leave, GUARANTEED\n- Even if you trip and fall (error), door still closes!\n\nThe **with statement** is Python's way of saying: \"Let me handle the cleanup for you.\"\n\n**Old way (manual):**\n```python\nfile = open(\"data.txt\", \"r\")\ntry:\n    content = file.read()\nfinally:\n    file.close()  # Must remember this!\n```\n\n**New way (with statement):**\n```python\nwith open(\"data.txt\", \"r\") as file:\n    content = file.read()\n# File automatically closed here, even if error!\n```\n\n**Benefits of with:**\n1. **Automatic cleanup** - file closes automatically\n2. **Error safe** - closes even if exception occurs\n3. **Cleaner code** - no need for try/finally\n4. **Professional** - this is how Python experts write code\n\n**When to use with:**\n- Files (always!)\n- Database connections\n- Network sockets\n- Locks and semaphores\n- Any resource that needs cleanup\n\nFrom now on, ALWAYS use 'with' for files. It's the Pythonic way!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example: with Statement in Action",
              "content": "The with statement provides:\n1. **Automatic resource management** - file closes when block ends\n2. **Exception safety** - file closes even if error occurs\n3. **Cleaner syntax** - no need for try/finally\n4. **Multiple resources** - can open multiple files in one with\n5. **Iteration support** - can iterate over file object directly\n\nThe syntax: with open(filename, mode) as variable: means \"open this file, call it 'variable', and auto-close when done.\"",
              "code": "# Example 1: Basic with statement\nprint(\"=== Basic with Statement ===\")\n\n# Write to file using with\nwith open(\"demo.txt\", \"w\") as file:\n    file.write(\"Line 1\\n\")\n    file.write(\"Line 2\\n\")\n    file.write(\"Line 3\\n\")\n# File automatically closed here!\n\nprint(\"✓ File written and auto-closed\")\n\n# Read from file using with\nwith open(\"demo.txt\", \"r\") as file:\n    content = file.read()\n    print(\"\\nContent:\")\n    print(content)\n# File automatically closed here!\n\nprint(\"✓ File read and auto-closed\\n\")\n\n# Example 2: with handles errors automatically\nprint(\"=== Error Handling with 'with' ===\")\n\ntry:\n    with open(\"demo.txt\", \"r\") as file:\n        print(\"Reading file...\")\n        content = file.read()\n        print(\"File content retrieved\")\n        \n        # Simulate an error\n        raise ValueError(\"Simulated error!\")\n        \n        print(\"This line never runs\")\n        \nexcept ValueError as e:\n    print(f\"Error occurred: {e}\")\n    print(\"But file was STILL closed automatically!\\n\")\n\n# Example 3: Multiple files at once\nprint(\"=== Opening Multiple Files ===\")\n\n# Write source file\nwith open(\"source.txt\", \"w\") as file:\n    file.write(\"This is the source content.\\n\")\n\nprint(\"✓ Source file created\")\n\n# Copy from one file to another\nwith open(\"source.txt\", \"r\") as source, \\\n     open(\"destination.txt\", \"w\") as dest:\n    \n    # Read from source\n    content = source.read()\n    \n    # Write to destination\n    dest.write(content)\n    dest.write(\"This line was added during copy.\\n\")\n\nprint(\"✓ File copied\")\n\n# Verify\nwith open(\"destination.txt\", \"r\") as file:\n    print(\"\\nDestination content:\")\n    print(file.read())\n\n# Example 4: with vs. manual closing comparison\nprint(\"=== Comparison: with vs. Manual ===\")\n\nprint(\"\\nManual way (old, error-prone):\")\ntry:\n    file = open(\"manual.txt\", \"w\")\n    file.write(\"Manual closing\\n\")\nfinally:\n    file.close()\n    print(\"  ✓ Had to remember to close in finally\")\n\nprint(\"\\nWith statement (modern, safe):\")\nwith open(\"with.txt\", \"w\") as file:\n    file.write(\"Automatic closing\\n\")\nprint(\"  ✓ Automatically closed, no finally needed\")\n\n# Example 5: Reading file line by line with 'with'\nprint(\"\\n=== Line-by-Line Reading ===\")\n\n# Create test file\nwith open(\"lines.txt\", \"w\") as file:\n    for i in range(1, 6):\n        file.write(f\"Line {i}: Some content here\\n\")\n\nprint(\"✓ Created test file\")\n\n# Read line by line\nprint(\"\\nReading line by line:\")\nwith open(\"lines.txt\", \"r\") as file:\n    for line_num, line in enumerate(file, 1):\n        print(f\"  {line_num}. {line.strip()}\")\n\nprint(\"\\n✓ File automatically closed after iteration\")\n\n# Example 6: Appending with 'with'\nprint(\"\\n=== Appending to File ===\")\n\nwith open(\"log.txt\", \"w\") as file:\n    file.write(\"Log started\\n\")\n\nprint(\"✓ Log file created\")\n\nwith open(\"log.txt\", \"a\") as file:\n    file.write(\"Entry 1: User logged in\\n\")\n    file.write(\"Entry 2: User viewed dashboard\\n\")\n    file.write(\"Entry 3: User logged out\\n\")\n\nprint(\"✓ Entries appended\")\n\nwith open(\"log.txt\", \"r\") as file:\n    print(\"\\nLog content:\")\n    print(file.read())\n\nprint(\"=== All examples completed ===\")",
              "language": "python"
            },
            {
              "type": "ANALOGY",
              "title": "Syntax Breakdown: The with Statement",
              "content": "**Basic with syntax:**\n```python\nwith open(filename, mode) as variable_name:\n    # Code that uses the file\n    # File is open inside this indented block\n# File automatically closed here (outside block)\n```\n\n**Reading with 'with':**\n```python\nwith open(\"data.txt\", \"r\") as file:\n    content = file.read()\n    print(content)\n# file.close() called automatically\n```\n\n**Writing with 'with':**\n```python\nwith open(\"output.txt\", \"w\") as file:\n    file.write(\"Hello\\n\")\n    file.write(\"World\\n\")\n# file.close() called automatically\n```\n\n**Appending with 'with':**\n```python\nwith open(\"log.txt\", \"a\") as file:\n    file.write(\"New entry\\n\")\n# file.close() called automatically\n```\n\n**Multiple files:**\n```python\n# Can open multiple files in one with statement\nwith open(\"input.txt\", \"r\") as infile, \\\n     open(\"output.txt\", \"w\") as outfile:\n    content = infile.read()\n    outfile.write(content.upper())\n# Both files closed automatically\n```\n\n**Iterating over lines:**\n```python\n# Most memory-efficient way to read large files\nwith open(\"data.txt\", \"r\") as file:\n    for line in file:  # Reads one line at a time\n        print(line.strip())\n# File closed automatically after loop\n```\n\n**How with works (behind the scenes):**\n\nWhen you write:\n```python\nwith open(\"file.txt\", \"r\") as file:\n    content = file.read()\n```\n\nPython does this:\n```python\nfile = open(\"file.txt\", \"r\")  # __enter__ called\ntry:\n    content = file.read()\nfinally:\n    file.close()  # __exit__ called, even if error\n```\n\nThe with statement:\n1. Calls `__enter__()` method (opens file)\n2. Runs your code in the block\n3. Calls `__exit__()` method (closes file) in finally block\n4. Guarantees cleanup happens!\n\n**Why the name 'context manager'?**\n\n\"Context\" = the environment/setup needed for your code\n\"Manager\" = handles setup and cleanup automatically\n\nopen() is a context manager because it:\n- Sets up context: opens the file\n- Manages cleanup: closes the file\n\n**With vs. Manual Closing:**\n\n**❌ Don't do this (manual closing):**\n```python\nfile = open(\"data.txt\", \"r\")\ncontent = file.read()\nfile.close()  # Might not run if error occurs!\n```\n\n**✅ Do this (with statement):**\n```python\nwith open(\"data.txt\", \"r\") as file:\n    content = file.read()\n# Always closes, even if error\n```\n\n**When is the file actually closed?**\n\nThe file closes IMMEDIATELY when:\n1. The with block ends (normal execution)\n2. An exception occurs (error)\n3. You return from inside the block\n4. You break from a loop in the block\n\nNo matter what, the file WILL close!"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "- **Always use 'with' for files** - it's the professional, Pythonic way. Guarantees files are closed even if errors occur.\n- **Syntax: with open(filename, mode) as variable:** Opens file, assigns to variable, auto-closes when block ends.\n- **Automatic cleanup:** File closes IMMEDIATELY when with block ends, no matter what (normal end, error, return, break).\n- **Exception safe:** Even if an exception occurs inside the with block, the file WILL close. No need for try/finally.\n- **Multiple files:** Can open multiple files in one with: with open(f1) as a, open(f2) as b:\n- **File closed after with:** You CANNOT use the file object after the with block ends - it's already closed.\n- **Read/write inside with:** All file operations must happen inside the indented with block while file is open.\n- **Context managers:** 'with' works with any context manager (files, locks, database connections). Handles setup and cleanup.\n- **Memory efficient iteration:** with open(...) as f: for line in f: reads one line at a time (great for huge files).\n- **Professional code:** From now on, use 'with' for ALL file operations. It's cleaner, safer, and Pythonic."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "09_02-challenge-3",
              "title": "Interactive Exercise: File Copy with Error Handling",
              "description": "Create a file copy function that:\n1. Copies content from source file to destination file\n2. Uses with statement for both files\n3. Handles FileNotFoundError if source doesn't exist\n4. Adds a header line to the copied file: \"--- Copy of [filename] ---\"\n5. Returns True if successful, False if source not found\n\n**Your task:**\nImplement copy_file(source, destination)\n\n**Starter code:**",
              "instructions": "Create a file copy function that:\n1. Copies content from source file to destination file\n2. Uses with statement for both files\n3. Handles FileNotFoundError if source doesn't exist\n4. Adds a header line to the copied file: \"--- Copy of [filename] ---\"\n5. Returns True if successful, False if source not found\n\n**Your task:**\nImplement copy_file(source, destination)\n\n**Starter code:**",
              "starterCode": "def copy_file(source, destination):\n    \"\"\"Copy file with header using context managers.\n    \n    Args:\n        source: Source filename\n        destination: Destination filename\n        \n    Returns:\n        bool: True if successful, False if source not found\n    \"\"\"\n    try:\n        # TODO: Use with to open source file in read mode\n        # TODO: Read all content from source\n        \n        # TODO: Use with to open destination file in write mode\n        # TODO: Write header: \"--- Copy of [source] ---\\n\"\n        # TODO: Write the content from source\n        \n        return True\n    \n    except FileNotFoundError:\n        print(f\"Error: Source file '{source}' not found\")\n        return False\n\n# Test your function\nprint(\"=== Testing File Copy ===\")\n\n# Create source file\nwith open(\"original.txt\", \"w\") as f:\n    f.write(\"This is the original content.\\n\")\n    f.write(\"It has multiple lines.\\n\")\n    f.write(\"All should be copied.\\n\")\n\nprint(\"✓ Created source file\\n\")\n\n# Test 1: Copy existing file\nprint(\"Test 1: Copy existing file\")\nif copy_file(\"original.txt\", \"copy.txt\"):\n    with open(\"copy.txt\", \"r\") as f:\n        print(\"Copied content:\")\n        print(f.read())\n\n# Test 2: Copy non-existent file\nprint(\"\\nTest 2: Copy non-existent file\")\ncopy_file(\"missing.txt\", \"copy2.txt\")",
              "solution": "",
              "language": "python",
              "testCases": [
                {
                  "description": "Code runs without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use two separate with statements: first to read source, then to write destination. Or use with open(...) as src, open(...) as dst: for both at once."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "09_03",
          "title": "Working with CSV Files",
          "moduleId": "module-09",
          "order": 3,
          "estimatedMinutes": 30,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Concept: Spreadsheets as Text Files",
              "content": "**CSV = Comma-Separated Values** - A simple way to store spreadsheet/table data in plain text.\n\n**Real-world analogy: A Table Written in Text**\n\nImagine you have a spreadsheet:\n```\nName       | Age | City\n-----------|-----|----------\nAlice      | 25  | NYC\nBob        | 30  | LA\nCarol      | 28  | Chicago\n```\n\nIn CSV format, this becomes:\n```\nName,Age,City\nAlice,25,NYC\nBob,30,LA\nCarol,28,Chicago\n```\n\nEach row = one line, values separated by commas.\n\n**Why CSV is everywhere:**\n- Excel can open it\n- Google Sheets can open it\n- Databases can import/export it\n- Every programming language can read it\n- Simple, universal format\n\n**Real-world uses:**\n1. **Export data from apps** - Download your bank transactions, contacts, sales data\n2. **Data exchange** - Share data between different programs\n3. **Bulk uploads** - Import 1000 products into your store\n4. **Data analysis** - Load data into Python for processing\n\n**Python's csv module** handles:\n- Reading CSV files (parsing commas correctly)\n- Writing CSV files (formatting data correctly)\n- Handling special cases (commas in data, quotes, etc.)\n\n**Why use csv module instead of split(','):**\n\nBasic split breaks with:\n```\n\"Smith, John\",25,NYC  # Name has a comma!\n\"Product \"\"Best\"\" 2000\",19.99  # Quotes in name!\n```\n\nThe csv module handles these edge cases automatically.\n\n**Common operations:**\n- Read CSV → Process rows → Display/analyze\n- Create list of dicts → Write to CSV → Share file\n- Read CSV → Modify data → Write new CSV\n- Filter CSV data (select certain rows/columns)"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example: Reading and Writing CSV Files",
              "content": "Key concepts:\n1. **csv.writer()** - Write lists to CSV (row by row)\n2. **csv.reader()** - Read CSV into lists\n3. **csv.DictWriter()** - Write dictionaries to CSV (keys = column names)\n4. **csv.DictReader()** - Read CSV into dictionaries (column names = keys)\n5. **newline=''** - Required parameter when opening CSV files in write mode\n6. **writeheader()** - DictWriter method to write column headers\n7. **next(reader)** - Skip header row when processing data\n\nDictReader/DictWriter are usually easier because you can access columns by name!",
              "code": "import csv\n\n# Example 1: Writing a CSV file\nprint(\"=== Writing CSV File ===\")\n\n# Data to write (list of lists)\nstudents = [\n    [\"Name\", \"Age\", \"Grade\", \"City\"],  # Header row\n    [\"Alice\", 20, \"A\", \"NYC\"],\n    [\"Bob\", 22, \"B\", \"LA\"],\n    [\"Carol\", 21, \"A\", \"Chicago\"],\n    [\"David\", 23, \"C\", \"Boston\"]\n]\n\nwith open(\"students.csv\", \"w\", newline='') as file:\n    writer = csv.writer(file)\n    \n    # Write all rows\n    writer.writerows(students)\n    # Or write one at a time: writer.writerow(row)\n\nprint(\"✓ Created students.csv\\n\")\n\n# Example 2: Reading a CSV file\nprint(\"=== Reading CSV File ===\")\n\nwith open(\"students.csv\", \"r\") as file:\n    reader = csv.reader(file)\n    \n    print(\"File contents:\")\n    for row in reader:\n        print(row)  # Each row is a list\n\nprint(\"\")\n\n# Example 3: Reading with headers\nprint(\"=== Reading with Header Processing ===\")\n\nwith open(\"students.csv\", \"r\") as file:\n    reader = csv.reader(file)\n    \n    # Get header row first\n    headers = next(reader)\n    print(f\"Headers: {headers}\\n\")\n    \n    # Process data rows\n    print(\"Students:\")\n    for row in reader:\n        name, age, grade, city = row\n        print(f\"  {name} (age {age}): Grade {grade} from {city}\")\n\nprint(\"\")\n\n# Example 4: Using DictReader (rows as dictionaries)\nprint(\"=== DictReader - Rows as Dictionaries ===\")\n\nwith open(\"students.csv\", \"r\") as file:\n    reader = csv.DictReader(file)\n    \n    for row in reader:\n        # Each row is a dictionary!\n        print(f\"{row['Name']}: {row['Grade']} grade, {row['Age']} years old\")\n\nprint(\"\")\n\n# Example 5: Writing with DictWriter\nprint(\"=== DictWriter - Writing Dictionaries ===\")\n\nproducts = [\n    {\"Product\": \"Laptop\", \"Price\": 999.99, \"Stock\": 15},\n    {\"Product\": \"Mouse\", \"Price\": 29.99, \"Stock\": 50},\n    {\"Product\": \"Keyboard\", \"Price\": 79.99, \"Stock\": 30}\n]\n\nwith open(\"products.csv\", \"w\", newline='') as file:\n    fieldnames = [\"Product\", \"Price\", \"Stock\"]\n    writer = csv.DictWriter(file, fieldnames=fieldnames)\n    \n    # Write header\n    writer.writeheader()\n    \n    # Write data rows\n    writer.writerows(products)\n\nprint(\"✓ Created products.csv\\n\")\n\n# Read it back\nprint(\"Product catalog:\")\nwith open(\"products.csv\", \"r\") as file:\n    reader = csv.DictReader(file)\n    for row in reader:\n        print(f\"  {row['Product']}: ${row['Price']} ({row['Stock']} in stock)\")\n\nprint(\"\")\n\n# Example 6: Filtering and processing CSV data\nprint(\"=== Filtering CSV Data ===\")\n\nprint(\"Students with grade 'A':\")\nwith open(\"students.csv\", \"r\") as file:\n    reader = csv.DictReader(file)\n    \n    for row in reader:\n        if row['Grade'] == 'A':\n            print(f\"  - {row['Name']} from {row['City']}\")\n\nprint(\"\")\n\n# Example 7: Handling special characters\nprint(\"=== Handling Special Characters ===\")\n\nspecial_data = [\n    [\"Name\", \"Company\", \"Salary\"],\n    [\"Smith, John\", \"Tech Corp\", \"75,000\"],  # Commas in data!\n    ['Jane \"JJ\" Doe', \"StartUp Inc\", \"80,000\"],  # Quotes in data!\n]\n\nwith open(\"special.csv\", \"w\", newline='') as file:\n    writer = csv.writer(file)\n    writer.writerows(special_data)\n\nprint(\"✓ Written data with commas and quotes\")\n\n# Read it back - csv module handles it correctly\nwith open(\"special.csv\", \"r\") as file:\n    reader = csv.reader(file)\n    next(reader)  # Skip header\n    \n    print(\"\\nData read correctly:\")\n    for row in reader:\n        print(f\"  Name: {row[0]}\")\n        print(f\"  Company: {row[1]}\")\n        print(f\"  Salary: {row[2]}\\n\")\n\nprint(\"✓ CSV module handled special characters correctly!\")",
              "language": "python"
            },
            {
              "type": "ANALOGY",
              "title": "Syntax Breakdown: CSV Operations",
              "content": "**Importing csv module:**\n```python\nimport csv\n```\n\n**Writing CSV - Basic (lists):**\n```python\nwith open('data.csv', 'w', newline='') as file:\n    writer = csv.writer(file)\n    \n    # Write one row\n    writer.writerow(['Name', 'Age', 'City'])\n    \n    # Write multiple rows\n    rows = [\n        ['Alice', 25, 'NYC'],\n        ['Bob', 30, 'LA']\n    ]\n    writer.writerows(rows)\n```\n\n**Reading CSV - Basic (lists):**\n```python\nwith open('data.csv', 'r') as file:\n    reader = csv.reader(file)\n    \n    for row in reader:\n        # row is a list: ['Alice', '25', 'NYC']\n        print(row[0], row[1], row[2])\n```\n\n**Writing CSV - Dictionaries (recommended):**\n```python\nwith open('data.csv', 'w', newline='') as file:\n    fieldnames = ['Name', 'Age', 'City']\n    writer = csv.DictWriter(file, fieldnames=fieldnames)\n    \n    writer.writeheader()  # Write column names\n    \n    writer.writerow({'Name': 'Alice', 'Age': 25, 'City': 'NYC'})\n    \n    # Or write multiple\n    data = [\n        {'Name': 'Bob', 'Age': 30, 'City': 'LA'},\n        {'Name': 'Carol', 'Age': 28, 'City': 'Chicago'}\n    ]\n    writer.writerows(data)\n```\n\n**Reading CSV - Dictionaries (recommended):**\n```python\nwith open('data.csv', 'r') as file:\n    reader = csv.DictReader(file)\n    \n    for row in reader:\n        # row is a dict: {'Name': 'Alice', 'Age': '25', 'City': 'NYC'}\n        print(row['Name'], row['Age'], row['City'])\n```\n\n**Important: newline='' parameter**\n\nAlways use `newline=''` when opening CSV files in write mode:\n```python\nwith open('data.csv', 'w', newline='') as file:  # newline='' required!\n```\n\nWithout it, you get extra blank lines on Windows.\n\n**Skipping header row:**\n```python\nwith open('data.csv', 'r') as file:\n    reader = csv.reader(file)\n    next(reader)  # Skip first row (header)\n    \n    for row in reader:\n        # Process data rows only\n        pass\n```\n\n**Common patterns:**\n\n**1. Read CSV into list of dictionaries:**\n```python\nwith open('data.csv', 'r') as file:\n    reader = csv.DictReader(file)\n    data = list(reader)  # Convert to list\n\n# Now you have: [{'Name': 'Alice', ...}, {...}, ...]\n```\n\n**2. Filter CSV data:**\n```python\nwith open('data.csv', 'r') as file:\n    reader = csv.DictReader(file)\n    \n    for row in reader:\n        if int(row['Age']) >= 25:  # Filter condition\n            print(row['Name'])\n```\n\n**3. Transform CSV (read → modify → write):**\n```python\n# Read\nwith open('input.csv', 'r') as infile:\n    reader = csv.DictReader(infile)\n    data = list(reader)\n\n# Modify\nfor row in data:\n    row['Age'] = int(row['Age']) + 1  # Add 1 to age\n\n# Write\nwith open('output.csv', 'w', newline='') as outfile:\n    writer = csv.DictWriter(outfile, fieldnames=data[0].keys())\n    writer.writeheader()\n    writer.writerows(data)\n```\n\n**CSV vs regular text files:**\n\n**Regular text file:**\n```python\nwith open('file.txt', 'w') as f:\n    f.write('Hello\\n')\n```\n\n**CSV file:**\n```python\nwith open('file.csv', 'w', newline='') as f:\n    writer = csv.writer(f)\n    writer.writerow(['Hello', 'World'])\n```\n\n**Key differences:**\n- CSV needs `import csv`\n- CSV needs `newline=''` when writing\n- CSV handles commas/quotes in data automatically\n- DictReader/DictWriter make column access easier"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "- **CSV = Comma-Separated Values** - Universal format for tabular/spreadsheet data. Works with Excel, databases, and all programming languages.\n- **import csv** - Python's built-in module for reading and writing CSV files. Handles edge cases (commas in data, quotes) automatically.\n- **csv.writer()** writes lists to CSV. **csv.DictWriter()** writes dictionaries (recommended - easier to use).\n- **csv.reader()** reads CSV as lists. **csv.DictReader()** reads as dictionaries (recommended - access by column name).\n- **Always use newline=''** when opening CSV files in write mode: open('file.csv', 'w', newline=''). Required to avoid extra blank lines.\n- **writeheader()** - DictWriter method to write column names as first row. Don't forget to call this!\n- **CSV values are strings!** Even numbers come back as strings. Always convert: int(row['Age']), float(row['Price']).\n- **DictReader/DictWriter advantages:** Access columns by name (row['Name']) instead of index (row[0]). More readable and less error-prone.\n- **Never use split(',')** for CSV! Use csv module instead. It correctly handles commas in data, quotes, and other edge cases.\n- **Common pattern:** Read CSV with DictReader → Process/filter data → Write new CSV with DictWriter."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "09_03-challenge-3",
              "title": "Interactive Exercise: Student Grade Manager",
              "description": "Create a student grade management system that:\n1. Writes student records to \"grades.csv\" (Name, Subject, Grade, Score)\n2. Reads and displays all records\n3. Calculates average score per student\n4. Finds all students with grade 'A'\n\nUse DictWriter and DictReader for easier column access.\n\n**Your task:**\nImplement the functions below.\n\n**Starter code:**",
              "instructions": "Create a student grade management system that:\n1. Writes student records to \"grades.csv\" (Name, Subject, Grade, Score)\n2. Reads and displays all records\n3. Calculates average score per student\n4. Finds all students with grade 'A'\n\nUse DictWriter and DictReader for easier column access.\n\n**Your task:**\nImplement the functions below.\n\n**Starter code:**",
              "starterCode": "import csv\n\ndef create_grades_file(records):\n    \"\"\"Write grade records to CSV.\n    \n    Args:\n        records: List of dictionaries with keys: Name, Subject, Grade, Score\n    \"\"\"\n    # TODO: Open grades.csv in write mode with newline=''\n    # TODO: Create DictWriter with fieldnames\n    # TODO: Write header\n    # TODO: Write all records\n    pass\n\ndef read_all_grades():\n    \"\"\"Read and display all grade records.\"\"\"\n    # TODO: Open grades.csv in read mode\n    # TODO: Create DictReader\n    # TODO: Read and print each row\n    pass\n\ndef calculate_averages():\n    \"\"\"Calculate average score per student.\n    \n    Returns:\n        dict: {student_name: average_score}\n    \"\"\"\n    # TODO: Read CSV with DictReader\n    # TODO: Group scores by student name\n    # TODO: Calculate average for each student\n    # TODO: Return dictionary\n    pass\n\ndef find_a_students():\n    \"\"\"Find all students with grade 'A'.\n    \n    Returns:\n        list: List of student names with grade A\n    \"\"\"\n    # TODO: Read CSV with DictReader\n    # TODO: Filter rows where Grade == 'A'\n    # TODO: Return list of names\n    pass\n\n# Test data\ngrade_records = [\n    {'Name': 'Alice', 'Subject': 'Math', 'Grade': 'A', 'Score': '95'},\n    {'Name': 'Alice', 'Subject': 'English', 'Grade': 'B', 'Score': '85'},\n    {'Name': 'Bob', 'Subject': 'Math', 'Grade': 'B', 'Score': '88'},\n    {'Name': 'Bob', 'Subject': 'English', 'Grade': 'A', 'Score': '92'},\n    {'Name': 'Carol', 'Subject': 'Math', 'Grade': 'A', 'Score': '97'},\n    {'Name': 'Carol', 'Subject': 'English', 'Grade': 'A', 'Score': '94'},\n]\n\n# Test your functions\nprint(\"Creating grades file...\")\ncreate_grades_file(grade_records)\n\nprint(\"\\nAll grades:\")\nread_all_grades()\n\nprint(\"\\nAverage scores:\")\naverages = calculate_averages()\nfor name, avg in averages.items():\n    print(f\"  {name}: {avg:.1f}\")\n\nprint(\"\\nStudents with A grades:\")\na_students = find_a_students()\nfor name in a_students:\n    print(f\"  - {name}\")",
              "solution": "",
              "language": "python",
              "testCases": [
                {
                  "description": "Code runs without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use csv.DictWriter(file, fieldnames=['Name', 'Subject', 'Grade', 'Score']) for writing. Use csv.DictReader(file) for reading. Remember newline='' when opening for write!"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "09_04",
          "title": "Working with JSON Files - Structured Data Storage",
          "moduleId": "module-09",
          "order": 4,
          "estimatedMinutes": 30,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Concept: Speaking the Internet's Language",
              "content": "**JSON = JavaScript Object Notation** - The universal language for exchanging data between programs, websites, and APIs.\n\n**Real-world analogy: International Shipping Labels**\n\nImagine you need to ship a package internationally. You can't write the address in just English or just Chinese - you need a universal format that every postal service understands.\n\n**JSON is that universal format for data.**\n\nEvery programming language speaks JSON:\n- Python ↔ JSON ↔ JavaScript\n- Java ↔ JSON ↔ Ruby\n- C++ ↔ JSON ↔ Go\n\n**Why JSON is everywhere:**\n1. **APIs** - 99% of web APIs send/receive JSON\n2. **Configuration files** - package.json, settings.json, config.json\n3. **Data exchange** - Save Python data, load in JavaScript\n4. **Databases** - MongoDB, Postgres use JSON\n5. **Human-readable** - You can read and edit it\n\n**JSON looks like Python dictionaries:**\n\n```python\n# Python dictionary\nperson = {\n    \"name\": \"Alice\",\n    \"age\": 25,\n    \"hobbies\": [\"reading\", \"coding\"],\n    \"active\": True\n}\n\n# JSON (almost identical!)\n{\n    \"name\": \"Alice\",\n    \"age\": 25,\n    \"hobbies\": [\"reading\", \"coding\"],\n    \"active\": true\n}\n```\n\n**Key differences:**\n- JSON uses `true`/`false`/`null` (lowercase)\n- Python uses `True`/`False`/`None`\n- JSON requires double quotes \" (not single ')\n\n**Two main operations:**\n\n1. **Serialization (Python → JSON):**\n   - Convert Python object to JSON string\n   - `json.dumps()` - dump to string\n   - `json.dump()` - dump to file\n\n2. **Deserialization (JSON → Python):**\n   - Convert JSON string to Python object  \n   - `json.loads()` - load from string\n   - `json.load()` - load from file\n\n**Common use cases:**\n- Save app settings to config.json\n- Store user data between sessions\n- Send data to/from web APIs\n- Exchange data between programs\n- Create data files for testing"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example: JSON Operations",
              "content": "Key functions:\n\n**Writing (Serialization):**\n- `json.dumps(obj)` - Convert Python object to JSON **string**\n- `json.dump(obj, file)` - Write Python object to JSON **file**\n- `indent=2` - Make JSON human-readable with indentation\n\n**Reading (Deserialization):**\n- `json.loads(string)` - Convert JSON **string** to Python object\n- `json.load(file)` - Read JSON **file** to Python object\n\n**Remember:** \n- dumps/loads = string operations (s for string)\n- dump/load = file operations\n- Always use 'with' statement for files\n- JSON keys must be strings!",
              "code": "import json\n\n# Example 1: Python → JSON (Serialization)\nprint(\"=== Python to JSON (Serialization) ===\")\n\n# Python data\nstudent = {\n    \"name\": \"Alice Johnson\",\n    \"age\": 20,\n    \"grades\": [95, 87, 92, 88],\n    \"enrolled\": True,\n    \"graduation_year\": None\n}\n\nprint(\"Python dictionary:\")\nprint(student)\nprint(f\"Type: {type(student)}\\n\")\n\n# Convert to JSON string\njson_string = json.dumps(student)\nprint(\"JSON string:\")\nprint(json_string)\nprint(f\"Type: {type(json_string)}\\n\")\n\n# Pretty-printed JSON (readable)\njson_pretty = json.dumps(student, indent=2)\nprint(\"Pretty JSON:\")\nprint(json_pretty)\nprint(\"\")\n\n# Example 2: JSON → Python (Deserialization)\nprint(\"=== JSON to Python (Deserialization) ===\")\n\njson_data = '{\"product\": \"Laptop\", \"price\": 999.99, \"in_stock\": true}'\nprint(\"JSON string:\")\nprint(json_data)\nprint(f\"Type: {type(json_data)}\\n\")\n\n# Convert to Python\nproduct = json.loads(json_data)\nprint(\"Python dictionary:\")\nprint(product)\nprint(f\"Type: {type(product)}\")\nprint(f\"Accessing: product['price'] = ${product['price']}\\n\")\n\n# Example 3: Writing JSON to file\nprint(\"=== Writing JSON to File ===\")\n\nconfig = {\n    \"app_name\": \"MyApp\",\n    \"version\": \"1.0.0\",\n    \"debug_mode\": True,\n    \"database\": {\n        \"host\": \"localhost\",\n        \"port\": 5432,\n        \"name\": \"mydb\"\n    },\n    \"features\": [\"auth\", \"payments\", \"analytics\"]\n}\n\nwith open(\"config.json\", \"w\") as file:\n    json.dump(config, file, indent=2)\n\nprint(\"✓ Wrote config.json\\n\")\n\n# Example 4: Reading JSON from file\nprint(\"=== Reading JSON from File ===\")\n\nwith open(\"config.json\", \"r\") as file:\n    loaded_config = json.load(file)\n\nprint(\"Loaded configuration:\")\nprint(f\"  App: {loaded_config['app_name']}\")\nprint(f\"  Version: {loaded_config['version']}\")\nprint(f\"  Database: {loaded_config['database']['host']}:{loaded_config['database']['port']}\")\nprint(f\"  Features: {', '.join(loaded_config['features'])}\\n\")\n\n# Example 5: Type conversions\nprint(\"=== JSON ↔ Python Type Mapping ===\")\n\ndata = {\n    \"string\": \"hello\",\n    \"number_int\": 42,\n    \"number_float\": 3.14,\n    \"boolean\": True,\n    \"null_value\": None,\n    \"array\": [1, 2, 3],\n    \"object\": {\"key\": \"value\"}\n}\n\njson_str = json.dumps(data, indent=2)\nprint(\"Python → JSON:\")\nprint(json_str)\nprint(\"\")\n\nback_to_python = json.loads(json_str)\nprint(\"JSON → Python:\")\nfor key, value in back_to_python.items():\n    print(f\"  {key}: {value} (type: {type(value).__name__})\")\n\nprint(\"\")\n\n# Example 6: Working with lists of objects\nprint(\"=== List of Objects ===\")\n\nusers = [\n    {\"id\": 1, \"name\": \"Alice\", \"role\": \"admin\"},\n    {\"id\": 2, \"name\": \"Bob\", \"role\": \"user\"},\n    {\"id\": 3, \"name\": \"Carol\", \"role\": \"moderator\"}\n]\n\n# Save to file\nwith open(\"users.json\", \"w\") as file:\n    json.dump(users, file, indent=2)\n\nprint(\"✓ Saved users.json\")\n\n# Load and process\nwith open(\"users.json\", \"r\") as file:\n    loaded_users = json.load(file)\n\nprint(\"\\nUsers from file:\")\nfor user in loaded_users:\n    print(f\"  - {user['name']} (ID: {user['id']}, Role: {user['role']})\")\n\nprint(\"\")\n\n# Example 7: Error handling\nprint(\"=== Error Handling ===\")\n\n# Invalid JSON\ninvalid_json = '{\"name\": \"Alice\", age: 25}'  # Missing quotes on 'age'\n\ntry:\n    json.loads(invalid_json)\nexcept json.JSONDecodeError as e:\n    print(f\"❌ JSON Error: {e}\")\n    print(\"   (Keys must be in double quotes)\\n\")\n\n# File not found\ntry:\n    with open(\"missing.json\", \"r\") as file:\n        json.load(file)\nexcept FileNotFoundError:\n    print(\"❌ File not found: missing.json\\n\")\n\nprint(\"✓ All JSON examples completed!\")",
              "language": "python"
            },
            {
              "type": "ANALOGY",
              "title": "Syntax Breakdown: JSON Operations",
              "content": "**Import json module:**\n```python\nimport json\n```\n\n**Python → JSON String:**\n```python\ndata = {\"name\": \"Alice\", \"age\": 25}\n\n# Convert to JSON string\njson_string = json.dumps(data)\n# '{\"name\": \"Alice\", \"age\": 25}'\n\n# Pretty-printed (readable)\njson_pretty = json.dumps(data, indent=2)\n# {\n#   \"name\": \"Alice\",\n#   \"age\": 25\n# }\n```\n\n**JSON String → Python:**\n```python\njson_string = '{\"name\": \"Alice\", \"age\": 25}'\n\n# Convert to Python\ndata = json.loads(json_string)\n# {'name': 'Alice', 'age': 25}\n```\n\n**Python → JSON File:**\n```python\ndata = {\"name\": \"Alice\", \"age\": 25}\n\nwith open(\"data.json\", \"w\") as file:\n    json.dump(data, file, indent=2)\n# File created with pretty JSON\n```\n\n**JSON File → Python:**\n```python\nwith open(\"data.json\", \"r\") as file:\n    data = json.load(file)\n# data is now a Python dict\n```\n\n**Type Conversions (JSON ↔ Python):**\n\n| Python Type | JSON Type | Example |\n|-------------|-----------|----------|\n| dict | object | {\"key\": \"value\"} |\n| list | array | [1, 2, 3] |\n| str | string | \"hello\" |\n| int, float | number | 42, 3.14 |\n| True | true | true |\n| False | false | false |\n| None | null | null |\n\n**Mnemonic: Remember 's' for string**\n- `dump**s**` - dump to **s**tring\n- `load**s**` - load from **s**tring\n- `dump` - dump to **file**\n- `load` - load from **file**\n\n**Common options:**\n\n```python\njson.dumps(data, \n    indent=2,          # Pretty-print with 2 spaces\n    sort_keys=True,    # Sort keys alphabetically\n    ensure_ascii=False # Allow non-ASCII characters\n)\n```\n\n**Error handling:**\n\n```python\ntry:\n    data = json.loads(json_string)\nexcept json.JSONDecodeError as e:\n    print(f\"Invalid JSON: {e}\")\n\ntry:\n    with open(\"data.json\", \"r\") as f:\n        data = json.load(f)\nexcept FileNotFoundError:\n    print(\"File not found\")\nexcept json.JSONDecodeError:\n    print(\"Invalid JSON in file\")\n```\n\n**What CAN'T be converted to JSON:**\n\n```python\n# ❌ Sets\ndata = {1, 2, 3}  # Can't convert set\n\n# ❌ Tuples (converted to arrays)\ndata = (1, 2, 3)  # Becomes [1, 2, 3] in JSON\n\n# ❌ Functions\ndata = {\"func\": lambda x: x}  # Can't convert function\n\n# ❌ Custom objects\nclass Person:\n    pass\ndata = Person()  # Can't convert (need custom encoder)\n```\n\n**JSON can only handle:**\n- Dictionaries\n- Lists  \n- Strings\n- Numbers (int, float)\n- Booleans (True/False)\n- None (null)\n\n**Complete workflow:**\n\n```python\n# 1. Create Python data\ndata = {\"users\": [\"Alice\", \"Bob\"], \"count\": 2}\n\n# 2. Save to JSON file\nwith open(\"data.json\", \"w\") as f:\n    json.dump(data, f, indent=2)\n\n# 3. Load from JSON file\nwith open(\"data.json\", \"r\") as f:\n    loaded = json.load(f)\n\n# 4. Use the data\nfor user in loaded[\"users\"]:\n    print(user)\n```"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "- **JSON = JavaScript Object Notation** - Universal format for data exchange. Every programming language and web API uses it.\n- **import json** - Python's built-in module for working with JSON. No installation needed.\n- **dump/dumps (Serialize):** Python → JSON. dumps = string, dump = file. Remember 's' for string!\n- **load/loads (Deserialize):** JSON → Python. loads = string, load = file. Remember 's' for string!\n- **Always use indent=2** when writing JSON files: json.dump(data, file, indent=2). Makes JSON human-readable.\n- **Type conversions:** dict↔object, list↔array, str↔string, int/float↔number, True/False↔true/false, None↔null.\n- **Handle errors:** FileNotFoundError (file missing) and json.JSONDecodeError (invalid JSON). Always use try/except.\n- **JSON limitations:** Can only encode dict, list, str, int, float, bool, None. Cannot encode sets, functions, or custom objects.\n- **JSON keys must be strings!** {'name': 'Alice'} works, {123: 'Alice'} will have key converted to string '123'.\n- **Common use:** Save app state, config files, API communication, data exchange between programs."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "09_04-challenge-3",
              "title": "Interactive Exercise: User Profile Manager",
              "description": "Create a user profile management system that:\n1. Saves user profiles to JSON file\n2. Loads user profiles from JSON file  \n3. Adds a new user profile\n4. Updates an existing user profile\n5. Displays all profiles\n\nEach profile should have: username, email, age, premium (boolean)\n\n**Your task:**\nImplement the functions below.\n\n**Starter code:**",
              "instructions": "Create a user profile management system that:\n1. Saves user profiles to JSON file\n2. Loads user profiles from JSON file  \n3. Adds a new user profile\n4. Updates an existing user profile\n5. Displays all profiles\n\nEach profile should have: username, email, age, premium (boolean)\n\n**Your task:**\nImplement the functions below.\n\n**Starter code:**",
              "starterCode": "import json\n\nFILENAME = \"profiles.json\"\n\ndef save_profiles(profiles):\n    \"\"\"Save profiles list to JSON file.\n    \n    Args:\n        profiles: List of profile dictionaries\n    \"\"\"\n    # TODO: Open file in write mode\n    # TODO: Use json.dump() with indent=2\n    pass\n\ndef load_profiles():\n    \"\"\"Load profiles from JSON file.\n    \n    Returns:\n        list: List of profiles, or empty list if file doesn't exist\n    \"\"\"\n    try:\n        # TODO: Open file in read mode\n        # TODO: Use json.load() to read\n        # TODO: Return the profiles\n        pass\n    except FileNotFoundError:\n        # File doesn't exist yet, return empty list\n        return []\n\ndef add_profile(username, email, age, premium=False):\n    \"\"\"Add a new user profile.\n    \n    Args:\n        username: User's username\n        email: User's email\n        age: User's age\n        premium: Premium status (default False)\n    \"\"\"\n    # TODO: Load existing profiles\n    # TODO: Create new profile dictionary\n    # TODO: Append to profiles list\n    # TODO: Save profiles\n    pass\n\ndef update_profile(username, **updates):\n    \"\"\"Update an existing profile.\n    \n    Args:\n        username: Username to update\n        **updates: Fields to update (email, age, premium)\n    \n    Returns:\n        bool: True if updated, False if user not found\n    \"\"\"\n    # TODO: Load profiles\n    # TODO: Find profile with matching username\n    # TODO: Update fields from **updates\n    # TODO: Save profiles\n    # TODO: Return True if found, False otherwise\n    pass\n\ndef display_profiles():\n    \"\"\"Display all profiles.\"\"\"\n    # TODO: Load profiles\n    # TODO: Print each profile nicely\n    pass\n\n# Test your functions\nprint(\"=== User Profile Manager ===\")\n\nprint(\"\\n1. Adding profiles...\")\nadd_profile(\"alice\", \"alice@example.com\", 25, True)\nadd_profile(\"bob\", \"bob@example.com\", 30)\nadd_profile(\"carol\", \"carol@example.com\", 28, True)\n\nprint(\"\\n2. All profiles:\")\ndisplay_profiles()\n\nprint(\"\\n3. Updating Bob's profile...\")\nupdate_profile(\"bob\", premium=True, age=31)\n\nprint(\"\\n4. Updated profiles:\")\ndisplay_profiles()",
              "solution": "",
              "language": "python",
              "testCases": [
                {
                  "description": "Code runs without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use json.dump(profiles, file, indent=2) to save. Use json.load(file) to load. Remember to use 'with' statement for files!"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "09_05",
          "title": "File Paths and Directory Operations",
          "moduleId": "module-09",
          "order": 5,
          "estimatedMinutes": 30,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Concept: GPS for Your File System",
              "content": "**The Problem: Hardcoded Paths Break**\n\n```python\n# Windows path\nfile = open('C:\\\\Users\\\\Alice\\\\Documents\\\\data.txt')\n\n# Mac/Linux path  \nfile = open('/home/alice/documents/data.txt')\n\n# Breaks when you share code!\n```\n\n**Real-world analogy: Street Addresses**\n\nImagine giving directions:\n- ❌ \"Go to 123 Main St, Apartment 4B\" (hardcoded - only works in one city)\n- ✅ \"Go to my_home/living_room/couch\" (relative - works anywhere)\n\n**pathlib is your GPS for files:**\n- Cross-platform (works on Windows, Mac, Linux)\n- Relative paths (\"start from current location\")\n- Path operations (join, split, check existence)\n- Directory operations (create, list, delete)\n\n**Key concepts:**\n\n**1. Absolute vs Relative Paths:**\n```python\n# Absolute (full address from root)\n/home/alice/projects/myapp/data.txt\nC:\\Users\\Alice\\Projects\\myapp\\data.txt\n\n# Relative (from current location)\ndata.txt\n./data.txt\n../other_folder/file.txt\n```\n\n**2. Path Components:**\n```python\n/home/alice/projects/myapp/data.txt\n│     │     │        │      │\n│     │     │        │      └─ filename\n│     │     │        └─ parent directory\n│     │     └─ grandparent directory\n│     └─ great-grandparent\n└─ root\n```\n\n**3. Special paths:**\n- `.` = current directory\n- `..` = parent directory  \n- `~` = home directory\n- `/` = root directory (Unix)\n- `C:\\` = drive root (Windows)\n\n**Why pathlib over string concatenation:**\n\n❌ **Don't do this:**\n```python\npath = 'folder' + '/' + 'file.txt'  # Breaks on Windows!\npath = 'C:\\\\Users\\\\' + name  # Escape chars nightmare\n```\n\n✅ **Do this:**\n```python\nfrom pathlib import Path\npath = Path('folder') / 'file.txt'  # Works everywhere!\n```"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example: Working with Paths",
              "content": "**Key Path operations:**\n\n1. **Path.cwd()** - Current working directory\n2. **Path.home()** - User's home directory\n3. **Path() / 'file'** - Join paths (cross-platform!)\n4. **.exists()** - Check if path exists\n5. **.is_file() / .is_dir()** - Check type\n6. **.mkdir()** - Create directory\n7. **.glob(pattern)** - Find files matching pattern\n8. **.rglob(pattern)** - Recursive glob (search subdirectories)\n9. **.read_text() / .write_text()** - Quick file I/O\n10. **.resolve()** - Convert to absolute path\n\n**mkdir parameters:**\n- `parents=True` - Create parent directories if needed\n- `exist_ok=True` - Don't error if directory already exists",
              "code": "from pathlib import Path\nimport os\n\n# Example 1: Creating paths\nprint(\"=== Creating Paths ===\")\n\n# Current directory\ncurrent = Path.cwd()  # cwd = current working directory\nprint(f\"Current directory: {current}\")\n\n# Home directory\nhome = Path.home()\nprint(f\"Home directory: {home}\")\n\n# Build path with / operator (cross-platform!)\ndata_file = Path('data') / 'users.txt'\nprint(f\"Data file path: {data_file}\")\n\n# Multiple levels\nconfig_path = Path('config') / 'settings' / 'app.json'\nprint(f\"Config path: {config_path}\\n\")\n\n# Example 2: Path information\nprint(\"=== Path Information ===\")\n\npath = Path('projects/myapp/src/main.py')\n\nprint(f\"Full path: {path}\")\nprint(f\"Name: {path.name}\")  # main.py\nprint(f\"Stem: {path.stem}\")  # main (without extension)\nprint(f\"Suffix: {path.suffix}\")  # .py\nprint(f\"Parent: {path.parent}\")  # projects/myapp/src\nprint(f\"Parents[0]: {path.parents[0]}\")  # immediate parent\nprint(f\"Parents[1]: {path.parents[1]}\")  # grandparent\nprint(f\"Parts: {path.parts}\\n\")  # ('projects', 'myapp', 'src', 'main.py')\n\n# Example 3: Checking existence\nprint(\"=== Checking Existence ===\")\n\n# Create a test file\ntest_file = Path('test.txt')\ntest_file.write_text('Hello, World!')\n\nprint(f\"test.txt exists: {test_file.exists()}\")\nprint(f\"test.txt is file: {test_file.is_file()}\")\nprint(f\"test.txt is directory: {test_file.is_dir()}\")\n\n# Check non-existent\nfake = Path('nonexistent.txt')\nprint(f\"nonexistent.txt exists: {fake.exists()}\\n\")\n\n# Example 4: Creating directories\nprint(\"=== Creating Directories ===\")\n\n# Create single directory\nPath('output').mkdir(exist_ok=True)\nprint(\"✓ Created 'output' directory\")\n\n# Create nested directories\nPath('data/processed/2024').mkdir(parents=True, exist_ok=True)\nprint(\"✓ Created nested 'data/processed/2024' directories\\n\")\n\n# Example 5: Listing directory contents\nprint(\"=== Listing Directory Contents ===\")\n\n# List all items in current directory\nprint(\"Files in current directory:\")\nfor item in Path('.').iterdir():\n    if item.is_file():\n        print(f\"  📄 {item.name}\")\n\nprint(\"\\nDirectories in current directory:\")\nfor item in Path('.').iterdir():\n    if item.is_dir():\n        print(f\"  📁 {item.name}\")\n\n# Example 6: Glob patterns (finding files)\nprint(\"\\n=== Finding Files with Glob ===\")\n\n# Create some test files\nfor i in range(3):\n    (Path('output') / f'file{i}.txt').write_text(f'Content {i}')\n    (Path('output') / f'data{i}.json').write_text('{}')\n\nprint(\"Created test files in output/\")\n\n# Find all .txt files\nprint(\"\\nAll .txt files in output/:\")\nfor file in Path('output').glob('*.txt'):\n    print(f\"  - {file.name}\")\n\n# Find all .json files\nprint(\"\\nAll .json files in output/:\")\nfor file in Path('output').glob('*.json'):\n    print(f\"  - {file.name}\")\n\n# Recursive glob (search subdirectories too)\nprint(\"\\nAll .txt files (recursive):\")\nfor file in Path('.').rglob('*.txt'):\n    print(f\"  - {file}\")\n\nprint(\"\")\n\n# Example 7: Reading and writing with Path\nprint(\"=== Reading/Writing with Path ===\")\n\ndata_path = Path('data.txt')\n\n# Write text\ndata_path.write_text('Line 1\\nLine 2\\nLine 3\\n')\nprint(\"✓ Wrote data.txt\")\n\n# Read text\ncontent = data_path.read_text()\nprint(\"\\nContent:\")\nprint(content)\n\n# Read lines\nlines = data_path.read_text().splitlines()\nprint(f\"Number of lines: {len(lines)}\\n\")\n\n# Example 8: Absolute vs Relative paths\nprint(\"=== Absolute vs Relative Paths ===\")\n\nrelative = Path('data/file.txt')\nprint(f\"Relative: {relative}\")\nprint(f\"Absolute: {relative.resolve()}\")\nprint(f\"Is absolute: {relative.is_absolute()}\")\n\nabsolute = Path.cwd() / 'data' / 'file.txt'\nprint(f\"\\nAbsolute: {absolute}\")\nprint(f\"Is absolute: {absolute.is_absolute()}\\n\")\n\n# Example 9: Joining paths safely\nprint(\"=== Joining Paths (Cross-Platform) ===\")\n\nbase = Path('projects')\nsubdir = 'myapp'\nfilename = 'config.json'\n\n# Method 1: / operator\npath1 = base / subdir / filename\nprint(f\"Using /: {path1}\")\n\n# Method 2: joinpath\npath2 = base.joinpath(subdir, filename)\nprint(f\"Using joinpath: {path2}\")\n\nprint(\"\\n✓ Both create correct path for your OS!\")\nprint(\"(Forward slashes on Unix, backslashes on Windows)\")",
              "language": "python"
            },
            {
              "type": "ANALOGY",
              "title": "Syntax Breakdown: pathlib Operations",
              "content": "**Import pathlib:**\n```python\nfrom pathlib import Path\n```\n\n**Creating paths:**\n```python\n# Current directory\nPath.cwd()\n\n# Home directory\nPath.home()\n\n# From string\nPath('folder/file.txt')\nPath('/absolute/path/file.txt')\n\n# Join paths (cross-platform!)\nPath('folder') / 'subfolder' / 'file.txt'\n```\n\n**Path information:**\n```python\npath = Path('projects/myapp/src/main.py')\n\npath.name      # 'main.py' (filename)\npath.stem      # 'main' (filename without extension)\npath.suffix    # '.py' (extension)\npath.parent    # Path('projects/myapp/src')\npath.parts     # ('projects', 'myapp', 'src', 'main.py')\n```\n\n**Checking existence:**\n```python\npath.exists()   # True if exists\npath.is_file()  # True if file\npath.is_dir()   # True if directory\npath.is_absolute()  # True if absolute path\n```\n\n**Creating directories:**\n```python\n# Create directory\nPath('output').mkdir()\n\n# Create with parents\nPath('data/processed/2024').mkdir(parents=True)\n\n# Don't error if exists\nPath('output').mkdir(exist_ok=True)\n\n# Both options\nPath('data/logs').mkdir(parents=True, exist_ok=True)\n```\n\n**Listing directory:**\n```python\n# List all items\nfor item in Path('.').iterdir():\n    print(item)\n\n# List only files\nfor item in Path('.').iterdir():\n    if item.is_file():\n        print(item)\n\n# List only directories\nfor item in Path('.').iterdir():\n    if item.is_dir():\n        print(item)\n```\n\n**Finding files (glob):**\n```python\n# All .txt files in directory\nfor file in Path('folder').glob('*.txt'):\n    print(file)\n\n# All .py files (recursive)\nfor file in Path('.').rglob('*.py'):\n    print(file)\n\n# Specific pattern\nfor file in Path('.').glob('data_*.csv'):\n    print(file)\n```\n\n**Reading/Writing:**\n```python\npath = Path('file.txt')\n\n# Write text\npath.write_text('Hello, World!')\n\n# Read text\ncontent = path.read_text()\n\n# Write bytes\npath.write_bytes(b'\\x00\\x01\\x02')\n\n# Read bytes\ndata = path.read_bytes()\n```\n\n**Path conversions:**\n```python\n# Relative to absolute\nrelative = Path('data/file.txt')\nabsolute = relative.resolve()\n\n# Path to string\npath_str = str(path)\n```\n\n**Deleting:**\n```python\n# Delete file\nPath('file.txt').unlink()\n\n# Delete empty directory\nPath('folder').rmdir()\n\n# Delete directory with contents (need shutil)\nimport shutil\nshutil.rmtree('folder')\n```\n\n**Common patterns:**\n\n**1. Process all files in directory:**\n```python\nfor file in Path('data').glob('*.csv'):\n    # Process each CSV file\n    content = file.read_text()\n    process(content)\n```\n\n**2. Create directory structure:**\n```python\nbase = Path('project')\n(base / 'src').mkdir(parents=True, exist_ok=True)\n(base / 'tests').mkdir(exist_ok=True)\n(base / 'data').mkdir(exist_ok=True)\n```\n\n**3. Safe file operations:**\n```python\npath = Path('data.txt')\n\nif path.exists():\n    content = path.read_text()\nelse:\n    print('File not found')\n```\n\n**Why pathlib is better:**\n\n❌ **Old way (os module):**\n```python\nimport os\npath = os.path.join('folder', 'file.txt')\nif os.path.exists(path):\n    with open(path) as f:\n        content = f.read()\n```\n\n✅ **New way (pathlib):**\n```python\nfrom pathlib import Path\npath = Path('folder') / 'file.txt'\nif path.exists():\n    content = path.read_text()\n```"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "- **from pathlib import Path** - Modern, cross-platform way to work with file paths. Replaces old os.path module.\n- **Path() / 'file'** - Join paths with / operator. Works on Windows, Mac, Linux automatically. Better than string concatenation.\n- **Path.cwd()** - Current working directory. **Path.home()** - User's home directory. Starting points for paths.\n- **.mkdir(parents=True, exist_ok=True)** - Safely create directories. parents=True creates parent dirs, exist_ok=True doesn't error if exists.\n- **.glob(pattern)** - Find files matching pattern. **.rglob(pattern)** - Recursive glob (search subdirectories too).\n- **.exists(), .is_file(), .is_dir()** - Check if path exists and what type it is. Always check before operations.\n- **.name, .stem, .suffix, .parent** - Get path components. name=filename, stem=filename without extension, suffix=extension, parent=parent directory.\n- **.read_text() / .write_text()** - Quick file I/O. For simple text files, easier than open().\n- **.iterdir()** - List directory contents. Returns Path objects for each item. Use .is_file() or .is_dir() to filter.\n- **Cross-platform:** pathlib handles path differences between OS automatically. Write once, works everywhere!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "09_05-challenge-3",
              "title": "Interactive Exercise: Project File Organizer",
              "description": "Create a file organizer that:\n1. Creates a project directory structure\n2. Finds all files of specific types\n3. Organizes files into folders by type\n4. Lists all files in the organized structure\n\n**Project structure to create:**\n```\nproject/\n  ├── images/\n  ├── documents/\n  ├── code/\n  └── data/\n```\n\n**Your task:**\nImplement the functions below.\n\n**Starter code:**",
              "instructions": "Create a file organizer that:\n1. Creates a project directory structure\n2. Finds all files of specific types\n3. Organizes files into folders by type\n4. Lists all files in the organized structure\n\n**Project structure to create:**\n```\nproject/\n  ├── images/\n  ├── documents/\n  ├── code/\n  └── data/\n```\n\n**Your task:**\nImplement the functions below.\n\n**Starter code:**",
              "starterCode": "from pathlib import Path\n\ndef create_project_structure(base_path):\n    \"\"\"Create project directory structure.\n    \n    Args:\n        base_path: Base directory path (string or Path)\n    \"\"\"\n    # TODO: Convert to Path object\n    # TODO: Create base directory\n    # TODO: Create subdirectories: images, documents, code, data\n    # Use mkdir(parents=True, exist_ok=True)\n    pass\n\ndef find_files_by_extension(directory, extension):\n    \"\"\"Find all files with specific extension.\n    \n    Args:\n        directory: Directory to search\n        extension: File extension (e.g., '.txt', '.py')\n        \n    Returns:\n        list: List of Path objects\n    \"\"\"\n    # TODO: Convert directory to Path\n    # TODO: Use glob to find files with extension\n    # TODO: Return list of matching files\n    pass\n\ndef organize_files(source_dir, dest_dir):\n    \"\"\"Organize files by type into folders.\n    \n    Args:\n        source_dir: Source directory with mixed files\n        dest_dir: Destination directory (project structure)\n    \"\"\"\n    # TODO: Define file type mappings\n    # Images: .jpg, .png, .gif → images/\n    # Documents: .txt, .pdf, .doc → documents/\n    # Code: .py, .js, .html → code/\n    # Data: .csv, .json, .xml → data/\n    \n    # TODO: For each file in source_dir:\n    #   - Get file extension\n    #   - Determine destination folder\n    #   - Copy or move file to destination\n    pass\n\ndef list_project_files(project_dir):\n    \"\"\"List all files in project structure.\n    \n    Args:\n        project_dir: Project directory path\n    \"\"\"\n    # TODO: For each subdirectory:\n    #   - Print directory name\n    #   - List files in that directory\n    pass\n\n# Test your functions\nprint(\"=== File Organizer ===\")\n\nprint(\"\\n1. Creating project structure...\")\ncreate_project_structure('my_project')\n\nprint(\"\\n2. Creating test files...\")\n# Create some test files\ntest_files = [\n    'photo1.jpg', 'photo2.png',\n    'document.txt', 'report.pdf',\n    'script.py', 'app.js',\n    'data.csv', 'config.json'\n]\n\nfor filename in test_files:\n    Path(filename).write_text(f'Content of {filename}')\nprint(f\"✓ Created {len(test_files)} test files\")\n\nprint(\"\\n3. Finding .jpg files...\")\njpg_files = find_files_by_extension('.', '.jpg')\nfor f in jpg_files:\n    print(f\"  - {f.name}\")\n\nprint(\"\\n4. Organizing files...\")\norganize_files('.', 'my_project')\n\nprint(\"\\n5. Project structure:\")\nlist_project_files('my_project')",
              "solution": "",
              "language": "python",
              "testCases": [
                {
                  "description": "Code runs without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use Path(dir).mkdir(parents=True, exist_ok=True) to create directories. Use Path(dir).glob('*' + extension) to find files. Use file.rename() or shutil.copy() to move files."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "09_06",
          "title": "Mini-Project: Log File Analyzer",
          "moduleId": "module-09",
          "order": 6,
          "estimatedMinutes": 45,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Project Overview: The System Detective",
              "content": "**The Challenge:** Build a log analyzer that reads server log files, extracts insights, and generates reports.\n\n**Real-world scenario:** You're a DevOps engineer. Your web server generates thousands of log entries daily. You need to:\n- Find all errors and warnings\n- Identify which pages are most visited\n- Track response times\n- Generate daily reports\n- Export data for analysis\n\n**What you'll build:**\n\n1. **Log Parser:**\n   - Read log files (text format)\n   - Parse each line into structured data\n   - Handle different log formats\n\n2. **Analysis Engine:**\n   - Count errors, warnings, info messages\n   - Find slowest requests\n   - Identify most common errors\n   - Calculate statistics\n\n3. **Report Generator:**\n   - Summary statistics\n   - Top errors\n   - Export to CSV\n   - Save analysis to JSON\n\n**Sample log format:**\n```\n2024-01-15 10:23:45 [ERROR] Database connection failed\n2024-01-15 10:23:46 [INFO] User login: alice@example.com\n2024-01-15 10:23:47 [WARNING] Slow query: 2.5s\n```\n\n**Skills applied:**\n- Reading text files with `with` statement\n- String parsing and pattern matching\n- Working with CSV for exports\n- Working with JSON for structured data\n- Using pathlib for file operations\n- Error handling throughout\n\n**Project structure:**\n```\nlog_analyzer/\n  ├── logs/           # Input log files\n  ├── reports/        # Generated reports\n  ├── exports/        # CSV/JSON exports\n  └── analyzer.py     # Main program\n```"
            },
            {
              "type": "EXAMPLE",
              "title": "Complete Implementation: Log File Analyzer",
              "content": "This production-ready log analyzer demonstrates:\n\n**File I/O Concepts:**\n1. **Reading files** with `with` statement\n2. **Writing files** for reports\n3. **CSV export** with csv module\n4. **JSON export** for structured data\n5. **pathlib** for cross-platform paths\n6. **Error handling** throughout\n\n**Data Processing:**\n- Parsing log lines into structured objects\n- Grouping and counting with Counter and defaultdict\n- Filtering data (errors, warnings)\n- Statistical analysis\n\n**Real-world Features:**\n- Handles malformed log lines\n- Generates multiple output formats\n- Creates directory structure\n- Professional report formatting\n- Reusable functions\n\n**Why this matters:**\nLog analysis is essential in DevOps, security, and troubleshooting. This project teaches real skills used daily by software engineers.",
              "code": "\"\"\"Log File Analyzer - Complete File I/O Application\n\nDemonstrates: file reading, parsing, CSV export, JSON export,\npath operations, error handling, and data analysis.\n\"\"\"\n\nfrom pathlib import Path\nimport csv\nimport json\nfrom datetime import datetime\nfrom collections import defaultdict, Counter\n\n# ============================================================================\n# Log Entry Class\n# ============================================================================\n\nclass LogEntry:\n    \"\"\"Represents a single log entry.\"\"\"\n    \n    def __init__(self, timestamp, level, message):\n        self.timestamp = timestamp\n        self.level = level\n        self.message = message\n    \n    def __repr__(self):\n        return f\"LogEntry({self.timestamp}, {self.level}, {self.message[:30]}...)\"\n\n# ============================================================================\n# Log Parser\n# ============================================================================\n\ndef parse_log_line(line):\n    \"\"\"Parse a single log line.\n    \n    Format: YYYY-MM-DD HH:MM:SS [LEVEL] Message\n    \n    Returns:\n        LogEntry or None if parsing fails\n    \"\"\"\n    try:\n        # Split by brackets to get level\n        parts = line.strip().split('[')\n        if len(parts) < 2:\n            return None\n        \n        # Extract timestamp (before first [)\n        timestamp_str = parts[0].strip()\n        \n        # Extract level and message\n        level_and_msg = parts[1].split(']', 1)\n        if len(level_and_msg) < 2:\n            return None\n        \n        level = level_and_msg[0].strip()\n        message = level_and_msg[1].strip()\n        \n        return LogEntry(timestamp_str, level, message)\n    \n    except Exception:\n        return None\n\ndef read_log_file(filepath):\n    \"\"\"Read and parse entire log file.\n    \n    Returns:\n        list: List of LogEntry objects\n    \"\"\"\n    entries = []\n    \n    try:\n        with open(filepath, 'r') as file:\n            for line_num, line in enumerate(file, 1):\n                entry = parse_log_line(line)\n                if entry:\n                    entries.append(entry)\n    \n    except FileNotFoundError:\n        print(f\"Error: Log file '{filepath}' not found\")\n        return []\n    except Exception as e:\n        print(f\"Error reading log file: {e}\")\n        return []\n    \n    return entries\n\n# ============================================================================\n# Analysis Functions\n# ============================================================================\n\ndef analyze_logs(entries):\n    \"\"\"Analyze log entries and generate statistics.\n    \n    Returns:\n        dict: Analysis results\n    \"\"\"\n    # Count by level\n    level_counts = Counter(entry.level for entry in entries)\n    \n    # Count messages\n    message_counts = Counter(entry.message for entry in entries)\n    \n    # Group by level\n    by_level = defaultdict(list)\n    for entry in entries:\n        by_level[entry.level].append(entry)\n    \n    # Statistics\n    analysis = {\n        'total_entries': len(entries),\n        'level_counts': dict(level_counts),\n        'error_count': level_counts.get('ERROR', 0),\n        'warning_count': level_counts.get('WARNING', 0),\n        'info_count': level_counts.get('INFO', 0),\n        'top_errors': message_counts.most_common(5),\n        'entries_by_level': {level: len(items) for level, items in by_level.items()}\n    }\n    \n    return analysis\n\ndef find_errors(entries):\n    \"\"\"Find all error entries.\n    \n    Returns:\n        list: Error LogEntry objects\n    \"\"\"\n    return [entry for entry in entries if entry.level == 'ERROR']\n\ndef find_warnings(entries):\n    \"\"\"Find all warning entries.\n    \n    Returns:\n        list: Warning LogEntry objects\n    \"\"\"\n    return [entry for entry in entries if entry.level == 'WARNING']\n\n# ============================================================================\n# Export Functions\n# ============================================================================\n\ndef export_to_csv(entries, filepath):\n    \"\"\"Export log entries to CSV.\"\"\"\n    with open(filepath, 'w', newline='') as file:\n        writer = csv.writer(file)\n        \n        # Header\n        writer.writerow(['Timestamp', 'Level', 'Message'])\n        \n        # Data\n        for entry in entries:\n            writer.writerow([entry.timestamp, entry.level, entry.message])\n    \n    print(f\"✓ Exported {len(entries)} entries to {filepath}\")\n\ndef export_analysis_to_json(analysis, filepath):\n    \"\"\"Export analysis results to JSON.\"\"\"\n    # Convert Counter objects to regular dicts for JSON\n    json_data = {\n        'total_entries': analysis['total_entries'],\n        'level_counts': analysis['level_counts'],\n        'error_count': analysis['error_count'],\n        'warning_count': analysis['warning_count'],\n        'info_count': analysis['info_count'],\n        'top_errors': [[msg, count] for msg, count in analysis['top_errors']]\n    }\n    \n    with open(filepath, 'w') as file:\n        json.dump(json_data, file, indent=2)\n    \n    print(f\"✓ Exported analysis to {filepath}\")\n\n# ============================================================================\n# Report Generator\n# ============================================================================\n\ndef generate_report(entries, analysis, output_dir):\n    \"\"\"Generate comprehensive text report.\"\"\"\n    report_path = Path(output_dir) / 'report.txt'\n    \n    with open(report_path, 'w') as file:\n        file.write(\"=\" * 70 + \"\\n\")\n        file.write(\"LOG ANALYSIS REPORT\\n\")\n        file.write(\"=\" * 70 + \"\\n\\n\")\n        \n        # Summary\n        file.write(\"SUMMARY\\n\")\n        file.write(\"-\" * 70 + \"\\n\")\n        file.write(f\"Total Entries: {analysis['total_entries']}\\n\")\n        file.write(f\"Errors: {analysis['error_count']}\\n\")\n        file.write(f\"Warnings: {analysis['warning_count']}\\n\")\n        file.write(f\"Info: {analysis['info_count']}\\n\\n\")\n        \n        # Level breakdown\n        file.write(\"LEVEL BREAKDOWN\\n\")\n        file.write(\"-\" * 70 + \"\\n\")\n        for level, count in analysis['level_counts'].items():\n            percentage = (count / analysis['total_entries']) * 100\n            file.write(f\"{level:12} {count:6} ({percentage:.1f}%)\\n\")\n        file.write(\"\\n\")\n        \n        # Top errors\n        file.write(\"TOP 5 ERRORS\\n\")\n        file.write(\"-\" * 70 + \"\\n\")\n        for i, (message, count) in enumerate(analysis['top_errors'], 1):\n            file.write(f\"{i}. [{count}x] {message}\\n\")\n        file.write(\"\\n\")\n        \n        file.write(\"=\" * 70 + \"\\n\")\n    \n    print(f\"✓ Generated report: {report_path}\")\n    return report_path\n\n# ============================================================================\n# Main Application\n# ============================================================================\n\ndef create_sample_log():\n    \"\"\"Create sample log file for testing.\"\"\"\n    log_entries = [\n        \"2024-01-15 10:00:00 [INFO] Server started\",\n        \"2024-01-15 10:00:05 [INFO] User login: alice@example.com\",\n        \"2024-01-15 10:00:10 [ERROR] Database connection failed\",\n        \"2024-01-15 10:00:15 [WARNING] High memory usage: 85%\",\n        \"2024-01-15 10:00:20 [INFO] User login: bob@example.com\",\n        \"2024-01-15 10:00:25 [ERROR] Database connection failed\",\n        \"2024-01-15 10:00:30 [INFO] Processing request: /api/users\",\n        \"2024-01-15 10:00:35 [WARNING] Slow query: 2.5s\",\n        \"2024-01-15 10:00:40 [ERROR] File not found: config.yaml\",\n        \"2024-01-15 10:00:45 [INFO] Request completed: 200 OK\",\n        \"2024-01-15 10:00:50 [ERROR] Database connection failed\",\n        \"2024-01-15 10:00:55 [WARNING] Cache miss rate: 45%\",\n        \"2024-01-15 10:01:00 [INFO] User logout: alice@example.com\",\n        \"2024-01-15 10:01:05 [ERROR] Invalid API key\",\n        \"2024-01-15 10:01:10 [INFO] Backup completed successfully\",\n    ]\n    \n    Path('logs').mkdir(exist_ok=True)\n    log_file = Path('logs') / 'server.log'\n    \n    with open(log_file, 'w') as file:\n        for entry in log_entries:\n            file.write(entry + '\\n')\n    \n    print(f\"✓ Created sample log: {log_file}\")\n    return log_file\n\ndef run_analyzer():\n    \"\"\"Main analyzer workflow.\"\"\"\n    print(\"=\" * 70)\n    print(\"LOG FILE ANALYZER\")\n    print(\"=\" * 70)\n    \n    # Create directories\n    for dir_name in ['logs', 'reports', 'exports']:\n        Path(dir_name).mkdir(exist_ok=True)\n    \n    # Create sample log\n    print(\"\\n1. Creating sample log file...\")\n    log_file = create_sample_log()\n    \n    # Read and parse\n    print(\"\\n2. Reading and parsing log file...\")\n    entries = read_log_file(log_file)\n    print(f\"✓ Parsed {len(entries)} log entries\")\n    \n    # Analyze\n    print(\"\\n3. Analyzing logs...\")\n    analysis = analyze_logs(entries)\n    print(f\"✓ Found {analysis['error_count']} errors\")\n    print(f\"✓ Found {analysis['warning_count']} warnings\")\n    \n    # Generate report\n    print(\"\\n4. Generating report...\")\n    report_path = generate_report(entries, analysis, 'reports')\n    \n    # Export to CSV\n    print(\"\\n5. Exporting data...\")\n    errors = find_errors(entries)\n    export_to_csv(errors, 'exports/errors.csv')\n    export_to_csv(entries, 'exports/all_logs.csv')\n    \n    # Export analysis to JSON\n    export_analysis_to_json(analysis, 'exports/analysis.json')\n    \n    # Display report\n    print(\"\\n6. Report Contents:\")\n    print(\"=\" * 70)\n    with open(report_path, 'r') as f:\n        print(f.read())\n    \n    print(\"\\n\" + \"=\" * 70)\n    print(\"✓ Analysis complete!\")\n    print(f\"  - Report: {report_path}\")\n    print(f\"  - CSV exports: exports/\")\n    print(f\"  - JSON analysis: exports/analysis.json\")\n    print(\"=\" * 70)\n\n# Run the analyzer\nif __name__ == '__main__':\n    run_analyzer()",
              "language": "python"
            },
            {
              "type": "ANALOGY",
              "title": "Code Architecture Breakdown",
              "content": "**Project Structure:**\n\n```\n1. LogEntry Class\n   - Data structure for parsed log entries\n   - Stores timestamp, level, message\n\n2. Parser Functions\n   - parse_log_line() - Parse single line\n   - read_log_file() - Read entire file\n   - Error handling for malformed data\n\n3. Analysis Functions\n   - analyze_logs() - Generate statistics\n   - find_errors() - Filter errors\n   - find_warnings() - Filter warnings\n   - Uses Counter and defaultdict\n\n4. Export Functions\n   - export_to_csv() - CSV format\n   - export_analysis_to_json() - JSON format\n   - Proper file handling with 'with'\n\n5. Report Generator\n   - generate_report() - Text report\n   - Formatted output\n   - Summary statistics\n\n6. Main Application\n   - run_analyzer() - Orchestrates workflow\n   - Creates directories\n   - Handles full pipeline\n```\n\n**Data Flow:**\n\n```\nLog File (text)\n    ↓\nRead with 'with' statement\n    ↓\nParse each line → LogEntry objects\n    ↓\nAnalyze (count, group, filter)\n    ↓\nGenerate outputs:\n  - Text report\n  - CSV export\n  - JSON export\n```\n\n**File I/O Patterns Used:**\n\n1. **Reading:**\n   ```python\n   with open(filepath, 'r') as file:\n       for line in file:\n           process(line)\n   ```\n\n2. **Writing:**\n   ```python\n   with open(filepath, 'w') as file:\n       file.write(content)\n   ```\n\n3. **CSV Export:**\n   ```python\n   with open(filepath, 'w', newline='') as file:\n       writer = csv.writer(file)\n       writer.writerow(data)\n   ```\n\n4. **JSON Export:**\n   ```python\n   with open(filepath, 'w') as file:\n       json.dump(data, file, indent=2)\n   ```\n\n5. **Path Operations:**\n   ```python\n   Path('dir').mkdir(exist_ok=True)\n   path = Path('dir') / 'file.txt'\n   ```\n\n**Why This Architecture:**\n\n✅ **Separation of concerns** - Each function has one job\n✅ **Reusable** - Functions can be used independently  \n✅ **Testable** - Easy to unit test each function\n✅ **Maintainable** - Clear structure, easy to modify\n✅ **Production-ready** - Error handling, logging, multiple outputs"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "- **Combine all File I/O skills:** Real projects use text files, CSV, JSON, and path operations together. This project demonstrates integration.\n- **Structure matters:** Separate parsing, analysis, and export into distinct functions. Makes code testable and maintainable.\n- **Error handling is essential:** Production code handles malformed data, missing files, and edge cases gracefully. Always use try/except.\n- **Multiple output formats:** Generate reports in multiple formats (text, CSV, JSON) for different audiences and use cases.\n- **Use appropriate data structures:** Counter for counting, defaultdict for grouping, lists for ordering. Choose the right tool.\n- **Path operations for portability:** Use pathlib for cross-platform file operations. mkdir(exist_ok=True) prevents errors.\n- **Parse then analyze:** First convert raw text into structured objects (LogEntry), then analyze the structured data. Separation of concerns.\n- **Real-world applications:** Log analysis is crucial in DevOps, security monitoring, troubleshooting, and system optimization.\n- **File I/O patterns are universal:** These patterns (read, parse, analyze, export) apply to any data processing task.\n- **Professional code practices:** Type hints, docstrings, error messages, organized functions - write code others can understand and maintain."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "09_06-challenge-3",
              "title": "Extension Challenge: Add Advanced Features",
              "description": "**Challenge 1: Add Time-Based Analysis**\n\nExtend the analyzer to:\n- Parse timestamps properly\n- Group logs by hour\n- Find peak error times\n- Calculate time ranges\n\n**Challenge 2: Add Filtering**\n\nAdd ability to:\n- Filter by date range\n- Filter by log level\n- Search for keywords in messages\n- Export filtered results\n\n**Challenge 3: Add Statistical Analysis**\n\nCalculate:\n- Average errors per hour\n- Error rate percentage\n- Time between errors\n- Most active hours\n\n**Starter code for Challenge 1:**",
              "instructions": "**Challenge 1: Add Time-Based Analysis**\n\nExtend the analyzer to:\n- Parse timestamps properly\n- Group logs by hour\n- Find peak error times\n- Calculate time ranges\n\n**Challenge 2: Add Filtering**\n\nAdd ability to:\n- Filter by date range\n- Filter by log level\n- Search for keywords in messages\n- Export filtered results\n\n**Challenge 3: Add Statistical Analysis**\n\nCalculate:\n- Average errors per hour\n- Error rate percentage\n- Time between errors\n- Most active hours\n\n**Starter code for Challenge 1:**",
              "starterCode": "from datetime import datetime\n\ndef parse_timestamp(timestamp_str):\n    \"\"\"Parse timestamp string to datetime object.\n    \n    Args:\n        timestamp_str: String like '2024-01-15 10:00:00'\n        \n    Returns:\n        datetime object or None if parsing fails\n    \"\"\"\n    try:\n        return datetime.strptime(timestamp_str, '%Y-%m-%d %H:%M:%S')\n    except ValueError:\n        return None\n\ndef group_by_hour(entries):\n    \"\"\"Group log entries by hour.\n    \n    Returns:\n        dict: {hour: [entries]}\n    \"\"\"\n    # TODO: Parse timestamps\n    # TODO: Extract hour from datetime\n    # TODO: Group entries by hour\n    # TODO: Return grouped data\n    pass\n\ndef find_peak_error_hour(entries):\n    \"\"\"Find hour with most errors.\n    \n    Returns:\n        tuple: (hour, error_count)\n    \"\"\"\n    # TODO: Filter errors only\n    # TODO: Group by hour\n    # TODO: Count errors per hour\n    # TODO: Return hour with max errors\n    pass",
              "solution": "",
              "language": "python",
              "testCases": [
                {
                  "description": "Code runs without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use datetime.strptime() to parse timestamps. Use datetime.hour to extract hour. Use defaultdict(list) to group by hour."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        }
      ],
      "quizzes": [
        {
          "id": "quiz-09",
          "title": "Module 9 Quiz: File I/O & Data Persistence",
          "description": "Test your mastery of file operations: reading/writing files, context managers, CSV/JSON handling, path operations, and real-world file processing. You need 14/20 correct (70%) to pass.",
          "moduleId": "module-09",
          "passingScore": 70,
          "estimatedMinutes": 15,
          "questions": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-09-q1",
              "title": "What's the difference between 'w' and 'a' file modes?",
              "description": "What's the difference between 'w' and 'a' file modes?",
              "options": [
                "They're the same",
                "'w' overwrites existing content, 'a' adds to the end without erasing",
                "'w' is for Windows, 'a' is for all systems",
                "'a' is faster than 'w'"
              ],
              "correctAnswer": 1,
              "explanation": "'w' (write) mode OVERWRITES - it erases all existing content and starts fresh. 'a' (append) mode ADDS to the end without erasing existing content. Choose 'w' to replace, 'a' to add. Both create the file if it doesn't exist."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-09-q2",
              "title": "What happens if you don't close a file after opening it?",
              "description": "What happens if you don't close a file after opening it?",
              "options": [
                "Nothing - Python closes it automatically",
                "Changes might not be saved and the file remains locked",
                "The program crashes",
                "The file gets deleted"
              ],
              "correctAnswer": 1,
              "explanation": "If you don't close a file, changes might not be saved (buffered data isn't flushed to disk), and the file remains locked, preventing other programs from accessing it. Always call file.close() or use 'with' statement (which auto-closes)."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-09-q3",
              "title": "What is the main benefit of using 'with' statement for file operations?",
              "description": "What is the main benefit of using 'with' statement for file operations?",
              "options": [
                "Files open faster",
                "Files are automatically closed even if errors occur",
                "You can write more content to the file",
                "Files can be read and written simultaneously"
              ],
              "correctAnswer": 1,
              "explanation": "The main benefit of 'with' is automatic resource cleanup - the file is GUARANTEED to close when the with block ends, even if an exception occurs. This prevents resource leaks and makes code safer than manual closing."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-09-q4",
              "title": "When does the file close in a 'with' statement?",
              "description": "When does the file close in a 'with' statement?",
              "options": [
                "When you call file.close()",
                "When the program ends",
                "Immediately when the with block ends (indentation ends)",
                "When you open another file"
              ],
              "correctAnswer": 2,
              "explanation": "The file closes IMMEDIATELY when the with block ends - that is, when the indentation returns to the previous level. This happens whether the block ends normally, via return, via break, or via exception."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-09-q5",
              "title": "Why should you always use newline='' when opening a CSV file in write mode?",
              "description": "Why should you always use newline='' when opening a CSV file in write mode?",
              "options": [
                "It makes writing faster",
                "It prevents extra blank lines in the CSV file (especially on Windows)",
                "It's required by the csv module to work",
                "It allows writing unicode characters"
              ],
              "correctAnswer": 1,
              "explanation": "Always use newline='' when opening CSV files in write mode: open('file.csv', 'w', newline=''). Without it, you get extra blank lines on Windows because Python adds its own line endings and the csv module adds them too. This is a Python CSV requirement."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-09-q6",
              "title": "What type are the values in a row when using csv.DictReader()?",
              "description": "What type are the values in a row when using csv.DictReader()?",
              "options": [
                "All values are automatically converted to the correct type (int, float, etc.)",
                "All values are strings - you must convert them yourself",
                "Numbers are int/float, everything else is string",
                "Values have no type until you use them"
              ],
              "correctAnswer": 1,
              "explanation": "CSV readers return ALL values as strings, even numbers that look like integers or floats. You must convert them manually: int(row['Age']), float(row['Price']). This is true for both csv.reader() and csv.DictReader()."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-09-q7",
              "title": "What's the advantage of using csv.DictReader over csv.reader?",
              "description": "What's the advantage of using csv.DictReader over csv.reader?",
              "options": [
                "DictReader is faster",
                "DictReader uses less memory",
                "DictReader lets you access columns by name (row['Name']) instead of index (row[0])",
                "DictReader automatically converts types"
              ],
              "correctAnswer": 2,
              "explanation": "DictReader lets you access columns by name: row['Name'], row['Age'] instead of by index: row[0], row[1]. This makes code more readable, self-documenting, and less error-prone. You don't have to remember column positions."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-09-q8",
              "title": "What's the difference between json.dump() and json.dumps()?",
              "description": "What's the difference between json.dump() and json.dumps()?",
              "options": [
                "They're the same function",
                "dump writes to a file, dumps returns a string (s = string)",
                "dumps is faster than dump",
                "dump is for Python 2, dumps is for Python 3"
              ],
              "correctAnswer": 1,
              "explanation": "dump() writes JSON directly to a file, while dumps() (dump string) converts to JSON and returns it as a string. The 's' in dumps means 'string'. Same for load() (file) vs loads() (string)."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-09-q9",
              "title": "What happens to Python True/False/None when converted to JSON?",
              "description": "What happens to Python True/False/None when converted to JSON?",
              "options": [
                "They stay the same: True/False/None",
                "They become lowercase: true/false/null",
                "They become strings: 'True'/'False'/'None'",
                "They cause an error"
              ],
              "correctAnswer": 1,
              "explanation": "Python's True/False/None become JSON's true/false/null (lowercase). When loading JSON back to Python, they convert back: true→True, false→False, null→None. This is an automatic conversion."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-09-q10",
              "title": "Why should you use indent=2 when writing JSON files?",
              "description": "Why should you use indent=2 when writing JSON files?",
              "options": [
                "It makes the file smaller",
                "It's required by the JSON specification",
                "It makes JSON human-readable with proper formatting",
                "It makes loading faster"
              ],
              "correctAnswer": 2,
              "explanation": "indent=2 (or indent=4) pretty-prints JSON with indentation, making it human-readable. Without it, JSON is one long unreadable line. Always use indent when saving JSON files - it makes debugging and manual editing much easier."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-09-q11",
              "title": "What's the advantage of using Path() / 'file' over string concatenation?",
              "description": "What's the advantage of using Path() / 'file' over string concatenation?",
              "options": [
                "It's faster",
                "It automatically uses the correct path separator for your OS (cross-platform)",
                "It uses less memory",
                "It's required by Python"
              ],
              "correctAnswer": 1,
              "explanation": "Path() / 'file' automatically uses the correct path separator for your OS - forward slash (/) on Unix/Mac, backslash (\\) on Windows. String concatenation with '/' only works on Unix. The / operator makes code cross-platform."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-09-q12",
              "title": "What does mkdir(parents=True, exist_ok=True) do?",
              "description": "What does mkdir(parents=True, exist_ok=True) do?",
              "options": [
                "Only creates the directory if it doesn't exist",
                "Creates parent directories if needed AND doesn't error if directory exists",
                "Deletes existing directory and creates new one",
                "Creates directory only if parent exists"
              ],
              "correctAnswer": 1,
              "explanation": "parents=True creates parent directories if they don't exist (like mkdir -p). exist_ok=True doesn't raise an error if the directory already exists. Together, they make mkdir() safe to call multiple times."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-09-q13",
              "title": "What's the difference between glob() and rglob()?",
              "description": "What's the difference between glob() and rglob()?",
              "options": [
                "glob is faster than rglob",
                "glob searches current directory only, rglob searches recursively (subdirectories too)",
                "glob is for files, rglob is for directories",
                "They're the same"
              ],
              "correctAnswer": 1,
              "explanation": "glob() searches only in the specified directory. rglob() (recursive glob) searches the directory AND all subdirectories. Use glob('*.txt') for current directory, rglob('*.txt') to find all .txt files everywhere below."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-09-q14",
              "title": "Why do you need to add \\n when using write()?",
              "description": "Why do you need to add \\n when using write()?",
              "options": [
                "You don't - write() adds it automatically",
                "write() doesn't add newlines automatically, so you must add \\n for line breaks",
                "\\n makes the code run faster",
                "It's only needed on Windows"
              ],
              "correctAnswer": 1,
              "explanation": "write() writes exactly what you give it - it doesn't add newlines automatically. If you want separate lines, you must add \\n at the end: file.write('Line 1\\n'). Without \\n, everything runs together: 'Line 1Line 2'."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-09-q15",
              "title": "What happens if you try to use a file object after the 'with' block has ended?",
              "description": "What happens if you try to use a file object after the 'with' block has ended?",
              "options": [
                "It works normally",
                "It re-opens the file automatically",
                "You get an error because the file is already closed",
                "The file reopens in read mode"
              ],
              "correctAnswer": 2,
              "explanation": "After the with block ends, the file is closed and you cannot use the file object anymore. Trying to read/write will raise a ValueError: I/O operation on closed file. You must perform all file operations inside the with block."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-09-q16",
              "title": "What's the correct way to handle a file that might not exist when reading?",
              "description": "What's the correct way to handle a file that might not exist when reading?",
              "options": [
                "Just open it - Python will create it",
                "Check if it exists first, then open it",
                "Use try/except to catch FileNotFoundError",
                "Use 'w' mode instead of 'r' mode"
              ],
              "correctAnswer": 2,
              "explanation": "Always wrap file reading in try/except to catch FileNotFoundError. The file might not exist, be moved, or deleted. Checking with exists() has a race condition (file could be deleted between check and open). try/except is the safest approach."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-09-q17",
              "title": "Why is it better to parse data into structured objects (like LogEntry) before analyzing?",
              "description": "Why is it better to parse data into structured objects (like LogEntry) before analyzing?",
              "options": [
                "It's faster",
                "It separates parsing logic from analysis logic, making code more maintainable",
                "It uses less memory",
                "It's required by Python"
              ],
              "correctAnswer": 1,
              "explanation": "Parsing into structured objects separates concerns: parsing handles text → data conversion, analysis handles data processing. This makes code easier to test, debug, and maintain. You can change parsing logic without touching analysis code (separation of concerns)."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-09-q18",
              "title": "Which file mode should you use to add data to an existing file without erasing it?",
              "description": "Which file mode should you use to add data to an existing file without erasing it?",
              "options": [
                "'r' (read mode)",
                "'w' (write mode)",
                "'a' (append mode)",
                "'x' (exclusive mode)"
              ],
              "correctAnswer": 2,
              "explanation": "'a' (append) mode adds content to the end of an existing file without erasing it. 'w' mode would erase everything first. 'r' mode is read-only. 'a' mode creates the file if it doesn't exist."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-09-q19",
              "title": "What does Path.cwd() return?",
              "description": "What does Path.cwd() return?",
              "options": [
                "The user's home directory",
                "The current working directory",
                "The Python installation directory",
                "The root directory"
              ],
              "correctAnswer": 1,
              "explanation": "Path.cwd() returns the current working directory (cwd = current working directory) - the directory your program is running from. Path.home() returns the user's home directory. These are common starting points for building paths."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-09-q20",
              "title": "Why generate multiple output formats (text, CSV, JSON) in data processing applications?",
              "description": "Why generate multiple output formats (text, CSV, JSON) in data processing applications?",
              "options": [
                "To use more disk space",
                "Different formats serve different purposes: text for humans, CSV for spreadsheets, JSON for programs",
                "It makes the program slower",
                "It's a Python requirement"
              ],
              "correctAnswer": 1,
              "explanation": "Different formats serve different audiences: text reports are human-readable for quick review, CSV can be opened in Excel for further analysis, JSON can be consumed by other programs or APIs. Professional applications provide multiple export options to serve different needs."
            }
          ]
        }
      ]
    },
    {
      "id": "module-10",
      "title": "Module 10",
      "description": "Python programming fundamentals - Module 10",
      "difficulty": "intermediate",
      "estimatedHours": 3,
      "lessons": [
        {
          "id": "10_01",
          "title": "Importing Modules - Using Python's Built-in Libraries",
          "moduleId": "module-10",
          "order": 1,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Concept: Your Code Toolbox",
              "content": "**Modules = Pre-written code you can use**\n\nImagine building a house. You don't make your own nails, hammer, or saw - you use tools others have already made. Python modules are like that toolbox.\n\n**Python comes with 200+ built-in modules:**\n- **math** - Mathematical functions (sqrt, sin, cos)\n- **random** - Generate random numbers\n- **datetime** - Work with dates and times\n- **json** - Handle JSON data (we used this!)\n- **csv** - Handle CSV files (we used this too!)\n- **pathlib** - File system operations (Path)\n\n**Why use modules?**\n1. **Don't reinvent the wheel** - Use tested, optimized code\n2. **Save time** - Focus on your unique logic\n3. **Cleaner code** - Keep your files small and focused\n4. **Community knowledge** - Benefit from expert implementations\n\n**Real-world analogy:** Calculator vs Computer\n- Without modules: Like doing all math in your head\n- With modules: Like having a calculator, spreadsheet, and computer"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example: Import Styles",
              "content": "**Import styles:**\n1. `import math` - Use as math.sqrt()\n2. `from math import sqrt` - Use directly as sqrt()\n3. `import math as m` - Alias for shorter names\n4. `from math import *` - Import everything (avoid this!)\n\n**Best practice:** Use `import module` or `from module import specific_items`",
              "code": "# Style 1: Import entire module\nimport math\n\nprint(\"=== Import Entire Module ===\")\nprint(f\"Square root of 16: {math.sqrt(16)}\")\nprint(f\"Pi: {math.pi}\")\nprint(f\"Sin(90°): {math.sin(math.radians(90))}\\n\")\n\n# Style 2: Import specific functions\nfrom math import sqrt, pi\n\nprint(\"=== Import Specific Functions ===\")\nprint(f\"Square root of 25: {sqrt(25)}\")\nprint(f\"Pi: {pi}\\n\")\n\n# Style 3: Import with alias\nimport datetime as dt\n\nprint(\"=== Import with Alias ===\")\nnow = dt.datetime.now()\nprint(f\"Current time: {now}\")\nprint(f\"Year: {now.year}\\n\")\n\n# Style 4: Import all (not recommended)\nfrom random import *\n\nprint(\"=== Import All (use sparingly) ===\")\nprint(f\"Random number: {randint(1, 100)}\")\nprint(f\"Random choice: {choice(['apple', 'banana', 'cherry'])}\\n\")\n\n# Popular modules\nprint(\"=== Common Built-in Modules ===\")\n\nimport os\nprint(f\"Current directory: {os.getcwd()}\")\n\nimport sys\nprint(f\"Python version: {sys.version.split()[0]}\")\n\nimport time\nstart = time.time()\ntime.sleep(0.1)\nprint(f\"Elapsed: {time.time() - start:.2f}s\")",
              "language": "python"
            },
            {
              "type": "ANALOGY",
              "title": "Syntax Breakdown",
              "content": "**Basic import:**\n```python\nimport math\nresult = math.sqrt(16)  # Must use math.sqrt()\n```\n\n**Import specific items:**\n```python\nfrom math import sqrt, pi\nresult = sqrt(16)  # Use directly\n```\n\n**Import with alias:**\n```python\nimport datetime as dt\nnow = dt.datetime.now()  # Use dt instead of datetime\n```\n\n**Common modules:**\n- **math** - sqrt(), sin(), cos(), pi, e\n- **random** - randint(), choice(), shuffle()\n- **datetime** - datetime.now(), timedelta\n- **time** - time(), sleep()\n- **os** - getcwd(), listdir(), mkdir()\n- **sys** - argv, exit(), version"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "- **Modules = reusable code libraries.** Python has 200+ built-in modules.\n- **import module** - Use as module.function()\n- **from module import item** - Use item directly\n- **import module as alias** - Shorter name (import pandas as pd)\n- **Avoid from module import *** - Pollutes namespace\n- **Common modules:** math, random, datetime, json, csv, pathlib, os, sys"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "10_01-challenge-3",
              "title": "Interactive Exercise",
              "description": "Use the `random` module to:\n1. Generate 5 random numbers between 1-100\n2. Shuffle a list of names\n3. Pick a random winner\n\n**Starter code:**",
              "instructions": "Use the `random` module to:\n1. Generate 5 random numbers between 1-100\n2. Shuffle a list of names\n3. Pick a random winner\n\n**Starter code:**",
              "starterCode": "import random\n\n# TODO: Generate 5 random numbers\nnumbers = []\n\n# TODO: Create list of names\nnames = ['Alice', 'Bob', 'Carol', 'David']\n\n# TODO: Shuffle names\n\n# TODO: Pick random winner\nwinner = None\n\nprint(f\"Numbers: {numbers}\")\nprint(f\"Shuffled: {names}\")\nprint(f\"Winner: {winner}\")",
              "solution": "",
              "language": "python",
              "testCases": [
                {
                  "description": "Code runs without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use random.randint(1, 100) for numbers, random.shuffle(list) to shuffle, random.choice(list) to pick one."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "10_02",
          "title": "Creating Your Own Modules",
          "moduleId": "module-10",
          "order": 2,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Concept: Your Personal Library",
              "content": "**A module is just a .py file with functions/classes you can import.**\n\nInstead of copying the same functions between projects, create a module once and import it everywhere!\n\n**Example:** You write utility functions for string formatting:\n```python\n# utils.py\ndef capitalize_words(text):\n    return text.title()\n\ndef remove_spaces(text):\n    return text.replace(' ', '')\n```\n\nNow use it in any project:\n```python\n# my_app.py\nimport utils\nresult = utils.capitalize_words('hello world')\n```\n\n**Benefits:**\n1. **Reusability** - Write once, use everywhere\n2. **Organization** - Keep related code together\n3. **Testing** - Test modules independently\n4. **Collaboration** - Share code with team"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example: Creating a Module",
              "content": "**Key concepts:**\n1. Module = .py file with functions/classes/variables\n2. Import with `import filename` (no .py extension!)\n3. `if __name__ == '__main__':` - Code that runs only when file executed directly, not when imported\n4. Can define constants, functions, classes in module",
              "code": "# First, create a module file: math_utils.py\n# (In real project, save as separate file)\n\nmath_utils_code = '''\ndef add(a, b):\n    \"\"\"Add two numbers.\"\"\"\n    return a + b\n\ndef multiply(a, b):\n    \"\"\"Multiply two numbers.\"\"\"\n    return a * b\n\ndef is_even(n):\n    \"\"\"Check if number is even.\"\"\"\n    return n % 2 == 0\n\nPI = 3.14159\n\nif __name__ == \"__main__\":\n    # This code runs only when file is executed directly\n    print(\"Testing math_utils...\")\n    print(f\"5 + 3 = {add(5, 3)}\")\n    print(f\"5 * 3 = {multiply(5, 3)}\")\n    print(f\"Is 4 even? {is_even(4)}\")\n'''\n\n# Save the module\nfrom pathlib import Path\nPath('math_utils.py').write_text(math_utils_code)\n\nprint(\"=== Created math_utils.py module ===\")\nprint(math_utils_code)\nprint()\n\n# Now import and use it\nimport math_utils\n\nprint(\"=== Using the Module ===\")\nprint(f\"10 + 5 = {math_utils.add(10, 5)}\")\nprint(f\"10 * 5 = {math_utils.multiply(10, 5)}\")\nprint(f\"Is 7 even? {math_utils.is_even(7)}\")\nprint(f\"Pi constant: {math_utils.PI}\")",
              "language": "python"
            },
            {
              "type": "ANALOGY",
              "title": "Syntax Breakdown",
              "content": "**Creating a module:**\n```python\n# my_module.py\ndef my_function():\n    return \"Hello\"\n\nMY_CONSTANT = 42\n```\n\n**Using your module:**\n```python\n# main.py\nimport my_module\nresult = my_module.my_function()\n```\n\n**The __name__ == '__main__' pattern:**\n```python\n# my_module.py\ndef helper():\n    return \"I'm a helper\"\n\nif __name__ == \"__main__\":\n    # Runs only when: python my_module.py\n    # Does NOT run when: import my_module\n    print(\"Testing module...\")\n    print(helper())\n```\n\n**Why use __name__ == '__main__'?**\n- Test code while developing\n- Demo module functionality\n- Provide CLI interface\n- Code runs when executed directly, not when imported"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "- **Module = any .py file.** Can contain functions, classes, variables.\n- **Import your module:** `import my_module` (no .py!)\n- **if __name__ == '__main__':' - Code runs only when file executed directly\n- **Use modules for:** Organizing code, reusability, testing\n- **Module must be in same directory or Python path to import**"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "10_02-challenge-3",
              "title": "Interactive Exercise",
              "description": "Create a `string_utils.py` module with:\n1. `reverse(text)` - Reverse a string\n2. `count_vowels(text)` - Count vowels\n3. Test code in `if __name__ == '__main__':`",
              "instructions": "Create a `string_utils.py` module with:\n1. `reverse(text)` - Reverse a string\n2. `count_vowels(text)` - Count vowels\n3. Test code in `if __name__ == '__main__':`",
              "starterCode": "# Create string_utils.py module\n\ndef reverse(text):\n    # TODO: Return reversed text\n    pass\n\ndef count_vowels(text):\n    # TODO: Count a, e, i, o, u (case-insensitive)\n    pass\n\nif __name__ == \"__main__\":\n    # TODO: Test your functions\n    pass",
              "solution": "",
              "language": "python",
              "testCases": [
                {
                  "description": "Code runs without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "reverse: text[::-1], count_vowels: sum(1 for char in text.lower() if char in 'aeiou')"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "10_03",
          "title": "Packages and Project Structure",
          "moduleId": "module-10",
          "order": 3,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Concept: Organizing Your Library",
              "content": "**Module = single file. Package = folder of modules.**\n\nImagine a library:\n- **Module** = single book\n- **Package** = bookshelf with related books organized together\n\n**Package structure:**\n```\nmy_package/\n  __init__.py       ← Makes it a package!\n  module1.py\n  module2.py\n  sub_package/\n    __init__.py\n    module3.py\n```\n\n**Real example - web framework:**\n```\nflask/\n  __init__.py\n  app.py\n  routing.py\n  templating/\n    __init__.py\n    jinja.py\n```\n\n**The magic __init__.py:**\n- Empty file that tells Python \"this directory is a package\"\n- Can contain initialization code\n- Controls what `from package import *` imports"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example: Creating a Package",
              "content": "**Key points:**\n1. __init__.py makes directory a package\n2. Can import from __init__.py for convenience\n3. __all__ controls what `from package import *` imports\n4. Packages can be nested (sub-packages)\n5. Use relative imports (from .module) inside packages",
              "code": "from pathlib import Path\n\n# Create package structure\nprint(\"=== Creating Package Structure ===\")\n\nbase = Path('my_tools')\nbase.mkdir(exist_ok=True)\n\n# Create __init__.py (makes it a package)\n(base / '__init__.py').write_text('''\n\"\"\"My Tools Package - Utility functions.\"\"\"\n\nfrom .string_ops import reverse, uppercase\nfrom .math_ops import add, multiply\n\n__version__ = '1.0.0'\n__all__ = ['reverse', 'uppercase', 'add', 'multiply']\n''')\n\n# Create string_ops.py module\n(base / 'string_ops.py').write_text('''\ndef reverse(text):\n    return text[::-1]\n\ndef uppercase(text):\n    return text.upper()\n\ndef lowercase(text):  # Not exported by default\n    return text.lower()\n''')\n\n# Create math_ops.py module\n(base / 'math_ops.py').write_text('''\ndef add(a, b):\n    return a + b\n\ndef multiply(a, b):\n    return a * b\n\ndef subtract(a, b):  # Not exported by default\n    return a - b\n''')\n\nprint(\"✓ Created my_tools package\")\nprint(\"  - my_tools/__init__.py\")\nprint(\"  - my_tools/string_ops.py\")\nprint(\"  - my_tools/math_ops.py\\n\")\n\n# Import and use the package\nprint(\"=== Using the Package ===\")\n\nimport my_tools\n\nprint(f\"Version: {my_tools.__version__}\")\nprint(f\"Reverse 'hello': {my_tools.reverse('hello')}\")\nprint(f\"Uppercase 'world': {my_tools.uppercase('world')}\")\nprint(f\"Add 5 + 3: {my_tools.add(5, 3)}\")\nprint(f\"Multiply 4 * 7: {my_tools.multiply(4, 7)}\\n\")\n\n# Import specific module\nfrom my_tools import string_ops\n\nprint(\"=== Using Specific Module ===\")\nprint(f\"Lowercase (direct): {string_ops.lowercase('HELLO')}\")\n\n# Nested package\nprint(\"\\n=== Creating Nested Package ===\")\n\nutils = base / 'utils'\nutils.mkdir(exist_ok=True)\n(utils / '__init__.py').write_text('\"\"\"Utility subpackage.\"\"\"')\n(utils / 'file_ops.py').write_text('''\ndef read_file(path):\n    with open(path) as f:\n        return f.read()\n''')\n\nprint(\"✓ Created nested package: my_tools/utils/\")\n\n# Use nested package\nfrom my_tools.utils import file_ops\nprint(\"✓ Can import: from my_tools.utils import file_ops\")",
              "language": "python"
            },
            {
              "type": "ANALOGY",
              "title": "Syntax Breakdown",
              "content": "**Package structure:**\n```\nmy_package/\n  __init__.py      ← Required! Makes it a package\n  module1.py\n  module2.py\n```\n\n**Basic __init__.py:**\n```python\n# my_package/__init__.py\n\"\"\"Package docstring.\"\"\"\n\n# Import for convenience\nfrom .module1 import function1\nfrom .module2 import function2\n\n__version__ = '1.0.0'\n```\n\n**Importing from packages:**\n```python\n# Import package\nimport my_package\nmy_package.function1()\n\n# Import module from package\nfrom my_package import module1\nmodule1.function1()\n\n# Import function directly\nfrom my_package.module1 import function1\nfunction1()\n```\n\n**Relative imports (inside package):**\n```python\n# In my_package/module1.py\nfrom . import module2  # Same package\nfrom .module2 import function  # Specific import\nfrom ..other_package import something  # Parent package\n```"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "- **Package = directory with __init__.py** (collection of modules)\n- **__init__.py required** to make directory a package (can be empty)\n- **Import from package:** `from package.module import function`\n- **Relative imports:** `from .module import function` (inside package)\n- **__all__ in __init__.py** controls what `import *` imports\n- **Nested packages allowed** for organizing large projects"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "10_03-challenge-3",
              "title": "Interactive Exercise",
              "description": "Create a package structure:\n```\nutils/\n  __init__.py\n  text.py      (capitalize, reverse)\n  numbers.py   (is_even, is_prime)\n```",
              "instructions": "Create a package structure:\n```\nutils/\n  __init__.py\n  text.py      (capitalize, reverse)\n  numbers.py   (is_even, is_prime)\n```",
              "starterCode": "from pathlib import Path\n\n# TODO: Create utils directory\n\n# TODO: Create __init__.py\n\n# TODO: Create text.py with capitalize and reverse\n\n# TODO: Create numbers.py with is_even and is_prime\n\n# TODO: Import and test",
              "solution": "",
              "language": "python",
              "testCases": [
                {
                  "description": "Code runs without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use Path('utils').mkdir(), write_text() for files, import utils to test."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "10_04",
          "title": "pip and Virtual Environments - Managing Dependencies",
          "moduleId": "module-10",
          "order": 4,
          "estimatedMinutes": 30,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Concept: Your Project's Toolbox",
              "content": "**pip = Package Installer for Python**\n\nThink of pip like an app store for Python. Instead of downloading and installing packages manually, pip does it for you!\n\n**PyPI (Python Package Index)** = The app store\n- 400,000+ packages available\n- Free, open-source libraries\n- Install with one command\n\n**Virtual Environments** = Separate toolboxes for each project\n\nImagine you have two projects:\n- **Project A** needs requests version 2.0\n- **Project B** needs requests version 3.0\n\nWithout virtual environments: **CONFLICT!**\nWith virtual environments: Each project has its own isolated packages.\n\n**Real-world analogy:**\n- **No venv:** Like one shared toolbox for all projects (conflicts!)\n- **With venv:** Each project has its own toolbox (no conflicts!)\n\n**Why virtual environments:**\n1. **Isolation** - Projects don't interfere\n2. **Reproducibility** - Track exact versions\n3. **Clean system** - Don't pollute global Python\n4. **Easy deployment** - Share requirements.txt"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example: Using pip",
              "content": "**Key pip commands:**\n- `pip install package` - Install\n- `pip list` - Show all installed\n- `pip freeze > requirements.txt` - Save current packages\n- `pip install -r requirements.txt` - Install from file\n\n**requirements.txt = Project's shopping list**\nLists all packages and versions needed",
              "code": "import subprocess\nimport sys\n\nprint(\"=== pip Commands (demonstration) ===\")\n\n# Note: In real terminal, use these commands:\nprint(\"\"\"\nCommon pip commands:\n\n# Install a package\npip install requests\npip install pandas==1.5.0  # Specific version\n\n# Install multiple packages\npip install requests pandas numpy\n\n# Upgrade a package\npip install --upgrade requests\n\n# Uninstall a package\npip uninstall requests\n\n# List installed packages\npip list\n\n# Show package info\npip show requests\n\n# Install from requirements.txt\npip install -r requirements.txt\n\n# Create requirements.txt\npip freeze > requirements.txt\n\"\"\")\n\nprint(\"\\n=== Checking Installed Packages ===\")\n\n# List some common packages (if installed)\ntry:\n    import json\n    print(f\"✓ json (built-in)\")\nexcept:\n    pass\n\ntry:\n    import csv\n    print(f\"✓ csv (built-in)\")\nexcept:\n    pass\n\n# Check Python version\nprint(f\"\\nPython version: {sys.version.split()[0]}\")\nprint(f\"Python executable: {sys.executable}\")\n\nprint(\"\\n=== requirements.txt Example ===\")\nrequirements = \"\"\"\nrequests==2.31.0\npandas>=1.5.0\nnumpy<2.0.0\nflask~=2.3.0\n\"\"\"\nprint(\"Example requirements.txt:\")\nprint(requirements)\n\nprint(\"Version specifiers:\")\nprint(\"  == : Exact version (requests==2.31.0)\")\nprint(\"  >= : Minimum version (pandas>=1.5.0)\")\nprint(\"  <  : Below version (numpy<2.0.0)\")\nprint(\"  ~= : Compatible version (flask~=2.3.0 means >=2.3.0,<2.4.0)\")",
              "language": "python"
            },
            {
              "type": "ANALOGY",
              "title": "Syntax Breakdown",
              "content": "**Creating virtual environment:**\n```bash\n# Create venv\npython -m venv myenv\n\n# Activate (Linux/Mac)\nsource myenv/bin/activate\n\n# Activate (Windows)\nmyenv\\Scripts\\activate\n\n# Deactivate\ndeactivate\n```\n\n**Installing packages:**\n```bash\n# Single package\npip install requests\n\n# Specific version\npip install requests==2.31.0\n\n# From requirements.txt\npip install -r requirements.txt\n\n# Multiple packages\npip install requests pandas numpy\n```\n\n**Managing packages:**\n```bash\n# List installed\npip list\n\n# Show package details\npip show requests\n\n# Freeze to requirements.txt\npip freeze > requirements.txt\n\n# Upgrade package\npip install --upgrade requests\n\n# Uninstall\npip uninstall requests\n```\n\n**Project workflow:**\n```bash\n# 1. Create project\nmkdir my_project\ncd my_project\n\n# 2. Create virtual environment\npython -m venv venv\n\n# 3. Activate\nsource venv/bin/activate  # or venv\\Scripts\\activate on Windows\n\n# 4. Install packages\npip install requests pandas\n\n# 5. Save dependencies\npip freeze > requirements.txt\n\n# 6. Work on project...\n\n# 7. Deactivate when done\ndeactivate\n```"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "- **pip = Python package installer.** Installs from PyPI (Python Package Index).\n- **Virtual environments isolate projects.** Each project gets its own packages.\n- **Create venv:** `python -m venv venv`\n- **Activate venv:** `source venv/bin/activate` (Linux/Mac) or `venv\\\\Scripts\\\\activate` (Windows)\n- **requirements.txt** lists project dependencies. Create with `pip freeze > requirements.txt`\n- **Install from requirements.txt:** `pip install -r requirements.txt`\n- **Always use virtual environments!** Prevents version conflicts between projects."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "10_04-challenge-3",
              "title": "Interactive Exercise",
              "description": "Create a requirements.txt file for a web scraping project that needs:\n- requests (for HTTP)\n- beautifulsoup4 (for parsing HTML)\n- pandas (for data analysis)\n\n**Starter code:**",
              "instructions": "Create a requirements.txt file for a web scraping project that needs:\n- requests (for HTTP)\n- beautifulsoup4 (for parsing HTML)\n- pandas (for data analysis)\n\n**Starter code:**",
              "starterCode": "# TODO: Create requirements.txt content\nrequirements = \"\"\"\n# Add packages here\n\"\"\"\n\n# Save to file\nfrom pathlib import Path\nPath('requirements.txt').write_text(requirements)\nprint(\"✓ Created requirements.txt\")\nprint(requirements)",
              "solution": "",
              "language": "python",
              "testCases": [
                {
                  "description": "Code runs without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "List one package per line. Can specify versions with ==, >=, etc."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "10_05",
          "title": "Popular Third-Party Packages",
          "moduleId": "module-10",
          "order": 5,
          "estimatedMinutes": 30,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Concept: Standing on the Shoulders of Giants",
              "content": "**Don't reinvent the wheel!** For almost any task, someone has already written a great library.\n\n**Essential Categories:**\n\n**1. Web Development:**\n- **Flask** - Lightweight web framework\n- **Django** - Full-featured web framework\n- **FastAPI** - Modern, fast API framework\n- **requests** - HTTP library (much better than urllib!)\n\n**2. Data Science:**\n- **pandas** - Data analysis (Excel on steroids)\n- **numpy** - Numerical computing\n- **matplotlib** - Data visualization\n- **scikit-learn** - Machine learning\n\n**3. Web Scraping:**\n- **beautifulsoup4** - Parse HTML/XML\n- **selenium** - Browser automation\n- **scrapy** - Web crawling framework\n\n**4. Utilities:**\n- **python-dotenv** - Load environment variables\n- **pytest** - Testing framework\n- **black** - Code formatter\n- **pillow** - Image processing\n\n**How to choose packages:**\n1. Check PyPI downloads\n2. Look at GitHub stars\n3. Read documentation quality\n4. Check last update date\n5. Review issue tracker"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example: Popular Packages Demo",
              "content": "**Key packages and what they're best for:**\n- **requests**: HTTP requests (APIs, web scraping)\n- **pandas**: Data analysis, CSV/Excel manipulation\n- **Flask/FastAPI**: Building web apps and APIs\n- **beautifulsoup4**: Parsing HTML/XML\n- **python-dotenv**: Managing config/secrets\n\n**Installation:** `pip install package-name`",
              "code": "# Note: These examples show usage. Install with: pip install <package>\n\nprint(\"=== requests - HTTP Made Easy ===\")\nprint(\"\"\"\n# Without requests (painful!):\nimport urllib.request\nresponse = urllib.request.urlopen('https://api.github.com')\ndata = response.read().decode('utf-8')\n\n# With requests (easy!):\nimport requests\nresponse = requests.get('https://api.github.com')\ndata = response.json()  # Auto-parses JSON!\n\"\"\")\n\nprint(\"\\n=== pandas - Data Analysis ===\")\nprint(\"\"\"\nimport pandas as pd\n\n# Read CSV\ndf = pd.read_csv('data.csv')\n\n# Quick stats\nprint(df.describe())\n\n# Filter data\nfiltered = df[df['age'] > 25]\n\n# Group and aggregate\nby_city = df.groupby('city')['salary'].mean()\n\n# Export to Excel\ndf.to_excel('output.xlsx')\n\"\"\")\n\nprint(\"\\n=== Flask - Web Framework ===\")\nprint(\"\"\"\nfrom flask import Flask\napp = Flask(__name__)\n\n@app.route('/')\ndef home():\n    return 'Hello, World!'\n\n@app.route('/api/users/<int:user_id>')\ndef get_user(user_id):\n    return {'id': user_id, 'name': 'Alice'}\n\nif __name__ == '__main__':\n    app.run(debug=True)\n\"\"\")\n\nprint(\"\\n=== beautifulsoup4 - Web Scraping ===\")\nprint(\"\"\"\nfrom bs4 import BeautifulSoup\nimport requests\n\n# Fetch webpage\nresponse = requests.get('https://example.com')\nsoup = BeautifulSoup(response.content, 'html.parser')\n\n# Extract data\ntitle = soup.find('title').text\nlinks = [a['href'] for a in soup.find_all('a')]\nheadings = soup.find_all('h2')\n\"\"\")\n\nprint(\"\\n=== python-dotenv - Environment Variables ===\")\nprint(\"\"\"\n# .env file:\n# DATABASE_URL=postgresql://localhost/mydb\n# SECRET_KEY=my-secret-key\n\nfrom dotenv import load_dotenv\nimport os\n\nload_dotenv()  # Load from .env file\n\ndb_url = os.getenv('DATABASE_URL')\nsecret = os.getenv('SECRET_KEY')\n\"\"\")\n\nprint(\"\\n=== Package Combinations ===\")\nprint(\"\"\"\nCommon project stacks:\n\nWeb API:\n  - FastAPI (framework)\n  - pydantic (data validation)\n  - sqlalchemy (database)\n  - requests (external APIs)\n\nData Pipeline:\n  - pandas (data processing)\n  - sqlalchemy (database)\n  - schedule (task scheduling)\n  - python-dotenv (config)\n\nWeb Scraping:\n  - requests (fetch pages)\n  - beautifulsoup4 (parse HTML)\n  - pandas (organize data)\n  - openpyxl (export to Excel)\n\"\"\")",
              "language": "python"
            },
            {
              "type": "ANALOGY",
              "title": "Syntax Breakdown",
              "content": "**Finding packages:**\n```bash\n# Search PyPI\npip search keyword  # (disabled, use pypi.org instead)\n\n# Browse at https://pypi.org\n# Check GitHub for popular projects\n```\n\n**Installing:**\n```bash\n# Basic install\npip install requests\n\n# Specific version\npip install requests==2.31.0\n\n# Upgrade\npip install --upgrade requests\n\n# With extras\npip install fastapi[all]  # Installs optional dependencies\n```\n\n**Common package patterns:**\n```python\n# requests - HTTP\nimport requests\nresponse = requests.get(url)\ndata = response.json()\n\n# pandas - Data\nimport pandas as pd\ndf = pd.read_csv('file.csv')\n\n# flask - Web\nfrom flask import Flask\napp = Flask(__name__)\n\n# beautifulsoup - Parsing\nfrom bs4 import BeautifulSoup\nsoup = BeautifulSoup(html, 'html.parser')\n```"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "- **Don't reinvent the wheel** - Use existing packages for common tasks\n- **requests** - Best HTTP library (APIs, web scraping)\n- **pandas** - Data analysis and Excel/CSV manipulation\n- **Flask/FastAPI** - Web frameworks for APIs and websites\n- **beautifulsoup4** - HTML/XML parsing for web scraping\n- **pytest** - Modern testing framework\n- **Check PyPI** (pypi.org) for packages. 400,000+ available!\n- **Always use virtual environments** when installing packages"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "10_05-challenge-3",
              "title": "Interactive Exercise",
              "description": "Research and create requirements.txt for a data analysis project that needs:\n- Data reading/writing\n- HTTP requests\n- Data visualization\n- Testing",
              "instructions": "Research and create requirements.txt for a data analysis project that needs:\n- Data reading/writing\n- HTTP requests\n- Data visualization\n- Testing",
              "starterCode": "# TODO: Research packages for:\n# 1. CSV/Excel operations\n# 2. HTTP requests\n# 3. Plotting graphs\n# 4. Unit testing\n\nrequirements = \"\"\"\n# TODO: Add packages\n\"\"\"\n\nfrom pathlib import Path\nPath('requirements.txt').write_text(requirements)\nprint(requirements)",
              "solution": "",
              "language": "python",
              "testCases": [
                {
                  "description": "Code runs without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Popular choices: pandas, requests, matplotlib, pytest"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "10_06",
          "title": "Mini-Project: Python Project Initializer",
          "moduleId": "module-10",
          "order": 6,
          "estimatedMinutes": 45,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Project Overview",
              "content": "**Build a Project Initializer Tool!**\n\nYou'll create a CLI tool that sets up new Python projects with:\n- Proper package structure\n- Custom modules\n- requirements.txt with popular packages\n- Virtual environment instructions\n- Example code using third-party libraries\n\n**What you'll practice:**\n- Creating packages with `__init__.py`\n- Writing reusable modules\n- Managing dependencies\n- Importing and using modules\n- Project organization best practices\n\n**Project Structure:**\n```\nproject_initializer/\n├── __init__.py\n├── templates/\n│   ├── __init__.py\n│   ├── web_template.py\n│   └── data_template.py\n├── utils/\n│   ├── __init__.py\n│   ├── file_utils.py\n│   └── package_checker.py\n└── main.py\n```\n\n**Features:**\n1. Choose project type (web, data science, general)\n2. Generate appropriate folder structure\n3. Create requirements.txt with relevant packages\n4. Generate sample code files\n5. Display setup instructions"
            },
            {
              "type": "EXAMPLE",
              "title": "Step 1: File Utilities Module",
              "content": "**file_utils.py** provides reusable file operations:\n- `create_directory_structure()`: Recursively creates folders\n- `write_file()`: Safely writes files\n- `create_init_file()`: Creates `__init__.py` files\n- Uses pathlib for cross-platform paths\n- `if __name__ == '__main__':` allows testing the module",
              "code": "# project_initializer/utils/file_utils.py\n\"\"\"Utility functions for file and directory operations.\"\"\"\n\nfrom pathlib import Path\nimport json\n\ndef create_directory_structure(base_path, structure):\n    \"\"\"Create directories from a nested dictionary structure.\n    \n    Args:\n        base_path: Root directory path\n        structure: Dict representing folder structure\n    \n    Example:\n        structure = {\n            'src': {\n                'utils': {},\n                'models': {}\n            }\n        }\n    \"\"\"\n    base = Path(base_path)\n    base.mkdir(exist_ok=True)\n    \n    for name, subdirs in structure.items():\n        dir_path = base / name\n        dir_path.mkdir(exist_ok=True)\n        print(f\"✓ Created: {dir_path}\")\n        \n        if subdirs:\n            create_directory_structure(dir_path, subdirs)\n\ndef write_file(path, content):\n    \"\"\"Write content to a file.\"\"\"\n    file_path = Path(path)\n    file_path.parent.mkdir(parents=True, exist_ok=True)\n    file_path.write_text(content)\n    print(f\"✓ Created: {file_path}\")\n\ndef create_init_file(directory, content=\"\"):\n    \"\"\"Create __init__.py file in directory.\"\"\"\n    init_path = Path(directory) / \"__init__.py\"\n    init_path.write_text(content)\n    print(f\"✓ Created: {init_path}\")\n\nif __name__ == \"__main__\":\n    # Test the module\n    print(\"Testing file_utils module...\\n\")\n    \n    test_structure = {\n        'test_project': {\n            'src': {},\n            'tests': {}\n        }\n    }\n    \n    create_directory_structure('temp', test_structure)\n    print(\"\\n✓ Module works correctly!\")",
              "language": "python"
            },
            {
              "type": "EXAMPLE",
              "title": "Step 2: Package Templates Module",
              "content": "**Template modules** define project blueprints:\n- Each template is a separate module\n- Exports: requirements, folder structure, starter code\n- `get_template()` function returns complete configuration\n- Demonstrates module organization and reusability",
              "code": "# project_initializer/templates/web_template.py\n\"\"\"Templates for web development projects.\"\"\"\n\nREQUIREMENTS = \"\"\"\n# Web Development Dependencies\nflask>=3.0.0\nrequests>=2.31.0\npython-dotenv>=1.0.0\npytest>=7.4.0\n\"\"\".strip()\n\nSTRUCTURE = {\n    'app': {\n        'routes': {},\n        'models': {},\n        'static': {\n            'css': {},\n            'js': {}\n        },\n        'templates': {}\n    },\n    'tests': {}\n}\n\nMAIN_CODE = '''\nfrom flask import Flask, jsonify\nfrom dotenv import load_dotenv\nimport os\n\nload_dotenv()\n\napp = Flask(__name__)\napp.config['SECRET_KEY'] = os.getenv('SECRET_KEY', 'dev-key-change-this')\n\n@app.route('/')\ndef home():\n    return jsonify({\n        'message': 'Welcome to your Flask API!',\n        'status': 'running'\n    })\n\n@app.route('/api/health')\ndef health():\n    return jsonify({'status': 'healthy'})\n\nif __name__ == '__main__':\n    app.run(debug=True, port=5000)\n'''\n\nENV_TEMPLATE = \"\"\"\n# Environment Variables\nSECRET_KEY=your-secret-key-here\nDATABASE_URL=sqlite:///app.db\nDEBUG=True\n\"\"\".strip()\n\ndef get_template():\n    \"\"\"Return complete web project template.\"\"\"\n    return {\n        'requirements': REQUIREMENTS,\n        'structure': STRUCTURE,\n        'main_code': MAIN_CODE,\n        'env': ENV_TEMPLATE,\n        'description': 'Flask web application with API endpoints'\n    }\n\n# project_initializer/templates/data_template.py\n\"\"\"Templates for data science projects.\"\"\"\n\nREQUIREMENTS = \"\"\"\n# Data Science Dependencies\npandas>=2.0.0\nnumpy>=1.24.0\nmatplotlib>=3.7.0\nseaborn>=0.12.0\njupyter>=1.0.0\npytest>=7.4.0\n\"\"\".strip()\n\nSTRUCTURE = {\n    'data': {\n        'raw': {},\n        'processed': {}\n    },\n    'notebooks': {},\n    'src': {\n        'analysis': {},\n        'visualization': {}\n    },\n    'tests': {}\n}\n\nMAIN_CODE = '''\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom pathlib import Path\n\ndef load_data(filepath):\n    \"\"\"Load data from CSV file.\"\"\"\n    return pd.read_csv(filepath)\n\ndef analyze_data(df):\n    \"\"\"Perform basic data analysis.\"\"\"\n    print(\"Dataset Info:\")\n    print(f\"Rows: {len(df)}\")\n    print(f\"Columns: {len(df.columns)}\")\n    print(\"\\nSummary Statistics:\")\n    print(df.describe())\n    return df.describe()\n\ndef visualize_data(df, column):\n    \"\"\"Create visualization for a column.\"\"\"\n    plt.figure(figsize=(10, 6))\n    df[column].hist(bins=30)\n    plt.title(f'Distribution of {column}')\n    plt.xlabel(column)\n    plt.ylabel('Frequency')\n    plt.savefig(f'output_{column}.png')\n    print(f\"✓ Saved visualization: output_{column}.png\")\n\nif __name__ == '__main__':\n    print(\"Data Analysis Pipeline Ready!\")\n    print(\"Place your CSV files in the data/raw/ directory\")\n'''\n\ndef get_template():\n    \"\"\"Return complete data science project template.\"\"\"\n    return {\n        'requirements': REQUIREMENTS,\n        'structure': STRUCTURE,\n        'main_code': MAIN_CODE,\n        'description': 'Data science project with pandas and visualization'\n    }",
              "language": "python"
            },
            {
              "type": "EXAMPLE",
              "title": "Step 3: Package Initialization Files",
              "content": "**__init__.py files** define package interfaces:\n- Main `__init__.py`: Package metadata, version, convenient imports\n- `utils/__init__.py`: Exports utility functions\n- `templates/__init__.py`: Template registry and getter functions\n- `__all__` controls what's exported\n- Runs initialization code when package is imported",
              "code": "# project_initializer/__init__.py\n\"\"\"Python Project Initializer Package.\n\nA tool for quickly setting up new Python projects with proper structure,\ndependencies, and example code.\n\"\"\"\n\n__version__ = '1.0.0'\n__author__ = 'Your Name'\n\n# Import main functionality\nfrom .utils.file_utils import create_directory_structure, write_file\nfrom .templates import web_template, data_template\n\n# Define what gets imported with 'from project_initializer import *'\n__all__ = [\n    'create_directory_structure',\n    'write_file',\n    'web_template',\n    'data_template',\n    'create_project'\n]\n\ndef create_project(project_name, project_type='general'):\n    \"\"\"Convenience function to create a new project.\"\"\"\n    print(f\"Creating {project_type} project: {project_name}\")\n    # Implementation in main.py\n\nprint(f\"Project Initializer v{__version__} loaded\")\n\n# project_initializer/utils/__init__.py\n\"\"\"Utility modules for project initialization.\"\"\"\n\nfrom .file_utils import (\n    create_directory_structure,\n    write_file,\n    create_init_file\n)\n\n__all__ = ['create_directory_structure', 'write_file', 'create_init_file']\n\n# project_initializer/templates/__init__.py\n\"\"\"Project templates for different types of Python projects.\"\"\"\n\nfrom . import web_template\nfrom . import data_template\n\nTEMPLATES = {\n    'web': web_template,\n    'data': data_template\n}\n\ndef get_available_templates():\n    \"\"\"Return list of available project templates.\"\"\"\n    return list(TEMPLATES.keys())\n\ndef get_template(template_type):\n    \"\"\"Get template configuration by type.\"\"\"\n    if template_type in TEMPLATES:\n        return TEMPLATES[template_type].get_template()\n    raise ValueError(f\"Unknown template: {template_type}\")\n\n__all__ = ['TEMPLATES', 'get_available_templates', 'get_template']",
              "language": "python"
            },
            {
              "type": "EXAMPLE",
              "title": "Step 4: Main Application",
              "content": "**Main application** ties everything together:\n- Imports from our custom packages\n- Uses template modules to get configurations\n- Uses file_utils to create structure\n- Demonstrates practical module usage\n- CLI interface with `if __name__ == '__main__':`\n- Can be run as script or imported as module",
              "code": "# project_initializer/main.py\n\"\"\"Main entry point for project initializer.\"\"\"\n\nfrom pathlib import Path\nimport sys\n\n# Import from our package\nfrom utils.file_utils import create_directory_structure, write_file, create_init_file\nfrom templates import get_available_templates, get_template\n\ndef create_project(project_name, template_type='web'):\n    \"\"\"Create a new Python project from template.\n    \n    Args:\n        project_name: Name of the project\n        template_type: Type of template ('web' or 'data')\n    \"\"\"\n    print(f\"\\n{'='*50}\")\n    print(f\"Creating {template_type.upper()} project: {project_name}\")\n    print('='*50 + '\\n')\n    \n    # Get template configuration\n    try:\n        template = get_template(template_type)\n    except ValueError as e:\n        print(f\"Error: {e}\")\n        print(f\"Available templates: {', '.join(get_available_templates())}\")\n        return\n    \n    # Create base directory\n    project_path = Path(project_name)\n    if project_path.exists():\n        print(f\"Error: Directory '{project_name}' already exists!\")\n        return\n    \n    project_path.mkdir()\n    print(f\"✓ Created project directory: {project_name}\\n\")\n    \n    # Create folder structure\n    print(\"Creating directory structure...\")\n    create_directory_structure(project_path, template['structure'])\n    \n    # Create __init__.py files for Python packages\n    print(\"\\nCreating package files...\")\n    for folder in ['app', 'src', 'tests'] if template_type == 'web' else ['src', 'tests']:\n        folder_path = project_path / folder\n        if folder_path.exists():\n            create_init_file(folder_path)\n    \n    # Write main application file\n    print(\"\\nCreating main application...\")\n    main_file = project_path / ('app.py' if template_type == 'web' else 'main.py')\n    write_file(main_file, template['main_code'])\n    \n    # Write requirements.txt\n    print(\"\\nCreating requirements.txt...\")\n    write_file(project_path / 'requirements.txt', template['requirements'])\n    \n    # Write .env file for web projects\n    if template_type == 'web' and 'env' in template:\n        print(\"Creating .env template...\")\n        write_file(project_path / '.env.example', template['env'])\n    \n    # Create README\n    readme_content = f\"\"\"# {project_name}\n\n{template['description']}\n\n## Setup\n\n1. Create virtual environment:\n   ```bash\n   python -m venv venv\n   source venv/bin/activate  # On Windows: venv\\\\Scripts\\\\activate\n   ```\n\n2. Install dependencies:\n   ```bash\n   pip install -r requirements.txt\n   ```\n\n3. Run the application:\n   ```bash\n   python {'app.py' if template_type == 'web' else 'main.py'}\n   ```\n\n## Project Structure\n\nGenerated using Python Project Initializer.\n\"\"\"\n    write_file(project_path / 'README.md', readme_content)\n    \n    # Success message\n    print(\"\\n\" + \"=\"*50)\n    print(\"✓ Project created successfully!\")\n    print(\"=\"*50)\n    print(f\"\\nNext steps:\")\n    print(f\"1. cd {project_name}\")\n    print(f\"2. python -m venv venv\")\n    print(f\"3. source venv/bin/activate\")\n    print(f\"4. pip install -r requirements.txt\")\n    print(f\"5. python {'app.py' if template_type == 'web' else 'main.py'}\")\n    print(\"\\nHappy coding! 🚀\\n\")\n\ndef main():\n    \"\"\"Main CLI interface.\"\"\"\n    print(\"\\n\" + \"=\"*50)\n    print(\"Python Project Initializer\")\n    print(\"=\"*50)\n    \n    # Get project name\n    if len(sys.argv) > 1:\n        project_name = sys.argv[1]\n    else:\n        project_name = input(\"\\nProject name: \").strip()\n    \n    if not project_name:\n        print(\"Error: Project name required!\")\n        return\n    \n    # Get project type\n    print(f\"\\nAvailable templates: {', '.join(get_available_templates())}\")\n    if len(sys.argv) > 2:\n        template_type = sys.argv[2]\n    else:\n        template_type = input(\"Template type (web/data) [web]: \").strip() or 'web'\n    \n    # Create the project\n    create_project(project_name, template_type)\n\nif __name__ == '__main__':\n    main()",
              "language": "python"
            },
            {
              "type": "ANALOGY",
              "title": "How It All Works Together",
              "content": "**Module Organization:**\n\n```\nproject_initializer/          # Main package\n├── __init__.py              # Package interface, metadata\n├── main.py                  # Entry point (can run standalone)\n├── utils/                   # Utilities package\n│   ├── __init__.py         # Exports utility functions\n│   └── file_utils.py       # File operations module\n└── templates/               # Templates package\n    ├── __init__.py         # Template registry\n    ├── web_template.py     # Web project template\n    └── data_template.py    # Data science template\n```\n\n**Import Chain:**\n1. `main.py` imports from `utils` and `templates`\n2. `utils/__init__.py` imports from `file_utils.py`\n3. `templates/__init__.py` imports from template modules\n4. Each `__init__.py` exposes clean API via `__all__`\n\n**Running the Project:**\n```bash\n# As a script\npython project_initializer/main.py my_project web\n\n# Or import as package\npython -c \"from project_initializer import create_project; create_project('test', 'data')\"\n```\n\n**Key Concepts Demonstrated:**\n- ✓ Package structure with `__init__.py`\n- ✓ Relative imports within package\n- ✓ Module reusability\n- ✓ `if __name__ == '__main__':` pattern\n- ✓ Dependency management (requirements.txt)\n- ✓ Virtual environment workflow"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "- **Packages = directories with __init__.py** - Organize related modules together\n- **__init__.py controls package interface** - Use __all__ to define public API\n- **Modules are reusable** - Write once, import anywhere in your package\n- **if __name__ == '__main__':' is essential** - Test modules independently\n- **requirements.txt manages dependencies** - Document what packages your project needs\n- **Virtual environments isolate projects** - Each project gets its own package versions\n- **Proper structure scales** - Start organized, stay organized as project grows\n- **Import from packages with dot notation** - from .module import function for relative imports"
            }
          ],
          "challenges": []
        }
      ],
      "quizzes": [
        {
          "id": "quiz-10",
          "title": "Module 10: Modules & Packages - Comprehensive Quiz",
          "description": "Test your understanding of Python modules, packages, imports, virtual environments, and third-party packages. 70% required to pass.",
          "moduleId": "module-10",
          "passingScore": 70,
          "estimatedMinutes": 15,
          "questions": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-10-q1",
              "title": "What is the correct way to import only the sqrt function from the math module?",
              "description": "What is the correct way to import only the sqrt function from the math module?",
              "options": [
                "import sqrt from math",
                "from math import sqrt",
                "import math.sqrt",
                "from sqrt import math"
              ],
              "correctAnswer": 1,
              "explanation": "'from math import sqrt' imports only the sqrt function, allowing you to use it directly as sqrt() instead of math.sqrt()."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-10-q2",
              "title": "What does 'import pandas as pd' do?",
              "description": "What does 'import pandas as pd' do?",
              "options": [
                "Imports pandas with error checking",
                "Imports pandas and creates an alias 'pd'",
                "Partially imports pandas",
                "Imports pandas data files"
              ],
              "correctAnswer": 1,
              "explanation": "The 'as' keyword creates an alias. 'import pandas as pd' lets you use 'pd' instead of 'pandas', a common convention for brevity."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-10-q3",
              "title": "What is the purpose of 'if __name__ == \"__main__\":'?",
              "description": "What is the purpose of 'if __name__ == \"__main__\":'?",
              "options": [
                "To check if the module name is correct",
                "To run code only when the file is executed directly, not when imported",
                "To validate the main function",
                "To set the module's name"
              ],
              "correctAnswer": 1,
              "explanation": "This allows code to run when the file is executed directly, but not when it's imported as a module. Essential for creating reusable modules with test code."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-10-q4",
              "title": "When you import a module, what gets executed?",
              "description": "When you import a module, what gets executed?",
              "options": [
                "Only function definitions",
                "All code in the module",
                "Only class definitions",
                "Nothing until you call a function"
              ],
              "correctAnswer": 1,
              "explanation": "All top-level code in a module executes when it's imported. This is why we use 'if __name__ == \"__main__\":' to prevent test code from running during imports."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-10-q5",
              "title": "What makes a directory a Python package?",
              "description": "What makes a directory a Python package?",
              "options": [
                "Having .py files inside it",
                "Being named with lowercase letters",
                "Having an __init__.py file",
                "Being registered with pip"
              ],
              "correctAnswer": 2,
              "explanation": "A directory becomes a package when it contains an __init__.py file. This file can be empty or contain initialization code."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-10-q6",
              "title": "What is the purpose of __init__.py in a package?",
              "description": "What is the purpose of __init__.py in a package?",
              "options": [
                "To initialize variables only",
                "To mark the directory as a package and optionally run initialization code",
                "To store configuration settings",
                "To list all files in the package"
              ],
              "correctAnswer": 1,
              "explanation": "__init__.py marks a directory as a Python package and runs when the package is imported. It can contain initialization code, imports, and define __all__."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-10-q7",
              "title": "In a package, what does 'from . import module' mean?",
              "description": "In a package, what does 'from . import module' mean?",
              "options": [
                "Import from the current file",
                "Import from the current package",
                "Import from all packages",
                "Import everything from module"
              ],
              "correctAnswer": 1,
              "explanation": "The dot (.) refers to the current package. 'from . import module' is a relative import from the same package level."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-10-q8",
              "title": "What does __all__ define in a module or package?",
              "description": "What does __all__ define in a module or package?",
              "options": [
                "All variables in the module",
                "What gets imported with 'from module import *'",
                "All functions that must be defined",
                "All required dependencies"
              ],
              "correctAnswer": 1,
              "explanation": "__all__ is a list of strings defining what gets exported when someone uses 'from module import *'. It controls the public API."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-10-q9",
              "title": "What command creates a virtual environment named 'venv'?",
              "description": "What command creates a virtual environment named 'venv'?",
              "options": [
                "pip create venv",
                "virtualenv venv",
                "python -m venv venv",
                "python create-venv venv"
              ],
              "correctAnswer": 2,
              "explanation": "'python -m venv venv' uses Python's built-in venv module to create a virtual environment. The first 'venv' is the module, the second is the directory name."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-10-q10",
              "title": "After creating a virtual environment on Linux/Mac, how do you activate it?",
              "description": "After creating a virtual environment on Linux/Mac, how do you activate it?",
              "options": [
                "python venv/activate",
                "venv/bin/activate",
                "source venv/bin/activate",
                "activate venv"
              ],
              "correctAnswer": 2,
              "explanation": "'source venv/bin/activate' activates the virtual environment on Linux/Mac. On Windows, use 'venv\\Scripts\\activate' instead."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-10-q11",
              "title": "What is the purpose of a virtual environment?",
              "description": "What is the purpose of a virtual environment?",
              "options": [
                "To make Python run faster",
                "To isolate project dependencies and avoid conflicts",
                "To create virtual machines",
                "To backup your code"
              ],
              "correctAnswer": 1,
              "explanation": "Virtual environments isolate each project's dependencies, preventing version conflicts. Each project can have different package versions without interfering with others."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-10-q12",
              "title": "What command installs packages listed in requirements.txt?",
              "description": "What command installs packages listed in requirements.txt?",
              "options": [
                "pip install requirements.txt",
                "pip install -r requirements.txt",
                "python install requirements.txt",
                "pip install-all"
              ],
              "correctAnswer": 1,
              "explanation": "'pip install -r requirements.txt' installs all packages listed in the requirements.txt file. The -r flag means 'read from file'."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-10-q13",
              "title": "How do you save your current environment's packages to requirements.txt?",
              "description": "How do you save your current environment's packages to requirements.txt?",
              "options": [
                "pip save requirements.txt",
                "pip list > requirements.txt",
                "pip freeze > requirements.txt",
                "pip export requirements.txt"
              ],
              "correctAnswer": 2,
              "explanation": "'pip freeze > requirements.txt' outputs all installed packages with exact versions in the format needed for requirements.txt."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-10-q14",
              "title": "In requirements.txt, what does 'requests>=2.31.0' mean?",
              "description": "In requirements.txt, what does 'requests>=2.31.0' mean?",
              "options": [
                "Install exactly version 2.31.0",
                "Install version 2.31.0 or higher",
                "Install version 2.31 or greater than 0",
                "Install approximately version 2.31.0"
              ],
              "correctAnswer": 1,
              "explanation": ">= means 'greater than or equal to'. This allows version 2.31.0 or any newer version, ensuring you get security updates while avoiding breaking changes."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-10-q15",
              "title": "Which package is the standard for making HTTP requests in Python?",
              "description": "Which package is the standard for making HTTP requests in Python?",
              "options": [
                "urllib",
                "http",
                "requests",
                "web"
              ],
              "correctAnswer": 2,
              "explanation": "'requests' is the de facto standard HTTP library. It's much more user-friendly than the built-in urllib. Install with: pip install requests"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-10-q16",
              "title": "What is pandas primarily used for?",
              "description": "What is pandas primarily used for?",
              "options": [
                "Web development",
                "Data analysis and manipulation",
                "HTTP requests",
                "Image processing"
              ],
              "correctAnswer": 1,
              "explanation": "pandas is the premier data analysis library for Python. It's excellent for working with CSV/Excel files, data cleaning, analysis, and manipulation."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-10-q17",
              "title": "Which package would you use to parse HTML when web scraping?",
              "description": "Which package would you use to parse HTML when web scraping?",
              "options": [
                "requests",
                "beautifulsoup4",
                "html",
                "scraper"
              ],
              "correctAnswer": 1,
              "explanation": "beautifulsoup4 is the standard for parsing HTML/XML. Typically used with requests: requests fetches the page, beautifulsoup4 parses it."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-10-q18",
              "title": "What is Flask?",
              "description": "What is Flask?",
              "options": [
                "A testing framework",
                "A web framework for building websites and APIs",
                "A data analysis library",
                "A virtual environment tool"
              ],
              "correctAnswer": 1,
              "explanation": "Flask is a lightweight web framework for building websites and APIs. It's popular for its simplicity and flexibility."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-10-q19",
              "title": "Why should you avoid 'from module import *'?",
              "description": "Why should you avoid 'from module import *'?",
              "options": [
                "It's slower than other import methods",
                "It imports everything, polluting namespace and making code unclear",
                "It doesn't work in Python 3",
                "It requires special permissions"
              ],
              "correctAnswer": 1,
              "explanation": "Wildcard imports (*) make code unclear - you don't know where names come from. They can also cause naming conflicts. Explicit imports are better."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-10-q20",
              "title": "Where do you find and search for Python packages to install?",
              "description": "Where do you find and search for Python packages to install?",
              "options": [
                "GitHub exclusively",
                "PyPI (Python Package Index) at pypi.org",
                "The Python website downloads section",
                "Stack Overflow"
              ],
              "correctAnswer": 1,
              "explanation": "PyPI (pypi.org) is the official repository for Python packages. It hosts over 400,000 packages. pip installs packages from PyPI by default."
            }
          ]
        }
      ]
    },
    {
      "id": "module-11",
      "title": "Module 11",
      "description": "Python programming fundamentals - Module 11",
      "difficulty": "advanced",
      "estimatedHours": 4,
      "lessons": [
        {
          "id": "11_01",
          "title": "Introduction to Classes and Objects",
          "moduleId": "module-11",
          "order": 1,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Concept: Blueprint vs. House",
              "content": "**Think of it like houses:**\n\n- **Class** = Blueprint 📋\n  - The design/template\n  - Defines what a house should have (rooms, doors, windows)\n  - You can't live in a blueprint!\n\n- **Object** = Actual House 🏠\n  - Built from the blueprint\n  - Each house can have different colors, sizes, furniture\n  - You can have many houses from one blueprint\n\n**Example:**\n- **Class: Dog** (blueprint)\n  - All dogs have: name, age, breed\n  - All dogs can: bark, eat, sleep\n\n- **Objects: Actual dogs** (instances)\n  - Buddy (3 years old, Golden Retriever)\n  - Max (5 years old, Beagle)\n  - Luna (2 years old, Husky)\n\n**Why use classes?**\n1. **Organization** - Group related data and functions\n2. **Reusability** - Create multiple objects from one class\n3. **Modeling** - Represent real-world things in code\n4. **Maintenance** - Change blueprint, all objects benefit"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example: Your First Class",
              "content": "**Key components:**\n- `class Dog:` - Defines the class (blueprint)\n- `__init__()` - Constructor, runs when creating object\n- `self` - Refers to the current object instance\n- `self.name` - Instance attribute (unique to each object)\n- Methods - Functions inside a class\n- `Dog(...)` - Creates a new object (instance)\n\n**The `self` parameter:**\n- First parameter of every instance method\n- Python automatically passes it\n- Refers to the specific object calling the method",
              "code": "# Define a class (blueprint)\nclass Dog:\n    # Constructor - runs when creating a new dog\n    def __init__(self, name, age, breed):\n        # Instance attributes (each dog has their own)\n        self.name = name\n        self.age = age\n        self.breed = breed\n    \n    # Instance method (behavior)\n    def bark(self):\n        return f\"{self.name} says: Woof! Woof!\"\n    \n    def birthday(self):\n        self.age += 1\n        return f\"Happy birthday {self.name}! Now {self.age} years old.\"\n    \n    def info(self):\n        return f\"{self.name} is a {self.age}-year-old {self.breed}\"\n\n# Create objects (actual dogs)\ndog1 = Dog(\"Buddy\", 3, \"Golden Retriever\")\ndog2 = Dog(\"Max\", 5, \"Beagle\")\ndog3 = Dog(\"Luna\", 2, \"Husky\")\n\nprint(\"=== Dog Objects ===\")\nprint(dog1.info())\nprint(dog2.info())\nprint(dog3.info())\n\nprint(\"\\n=== Dogs Barking ===\")\nprint(dog1.bark())\nprint(dog2.bark())\nprint(dog3.bark())\n\nprint(\"\\n=== Birthday Time ===\")\nprint(dog1.birthday())\nprint(f\"Updated info: {dog1.info()}\")\n\n# Accessing attributes\nprint(\"\\n=== Accessing Attributes ===\")\nprint(f\"Dog 2's name: {dog2.name}\")\nprint(f\"Dog 3's age: {dog3.age}\")\n\n# Modifying attributes\ndog2.breed = \"Beagle Mix\"\nprint(f\"Updated: {dog2.info()}\")",
              "language": "python"
            },
            {
              "type": "ANALOGY",
              "title": "Syntax Breakdown",
              "content": "**Class definition:**\n```python\nclass ClassName:\n    def __init__(self, parameters):\n        self.attribute = value\n    \n    def method_name(self):\n        # do something\n        return result\n```\n\n**Creating objects:**\n```python\nobj = ClassName(arguments)\n```\n\n**Key terms:**\n- **Class** - The blueprint/template\n- **Object/Instance** - Specific creation from the class\n- **`__init__()`** - Constructor method (initializer)\n- **`self`** - Reference to the current instance\n- **Attribute** - Variable belonging to object (self.name)\n- **Method** - Function belonging to class\n\n**Naming conventions:**\n- Classes: `CapitalCase` (Dog, BankAccount)\n- Methods: `snake_case` (bark, get_balance)\n- Attributes: `snake_case` (name, account_number)"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "- **Class = Blueprint, Object = Instance** - One class, many objects\n- **__init__() is the constructor** - Runs when creating new object\n- **self refers to the current instance** - Must be first parameter\n- **Attributes store data** (self.name) - Each object has its own\n- **Methods define behavior** - Functions inside classes\n- **Create objects with ClassName(args)** - Calls __init__()\n- **Access with dot notation** - obj.attribute, obj.method()\n- **Classes organize related code** - Data + behavior together"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "11_01-challenge-3",
              "title": "Interactive Exercise",
              "description": "Create a BankAccount class with:\n- Attributes: account_holder, balance\n- Methods: deposit, withdraw, get_balance\n- Create two account objects and perform transactions",
              "instructions": "Create a BankAccount class with:\n- Attributes: account_holder, balance\n- Methods: deposit, withdraw, get_balance\n- Create two account objects and perform transactions",
              "starterCode": "class BankAccount:\n    def __init__(self, account_holder, initial_balance=0):\n        # TODO: Set account_holder and balance attributes\n        pass\n    \n    def deposit(self, amount):\n        # TODO: Add amount to balance\n        pass\n    \n    def withdraw(self, amount):\n        # TODO: Subtract amount if sufficient balance\n        # Return True if successful, False if insufficient funds\n        pass\n    \n    def get_balance(self):\n        # TODO: Return current balance\n        pass\n\n# TODO: Create two accounts\n# TODO: Perform deposits and withdrawals\n# TODO: Print balances",
              "solution": "",
              "language": "python",
              "testCases": [
                {
                  "description": "Code runs without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Remember to use self.attribute_name to access instance attributes. Check if balance is sufficient before withdrawing."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "11_02",
          "title": "Class Attributes and Methods",
          "moduleId": "module-11",
          "order": 2,
          "estimatedMinutes": 30,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Concept: Shared vs. Personal",
              "content": "**Think of a car dealership:**\n\n**Instance Attributes** (Personal)\n- Each car has its own: color, mileage, VIN number\n- Different for every car\n- Defined in `__init__` with `self.attribute`\n\n**Class Attributes** (Shared)\n- All cars share: manufacturer name, warranty period\n- Same for every car\n- Defined directly in class, outside methods\n\n**Example:**\n```\nInstance (Personal):           Class (Shared):\n- My car is red               - All are Toyota\n- My car has 15k miles        - All have 3-year warranty\n- My VIN: ABC123              - All made in 2024\n```\n\n**Types of methods:**\n\n1. **Instance methods** (most common)\n   - Work with specific object (self)\n   - Can access instance AND class attributes\n\n2. **Class methods** (@classmethod)\n   - Work with the class itself (cls)\n   - Often used for alternative constructors\n\n3. **Static methods** (@staticmethod)\n   - Don't access instance or class\n   - Utility functions related to the class"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example: Instance vs Class Attributes",
              "content": "**Key differences:**\n\n**Instance Attributes:**\n- Defined with `self.attribute` in `__init__`\n- Unique to each object\n- Access with `self.attribute` or `obj.attribute`\n\n**Class Attributes:**\n- Defined directly in class body\n- Shared by all instances\n- Access with `ClassName.attribute` or `cls.attribute`\n\n**Method Types:**\n- `def method(self):` - Instance method\n- `@classmethod def method(cls):` - Class method\n- `@staticmethod def method():` - Static method",
              "code": "class Car:\n    # Class attributes (shared by all cars)\n    manufacturer = \"Toyota\"\n    warranty_years = 3\n    total_cars = 0  # Track how many cars created\n    \n    def __init__(self, model, color, price):\n        # Instance attributes (unique to each car)\n        self.model = model\n        self.color = color\n        self.price = price\n        self.mileage = 0\n        \n        # Increment class attribute\n        Car.total_cars += 1\n    \n    # Instance method (works with specific car)\n    def drive(self, miles):\n        self.mileage += miles\n        return f\"{self.color} {self.model} drove {miles} miles. Total: {self.mileage}\"\n    \n    def info(self):\n        return f\"{Car.manufacturer} {self.model} ({self.color}) - ${self.price} - {self.mileage} miles\"\n    \n    # Class method (works with the class)\n    @classmethod\n    def from_string(cls, car_string):\n        \"\"\"Alternative constructor from string 'Model,Color,Price'\"\"\"\n        model, color, price = car_string.split(',')\n        return cls(model, color, float(price))\n    \n    @classmethod\n    def get_total_cars(cls):\n        return f\"Total {cls.manufacturer} cars created: {cls.total_cars}\"\n    \n    # Static method (utility function)\n    @staticmethod\n    def is_luxury(price):\n        \"\"\"Check if price indicates luxury car\"\"\"\n        return price > 50000\n\n# Create cars normally\nprint(\"=== Creating Cars ===\")\ncar1 = Car(\"Camry\", \"Blue\", 28000)\ncar2 = Car(\"Corolla\", \"Red\", 23000)\ncar3 = Car(\"Avalon\", \"Black\", 42000)\n\nprint(car1.info())\nprint(car2.info())\nprint(car3.info())\n\nprint(\"\\n=== Class Attributes (Shared) ===\")\nprint(f\"Manufacturer: {Car.manufacturer}\")\nprint(f\"Warranty: {Car.warranty_years} years\")\nprint(Car.get_total_cars())\n\nprint(\"\\n=== Instance Attributes (Unique) ===\")\nprint(f\"Car 1 color: {car1.color}\")\nprint(f\"Car 2 model: {car2.model}\")\nprint(f\"Car 3 price: ${car3.price}\")\n\nprint(\"\\n=== Using Instance Method ===\")\nprint(car1.drive(100))\nprint(car1.drive(50))\nprint(car2.drive(200))\n\nprint(\"\\n=== Using Class Method (Alternative Constructor) ===\")\ncar4 = Car.from_string(\"RAV4,Silver,32000\")\nprint(car4.info())\nprint(Car.get_total_cars())\n\nprint(\"\\n=== Using Static Method ===\")\nprint(f\"Is $28,000 luxury? {Car.is_luxury(28000)}\")\nprint(f\"Is $42,000 luxury? {Car.is_luxury(42000)}\")\nprint(f\"Is car3 luxury? {Car.is_luxury(car3.price)}\")",
              "language": "python"
            },
            {
              "type": "ANALOGY",
              "title": "Syntax Breakdown",
              "content": "**Instance vs Class Attributes:**\n```python\nclass MyClass:\n    # Class attribute (shared)\n    class_var = \"shared by all\"\n    \n    def __init__(self):\n        # Instance attribute (unique)\n        self.instance_var = \"unique to each\"\n\nobj = MyClass()\nprint(obj.instance_var)  # Unique\nprint(MyClass.class_var) # Shared\n```\n\n**Method decorators:**\n```python\nclass MyClass:\n    # Instance method (most common)\n    def instance_method(self):\n        return f\"Instance: {self.attribute}\"\n    \n    # Class method\n    @classmethod\n    def class_method(cls):\n        return f\"Class: {cls.class_attribute}\"\n    \n    # Static method\n    @staticmethod\n    def static_method(arg):\n        return f\"Static: {arg}\"\n```\n\n**When to use each:**\n- **Instance method**: When you need object's data (self)\n- **Class method**: Alternative constructors, class-level operations\n- **Static method**: Utility functions that don't need instance/class data"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "- **Instance attributes (self.x)** - Unique to each object\n- **Class attributes** - Shared by all instances\n- **Access class attributes with ClassName.attribute** - Not self\n- **Instance methods** - Use self, work with object data\n- **Class methods (@classmethod)** - Use cls, often alternative constructors\n- **Static methods (@staticmethod)** - No self/cls, utility functions\n- **cls parameter** - Refers to the class (like self for classes)\n- **Use class attributes for constants** - Values same for all instances"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "11_02-challenge-3",
              "title": "Interactive Exercise",
              "description": "Create an Employee class with:\n- Class attributes: company_name, employee_count\n- Instance attributes: name, position, salary\n- Instance method: give_raise(amount)\n- Class method: from_dict(employee_dict)\n- Static method: is_valid_salary(amount)",
              "instructions": "Create an Employee class with:\n- Class attributes: company_name, employee_count\n- Instance attributes: name, position, salary\n- Instance method: give_raise(amount)\n- Class method: from_dict(employee_dict)\n- Static method: is_valid_salary(amount)",
              "starterCode": "class Employee:\n    # TODO: Add class attributes\n    \n    def __init__(self, name, position, salary):\n        # TODO: Set instance attributes\n        # TODO: Increment employee_count\n        pass\n    \n    def give_raise(self, amount):\n        # TODO: Increase salary\n        pass\n    \n    @classmethod\n    def from_dict(cls, emp_dict):\n        # TODO: Create employee from dictionary\n        # Example: {'name': 'John', 'position': 'Dev', 'salary': 75000}\n        pass\n    \n    @staticmethod\n    def is_valid_salary(amount):\n        # TODO: Return True if salary between 20k and 500k\n        pass\n\n# TODO: Create employees and test methods",
              "solution": "",
              "language": "python",
              "testCases": [
                {
                  "description": "Code runs without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use cls.attribute for class attributes in class methods. Static methods don't use cls or self."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "11_03",
          "title": "Inheritance",
          "moduleId": "module-11",
          "order": 3,
          "estimatedMinutes": 30,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Concept: Family Tree",
              "content": "**Think of it like genetics:**\n\n**Parent Class (Base/Superclass)**\n- Defines common features\n- Example: Animal\n  - All animals: eat, sleep, breathe\n\n**Child Class (Derived/Subclass)**\n- Inherits from parent\n- Adds specific features\n- Examples:\n  - Dog (Animal) → adds bark()\n  - Cat (Animal) → adds meow()\n  - Bird (Animal) → adds fly()\n\n**Inheritance Benefits:**\n\n1. **Code Reuse** ♻️\n   - Write common code once in parent\n   - All children automatically get it\n\n2. **Organization** 📁\n   - Clear hierarchy\n   - Related classes grouped\n\n3. **Extensibility** 🔧\n   - Add new types easily\n   - Override behavior when needed\n\n4. **Polymorphism** 🎭\n   - Treat different types uniformly\n   - More on this in next lesson\n\n**Real-world examples:**\n- Vehicle → Car, Motorcycle, Truck\n- Shape → Circle, Square, Triangle\n- Employee → Manager, Developer, Designer\n- Account → CheckingAccount, SavingsAccount"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example: Basic Inheritance",
              "content": "**Key concepts:**\n\n**Inheritance syntax:**\n```python\nclass ChildClass(ParentClass):\n    ...\n```\n\n**super() function:**\n- Calls parent class methods\n- Common in `__init__` to initialize parent attributes\n- `super().__init__(args)` calls parent's constructor\n\n**Method overriding:**\n- Child can replace parent's method\n- Same name, different implementation\n- Dog overrides Animal's `info()` method\n\n**Inherited features:**\n- Dog, Cat, Bird all inherit `eat()` and `sleep()`\n- No need to rewrite common functionality",
              "code": "# Parent class (base class)\nclass Animal:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n        print(f\"Animal created: {name}\")\n    \n    def eat(self):\n        return f\"{self.name} is eating\"\n    \n    def sleep(self):\n        return f\"{self.name} is sleeping\"\n    \n    def info(self):\n        return f\"{self.name} is {self.age} years old\"\n\n# Child class (derived class)\nclass Dog(Animal):  # Inherits from Animal\n    def __init__(self, name, age, breed):\n        # Call parent's __init__\n        super().__init__(name, age)\n        # Add dog-specific attribute\n        self.breed = breed\n    \n    def bark(self):\n        return f\"{self.name} says: Woof! Woof!\"\n    \n    # Override parent method\n    def info(self):\n        return f\"{self.name} is a {self.age}-year-old {self.breed}\"\n\nclass Cat(Animal):  # Also inherits from Animal\n    def __init__(self, name, age, indoor=True):\n        super().__init__(name, age)\n        self.indoor = indoor\n    \n    def meow(self):\n        return f\"{self.name} says: Meow!\"\n    \n    def info(self):\n        location = \"indoor\" if self.indoor else \"outdoor\"\n        return f\"{self.name} is a {self.age}-year-old {location} cat\"\n\nclass Bird(Animal):\n    def __init__(self, name, age, can_fly=True):\n        super().__init__(name, age)\n        self.can_fly = can_fly\n    \n    def chirp(self):\n        return f\"{self.name} says: Chirp chirp!\"\n    \n    def fly(self):\n        if self.can_fly:\n            return f\"{self.name} is flying!\"\n        return f\"{self.name} can't fly (maybe a penguin?)\"\n\nprint(\"=== Creating Animals ===\")\ndog = Dog(\"Buddy\", 3, \"Golden Retriever\")\ncat = Cat(\"Whiskers\", 2, indoor=True)\nbird = Bird(\"Tweety\", 1, can_fly=True)\npenguin = Bird(\"Pingu\", 5, can_fly=False)\n\nprint(\"\\n=== Inherited Methods (from Animal) ===\")\nprint(dog.eat())\nprint(cat.sleep())\nprint(bird.eat())\n\nprint(\"\\n=== Child-Specific Methods ===\")\nprint(dog.bark())\nprint(cat.meow())\nprint(bird.chirp())\nprint(bird.fly())\nprint(penguin.fly())\n\nprint(\"\\n=== Overridden info() Method ===\")\nprint(dog.info())\nprint(cat.info())\nprint(bird.info())\n\nprint(\"\\n=== Checking Inheritance ===\")\nprint(f\"Is dog an Animal? {isinstance(dog, Animal)}\")\nprint(f\"Is dog a Dog? {isinstance(dog, Dog)}\")\nprint(f\"Is dog a Cat? {isinstance(dog, Cat)}\")\nprint(f\"Is Dog a subclass of Animal? {issubclass(Dog, Animal)}\")",
              "language": "python"
            },
            {
              "type": "ANALOGY",
              "title": "Syntax Breakdown",
              "content": "**Creating inheritance:**\n```python\n# Parent class\nclass Parent:\n    def __init__(self, x):\n        self.x = x\n    \n    def method(self):\n        return \"parent\"\n\n# Child class\nclass Child(Parent):  # Inherit from Parent\n    def __init__(self, x, y):\n        super().__init__(x)  # Call parent's __init__\n        self.y = y\n    \n    # Override parent method\n    def method(self):\n        return \"child\"\n```\n\n**super() function:**\n```python\nsuper().__init__(args)     # Call parent's __init__\nsuper().method(args)       # Call parent's method\n```\n\n**Multiple levels:**\n```python\nclass Grandparent:\n    pass\n\nclass Parent(Grandparent):\n    pass\n\nclass Child(Parent):\n    pass  # Child inherits from both Parent and Grandparent\n```\n\n**Checking relationships:**\n```python\nisinstance(obj, ClassName)  # Is obj an instance of ClassName?\nissubclass(Child, Parent)   # Is Child a subclass of Parent?\n```"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "- **Inheritance creates 'is-a' relationships** - Dog is an Animal\n- **Syntax: class Child(Parent):** - Inherit from parent class\n- **super() calls parent methods** - Especially __init__()\n- **Children inherit all parent attributes/methods** - No rewriting needed\n- **Override methods by redefining them** - Same name, new implementation\n- **Use isinstance(obj, Class)** - Check if object is instance of class\n- **Use issubclass(Child, Parent)** - Check inheritance relationship\n- **DRY principle** - Don't Repeat Yourself, use inheritance"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "11_03-challenge-3",
              "title": "Interactive Exercise",
              "description": "Create a Vehicle hierarchy:\n- Vehicle (parent): brand, year, start(), stop()\n- Car (child): num_doors, additional info\n- Motorcycle (child): has_sidecar, additional info\nBoth children should override info() and add specific methods",
              "instructions": "Create a Vehicle hierarchy:\n- Vehicle (parent): brand, year, start(), stop()\n- Car (child): num_doors, additional info\n- Motorcycle (child): has_sidecar, additional info\nBoth children should override info() and add specific methods",
              "starterCode": "class Vehicle:\n    def __init__(self, brand, year):\n        # TODO: Set brand and year\n        pass\n    \n    def start(self):\n        # TODO: Return start message\n        pass\n    \n    def stop(self):\n        # TODO: Return stop message\n        pass\n    \n    def info(self):\n        # TODO: Return basic info\n        pass\n\nclass Car(Vehicle):\n    def __init__(self, brand, year, num_doors):\n        # TODO: Call parent __init__ and set num_doors\n        pass\n    \n    def info(self):\n        # TODO: Override with car-specific info\n        pass\n\nclass Motorcycle(Vehicle):\n    def __init__(self, brand, year, has_sidecar=False):\n        # TODO: Call parent __init__ and set has_sidecar\n        pass\n    \n    def info(self):\n        # TODO: Override with motorcycle-specific info\n        pass\n\n# TODO: Create vehicles and test methods",
              "solution": "",
              "language": "python",
              "testCases": [
                {
                  "description": "Code runs without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use super().__init__() to call parent constructor. Override info() to provide specific details."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "11_04",
          "title": "Polymorphism",
          "moduleId": "module-11",
          "order": 4,
          "estimatedMinutes": 30,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Concept: Many Forms, Same Interface",
              "content": "**Polymorphism** = \"Many forms\"\n\n**Think of it like a TV remote:**\n- Same button (\"Play\") works on:\n  - DVD player → plays DVD\n  - Streaming box → plays stream\n  - Game console → starts game\n- **Same interface, different behavior**\n\n**In Python:**\n```\nSame method name, different implementations:\n\ndog.speak() → \"Woof!\"\ncat.speak() → \"Meow!\"\nbird.speak() → \"Chirp!\"\n\nAll respond to speak(), each does it differently\n```\n\n**Two types of polymorphism:**\n\n**1. Method Overriding** (inheritance-based)\n- Child classes override parent method\n- Same method name, different implementation\n```python\nclass Animal:\n    def speak(self): pass\n\nclass Dog(Animal):\n    def speak(self): return \"Woof\"\n\nclass Cat(Animal):\n    def speak(self): return \"Meow\"\n```\n\n**2. Duck Typing** (\"If it walks like a duck...\")\n- Don't check type, check behavior\n- If it has the method, use it!\n```python\n# Don't care about type, just that it has speak()\nfor animal in animals:\n    print(animal.speak())  # Works for any object with speak()\n```\n\n**Benefits:**\n- Write generic code\n- Easy to extend\n- Flexible and reusable"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example: Polymorphism in Action",
              "content": "**Polymorphism demonstrated:**\n\n**1. Method Overriding:**\n- Each shape implements `area()` and `perimeter()` differently\n- Same method names, different calculations\n\n**2. Uniform Interface:**\n- `print_shape_info()` works with any shape\n- Doesn't care about specific type\n- Just calls `area()` and `perimeter()`\n\n**3. Duck Typing:**\n- `Square` doesn't inherit from `Shape`\n- But has required methods\n- Works perfectly with polymorphic functions!\n\n**Key insight:** Code to interfaces, not implementations",
              "code": "# Base class with common interface\nclass Shape:\n    def __init__(self, name):\n        self.name = name\n    \n    def area(self):\n        raise NotImplementedError(\"Subclass must implement area()\")\n    \n    def perimeter(self):\n        raise NotImplementedError(\"Subclass must implement perimeter()\")\n    \n    def describe(self):\n        return f\"{self.name}: Area = {self.area()}, Perimeter = {self.perimeter()}\"\n\n# Different shapes, same interface\nclass Circle(Shape):\n    def __init__(self, radius):\n        super().__init__(\"Circle\")\n        self.radius = radius\n    \n    def area(self):\n        return 3.14159 * self.radius ** 2\n    \n    def perimeter(self):\n        return 2 * 3.14159 * self.radius\n\nclass Rectangle(Shape):\n    def __init__(self, width, height):\n        super().__init__(\"Rectangle\")\n        self.width = width\n        self.height = height\n    \n    def area(self):\n        return self.width * self.height\n    \n    def perimeter(self):\n        return 2 * (self.width + self.height)\n\nclass Triangle(Shape):\n    def __init__(self, base, height, side1, side2, side3):\n        super().__init__(\"Triangle\")\n        self.base = base\n        self.height = height\n        self.sides = [side1, side2, side3]\n    \n    def area(self):\n        return 0.5 * self.base * self.height\n    \n    def perimeter(self):\n        return sum(self.sides)\n\n# Polymorphic function - works with any Shape\ndef print_shape_info(shape):\n    \"\"\"Works with any object that has area() and perimeter()\"\"\"\n    print(f\"{shape.name}:\")\n    print(f\"  Area: {shape.area():.2f}\")\n    print(f\"  Perimeter: {shape.perimeter():.2f}\")\n    print()\n\ndef calculate_total_area(shapes):\n    \"\"\"Works with list of any shapes\"\"\"\n    total = sum(shape.area() for shape in shapes)\n    return total\n\n# Create different shapes\nprint(\"=== Creating Shapes ===\")\ncircle = Circle(5)\nrectangle = Rectangle(4, 6)\ntriangle = Triangle(base=3, height=4, side1=3, side2=4, side3=5)\n\n# Polymorphism: same method, different behavior\nprint(\"\\n=== Polymorphism: Each shape implements methods differently ===\")\nprint_shape_info(circle)\nprint_shape_info(rectangle)\nprint_shape_info(triangle)\n\n# Polymorphism: treating different types uniformly\nprint(\"=== Treating Different Shapes Uniformly ===\")\nshapes = [circle, rectangle, triangle]\n\nfor shape in shapes:\n    print(shape.describe())\n\nprint(f\"\\nTotal area of all shapes: {calculate_total_area(shapes):.2f}\")\n\n# Duck typing: if it has the methods, it works!\nprint(\"\\n=== Duck Typing ===\")\n\nclass Square:  # Doesn't inherit from Shape!\n    def __init__(self, side):\n        self.name = \"Square\"\n        self.side = side\n    \n    def area(self):\n        return self.side ** 2\n    \n    def perimeter(self):\n        return 4 * self.side\n\nsquare = Square(5)\nprint_shape_info(square)  # Works! Has area() and perimeter()\n\n# Add to shapes list\nshapes.append(square)\nprint(f\"Total area including square: {calculate_total_area(shapes):.2f}\")",
              "language": "python"
            },
            {
              "type": "ANALOGY",
              "title": "Syntax Breakdown",
              "content": "**Creating polymorphic behavior:**\n\n**Step 1: Define common interface**\n```python\nclass Base:\n    def method(self):\n        raise NotImplementedError(\"Must override\")\n```\n\n**Step 2: Override in children**\n```python\nclass Child1(Base):\n    def method(self):\n        return \"Child1 implementation\"\n\nclass Child2(Base):\n    def method(self):\n        return \"Child2 implementation\"\n```\n\n**Step 3: Use polymorphically**\n```python\ndef process(obj):\n    return obj.method()  # Works with any child!\n\nprocess(Child1())  # → \"Child1 implementation\"\nprocess(Child2())  # → \"Child2 implementation\"\n```\n\n**Duck typing:**\n```python\ndef process(obj):\n    # Don't check type, just call method\n    return obj.method()  # Works with ANY object that has method()\n```\n\n**Key pattern:**\n```python\n# Instead of this (bad):\nif isinstance(obj, Dog):\n    obj.bark()\nelif isinstance(obj, Cat):\n    obj.meow()\n\n# Do this (good):\nobj.speak()  # All have speak(), different implementations\n```"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "- **Polymorphism = 'many forms'** - Same interface, different implementations\n- **Method overriding enables polymorphism** - Children override parent methods\n- **Write code to interfaces** - Don't check types, call methods\n- **Duck typing: 'If it walks like a duck...'** - Behavior matters, not type\n- **Polymorphic functions work with any compatible type** - Very flexible\n- **Add new types without changing existing code** - Open/Closed Principle\n- **NotImplementedError in base class** - Forces children to implement\n- **Python doesn't require inheritance for polymorphism** - Just matching methods"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "11_04-challenge-3",
              "title": "Interactive Exercise",
              "description": "Create a payment processing system:\n- Payment base class with pay() method\n- CreditCard, PayPal, Bitcoin subclasses\n- process_payment() function that works with any payment type\n- Each payment type implements pay() differently",
              "instructions": "Create a payment processing system:\n- Payment base class with pay() method\n- CreditCard, PayPal, Bitcoin subclasses\n- process_payment() function that works with any payment type\n- Each payment type implements pay() differently",
              "starterCode": "class Payment:\n    def __init__(self, amount):\n        self.amount = amount\n    \n    def pay(self):\n        # TODO: Raise NotImplementedError\n        pass\n\nclass CreditCard(Payment):\n    def __init__(self, amount, card_number):\n        # TODO: Call parent init and store card_number\n        pass\n    \n    def pay(self):\n        # TODO: Return payment message\n        pass\n\nclass PayPal(Payment):\n    def __init__(self, amount, email):\n        # TODO: Call parent init and store email\n        pass\n    \n    def pay(self):\n        # TODO: Return payment message\n        pass\n\nclass Bitcoin(Payment):\n    def __init__(self, amount, wallet_address):\n        # TODO: Call parent init and store wallet_address\n        pass\n    \n    def pay(self):\n        # TODO: Return payment message\n        pass\n\ndef process_payment(payment):\n    # TODO: Process any payment type\n    pass\n\n# TODO: Create different payment types and process them",
              "solution": "",
              "language": "python",
              "testCases": [
                {
                  "description": "Code runs without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Each pay() method should return a string describing the payment. process_payment() should work with any Payment object."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "11_05",
          "title": "Encapsulation and Properties",
          "moduleId": "module-11",
          "order": 5,
          "estimatedMinutes": 30,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Concept: Information Hiding",
              "content": "**Encapsulation** = Bundling data with methods that operate on that data, and restricting direct access\n\n**Think of a car:**\n- You don't access engine internals directly\n- You use interface: steering wheel, pedals, gear shift\n- Engine details are hidden (encapsulated)\n- Prevents mistakes (can't accidentally break transmission)\n\n**In Python:**\n\n**Public** (normal attributes)\n```python\nself.name = \"John\"  # Anyone can access/modify\nobj.name = \"Jane\"   # Direct access\n```\n\n**Protected** (single underscore)\n```python\nself._internal = value  # Convention: \"please don't touch\"\n# Not enforced, just a hint to other developers\n```\n\n**Private** (double underscore)\n```python\nself.__secret = value  # Name mangling, harder to access\n# Becomes _ClassName__secret\n```\n\n**Why encapsulate?**\n\n1. **Validation** ✓\n   - Check values before setting\n   - Prevent invalid states\n\n2. **Controlled access** 🔒\n   - Read-only attributes\n   - Computed values\n\n3. **Change implementation** 🔧\n   - Modify internals without breaking code\n   - Maintain backward compatibility\n\n4. **Hide complexity** 🎭\n   - Simple interface, complex internals"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example: Properties and Encapsulation",
              "content": "**@property decorator creates managed attributes:**\n\n**1. Read-only property:**\n```python\n@property\ndef balance(self):\n    return self.__balance\n```\nUsage: `account.balance` (looks like attribute, actually method)\n\n**2. Property with setter:**\n```python\n@property\ndef fee(self):\n    return self._fee\n\n@fee.setter\ndef fee(self, value):\n    if value < 0:\n        raise ValueError()\n    self._fee = value\n```\n\n**3. Write-only property:**\n- Getter raises AttributeError\n- Only setter works\n\n**Key benefits:**\n- Validation on setting\n- Read-only access\n- Computed values\n- Looks like attribute access",
              "code": "class BankAccount:\n    def __init__(self, account_holder, initial_balance=0):\n        self.account_holder = account_holder  # Public\n        self._transaction_fee = 1.50          # Protected (by convention)\n        self.__balance = initial_balance       # Private (name mangled)\n        self.__pin = None                      # Private\n    \n    # Property: balance (read-only)\n    @property\n    def balance(self):\n        \"\"\"Read-only access to balance\"\"\"\n        return self.__balance\n    \n    # Property: pin (write-only via setter)\n    @property\n    def pin(self):\n        \"\"\"Can't read PIN!\"\"\"\n        raise AttributeError(\"PIN is write-only\")\n    \n    @pin.setter\n    def pin(self, value):\n        \"\"\"Set PIN with validation\"\"\"\n        if not isinstance(value, str) or len(value) != 4 or not value.isdigit():\n            raise ValueError(\"PIN must be 4 digits\")\n        self.__pin = value\n        print(\"PIN set successfully\")\n    \n    # Property with getter and setter\n    @property\n    def transaction_fee(self):\n        return self._transaction_fee\n    \n    @transaction_fee.setter\n    def transaction_fee(self, value):\n        if value < 0:\n            raise ValueError(\"Fee cannot be negative\")\n        self._transaction_fee = value\n    \n    # Methods that use private attributes\n    def deposit(self, amount):\n        if amount <= 0:\n            raise ValueError(\"Deposit must be positive\")\n        self.__balance += amount - self._transaction_fee\n        return f\"Deposited ${amount}. Fee: ${self._transaction_fee}. New balance: ${self.__balance}\"\n    \n    def withdraw(self, amount, pin):\n        if pin != self.__pin:\n            raise ValueError(\"Invalid PIN\")\n        if amount <= 0:\n            raise ValueError(\"Withdrawal must be positive\")\n        total = amount + self._transaction_fee\n        if total > self.__balance:\n            raise ValueError(\"Insufficient funds\")\n        self.__balance -= total\n        return f\"Withdrew ${amount}. Fee: ${self._transaction_fee}. New balance: ${self.__balance}\"\n\nprint(\"=== Creating Account ===\")\naccount = BankAccount(\"Alice\", 1000)\n\nprint(\"\\n=== Reading Balance (Property) ===\")\nprint(f\"Balance: ${account.balance}\")  # Uses @property\n\n# Try to modify balance directly (won't work!)\nprint(\"\\n=== Trying to Modify Balance Directly ===\")\ntry:\n    account.balance = 5000  # No setter defined!\nexcept AttributeError as e:\n    print(f\"Error: {e}\")\n\nprint(\"\\n=== Setting PIN (Property with Validation) ===\")\naccount.pin = \"1234\"  # Uses @pin.setter\n\n# Invalid PINs\nprint(\"\\n=== Invalid PIN Examples ===\")\ntry:\n    account.pin = \"123\"  # Too short\nexcept ValueError as e:\n    print(f\"Error: {e}\")\n\ntry:\n    account.pin = \"abcd\"  # Not digits\nexcept ValueError as e:\n    print(f\"Error: {e}\")\n\nprint(\"\\n=== Can't Read PIN ===\")\ntry:\n    print(account.pin)  # Raises AttributeError\nexcept AttributeError as e:\n    print(f\"Error: {e}\")\n\nprint(\"\\n=== Transaction Fee Property ===\")\nprint(f\"Current fee: ${account.transaction_fee}\")\naccount.transaction_fee = 2.00\nprint(f\"New fee: ${account.transaction_fee}\")\n\ntry:\n    account.transaction_fee = -5  # Validation!\nexcept ValueError as e:\n    print(f\"Error: {e}\")\n\nprint(\"\\n=== Using Methods ===\")\nprint(account.deposit(500))\nprint(account.withdraw(200, \"1234\"))\n\nprint(\"\\n=== Wrong PIN ===\")\ntry:\n    account.withdraw(100, \"9999\")\nexcept ValueError as e:\n    print(f\"Error: {e}\")\n\nprint(f\"\\nFinal balance: ${account.balance}\")\n\n# Demonstrate name mangling\nprint(\"\\n=== Name Mangling (Private Attributes) ===\")\nprint(f\"Can't access __balance directly: {hasattr(account, '__balance')}\")\nprint(f\"But it's stored as _BankAccount__balance: {hasattr(account, '_BankAccount__balance')}\")\nprint(\"(Don't do this in real code - defeats the purpose!)\")",
              "language": "python"
            },
            {
              "type": "ANALOGY",
              "title": "Syntax Breakdown",
              "content": "**Attribute access levels:**\n```python\nclass MyClass:\n    def __init__(self):\n        self.public = \"anyone can access\"\n        self._protected = \"convention: internal use\"\n        self.__private = \"name mangled\"\n```\n\n**Property (read-only):**\n```python\nclass MyClass:\n    def __init__(self):\n        self.__value = 0\n    \n    @property\n    def value(self):\n        return self.__value\n\nobj = MyClass()\nprint(obj.value)      # OK - calls getter\nobj.value = 10        # Error - no setter\n```\n\n**Property with setter:**\n```python\nclass MyClass:\n    def __init__(self):\n        self.__value = 0\n    \n    @property\n    def value(self):\n        return self.__value\n    \n    @value.setter\n    def value(self, val):\n        if val < 0:\n            raise ValueError(\"Must be positive\")\n        self.__value = val\n\nobj = MyClass()\nobj.value = 10        # OK - validated\nobj.value = -5        # Error - validation failed\n```\n\n**Property with deleter:**\n```python\n@value.deleter\ndef value(self):\n    print(\"Deleting value\")\n    del self.__value\n\ndel obj.value  # Calls deleter\n```"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "- **Encapsulation = bundling data with methods** that control access\n- **Public (name)** - normal access by everyone\n- **Protected (_name)** - convention for internal use\n- **Private (__name)** - name mangling, harder to access\n- **@property decorator** - makes method look like attribute\n- **@property.setter** - validates and controls setting\n- **Read-only properties** - only @property, no setter\n- **Computed properties** - calculate value on-the-fly, no storage needed"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "11_05-challenge-3",
              "title": "Interactive Exercise",
              "description": "Create a Temperature class that:\n- Stores temperature in Celsius (private)\n- Has celsius property (read/write with validation)\n- Has fahrenheit property (computed, read/write)\n- Has kelvin property (computed, read-only)\n- Validates: Celsius >= -273.15 (absolute zero)",
              "instructions": "Create a Temperature class that:\n- Stores temperature in Celsius (private)\n- Has celsius property (read/write with validation)\n- Has fahrenheit property (computed, read/write)\n- Has kelvin property (computed, read-only)\n- Validates: Celsius >= -273.15 (absolute zero)",
              "starterCode": "class Temperature:\n    def __init__(self, celsius=0):\n        # TODO: Initialize with validation\n        pass\n    \n    @property\n    def celsius(self):\n        # TODO: Return celsius\n        pass\n    \n    @celsius.setter\n    def celsius(self, value):\n        # TODO: Validate and set celsius\n        pass\n    \n    @property\n    def fahrenheit(self):\n        # TODO: Convert celsius to fahrenheit\n        # Formula: (C * 9/5) + 32\n        pass\n    \n    @fahrenheit.setter\n    def fahrenheit(self, value):\n        # TODO: Convert fahrenheit to celsius and set\n        # Formula: (F - 32) * 5/9\n        pass\n    \n    @property\n    def kelvin(self):\n        # TODO: Convert celsius to kelvin (read-only!)\n        # Formula: C + 273.15\n        pass\n\n# TODO: Create temperature objects and test properties",
              "solution": "",
              "language": "python",
              "testCases": [
                {
                  "description": "Code runs without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use self.__celsius for private storage. Validate >= -273.15 in celsius setter."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "11_06",
          "title": "Mini-Project: RPG Character System",
          "moduleId": "module-11",
          "order": 6,
          "estimatedMinutes": 45,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Project Overview",
              "content": "**Build an RPG Character System!**\n\nCreate a role-playing game character system with:\n- Base Character class (parent)\n- Warrior, Mage, Rogue classes (children)\n- Inventory management\n- Combat system\n- Leveling and experience\n\n**OOP Concepts Applied:**\n\n1. **Classes & Objects**\n   - Character blueprint\n   - Multiple character instances\n\n2. **Inheritance**\n   - Character (parent)\n   - Warrior, Mage, Rogue (children)\n\n3. **Polymorphism**\n   - Each class has unique `special_attack()`\n   - All work with same combat system\n\n4. **Encapsulation**\n   - Private attributes (health, mana)\n   - Properties with validation\n\n5. **Class Attributes**\n   - Character count\n   - Class-specific bonuses\n\n**Project Structure:**\n```\nCharacter (base)\n├── Warrior (high HP, melee)\n├── Mage (magic, low HP)\n└── Rogue (speed, critical hits)\n```\n\n**Features:**\n- Health/Mana management with validation\n- Inventory system\n- Level-up mechanics\n- Unique abilities per class\n- Combat simulation"
            },
            {
              "type": "EXAMPLE",
              "title": "Step 1: Base Character Class",
              "content": "**Base Character class features:**\n\n**Encapsulation:**\n- Private attributes: `__health`, `__mana`, `__experience`\n- Properties with validation\n- Health can't exceed max or go below 0\n\n**Class attributes:**\n- `total_characters` tracks all characters\n\n**Instance methods:**\n- `attack()`, `take_damage()`, `heal()`\n- `add_experience()`, `level_up()`\n- `add_item()`, `show_inventory()`\n\n**Foundation for inheritance:**\n- Children will override `special_attack()`",
              "code": "class Character:\n    \"\"\"Base character class for RPG\"\"\"\n    \n    # Class attributes\n    total_characters = 0\n    \n    def __init__(self, name, char_class, level=1):\n        # Public attributes\n        self.name = name\n        self.char_class = char_class\n        self.level = level\n        \n        # Private attributes (encapsulation)\n        self.__health = 100\n        self.__max_health = 100\n        self.__mana = 50\n        self.__max_mana = 50\n        self.__experience = 0\n        \n        # Protected attributes\n        self._inventory = []\n        self._is_alive = True\n        \n        # Increment class counter\n        Character.total_characters += 1\n        print(f\"Character created: {name} the {char_class} (Level {level})\")\n    \n    # Properties with encapsulation\n    @property\n    def health(self):\n        return self.__health\n    \n    @health.setter\n    def health(self, value):\n        \"\"\"Set health with validation\"\"\"\n        if value > self.__max_health:\n            value = self.__max_health\n        if value <= 0:\n            value = 0\n            self._is_alive = False\n            print(f\"{self.name} has been defeated!\")\n        self.__health = value\n    \n    @property\n    def mana(self):\n        return self.__mana\n    \n    @mana.setter\n    def mana(self, value):\n        \"\"\"Set mana with validation\"\"\"\n        if value > self.__max_mana:\n            value = self.__max_mana\n        if value < 0:\n            value = 0\n        self.__mana = value\n    \n    @property\n    def max_health(self):\n        return self.__max_health\n    \n    @property\n    def max_mana(self):\n        return self.__max_mana\n    \n    @property\n    def experience(self):\n        return self.__experience\n    \n    # Instance methods\n    def attack(self, target):\n        \"\"\"Basic attack\"\"\"\n        damage = 10 * self.level\n        print(f\"{self.name} attacks {target.name} for {damage} damage!\")\n        target.take_damage(damage)\n        return damage\n    \n    def take_damage(self, amount):\n        \"\"\"Take damage\"\"\"\n        self.health -= amount\n        if self._is_alive:\n            print(f\"{self.name} has {self.health}/{self.max_health} HP remaining\")\n    \n    def heal(self, amount):\n        \"\"\"Heal character\"\"\"\n        old_health = self.health\n        self.health += amount\n        healed = self.health - old_health\n        print(f\"{self.name} healed for {healed} HP ({self.health}/{self.max_health})\")\n    \n    def add_experience(self, amount):\n        \"\"\"Add experience and check for level up\"\"\"\n        self.__experience += amount\n        exp_needed = self.level * 100\n        print(f\"{self.name} gained {amount} XP ({self.__experience}/{exp_needed})\")\n        \n        if self.__experience >= exp_needed:\n            self.level_up()\n    \n    def level_up(self):\n        \"\"\"Level up character\"\"\"\n        self.level += 1\n        self.__max_health += 20\n        self.__max_mana += 10\n        self.health = self.__max_health  # Full heal on level up\n        self.mana = self.__max_mana\n        self.__experience = 0\n        print(f\"🎉 {self.name} leveled up to {self.level}!\")\n        print(f\"   HP: {self.__max_health}, Mana: {self.__max_mana}\")\n    \n    def add_item(self, item):\n        \"\"\"Add item to inventory\"\"\"\n        self._inventory.append(item)\n        print(f\"{self.name} obtained: {item}\")\n    \n    def show_inventory(self):\n        \"\"\"Display inventory\"\"\"\n        if not self._inventory:\n            print(f\"{self.name}'s inventory is empty\")\n        else:\n            print(f\"{self.name}'s inventory:\")\n            for i, item in enumerate(self._inventory, 1):\n                print(f\"  {i}. {item}\")\n    \n    def special_attack(self, target):\n        \"\"\"Override in subclasses\"\"\"\n        raise NotImplementedError(\"Subclass must implement special_attack\")\n    \n    def __str__(self):\n        status = \"ALIVE\" if self._is_alive else \"DEFEATED\"\n        return f\"{self.name} | {self.char_class} | Lvl {self.level} | HP: {self.health}/{self.max_health} | Mana: {self.mana}/{self.max_mana} | {status}\"\n    \n    @classmethod\n    def get_character_count(cls):\n        return f\"Total characters created: {cls.total_characters}\"\n\nprint(\"=== Testing Base Character ===\")\nchar = Character(\"TestHero\", \"Generic\")\nprint(char)\nchar.add_item(\"Health Potion\")\nchar.add_item(\"Sword\")\nchar.show_inventory()\nprint(Character.get_character_count())",
              "language": "python"
            },
            {
              "type": "EXAMPLE",
              "title": "Step 2: Warrior, Mage, Rogue Classes",
              "content": "**Three character classes demonstrating inheritance:**\n\n**Warrior:**\n- Higher starting HP (150)\n- Builds rage with attacks\n- Special: Berserker Rage (requires 50 rage)\n\n**Mage:**\n- Lower HP (80), higher mana (100)\n- Special: Fireball (costs 30 mana)\n- Unique: restore_mana() ability\n\n**Rogue:**\n- Normal HP\n- Can enter stealth\n- Special: Backstab (requires stealth)\n- Critical hit chance on normal attacks\n\n**Key inheritance features:**\n- All call `super().__init__()`\n- Override `special_attack()` polymorphically\n- Some override `attack()` with enhanced versions\n- Access parent's private attributes via name mangling",
              "code": "class Warrior(Character):\n    \"\"\"Warrior class - high HP, melee damage\"\"\"\n    \n    # Class attribute\n    armor_bonus = 1.5\n    \n    def __init__(self, name, level=1):\n        super().__init__(name, \"Warrior\", level)\n        # Warriors start with more health\n        self._Character__max_health = 150\n        self.health = 150\n        self._rage = 0\n    \n    def special_attack(self, target):\n        \"\"\"Berserker Rage - powerful attack\"\"\"\n        if self._rage < 50:\n            print(f\"{self.name} needs 50 rage (has {self._rage})\")\n            return 0\n        \n        damage = 30 * self.level\n        self._rage = 0\n        print(f\"⚔️  {self.name} uses BERSERKER RAGE!\")\n        print(f\"   Devastating attack for {damage} damage!\")\n        target.take_damage(damage)\n        return damage\n    \n    def attack(self, target):\n        \"\"\"Override attack to build rage\"\"\"\n        damage = super().attack(target)\n        self._rage += 20\n        print(f\"   Rage increased to {self._rage}\")\n        return damage\n\nclass Mage(Character):\n    \"\"\"Mage class - magic damage, low HP\"\"\"\n    \n    # Class attribute\n    spell_power = 1.8\n    \n    def __init__(self, name, level=1):\n        super().__init__(name, \"Mage\", level)\n        # Mages have less health but more mana\n        self._Character__max_health = 80\n        self._Character__max_mana = 100\n        self.health = 80\n        self.mana = 100\n    \n    def special_attack(self, target):\n        \"\"\"Fireball - magical damage\"\"\"\n        mana_cost = 30\n        if self.mana < mana_cost:\n            print(f\"{self.name} needs {mana_cost} mana (has {self.mana})\")\n            return 0\n        \n        self.mana -= mana_cost\n        damage = int(25 * self.level * self.spell_power)\n        print(f\"🔥 {self.name} casts FIREBALL!\")\n        print(f\"   Magical damage: {damage}\")\n        target.take_damage(damage)\n        return damage\n    \n    def restore_mana(self, amount=20):\n        \"\"\"Mage-specific ability\"\"\"\n        old_mana = self.mana\n        self.mana += amount\n        restored = self.mana - old_mana\n        print(f\"{self.name} meditates, restoring {restored} mana ({self.mana}/{self.max_mana})\")\n\nclass Rogue(Character):\n    \"\"\"Rogue class - speed and critical hits\"\"\"\n    \n    # Class attribute\n    crit_chance = 0.3  # 30% crit chance\n    \n    def __init__(self, name, level=1):\n        super().__init__(name, \"Rogue\", level)\n        self._stealth = False\n    \n    def special_attack(self, target):\n        \"\"\"Backstab - critical damage from stealth\"\"\"\n        if not self._stealth:\n            print(f\"{self.name} needs to be in stealth!\")\n            return 0\n        \n        damage = 40 * self.level\n        self._stealth = False\n        print(f\"🗡️  {self.name} uses BACKSTAB from stealth!\")\n        print(f\"   Critical damage: {damage}\")\n        target.take_damage(damage)\n        return damage\n    \n    def enter_stealth(self):\n        \"\"\"Rogue-specific ability\"\"\"\n        self._stealth = True\n        print(f\"{self.name} enters stealth mode...\")\n    \n    def attack(self, target):\n        \"\"\"Override attack for critical hits\"\"\"\n        import random\n        damage = 10 * self.level\n        \n        if random.random() < self.crit_chance:\n            damage *= 2\n            print(f\"💥 CRITICAL HIT!\")\n        \n        print(f\"{self.name} attacks {target.name} for {damage} damage!\")\n        target.take_damage(damage)\n        return damage\n\nprint(\"\\n=== Creating Different Classes ===\")\nwarrior = Warrior(\"Conan\")\nmage = Mage(\"Gandalf\")\nrogue = Rogue(\"Assassin\")\n\nprint(\"\\n=== Character Stats ===\")\nprint(warrior)\nprint(mage)\nprint(rogue)\n\nprint(f\"\\n{Character.get_character_count()}\")",
              "language": "python"
            },
            {
              "type": "EXAMPLE",
              "title": "Step 3: Combat Simulation",
              "content": "**Combat system demonstrating all OOP concepts:**\n\n**1. Polymorphism:**\n- Different classes all have `attack()` and `special_attack()`\n- Same combat loop works for any character type\n- Each implements abilities differently\n\n**2. Encapsulation:**\n- Health/mana managed through properties\n- Validation prevents invalid values\n- Private attributes protected\n\n**3. Inheritance:**\n- All share Character base functionality\n- Each adds unique features\n- Override methods for custom behavior\n\n**4. Class attributes:**\n- `total_characters` tracks all instances\n- Each class has specific bonuses\n\n**Complete RPG foundation ready to extend!**",
              "code": "def combat_demo():\n    \"\"\"Demonstrate polymorphic combat\"\"\"\n    print(\"\\n\" + \"=\"*50)\n    print(\"COMBAT ARENA\")\n    print(\"=\"*50)\n    \n    # Create fighters\n    hero = Warrior(\"Aragorn\", level=2)\n    villain = Mage(\"Saruman\", level=2)\n    \n    print(\"\\n=== Round 1: Basic Attacks ===\")\n    hero.attack(villain)\n    villain.attack(hero)\n    \n    print(\"\\n=== Round 2: More Attacks ===\")\n    hero.attack(villain)\n    villain.attack(hero)\n    \n    print(\"\\n=== Round 3: Special Attacks ===\")\n    # Warrior has rage now\n    hero.special_attack(villain)\n    # Mage casts fireball\n    villain.special_attack(hero)\n    \n    print(\"\\n=== Current Status ===\")\n    print(hero)\n    print(villain)\n    \n    print(\"\\n=== Healing ===\")\n    hero.heal(30)\n    villain.restore_mana(50)\n    \n    print(\"\\n=== Final Status ===\")\n    print(hero)\n    print(villain)\n\ndef polymorphism_demo():\n    \"\"\"Demonstrate polymorphism - different classes, same interface\"\"\"\n    print(\"\\n\" + \"=\"*50)\n    print(\"POLYMORPHISM DEMONSTRATION\")\n    print(\"=\"*50)\n    \n    # Create different character types\n    characters = [\n        Warrior(\"Brutor\"),\n        Mage(\"Merlin\"),\n        Rogue(\"Shadow\")\n    ]\n    \n    dummy = Character(\"Target Dummy\", \"Dummy\")\n    dummy.health = 500  # Lots of HP\n    \n    print(\"\\nAll characters attacking same target:\\n\")\n    \n    # Polymorphic loop - works with any Character subclass\n    for char in characters:\n        char.attack(dummy)\n        print()\n    \n    print(\"\\n=== Special Attacks ===\")\n    \n    # Warrior builds rage first\n    warrior = characters[0]\n    warrior.attack(dummy)\n    warrior.attack(dummy)\n    warrior.special_attack(dummy)  # Berserker Rage\n    \n    # Mage has mana\n    mage = characters[1]\n    mage.special_attack(dummy)  # Fireball\n    \n    # Rogue needs stealth\n    rogue = characters[2]\n    rogue.enter_stealth()\n    rogue.special_attack(dummy)  # Backstab\n    \n    print(f\"\\n{dummy.name}: {dummy.health}/{dummy.max_health} HP\")\n\ndef leveling_demo():\n    \"\"\"Demonstrate leveling system\"\"\"\n    print(\"\\n\" + \"=\"*50)\n    print(\"LEVELING SYSTEM\")\n    print(\"=\"*50)\n    \n    hero = Rogue(\"Leveling Hero\")\n    print(f\"\\nStarting stats: {hero}\")\n    \n    print(\"\\n=== Gaining Experience ===\")\n    hero.add_experience(50)\n    hero.add_experience(30)\n    hero.add_experience(30)  # Should level up (needs 100)\n    \n    print(f\"\\nAfter level up: {hero}\")\n    \n    print(\"\\n=== Inventory Management ===\")\n    hero.add_item(\"Dagger of Shadows\")\n    hero.add_item(\"Health Potion x3\")\n    hero.add_item(\"Smoke Bomb\")\n    hero.show_inventory()\n\n# Run all demonstrations\ncombat_demo()\npolymorphism_demo()\nleveling_demo()\n\nprint(\"\\n\" + \"=\"*50)\nprint(Character.get_character_count())\nprint(\"=\"*50)",
              "language": "python"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "- **OOP organizes complex systems** - RPG demonstrates real-world structure\n- **Inheritance creates hierarchies** - Character → Warrior/Mage/Rogue\n- **Polymorphism enables flexibility** - Same combat loop, different behaviors\n- **Encapsulation protects data** - Health/mana validated through properties\n- **Properties provide controlled access** - Can't set invalid values\n- **Class attributes track shared data** - Total character count\n- **Method overriding customizes behavior** - Each class has unique attacks\n- **super() maintains parent functionality** - Call parent then add custom logic"
            }
          ],
          "challenges": []
        }
      ],
      "quizzes": [
        {
          "id": "quiz-11",
          "title": "Module 11: Object-Oriented Programming - Comprehensive Quiz",
          "description": "Test your understanding of OOP concepts: classes, objects, inheritance, polymorphism, encapsulation, and properties. 70% required to pass.",
          "moduleId": "module-11",
          "passingScore": 70,
          "estimatedMinutes": 15,
          "questions": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-11-q1",
              "title": "What is a class in object-oriented programming?",
              "description": "What is a class in object-oriented programming?",
              "options": [
                "A specific instance of an object",
                "A blueprint or template for creating objects",
                "A collection of functions",
                "A type of variable"
              ],
              "correctAnswer": 1,
              "explanation": "A class is a blueprint or template that defines the structure and behavior of objects. You create multiple objects (instances) from one class."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-11-q2",
              "title": "What does the __init__ method do?",
              "description": "What does the __init__ method do?",
              "options": [
                "Deletes an object",
                "Initializes a new object's attributes when it's created",
                "Ends a program",
                "Imports modules"
              ],
              "correctAnswer": 1,
              "explanation": "__init__ is the constructor method that runs automatically when creating a new object. It initializes the object's attributes with starting values."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-11-q3",
              "title": "What does 'self' represent in a class method?",
              "description": "What does 'self' represent in a class method?",
              "options": [
                "The class itself",
                "The specific instance of the object",
                "All instances of the class",
                "The parent class"
              ],
              "correctAnswer": 1,
              "explanation": "'self' refers to the specific instance of the object. It allows each object to access its own attributes and methods."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-11-q4",
              "title": "What's the difference between instance and class attributes?",
              "description": "What's the difference between instance and class attributes?",
              "options": [
                "No difference",
                "Instance attributes are unique to each object, class attributes are shared by all",
                "Class attributes are unique, instance attributes are shared",
                "Instance attributes are faster"
              ],
              "correctAnswer": 1,
              "explanation": "Instance attributes (self.x) are unique to each object and set in __init__. Class attributes are defined in the class body and shared by all instances."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-11-q5",
              "title": "What is a class method and how is it defined?",
              "description": "What is a class method and how is it defined?",
              "options": [
                "Any method in a class",
                "A method decorated with @classmethod that receives cls instead of self",
                "A method that creates classes",
                "A private method"
              ],
              "correctAnswer": 1,
              "explanation": "A class method is decorated with @classmethod and receives 'cls' (the class) as its first parameter instead of 'self'. Often used for alternative constructors."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-11-q6",
              "title": "What is a static method?",
              "description": "What is a static method?",
              "options": [
                "A method that never changes",
                "A method decorated with @staticmethod that doesn't receive self or cls",
                "A method that can only be called once",
                "A class attribute"
              ],
              "correctAnswer": 1,
              "explanation": "Static methods are decorated with @staticmethod and don't receive self or cls. They're utility functions organized within a class but don't access instance or class data."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-11-q7",
              "title": "How do you create inheritance in Python?",
              "description": "How do you create inheritance in Python?",
              "options": [
                "class Child inherits Parent:",
                "class Child(Parent):",
                "class Child extends Parent:",
                "class Child from Parent:"
              ],
              "correctAnswer": 1,
              "explanation": "Use 'class Child(Parent):' to create inheritance. The child class inherits all attributes and methods from the parent class."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-11-q8",
              "title": "What does super().__init__() do?",
              "description": "What does super().__init__() do?",
              "options": [
                "Deletes the parent class",
                "Calls the parent class's __init__ method",
                "Creates a new parent class",
                "Overrides the parent's constructor"
              ],
              "correctAnswer": 1,
              "explanation": "super().__init__() calls the parent class's constructor, allowing the child to initialize parent attributes before adding its own."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-11-q9",
              "title": "What is method overriding?",
              "description": "What is method overriding?",
              "options": [
                "Calling multiple methods at once",
                "Redefining a parent class method in the child class",
                "Deleting a parent method",
                "Creating duplicate methods"
              ],
              "correctAnswer": 1,
              "explanation": "Method overriding is when a child class provides its own implementation of a method that exists in the parent class, replacing the parent's version."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-11-q10",
              "title": "What does isinstance(obj, ClassName) check?",
              "description": "What does isinstance(obj, ClassName) check?",
              "options": [
                "If obj is exactly ClassName",
                "If obj is an instance of ClassName or its subclasses",
                "If obj and ClassName are the same",
                "If obj is a class"
              ],
              "correctAnswer": 1,
              "explanation": "isinstance(obj, ClassName) returns True if obj is an instance of ClassName or any of its subclasses."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-11-q11",
              "title": "What is polymorphism?",
              "description": "What is polymorphism?",
              "options": [
                "Having multiple classes",
                "The ability to treat different objects with the same interface uniformly",
                "Creating many objects",
                "Multiple inheritance"
              ],
              "correctAnswer": 1,
              "explanation": "Polymorphism means 'many forms' - different objects can be treated uniformly when they share a common interface, even if implementations differ."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-11-q12",
              "title": "What is duck typing in Python?",
              "description": "What is duck typing in Python?",
              "options": [
                "A type of inheritance",
                "If an object has the required methods, it can be used regardless of its type",
                "Checking types before use",
                "A way to create duck objects"
              ],
              "correctAnswer": 1,
              "explanation": "Duck typing: 'If it walks like a duck and quacks like a duck, it's a duck.' If an object has the methods you need, use it regardless of its actual type."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-11-q13",
              "title": "Why raise NotImplementedError in a base class method?",
              "description": "Why raise NotImplementedError in a base class method?",
              "options": [
                "To delete the method",
                "To force subclasses to implement the method",
                "To prevent the method from running",
                "To create an error message"
              ],
              "correctAnswer": 1,
              "explanation": "Raising NotImplementedError in a base class signals that subclasses must override this method. It creates an interface that children must implement."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-11-q14",
              "title": "What does the @property decorator do?",
              "description": "What does the @property decorator do?",
              "options": [
                "Creates a class attribute",
                "Makes a method accessible like an attribute",
                "Makes an attribute private",
                "Creates multiple properties"
              ],
              "correctAnswer": 1,
              "explanation": "@property makes a method accessible like an attribute. You call obj.method instead of obj.method(), enabling getters/setters."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-11-q15",
              "title": "What does double underscore (__) before an attribute name do?",
              "description": "What does double underscore (__) before an attribute name do?",
              "options": [
                "Makes it completely inaccessible",
                "Triggers name mangling (_ClassName__attribute)",
                "Makes it a class variable",
                "Nothing special"
              ],
              "correctAnswer": 1,
              "explanation": "Double underscore triggers name mangling - Python renames it to _ClassName__attribute. It's not truly private but discourages direct access."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-11-q16",
              "title": "What's the difference between _attribute and __attribute?",
              "description": "What's the difference between _attribute and __attribute?",
              "options": [
                "No difference",
                "_attribute is a convention (protected), __attribute uses name mangling (private)",
                "__attribute is public, _attribute is private",
                "_attribute is faster"
              ],
              "correctAnswer": 1,
              "explanation": "Single underscore (_) is a convention meaning 'internal use, please don't touch.' Double underscore (__) triggers name mangling for stronger privacy."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-11-q17",
              "title": "How do you create a property with both getter and setter?",
              "description": "How do you create a property with both getter and setter?",
              "options": [
                "Use two @property decorators",
                "Use @property for getter and @property_name.setter for setter",
                "Use @getter and @setter",
                "Properties are always read-only"
              ],
              "correctAnswer": 1,
              "explanation": "Use @property for the getter method, then @property_name.setter for the setter method. They must have the same name."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-11-q18",
              "title": "Why use property setters?",
              "description": "Why use property setters?",
              "options": [
                "To make code faster",
                "To validate data before setting an attribute",
                "To create multiple attributes",
                "To inherit from parent"
              ],
              "correctAnswer": 1,
              "explanation": "Property setters allow validation and control over how attributes are set. You can check ranges, types, and enforce business rules."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-11-q19",
              "title": "What is encapsulation?",
              "description": "What is encapsulation?",
              "options": [
                "Creating multiple classes",
                "Bundling data with methods and restricting direct access",
                "Inheriting from parent classes",
                "Using many objects"
              ],
              "correctAnswer": 1,
              "explanation": "Encapsulation means bundling data (attributes) with methods that operate on that data, and controlling access through an interface."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-11-q20",
              "title": "In the RPG project, why does each character class override special_attack()?",
              "description": "In the RPG project, why does each character class override special_attack()?",
              "options": [
                "To delete the parent's method",
                "To provide class-specific implementations while maintaining a common interface",
                "Because they must have different method names",
                "To prevent other classes from using it"
              ],
              "correctAnswer": 1,
              "explanation": "Each class overrides special_attack() to provide unique behavior (Berserker Rage, Fireball, Backstab) while maintaining the same method signature for polymorphism."
            }
          ]
        }
      ]
    },
    {
      "id": "module-12",
      "title": "Module 12",
      "description": "Python programming fundamentals - Module 12",
      "difficulty": "advanced",
      "estimatedHours": 4,
      "lessons": [
        {
          "id": "12_01",
          "title": "Decorators",
          "moduleId": "module-12",
          "order": 1,
          "estimatedMinutes": 35,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Concept: Gift Wrapping Functions",
              "content": "**Decorators = Function wrappers**\n\n**Think of gift wrapping:**\n- You have a gift (function)\n- You wrap it in fancy paper (decorator)\n- The gift is the same, but now it's enhanced!\n\n**What decorators do:**\n- Add functionality to existing functions\n- Without modifying the original function\n- Reusable across multiple functions\n\n**Common uses:**\n1. **Logging** 📝 - Track when functions are called\n2. **Timing** ⏱️ - Measure execution time\n3. **Authentication** 🔐 - Check permissions\n4. **Validation** ✅ - Verify inputs\n5. **Caching** 💾 - Store results\n\n**Basic syntax:**\n```python\n@decorator_name\ndef my_function():\n    pass\n\n# Same as:\nmy_function = decorator_name(my_function)\n```\n\n**Key insight:**\nDecorators are functions that take a function and return a wrapped version."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example: Understanding Decorators",
              "content": "**How decorators work:**\n\n1. **Decorator function:**\n```python\ndef my_decorator(func):\n    def wrapper(*args, **kwargs):\n        # Before function call\n        result = func(*args, **kwargs)\n        # After function call\n        return result\n    return wrapper\n```\n\n2. **@ syntax:**\n```python\n@my_decorator\ndef my_func():\n    pass\n```\n\n3. **Stacking:**\n- Applied bottom-to-top\n- `@timer @log @validate` means: validate → log → timer\n\n4. **@wraps(func):**\n- Preserves original function's name, docstring\n- From functools module",
              "code": "import time\nfrom functools import wraps\n\n# Simple decorator without arguments\ndef timer_decorator(func):\n    \"\"\"Measures function execution time\"\"\"\n    @wraps(func)  # Preserves original function metadata\n    def wrapper(*args, **kwargs):\n        start = time.time()\n        result = func(*args, **kwargs)\n        end = time.time()\n        print(f\"{func.__name__} took {end - start:.4f} seconds\")\n        return result\n    return wrapper\n\ndef log_decorator(func):\n    \"\"\"Logs function calls\"\"\"\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        print(f\"Calling {func.__name__} with args={args}, kwargs={kwargs}\")\n        result = func(*args, **kwargs)\n        print(f\"{func.__name__} returned: {result}\")\n        return result\n    return wrapper\n\ndef validate_positive(func):\n    \"\"\"Validates that all arguments are positive numbers\"\"\"\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        for arg in args:\n            if isinstance(arg, (int, float)) and arg < 0:\n                raise ValueError(f\"All arguments must be positive, got {arg}\")\n        return func(*args, **kwargs)\n    return wrapper\n\n# Using decorators\nprint(\"=== Timer Decorator ===\")\n\n@timer_decorator\ndef slow_function():\n    \"\"\"Simulates slow operation\"\"\"\n    time.sleep(0.1)\n    return \"Done!\"\n\nresult = slow_function()\nprint(f\"Result: {result}\\n\")\n\nprint(\"=== Log Decorator ===\")\n\n@log_decorator\ndef add(a, b):\n    return a + b\n\nresult = add(5, 3)\nprint()\n\nprint(\"=== Validation Decorator ===\")\n\n@validate_positive\ndef calculate_area(width, height):\n    return width * height\n\nprint(f\"Area (5, 10): {calculate_area(5, 10)}\")\n\ntry:\n    calculate_area(-5, 10)\nexcept ValueError as e:\n    print(f\"Error: {e}\")\n\nprint(\"\\n=== Stacking Decorators ===\")\n\n@timer_decorator\n@log_decorator\n@validate_positive\ndef multiply(a, b):\n    return a * b\n\nprint(\"Calling multiply(4, 7):\")\nresult = multiply(4, 7)\n\nprint(\"\\n=== Without Decorator Syntax ===\")\ndef divide(a, b):\n    return a / b\n\n# Manual decoration (equivalent to @decorator)\ndivide_logged = log_decorator(divide)\nresult = divide_logged(10, 2)",
              "language": "python"
            },
            {
              "type": "ANALOGY",
              "title": "Syntax Breakdown",
              "content": "**Basic decorator pattern:**\n```python\ndef decorator(func):\n    def wrapper(*args, **kwargs):\n        # Do something before\n        result = func(*args, **kwargs)\n        # Do something after\n        return result\n    return wrapper\n\n@decorator\ndef my_function():\n    pass\n```\n\n**Decorator with arguments:**\n```python\ndef repeat(times):\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            for _ in range(times):\n                result = func(*args, **kwargs)\n            return result\n        return wrapper\n    return decorator\n\n@repeat(3)\ndef greet():\n    print(\"Hello!\")\n```\n\n**Class as decorator:**\n```python\nclass CountCalls:\n    def __init__(self, func):\n        self.func = func\n        self.count = 0\n    \n    def __call__(self, *args, **kwargs):\n        self.count += 1\n        print(f\"Call {self.count}\")\n        return self.func(*args, **kwargs)\n\n@CountCalls\ndef function():\n    pass\n```"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example: Decorators with Arguments",
              "content": "**Decorator with arguments pattern:**\n\n```python\ndef decorator_with_args(arg1, arg2):\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            # Use arg1, arg2 here\n            return func(*args, **kwargs)\n        return wrapper\n    return decorator\n```\n\n**Three levels:**\n1. Outer function: takes decorator arguments\n2. Middle function: takes the function to decorate\n3. Inner wrapper: the actual wrapper\n\n**Class-based decorators:**\n- Use `__init__` to receive function\n- Use `__call__` to make instance callable\n- Can maintain state (like call count)",
              "code": "from functools import wraps\nimport time\n\n# Decorator factory (takes arguments)\ndef repeat(times):\n    \"\"\"Repeats function execution N times\"\"\"\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            result = None\n            for i in range(times):\n                print(f\"  Execution {i+1}/{times}\")\n                result = func(*args, **kwargs)\n            return result\n        return wrapper\n    return decorator\n\ndef retry(max_attempts=3, delay=1):\n    \"\"\"Retries function on exception\"\"\"\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            for attempt in range(max_attempts):\n                try:\n                    return func(*args, **kwargs)\n                except Exception as e:\n                    if attempt == max_attempts - 1:\n                        raise\n                    print(f\"Attempt {attempt + 1} failed: {e}. Retrying in {delay}s...\")\n                    time.sleep(delay)\n        return wrapper\n    return decorator\n\ndef cache_result(func):\n    \"\"\"Simple caching decorator\"\"\"\n    cached = {}\n    @wraps(func)\n    def wrapper(*args):\n        if args in cached:\n            print(f\"  Cache hit for {args}\")\n            return cached[args]\n        print(f\"  Computing for {args}\")\n        result = func(*args)\n        cached[args] = result\n        return result\n    return wrapper\n\nprint(\"=== Repeat Decorator ===\")\n\n@repeat(times=3)\ndef greet(name):\n    print(f\"  Hello, {name}!\")\n\ngreet(\"Alice\")\n\nprint(\"\\n=== Retry Decorator ===\")\n\nattempt_count = 0\n\n@retry(max_attempts=3, delay=0.5)\ndef unreliable_function():\n    global attempt_count\n    attempt_count += 1\n    if attempt_count < 3:\n        raise ConnectionError(\"Network error\")\n    return \"Success!\"\n\nresult = unreliable_function()\nprint(f\"Final result: {result}\")\n\nprint(\"\\n=== Cache Decorator ===\")\n\n@cache_result\ndef fibonacci(n):\n    if n < 2:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n\nprint(\"First call:\")\nresult = fibonacci(5)\nprint(f\"fibonacci(5) = {result}\")\n\nprint(\"\\nSecond call (should use cache):\")\nresult = fibonacci(5)\nprint(f\"fibonacci(5) = {result}\")\n\nprint(\"\\n=== Class-Based Decorator ===\")\n\nclass CountCalls:\n    \"\"\"Decorator that counts function calls\"\"\"\n    def __init__(self, func):\n        self.func = func\n        self.count = 0\n        self.__name__ = func.__name__\n    \n    def __call__(self, *args, **kwargs):\n        self.count += 1\n        print(f\"[Call #{self.count}] {self.func.__name__}\")\n        return self.func(*args, **kwargs)\n    \n    def reset_count(self):\n        self.count = 0\n\n@CountCalls\ndef process_data(data):\n    return f\"Processed: {data}\"\n\nprocess_data(\"A\")\nprocess_data(\"B\")\nprocess_data(\"C\")\nprint(f\"Total calls: {process_data.count}\")",
              "language": "python"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "- **Decorators wrap functions** to add functionality without modifying them\n- **@decorator syntax** is shorthand for `func = decorator(func)`\n- **Use @wraps(func)** from functools to preserve function metadata\n- **Pattern: def decorator(func): def wrapper(): return wrapper**\n- **Decorators with arguments** require an extra level (factory pattern)\n- **Stack decorators** by using multiple @ - applied bottom to top\n- **Class-based decorators** use __init__ and __call__\n- **Common uses:** logging, timing, validation, caching, authentication"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "12_01-challenge-4",
              "title": "Interactive Exercise",
              "description": "Create a @benchmark decorator that:\n- Measures execution time\n- Counts function calls\n- Prints results in a formatted way\n- Works with any function",
              "instructions": "Create a @benchmark decorator that:\n- Measures execution time\n- Counts function calls\n- Prints results in a formatted way\n- Works with any function",
              "starterCode": "from functools import wraps\nimport time\n\nclass benchmark:\n    # TODO: Implement __init__ to receive function\n    # TODO: Track call_count and total_time\n    \n    def __init__(self, func):\n        pass\n    \n    # TODO: Implement __call__ to wrap function\n    def __call__(self, *args, **kwargs):\n        pass\n    \n    # TODO: Add method to print stats\n    def print_stats(self):\n        pass\n\n# Test the decorator\n@benchmark\ndef calculate(n):\n    total = sum(range(n))\n    return total\n\n# TODO: Call function multiple times\n# TODO: Print statistics",
              "solution": "",
              "language": "python",
              "testCases": [
                {
                  "description": "Code runs without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use time.time() to measure execution time. Track count in __call__. Store cumulative time."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "12_02",
          "title": "Generators and Iterators",
          "moduleId": "module-12",
          "order": 2,
          "estimatedMinutes": 35,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Concept: One Item at a Time",
              "content": "**Generators = Lazy iterators**\n\n**Think of a streaming service:**\n- **List approach:** Download entire movie first, then watch\n  - Uses lots of memory\n  - Have to wait for full download\n\n- **Generator approach:** Stream one frame at a time\n  - Minimal memory\n  - Start watching immediately\n  - Only load what you need\n\n**Why use generators?**\n\n1. **Memory Efficient** 💾\n   - Don't store all values\n   - Generate on-demand\n   - Perfect for large datasets\n\n2. **Lazy Evaluation** 😴\n   - Only compute when needed\n   - Can represent infinite sequences\n\n3. **Pipeline Processing** ⚡\n   - Chain operations efficiently\n   - Process streams of data\n\n**Key difference:**\n```python\n# List - all at once\ndef get_numbers():\n    return [1, 2, 3, 4, 5]  # All in memory\n\n# Generator - one at a time\ndef get_numbers():\n    yield 1\n    yield 2\n    yield 3\n    yield 4\n    yield 5  # Generated on demand\n```"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example: Generators with yield",
              "content": "**yield keyword:**\n- Pauses function execution\n- Returns value to caller\n- Remembers state\n- Resumes on next iteration\n\n**Generator features:**\n- `next(gen)`: Get next value\n- `gen.send(value)`: Send value to generator\n- `gen.close()`: Stop generator\n- One-time use (exhausted after iteration)\n\n**Memory comparison:**\n```python\nlist(range(1000000))      # 8MB+ memory\n(x for x in range(1000000))  # ~128 bytes\n```",
              "code": "# Regular function returns list (all at once)\ndef count_up_to_list(n):\n    \"\"\"Returns list of numbers - uses memory\"\"\"\n    result = []\n    for i in range(1, n + 1):\n        result.append(i)\n    return result\n\n# Generator function uses yield (one at a time)\ndef count_up_to_generator(n):\n    \"\"\"Yields numbers one by one - memory efficient\"\"\"\n    for i in range(1, n + 1):\n        print(f\"  Generating {i}\")\n        yield i\n\nprint(\"=== List vs Generator ===\")\nprint(\"\\nList (all at once):\")\nlist_result = count_up_to_list(5)\nprint(f\"Type: {type(list_result)}\")\nprint(f\"Values: {list_result}\")\nprint(f\"Can iterate again: {list(list_result)}\")\n\nprint(\"\\nGenerator (one at a time):\")\ngen_result = count_up_to_generator(5)\nprint(f\"Type: {type(gen_result)}\")\nprint(\"Iterating through generator:\")\nfor num in gen_result:\n    print(f\"    Got: {num}\")\n\nprint(\"\\nTrying to iterate again (generator exhausted):\")\nprint(f\"List: {list(gen_result)}\")\n\nprint(\"\\n=== Practical Example: Reading Large File ===\")\n\ndef read_file_list(filename):\n    \"\"\"Reads entire file into memory\"\"\"\n    with open(filename) as f:\n        return f.readlines()  # All lines at once\n\ndef read_file_generator(filename):\n    \"\"\"Yields lines one at a time\"\"\"\n    with open(filename) as f:\n        for line in f:\n            yield line.strip()\n\n# Create test file\nwith open('test.txt', 'w') as f:\n    for i in range(5):\n        f.write(f\"Line {i + 1}\\n\")\n\nprint(\"\\nUsing generator to read file:\")\nfor line in read_file_generator('test.txt'):\n    print(f\"  {line}\")\n\nprint(\"\\n=== Generator with State ===\")\n\ndef fibonacci_generator(limit):\n    \"\"\"Generate Fibonacci sequence\"\"\"\n    a, b = 0, 1\n    count = 0\n    while count < limit:\n        yield a\n        a, b = b, a + b\n        count += 1\n\nprint(\"Fibonacci numbers:\")\nfor num in fibonacci_generator(10):\n    print(num, end=\" \")\nprint()\n\nprint(\"\\n=== Infinite Generator ===\")\n\ndef infinite_counter(start=0):\n    \"\"\"Infinite sequence - only possible with generators!\"\"\"\n    while True:\n        yield start\n        start += 1\n\nprint(\"First 10 from infinite counter:\")\ncounter = infinite_counter(100)\nfor _ in range(10):\n    print(next(counter), end=\" \")\nprint()\n\nprint(\"\\n=== Generator with Send ===\")\n\ndef echo_generator():\n    \"\"\"Generator that can receive values\"\"\"\n    while True:\n        received = yield\n        if received:\n            print(f\"  Received: {received}\")\n            yield f\"Echo: {received}\"\n\necho = echo_generator()\nnext(echo)  # Prime the generator\nresponse = echo.send(\"Hello\")\nprint(f\"  {response}\")\nnext(echo)\nresponse = echo.send(\"World\")\nprint(f\"  {response}\")\n\nimport os\nos.remove('test.txt')",
              "language": "python"
            },
            {
              "type": "ANALOGY",
              "title": "Syntax Breakdown",
              "content": "**Generator function:**\n```python\ndef my_generator():\n    yield 1\n    yield 2\n    yield 3\n\ngen = my_generator()  # Creates generator object\nprint(next(gen))      # 1\nprint(next(gen))      # 2\n```\n\n**Generator expression:**\n```python\n# List comprehension (all at once)\nsquares_list = [x**2 for x in range(10)]\n\n# Generator expression (lazy)\nsquares_gen = (x**2 for x in range(10))\n```\n\n**Iterator protocol:**\n```python\nclass MyIterator:\n    def __iter__(self):\n        return self\n    \n    def __next__(self):\n        # Return next value or raise StopIteration\n        pass\n```\n\n**Using generators:**\n```python\n# In for loop\nfor item in my_generator():\n    print(item)\n\n# With next()\ngen = my_generator()\nvalue = next(gen)\n\n# Convert to list (caution: loads all into memory)\nall_values = list(my_generator())\n```"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example: Generator Expressions and Pipelines",
              "content": "**Generator expressions:**\n- Syntax: `(expression for item in iterable)`\n- Like list comprehension but with ()\n- Lazy evaluation\n- Much more memory efficient\n\n**Generator pipelines:**\n- Chain generators together\n- Each stage processes one item at a time\n- Very efficient for large datasets\n- Data flows through on demand\n\n**Benefits:**\n```python\n# Instead of:\ndata = read_all()           # 1GB in memory\nfiltered = filter_data(data) # 2GB in memory\nresult = process(filtered)   # 3GB in memory\n\n# Do this:\nresult = process(filter_data(read_all()))\n# Only processes one item at a time!\n```",
              "code": "print(\"=== Generator Expression vs List Comprehension ===\")\n\nimport sys\n\n# List comprehension - creates full list\nsquares_list = [x**2 for x in range(1000)]\nprint(f\"List size: {sys.getsizeof(squares_list)} bytes\")\n\n# Generator expression - lazy evaluation\nsquares_gen = (x**2 for x in range(1000))\nprint(f\"Generator size: {sys.getsizeof(squares_gen)} bytes\")\nprint(f\"Memory savings: {sys.getsizeof(squares_list) / sys.getsizeof(squares_gen):.1f}x\\n\")\n\nprint(\"=== Generator Pipeline ===\")\n\ndef read_numbers():\n    \"\"\"Simulate reading data\"\"\"\n    for i in range(1, 11):\n        print(f\"  Reading: {i}\")\n        yield i\n\ndef square(numbers):\n    \"\"\"Square each number\"\"\"\n    for n in numbers:\n        print(f\"  Squaring: {n}\")\n        yield n ** 2\n\ndef filter_large(numbers, threshold=50):\n    \"\"\"Filter numbers above threshold\"\"\"\n    for n in numbers:\n        if n > threshold:\n            print(f\"  Filtering: {n} (kept)\")\n            yield n\n        else:\n            print(f\"  Filtering: {n} (dropped)\")\n\n# Build pipeline (no execution yet!)\nprint(\"Building pipeline (lazy - nothing happens yet)...\")\npipeline = filter_large(square(read_numbers()), threshold=50)\nprint(f\"Pipeline created: {pipeline}\\n\")\n\nprint(\"Executing pipeline (pulling values)...\")\nresults = list(pipeline)\nprint(f\"\\nFinal results: {results}\")\n\nprint(\"\\n=== Practical Example: Data Processing ===\")\n\ndef read_log_lines(filename):\n    \"\"\"Read log file line by line\"\"\"\n    with open(filename) as f:\n        for line in f:\n            yield line.strip()\n\ndef parse_log_line(lines):\n    \"\"\"Parse log lines into structured data\"\"\"\n    for line in lines:\n        parts = line.split('|')\n        if len(parts) >= 3:\n            yield {\n                'timestamp': parts[0],\n                'level': parts[1],\n                'message': parts[2]\n            }\n\ndef filter_errors(logs):\n    \"\"\"Filter only ERROR level logs\"\"\"\n    for log in logs:\n        if log['level'] == 'ERROR':\n            yield log\n\n# Create sample log file\nwith open('app.log', 'w') as f:\n    f.write('2024-01-01 10:00|INFO|Application started\\n')\n    f.write('2024-01-01 10:05|ERROR|Database connection failed\\n')\n    f.write('2024-01-01 10:10|INFO|Retrying connection\\n')\n    f.write('2024-01-01 10:15|ERROR|Authentication failed\\n')\n    f.write('2024-01-01 10:20|INFO|Application stopped\\n')\n\nprint(\"Processing logs (memory efficient):\")\nlog_pipeline = filter_errors(parse_log_line(read_log_lines('app.log')))\n\nfor error in log_pipeline:\n    print(f\"  ERROR at {error['timestamp']}: {error['message']}\")\n\nprint(\"\\n=== Generator with Cleanup ===\")\n\ndef managed_resource():\n    \"\"\"Generator with setup and teardown\"\"\"\n    print(\"  Setting up resource...\")\n    resource = \"Database Connection\"\n    try:\n        for i in range(3):\n            print(f\"  Using resource: {i}\")\n            yield resource\n    finally:\n        print(\"  Cleaning up resource...\")\n\nprint(\"Using generator with cleanup:\")\nfor item in managed_resource():\n    print(f\"  Got: {item}\")\n\nimport os\nos.remove('app.log')",
              "language": "python"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "- **Generators use yield instead of return** - pause and resume execution\n- **Memory efficient** - generate values on demand, don't store all\n- **One-time use** - exhausted after iteration, can't reuse\n- **Generator expressions:** (x for x in iterable) - like list comp with ()\n- **Perfect for large datasets** - process millions of items with minimal memory\n- **Pipeline processing** - chain generators for efficient data transformation\n- **Infinite sequences possible** - while True: yield x\n- **Use next(gen) to get next value** - for loops call this automatically"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "12_02-challenge-4",
              "title": "Interactive Exercise",
              "description": "Create a batched_reader generator that:\n- Reads numbers from 1 to N\n- Yields them in batches of specified size\n- Example: batched_reader(10, batch_size=3) yields [1,2,3], [4,5,6], [7,8,9], [10]",
              "instructions": "Create a batched_reader generator that:\n- Reads numbers from 1 to N\n- Yields them in batches of specified size\n- Example: batched_reader(10, batch_size=3) yields [1,2,3], [4,5,6], [7,8,9], [10]",
              "starterCode": "def batched_reader(n, batch_size=10):\n    \"\"\"Yield numbers in batches\"\"\"\n    # TODO: Implement generator that yields batches\n    pass\n\n# Test your generator\nfor batch in batched_reader(25, batch_size=7):\n    print(f\"Batch: {batch}\")",
              "solution": "",
              "language": "python",
              "testCases": [
                {
                  "description": "Code runs without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use a loop with range(1, n+1). Accumulate items in a list, yield when batch is full, and don't forget the final partial batch."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "12_03",
          "title": "Context Managers",
          "moduleId": "module-12",
          "order": 3,
          "estimatedMinutes": 35,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Concept: Automatic Cleanup",
              "content": "**Context Managers = Guaranteed cleanup**\n\n**Think of borrowing a library book:**\n- ❌ **Without context manager:**\n  ```\n  1. Check out book\n  2. Read it\n  3. Forget to return it!\n  4. Get fined\n  ```\n\n- ✅ **With context manager:**\n  ```\n  1. Auto check-out when you enter library\n  2. Read\n  3. Auto return when you leave\n  4. No fines!\n  ```\n\n**The problem they solve:**\n```python\n# Easy to forget cleanup!\nfile = open('data.txt')\ndata = file.read()\n# Oops, forgot file.close()!\n# File handle stays open\n```\n\n```python\n# Context manager guarantees cleanup\nwith open('data.txt') as file:\n    data = file.read()\n# File automatically closed, even if error!\n```\n\n**Common use cases:**\n1. **File handling** 📁 - Auto close files\n2. **Database connections** 🗄️ - Auto close connections\n3. **Locks** 🔒 - Auto release locks\n4. **Transactions** 💳 - Auto commit/rollback\n5. **Temporary state** ⏱️ - Auto restore state\n\n**Key benefit:** Cleanup happens EVEN IF ERRORS OCCUR!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example: Understanding with Statement",
              "content": "**The `with` statement:**\n\n1. **Calls `__enter__()`:**\n   - Runs setup code\n   - Returns resource (file object)\n\n2. **Executes code block:**\n   - Your code runs\n   - Uses the resource\n\n3. **Calls `__exit__()`:**\n   - Runs cleanup code\n   - ALWAYS executes, even on errors\n   - Receives exception info if error occurred\n\n**Multiple context managers:**\n```python\n# Old way\nwith open('a.txt') as f1:\n    with open('b.txt') as f2:\n        ...\n\n# Modern way (Python 3.1+)\nwith open('a.txt') as f1, open('b.txt') as f2:\n    ...\n```",
              "code": "print(\"=== Without Context Manager ===\")\n\n# Manual resource management (error-prone)\ndef read_file_manual(filename):\n    file = None\n    try:\n        file = open(filename, 'r')\n        content = file.read()\n        return content\n    except Exception as e:\n        print(f\"Error: {e}\")\n        return None\n    finally:\n        if file:\n            file.close()\n            print(\"File closed manually\")\n\n# Create test file\nwith open('test.txt', 'w') as f:\n    f.write('Hello, World!')\n\nresult = read_file_manual('test.txt')\nprint(f\"Content: {result}\\n\")\n\nprint(\"=== With Context Manager ===\")\n\n# Clean and simple\ndef read_file_context(filename):\n    with open(filename, 'r') as file:\n        content = file.read()\n        return content\n    # File automatically closed here!\n\nresult = read_file_context('test.txt')\nprint(f\"Content: {result}\")\nprint(\"File automatically closed\\n\")\n\nprint(\"=== Context Manager with Error ===\")\n\ntry:\n    with open('test.txt', 'r') as file:\n        content = file.read()\n        print(f\"Read: {content}\")\n        raise ValueError(\"Simulated error!\")\n        print(\"This never executes\")\nexcept ValueError as e:\n    print(f\"Caught: {e}\")\n    print(\"File was still closed automatically!\\n\")\n\nprint(\"=== Multiple Context Managers ===\")\n\n# Create two files\nwith open('input.txt', 'w') as f:\n    f.write('Line 1\\nLine 2\\nLine 3')\n\n# Use multiple context managers\nwith open('input.txt', 'r') as infile, open('output.txt', 'w') as outfile:\n    for line in infile:\n        outfile.write(line.upper())\n    print(\"Copied and uppercased to output.txt\")\n# Both files automatically closed\n\nwith open('output.txt', 'r') as f:\n    print(f\"Output: {f.read()}\")\n\nprint(\"\\n=== What Happens Behind the Scenes ===\")\n\nclass FileSimulator:\n    \"\"\"Simulates what happens with context manager\"\"\"\n    def __init__(self, filename):\n        self.filename = filename\n        self.file = None\n    \n    def __enter__(self):\n        print(f\"  __enter__ called: Opening {self.filename}\")\n        self.file = open(self.filename, 'r')\n        return self.file\n    \n    def __exit__(self, exc_type, exc_val, exc_tb):\n        print(f\"  __exit__ called: Closing {self.filename}\")\n        if self.file:\n            self.file.close()\n        if exc_type:\n            print(f\"  Exception occurred: {exc_type.__name__}: {exc_val}\")\n        return False  # Don't suppress exceptions\n\nprint(\"Using custom FileSimulator:\")\nwith FileSimulator('test.txt') as f:\n    content = f.read()\n    print(f\"  Read content: {content}\")\nprint(\"  Back outside context\\n\")\n\nimport os\nfor filename in ['test.txt', 'input.txt', 'output.txt']:\n    if os.path.exists(filename):\n        os.remove(filename)",
              "language": "python"
            },
            {
              "type": "ANALOGY",
              "title": "Syntax Breakdown",
              "content": "**Basic context manager usage:**\n```python\nwith expression as variable:\n    # Use variable\n    pass\n# Cleanup happened automatically\n```\n\n**Creating context manager (class-based):**\n```python\nclass MyContext:\n    def __enter__(self):\n        # Setup\n        return resource\n    \n    def __exit__(self, exc_type, exc_val, exc_tb):\n        # Cleanup\n        return False  # Don't suppress exceptions\n\nwith MyContext() as resource:\n    # Use resource\n    pass\n```\n\n**__exit__ parameters:**\n- `exc_type`: Exception class (or None)\n- `exc_val`: Exception instance (or None)\n- `exc_tb`: Traceback (or None)\n- Return True to suppress exception\n- Return False/None to propagate exception\n\n**Multiple managers:**\n```python\nwith context1() as c1, context2() as c2:\n    # Use both\n    pass\n```"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example: Custom Context Managers",
              "content": "**Two ways to create context managers:**\n\n**1. Class-based (more control):**\n```python\nclass MyContext:\n    def __enter__(self): ...\n    def __exit__(self, ...): ...\n```\n- More verbose\n- Full control over behavior\n- Can maintain complex state\n\n**2. Function-based with @contextmanager:**\n```python\n@contextmanager\ndef my_context():\n    # Setup\n    yield resource\n    # Cleanup\n```\n- Simpler syntax\n- Code before yield = __enter__\n- Code after yield = __exit__\n- Must use try/finally for proper cleanup\n\n**Suppressing exceptions:**\n- Return True from __exit__ to suppress\n- Use carefully - can hide bugs!",
              "code": "import time\nfrom contextlib import contextmanager\n\nprint(\"=== Class-Based Context Manager ===\")\n\nclass Timer:\n    \"\"\"Context manager for timing code blocks\"\"\"\n    \n    def __init__(self, name=\"Code block\"):\n        self.name = name\n        self.start_time = None\n        self.elapsed = None\n    \n    def __enter__(self):\n        print(f\"Starting timer: {self.name}\")\n        self.start_time = time.time()\n        return self\n    \n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.elapsed = time.time() - self.start_time\n        print(f\"Finished: {self.name} took {self.elapsed:.4f}s\")\n        return False\n\nwith Timer(\"Sleep test\"):\n    time.sleep(0.1)\n\nprint()\n\nclass DatabaseConnection:\n    \"\"\"Simulates database connection manager\"\"\"\n    \n    def __init__(self, db_name):\n        self.db_name = db_name\n        self.connected = False\n    \n    def __enter__(self):\n        print(f\"  Connecting to {self.db_name}...\")\n        self.connected = True\n        print(f\"  Connected!\")\n        return self\n    \n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if exc_type:\n            print(f\"  Rolling back due to error: {exc_val}\")\n        else:\n            print(f\"  Committing changes...\")\n        print(f\"  Closing connection to {self.db_name}\")\n        self.connected = False\n        return False\n    \n    def execute(self, query):\n        if not self.connected:\n            raise RuntimeError(\"Not connected!\")\n        print(f\"  Executing: {query}\")\n        return \"Success\"\n\nprint(\"\\nSuccessful transaction:\")\nwith DatabaseConnection(\"users.db\") as db:\n    db.execute(\"SELECT * FROM users\")\n    db.execute(\"UPDATE users SET active=1\")\n\nprint(\"\\nTransaction with error:\")\ntry:\n    with DatabaseConnection(\"users.db\") as db:\n        db.execute(\"SELECT * FROM users\")\n        raise ValueError(\"Something went wrong!\")\n        db.execute(\"This never runs\")\nexcept ValueError:\n    print(\"  Error handled\\n\")\n\nprint(\"=== Function-Based with @contextmanager ===\")\n\n@contextmanager\ndef timer(name):\n    \"\"\"Function-based timer context manager\"\"\"\n    print(f\"Starting: {name}\")\n    start = time.time()\n    try:\n        yield  # Code block runs here\n    finally:\n        elapsed = time.time() - start\n        print(f\"Finished: {name} took {elapsed:.4f}s\")\n\nwith timer(\"Quick operation\"):\n    time.sleep(0.05)\n    print(\"  Doing work...\")\n\nprint()\n\n@contextmanager\ndef temporary_directory_change(path):\n    \"\"\"Temporarily change directory\"\"\"\n    import os\n    original = os.getcwd()\n    print(f\"  Changing to: {path}\")\n    os.chdir(path)\n    try:\n        yield original\n    finally:\n        print(f\"  Restoring to: {original}\")\n        os.chdir(original)\n\nprint(\"Current directory example:\")\nimport os\nprint(f\"Before: {os.getcwd()}\")\nwith temporary_directory_change('/tmp'):\n    print(f\"Inside: {os.getcwd()}\")\nprint(f\"After: {os.getcwd()}\")\n\nprint(\"\\n=== Suppressing Exceptions ===\")\n\nclass IgnoreErrors:\n    \"\"\"Context manager that suppresses exceptions\"\"\"\n    \n    def __init__(self, *exception_types):\n        self.exception_types = exception_types or (Exception,)\n    \n    def __enter__(self):\n        return self\n    \n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if exc_type and issubclass(exc_type, self.exception_types):\n            print(f\"  Suppressed: {exc_type.__name__}: {exc_val}\")\n            return True  # Suppress the exception\n        return False\n\nprint(\"Suppressing ValueError:\")\nwith IgnoreErrors(ValueError):\n    print(\"  Before error\")\n    raise ValueError(\"This will be suppressed\")\n    print(\"  This won't run\")\nprint(\"  Continued after context\\n\")\n\nprint(\"Not suppressing TypeError:\")\ntry:\n    with IgnoreErrors(ValueError):\n        print(\"  Before error\")\n        raise TypeError(\"This will NOT be suppressed\")\nexcept TypeError as e:\n    print(f\"  Caught: {e}\")",
              "language": "python"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "- **Context managers guarantee cleanup** - Even if exceptions occur\n- **with statement calls __enter__ and __exit__** - Automatic resource management\n- **Two ways to create:** Class-based or @contextmanager decorator\n- **@contextmanager is simpler** - Code before yield = setup, after = cleanup\n- **__exit__ receives exception info** - Can suppress by returning True\n- **Always use try/finally** - Ensures cleanup code runs\n- **Common uses:** files, database connections, locks, temporary state\n- **Multiple contexts:** with ctx1() as a, ctx2() as b: ..."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "12_03-challenge-4",
              "title": "Interactive Exercise",
              "description": "Create a ListModifier context manager that:\n- Accepts a list as input\n- Backs up the list on entry\n- Allows modifications in the context\n- Restores the original list if an exception occurs\n- Keeps modifications if no exception",
              "instructions": "Create a ListModifier context manager that:\n- Accepts a list as input\n- Backs up the list on entry\n- Allows modifications in the context\n- Restores the original list if an exception occurs\n- Keeps modifications if no exception",
              "starterCode": "from contextlib import contextmanager\n\n@contextmanager\ndef list_modifier(lst):\n    # TODO: Backup the list\n    # TODO: Yield to allow modifications\n    # TODO: If exception, restore backup\n    # TODO: If no exception, keep changes\n    pass\n\n# Test your context manager\nmy_list = [1, 2, 3]\n\nprint(f\"Original: {my_list}\")\n\n# Successful modification\nwith list_modifier(my_list):\n    my_list.append(4)\n    my_list.append(5)\n\nprint(f\"After success: {my_list}\")\n\n# Failed modification (should restore)\ntry:\n    with list_modifier(my_list):\n        my_list.append(6)\n        raise ValueError(\"Oops!\")\nexcept ValueError:\n    pass\n\nprint(f\"After failure: {my_list}\")",
              "solution": "",
              "language": "python",
              "testCases": [
                {
                  "description": "Code runs without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use list.copy() to backup. In the except block, restore the list using list[:] = backup to modify in-place."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "12_04",
          "title": "Advanced Comprehensions",
          "moduleId": "module-12",
          "order": 4,
          "estimatedMinutes": 30,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Concept: Compact List Creation",
              "content": "**Comprehensions = Concise collection creation**\n\n**Think of a shopping list:**\n\n❌ **Traditional approach (loop):**\n```python\nshopping_list = []\nfor item in all_items:\n    if item.price < 10:\n        shopping_list.append(item.name)\n```\n\n✅ **Comprehension (one line):**\n```python\nshopping_list = [item.name for item in all_items if item.price < 10]\n```\n\n**Types of comprehensions:**\n\n1. **List comprehension** `[...]`\n   ```python\n   squares = [x**2 for x in range(10)]\n   ```\n\n2. **Dictionary comprehension** `{key: value}`\n   ```python\n   squares_dict = {x: x**2 for x in range(10)}\n   ```\n\n3. **Set comprehension** `{value}`\n   ```python\n   unique_lengths = {len(word) for word in words}\n   ```\n\n4. **Generator expression** `(...)`\n   ```python\n   squares_gen = (x**2 for x in range(10))\n   ```\n\n**When to use comprehensions:**\n- ✅ Simple transformations\n- ✅ Filtering collections\n- ✅ Creating new collections\n- ❌ Complex logic (use regular loops)\n- ❌ Side effects (printing, file I/O)\n\n**Benefits:**\n- More readable (when simple)\n- Often faster\n- More Pythonic\n- Less code"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example: List Comprehensions",
              "content": "**List comprehension syntax:**\n\n**Basic:**\n```python\n[expression for item in iterable]\n```\n\n**With filter:**\n```python\n[expression for item in iterable if condition]\n```\n\n**With conditional expression:**\n```python\n[expr1 if condition else expr2 for item in iterable]\n```\n\n**Nested:**\n```python\n[expression for outer in iterable1 for inner in iterable2]\n# Same as:\nfor outer in iterable1:\n    for inner in iterable2:\n        expression\n```\n\n**Key difference:**\n- Filter: `if` at end (no else)\n- Transform: `if/else` before `for`",
              "code": "print(\"=== Basic List Comprehension ===\")\n\n# Traditional loop\nsquares_loop = []\nfor x in range(10):\n    squares_loop.append(x**2)\nprint(f\"Loop: {squares_loop}\")\n\n# List comprehension\nsquares_comp = [x**2 for x in range(10)]\nprint(f\"Comprehension: {squares_comp}\")\n\nprint(\"\\n=== Comprehension with Condition (Filter) ===\")\n\n# Only even numbers\nevens = [x for x in range(20) if x % 2 == 0]\nprint(f\"Evens: {evens}\")\n\n# Only positive numbers\nnumbers = [-5, -3, -1, 0, 2, 4, 6]\npositive = [x for x in numbers if x > 0]\nprint(f\"Positive: {positive}\")\n\n# Words longer than 3 characters\nwords = ['a', 'the', 'cat', 'in', 'hat', 'python', 'is', 'cool']\nlong_words = [word for word in words if len(word) > 3]\nprint(f\"Long words: {long_words}\")\n\nprint(\"\\n=== Comprehension with Transformation ===\")\n\n# Uppercase all words\nupper_words = [word.upper() for word in words]\nprint(f\"Uppercase: {upper_words}\")\n\n# Length of each word\nword_lengths = [len(word) for word in words]\nprint(f\"Lengths: {word_lengths}\")\n\n# Complex transformation\nusers = ['alice', 'bob', 'charlie']\nuser_info = [f\"User: {name.title()} ({len(name)} chars)\" for name in users]\nprint(f\"User info: {user_info}\")\n\nprint(\"\\n=== Comprehension with if-else (Transform) ===\")\n\n# Classify numbers as even or odd\nnumbers = [1, 2, 3, 4, 5, 6]\nclassified = ['even' if x % 2 == 0 else 'odd' for x in numbers]\nprint(f\"Classified: {classified}\")\n\n# Cap values at 100\nscores = [85, 92, 105, 78, 110, 88]\ncapped = [score if score <= 100 else 100 for score in scores]\nprint(f\"Capped scores: {capped}\")\n\n# Absolute values using conditional\nvalues = [-5, 3, -2, 8, -1]\nabsolute = [x if x >= 0 else -x for x in values]\nprint(f\"Absolute: {absolute}\")\n\nprint(\"\\n=== Multiple Conditions ===\")\n\n# Filter: divisible by 2 AND divisible by 3\nnumbers = range(1, 31)\ndiv_by_6 = [x for x in numbers if x % 2 == 0 if x % 3 == 0]\nprint(f\"Divisible by 6: {div_by_6}\")\n\n# Same as: if x % 2 == 0 and x % 3 == 0\ndiv_by_6_alt = [x for x in numbers if x % 2 == 0 and x % 3 == 0]\nprint(f\"Alternative: {div_by_6_alt}\")\n\nprint(\"\\n=== Nested Loops in Comprehension ===\")\n\n# Cartesian product\ncolors = ['red', 'blue']\nsizes = ['S', 'M', 'L']\ncombinations = [f\"{color}-{size}\" for color in colors for size in sizes]\nprint(f\"Combinations: {combinations}\")\n\n# Flatten nested list\nnested = [[1, 2], [3, 4], [5, 6]]\nflattened = [num for sublist in nested for num in sublist]\nprint(f\"Flattened: {flattened}\")\n\n# Matrix operations\nmatrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\n# Get all elements\nall_elements = [num for row in matrix for num in row]\nprint(f\"All elements: {all_elements}\")\n\n# Transpose matrix\ntransposed = [[row[i] for row in matrix] for i in range(3)]\nprint(f\"Transposed: {transposed}\")",
              "language": "python"
            },
            {
              "type": "ANALOGY",
              "title": "Syntax Breakdown",
              "content": "**List comprehension patterns:**\n\n```python\n# 1. Basic transformation\n[x*2 for x in numbers]\n\n# 2. Filter only\n[x for x in numbers if x > 0]\n\n# 3. Transform with filter\n[x*2 for x in numbers if x > 0]\n\n# 4. Conditional transform (no filter)\n[x if x > 0 else 0 for x in numbers]\n\n# 5. Conditional transform AND filter\n[x*2 if x > 10 else x for x in numbers if x != 0]\n```\n\n**Dictionary comprehension:**\n```python\n{key: value for item in iterable}\n{x: x**2 for x in range(5)}\n# {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}\n```\n\n**Set comprehension:**\n```python\n{expression for item in iterable}\n{len(word) for word in words}\n# {3, 5, 6}  # Unique lengths\n```\n\n**When NOT to use:**\n```python\n# Bad - too complex\n[process(x, y) for x in data if validate(x) \n for y in x.items if y.type == 'special' \n if check(y)]\n\n# Better - use regular loop\nresults = []\nfor x in data:\n    if validate(x):\n        for y in x.items:\n            if y.type == 'special' and check(y):\n                results.append(process(x, y))\n```"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example: Dict and Set Comprehensions",
              "content": "**Dictionary comprehension syntax:**\n```python\n{key_expr: value_expr for item in iterable}\n{key_expr: value_expr for item in iterable if condition}\n```\n\n**Set comprehension syntax:**\n```python\n{expression for item in iterable}\n{expression for item in iterable if condition}\n```\n\n**Practical patterns:**\n\n**1. Create lookup tables:**\n```python\nlookup = {item.id: item for item in items}\n```\n\n**2. Invert dictionaries:**\n```python\ninverted = {v: k for k, v in orig.items()}\n```\n\n**3. Filter dictionaries:**\n```python\nfiltered = {k: v for k, v in d.items() if condition}\n```\n\n**4. Get unique values:**\n```python\nunique = {item.property for item in items}\n```",
              "code": "print(\"=== Dictionary Comprehension ===\")\n\n# Create dict from range\nsquares_dict = {x: x**2 for x in range(6)}\nprint(f\"Squares: {squares_dict}\")\n\n# From two lists\nnames = ['Alice', 'Bob', 'Charlie']\nages = [25, 30, 35]\npeople = {name: age for name, age in zip(names, ages)}\nprint(f\"People: {people}\")\n\n# Swap keys and values\noriginal = {'a': 1, 'b': 2, 'c': 3}\nswapped = {value: key for key, value in original.items()}\nprint(f\"Swapped: {swapped}\")\n\n# Filter dictionary\nscores = {'Alice': 95, 'Bob': 67, 'Charlie': 89, 'David': 45}\npassing = {name: score for name, score in scores.items() if score >= 70}\nprint(f\"Passing: {passing}\")\n\n# Transform values\ntemps_celsius = {'morning': 20, 'noon': 28, 'evening': 22}\ntemps_fahrenheit = {time: (temp * 9/5) + 32 \n                    for time, temp in temps_celsius.items()}\nprint(f\"Fahrenheit: {temps_fahrenheit}\")\n\nprint(\"\\n=== Set Comprehension ===\")\n\n# Unique squares\nnumbers = [1, 2, 3, 4, 5, 1, 2, 3]\nunique_squares = {x**2 for x in numbers}\nprint(f\"Unique squares: {unique_squares}\")\n\n# Unique word lengths\nsentence = \"the quick brown fox jumps over the lazy dog\"\nword_lengths = {len(word) for word in sentence.split()}\nprint(f\"Unique word lengths: {sorted(word_lengths)}\")\n\n# Unique first letters\nwords = ['apple', 'banana', 'apricot', 'blueberry', 'cherry']\nfirst_letters = {word[0] for word in words}\nprint(f\"First letters: {sorted(first_letters)}\")\n\nprint(\"\\n=== Practical Examples ===\")\n\n# Count word frequency\ntext = \"python is great and python is fun and python is powerful\"\nwords = text.split()\nword_count = {word: words.count(word) for word in set(words)}\nprint(f\"Word frequency: {word_count}\")\n\n# Group by property\nstudents = [\n    {'name': 'Alice', 'grade': 'A'},\n    {'name': 'Bob', 'grade': 'B'},\n    {'name': 'Charlie', 'grade': 'A'},\n    {'name': 'David', 'grade': 'C'},\n    {'name': 'Eve', 'grade': 'B'}\n]\n\n# Group names by grade\nby_grade = {}\nfor student in students:\n    grade = student['grade']\n    if grade not in by_grade:\n        by_grade[grade] = []\n    by_grade[grade].append(student['name'])\n\nprint(f\"\\nGrouped by grade: {by_grade}\")\n\n# Create lookup table\nproducts = [\n    {'id': 1, 'name': 'Widget', 'price': 9.99},\n    {'id': 2, 'name': 'Gadget', 'price': 19.99},\n    {'id': 3, 'name': 'Doohickey', 'price': 14.99}\n]\n\nproduct_lookup = {p['id']: p for p in products}\nprint(f\"\\nProduct lookup:\")\nfor pid, product in product_lookup.items():\n    print(f\"  {pid}: {product['name']} - ${product['price']}\")\n\n# Multi-level filtering and transformation\ndata = [\n    {'name': 'file1.py', 'size': 1024},\n    {'name': 'file2.txt', 'size': 2048},\n    {'name': 'file3.py', 'size': 512},\n    {'name': 'file4.txt', 'size': 128}\n]\n\n# Python files with size in KB\npy_files = {f['name']: f['size'] / 1024 \n            for f in data \n            if f['name'].endswith('.py')}\nprint(f\"\\nPython files (KB): {py_files}\")\n\nprint(\"\\n=== Combining Comprehensions ===\")\n\n# Matrix to dict of dicts\nmatrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\n\n# Create dict: {row_index: {col_index: value}}\nmatrix_dict = {i: {j: val for j, val in enumerate(row)} \n               for i, row in enumerate(matrix)}\nprint(f\"Matrix as dict:\")\nfor row_idx, row_dict in matrix_dict.items():\n    print(f\"  Row {row_idx}: {row_dict}\")\n\n# Nested dict comprehension: grade statistics\ngrades = {\n    'Math': [85, 90, 78, 92],\n    'Science': [88, 76, 95, 84],\n    'English': [92, 89, 91, 88]\n}\n\nstats = {\n    subject: {\n        'avg': sum(scores) / len(scores),\n        'max': max(scores),\n        'min': min(scores)\n    }\n    for subject, scores in grades.items()\n}\n\nprint(f\"\\nGrade statistics:\")\nfor subject, stat in stats.items():\n    print(f\"  {subject}: avg={stat['avg']:.1f}, max={stat['max']}, min={stat['min']}\")",
              "language": "python"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "- **List comprehension:** [expr for item in iterable if condition]\n- **Dict comprehension:** {key: value for item in iterable}\n- **Set comprehension:** {expr for item in iterable} - auto deduplicates\n- **Filter at end:** if condition (no else)\n- **Transform before for:** expr1 if cond else expr2\n- **Nested comprehensions:** for x in a for y in b (reads left to right)\n- **Use for simple operations** - Complex logic needs regular loops\n- **More Pythonic and often faster** than equivalent loops"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "12_04-challenge-4",
              "title": "Interactive Exercise",
              "description": "Given a list of transactions, create:\n1. Dict of total spending per category (dict comprehension)\n2. Set of unique categories (set comprehension)\n3. List of transaction descriptions for amounts > 50 (list comprehension)",
              "instructions": "Given a list of transactions, create:\n1. Dict of total spending per category (dict comprehension)\n2. Set of unique categories (set comprehension)\n3. List of transaction descriptions for amounts > 50 (list comprehension)",
              "starterCode": "transactions = [\n    {'amount': 45.50, 'category': 'food', 'desc': 'Grocery shopping'},\n    {'amount': 12.00, 'category': 'transport', 'desc': 'Bus fare'},\n    {'amount': 78.90, 'category': 'food', 'desc': 'Restaurant'},\n    {'amount': 100.00, 'category': 'entertainment', 'desc': 'Concert'},\n    {'amount': 25.00, 'category': 'transport', 'desc': 'Taxi'},\n    {'amount': 55.00, 'category': 'food', 'desc': 'Takeout'}\n]\n\n# TODO: Create dict of total per category\ntotals_by_category = {}\n\n# TODO: Create set of unique categories\ncategories = set()\n\n# TODO: Create list of descriptions for amounts > 50\nlarge_transactions = []\n\nprint(f\"Totals: {totals_by_category}\")\nprint(f\"Categories: {categories}\")\nprint(f\"Large: {large_transactions}\")",
              "solution": "",
              "language": "python",
              "testCases": [
                {
                  "description": "Code runs without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "For totals: group by category and sum amounts. Use sum() with a generator expression."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "12_05",
          "title": "Type Hints and Annotations",
          "moduleId": "module-12",
          "order": 5,
          "estimatedMinutes": 30,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Concept: Documentation in Code",
              "content": "**Type Hints = Code documentation + Error prevention**\n\n**Think of labeled containers:**\n\n❌ **Without type hints:**\n```python\ndef process(data, flag):\n    # What type is data? String? List?\n    # What's flag? Boolean? String?\n    pass\n```\n\n✅ **With type hints:**\n```python\ndef process(data: list[str], flag: bool) -> None:\n    # Clear! data is list of strings\n    # flag is boolean\n    # Returns nothing\n    pass\n```\n\n**Benefits:**\n\n1. **Better documentation** 📖\n   - See expected types at a glance\n   - No need to guess\n\n2. **IDE support** 🚀\n   - Better autocomplete\n   - Catch errors before running\n\n3. **Error prevention** 🛡️\n   - Type checkers find bugs\n   - Before code runs!\n\n4. **Code maintainability** 🔧\n   - Easier for others to understand\n   - Refactoring is safer\n\n**Important:** Type hints are **optional** and **not enforced at runtime**!\n- Python doesn't check types when running\n- Use tools like mypy for type checking\n- Mainly for development/tooling\n\n**Common types:**\n- `int`, `float`, `str`, `bool`\n- `list`, `dict`, `set`, `tuple`\n- `Optional[type]` - can be None\n- `Union[type1, type2]` - can be either\n- `Any` - any type"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example: Basic Type Hints",
              "content": "**Type hint syntax:**\n\n**Function annotations:**\n```python\ndef function(param: type) -> return_type:\n    pass\n```\n\n**Variable annotations:**\n```python\nvariable: type = value\n```\n\n**Important notes:**\n\n1. **Not enforced at runtime:**\n   ```python\n   def add(a: int, b: int) -> int:\n       return a + b\n   \n   add(\"hello\", \"world\")  # Works! No error at runtime\n   ```\n\n2. **Need type checker:**\n   - Use `mypy` or similar tool\n   - Checks types before running\n   - IDE integration\n\n3. **Modern syntax (Python 3.10+):**\n   ```python\n   # Old\n   Optional[str]  → str | None\n   Union[int, str] → int | str\n   ```",
              "code": "print(\"=== Basic Type Hints ===\")\n\n# Simple function with type hints\ndef greet(name: str) -> str:\n    \"\"\"Return a greeting message\"\"\"\n    return f\"Hello, {name}!\"\n\nresult = greet(\"Alice\")\nprint(result)\n\n# Multiple parameters\ndef add_numbers(a: int, b: int) -> int:\n    \"\"\"Add two integers\"\"\"\n    return a + b\n\nprint(f\"Sum: {add_numbers(5, 3)}\")\n\n# Default values with type hints\ndef create_user(name: str, age: int = 18, active: bool = True) -> dict:\n    \"\"\"Create user dictionary\"\"\"\n    return {'name': name, 'age': age, 'active': active}\n\nuser = create_user(\"Bob\", 25)\nprint(f\"User: {user}\")\n\nprint(\"\\n=== Collection Type Hints ===\")\n\n# List of specific type\ndef process_names(names: list[str]) -> list[str]:\n    \"\"\"Convert names to uppercase\"\"\"\n    return [name.upper() for name in names]\n\nnames = [\"alice\", \"bob\", \"charlie\"]\nprint(f\"Uppercase: {process_names(names)}\")\n\n# Dictionary with type hints\ndef count_words(text: str) -> dict[str, int]:\n    \"\"\"Count word frequency\"\"\"\n    words = text.split()\n    return {word: words.count(word) for word in set(words)}\n\nresult = count_words(\"hello world hello\")\nprint(f\"Word count: {result}\")\n\n# Tuple with specific types\ndef get_user_info(user_id: int) -> tuple[str, int, str]:\n    \"\"\"Return (name, age, email)\"\"\"\n    return (\"Alice\", 25, \"alice@example.com\")\n\nname, age, email = get_user_info(1)\nprint(f\"User: {name}, {age}, {email}\")\n\nprint(\"\\n=== Optional and None ===\")\n\nfrom typing import Optional\n\n# Optional means \"can be None\"\ndef find_user(user_id: int) -> Optional[dict]:\n    \"\"\"Find user by ID, return None if not found\"\"\"\n    if user_id == 1:\n        return {'id': 1, 'name': 'Alice'}\n    return None\n\nuser = find_user(1)\nprint(f\"Found: {user}\")\n\nuser = find_user(999)\nprint(f\"Not found: {user}\")\n\n# Modern Python 3.10+ can use | None\ndef find_product(product_id: int) -> dict | None:\n    \"\"\"Find product, None if not found\"\"\"\n    return None\n\nprint(\"\\n=== Union Types ===\")\n\nfrom typing import Union\n\n# Can be multiple types\ndef process_id(user_id: Union[int, str]) -> str:\n    \"\"\"Accept int or string ID\"\"\"\n    return f\"ID: {user_id}\"\n\nprint(process_id(123))\nprint(process_id(\"ABC123\"))\n\n# Modern Python 3.10+ can use |\ndef format_value(value: int | float | str) -> str:\n    \"\"\"Format any of these types\"\"\"\n    return f\"Value: {value}\"\n\nprint(format_value(42))\nprint(format_value(3.14))\nprint(format_value(\"text\"))\n\nprint(\"\\n=== Variable Annotations ===\")\n\n# Annotate variables\nname: str = \"Alice\"\nage: int = 25\nscores: list[int] = [85, 90, 92]\nconfig: dict[str, bool] = {'debug': True, 'verbose': False}\n\nprint(f\"Name: {name}, Age: {age}\")\nprint(f\"Scores: {scores}\")\nprint(f\"Config: {config}\")\n\n# Type hints don't prevent wrong types at runtime!\nname = 123  # No error! Type hints are not enforced\nprint(f\"Name is now: {name} (still works, but type checkers would complain)\")",
              "language": "python"
            },
            {
              "type": "ANALOGY",
              "title": "Syntax Breakdown",
              "content": "**Basic types:**\n```python\ndef func(x: int, y: str, z: bool) -> float:\n    pass\n```\n\n**Collections:**\n```python\n# Old style (typing module)\nfrom typing import List, Dict, Set, Tuple\nlist[str]     # Python 3.9+\nList[str]     # Older, still works\n\ndict[str, int]\nDict[str, int]\n\nset[int]\nSet[int]\n\ntuple[str, int, bool]  # Fixed size\nTuple[str, int, bool]\n```\n\n**Optional and Union:**\n```python\nfrom typing import Optional, Union\n\n# Can be None\nOptional[str]  # Same as Union[str, None]\nstr | None     # Python 3.10+\n\n# Multiple types\nUnion[int, str]\nint | str      # Python 3.10+\n```\n\n**Any and None:**\n```python\nfrom typing import Any\n\nAny          # Any type allowed\nNone         # Returns nothing\nvoid         # NOT valid in Python, use None\n```\n\n**Callable (function types):**\n```python\nfrom typing import Callable\n\n# Function that takes (int, str) and returns bool\nCallable[[int, str], bool]\n```"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example: Advanced Type Hints",
              "content": "**Advanced type hint concepts:**\n\n**1. Any:**\n- Accepts any type\n- Opts out of type checking\n- Use sparingly\n\n**2. Callable:**\n```python\nCallable[[arg1_type, arg2_type], return_type]\nCallable[[], None]  # No args, no return\n```\n\n**3. Type aliases:**\n```python\nUserId = int\nUserDict = dict[str, Any]\n```\n\n**4. TypeVar (generics):**\n```python\nT = TypeVar('T')\ndef func(x: T) -> T:  # Same type in and out\n    return x\n```\n\n**5. Self-referencing:**\n```python\nclass Node:\n    def get_parent(self) -> 'Node | None':\n        ...\n```\nUse quotes for forward references\n\n**Type checking tools:**\n- mypy: `mypy script.py`\n- pyright: Built into VS Code\n- pyre: Facebook's type checker",
              "code": "from typing import Any, Callable, TypeVar, Generic\n\nprint(\"=== Any Type ===\")\n\ndef process_data(data: Any) -> Any:\n    \"\"\"Accept and return any type\"\"\"\n    return data\n\nprint(process_data(123))\nprint(process_data(\"text\"))\nprint(process_data([1, 2, 3]))\n\nprint(\"\\n=== Callable (Function) Types ===\")\n\ndef apply_operation(value: int, operation: Callable[[int], int]) -> int:\n    \"\"\"Apply a function to a value\"\"\"\n    return operation(value)\n\ndef double(x: int) -> int:\n    return x * 2\n\ndef square(x: int) -> int:\n    return x ** 2\n\nprint(f\"Double 5: {apply_operation(5, double)}\")\nprint(f\"Square 5: {apply_operation(5, square)}\")\n\n# Lambda with type hints (in context)\nresult = apply_operation(10, lambda x: x + 1)\nprint(f\"Add 1 to 10: {result}\")\n\nprint(\"\\n=== Type Aliases ===\")\n\n# Create type aliases for complex types\nVector = list[float]\nMatrix = list[list[float]]\nJSONDict = dict[str, Any]\n\ndef add_vectors(v1: Vector, v2: Vector) -> Vector:\n    \"\"\"Add two vectors\"\"\"\n    return [a + b for a, b in zip(v1, v2)]\n\nvec1: Vector = [1.0, 2.0, 3.0]\nvec2: Vector = [4.0, 5.0, 6.0]\nresult = add_vectors(vec1, vec2)\nprint(f\"Vector sum: {result}\")\n\nprint(\"\\n=== Class Type Hints ===\")\n\nclass User:\n    def __init__(self, name: str, age: int):\n        self.name: str = name\n        self.age: int = age\n    \n    def get_info(self) -> str:\n        \"\"\"Return user info\"\"\"\n        return f\"{self.name} ({self.age})\"\n    \n    @classmethod\n    def from_dict(cls, data: dict[str, Any]) -> 'User':\n        \"\"\"Create User from dictionary\"\"\"\n        return cls(data['name'], data['age'])\n    \n    def is_adult(self) -> bool:\n        \"\"\"Check if user is adult\"\"\"\n        return self.age >= 18\n\nuser = User(\"Alice\", 25)\nprint(user.get_info())\n\nuser2 = User.from_dict({'name': 'Bob', 'age': 30})\nprint(f\"Is Bob adult? {user2.is_adult()}\")\n\nprint(\"\\n=== Generic Types ===\")\n\nT = TypeVar('T')  # Generic type variable\n\ndef get_first(items: list[T]) -> T | None:\n    \"\"\"Get first item from list\"\"\"\n    return items[0] if items else None\n\n# Works with any type\nprint(f\"First int: {get_first([1, 2, 3])}\")\nprint(f\"First str: {get_first(['a', 'b', 'c'])}\")\nprint(f\"Empty: {get_first([])}\")\n\ndef swap_pair(a: T, b: T) -> tuple[T, T]:\n    \"\"\"Swap two values of same type\"\"\"\n    return b, a\n\nprint(f\"Swap ints: {swap_pair(1, 2)}\")\nprint(f\"Swap strs: {swap_pair('hello', 'world')}\")\n\nprint(\"\\n=== Practical Example: Typed Data Processing ===\")\n\nfrom typing import Iterator\n\ndef read_numbers(filename: str) -> Iterator[int]:\n    \"\"\"Read numbers from file, one per line\"\"\"\n    with open(filename) as f:\n        for line in f:\n            yield int(line.strip())\n\ndef calculate_stats(numbers: list[int]) -> dict[str, float]:\n    \"\"\"Calculate statistics\"\"\"\n    return {\n        'mean': sum(numbers) / len(numbers),\n        'min': float(min(numbers)),\n        'max': float(max(numbers))\n    }\n\n# Create test file\nwith open('numbers.txt', 'w') as f:\n    f.write('10\\n20\\n30\\n40\\n50')\n\nnumbers = list(read_numbers('numbers.txt'))\nstats = calculate_stats(numbers)\nprint(f\"Numbers: {numbers}\")\nprint(f\"Stats: {stats}\")\n\nprint(\"\\n=== Type Checking Example ===\")\n\ndef process_config(config: dict[str, str | int | bool]) -> None:\n    \"\"\"Process configuration\"\"\"\n    for key, value in config.items():\n        print(f\"{key}: {value} ({type(value).__name__})\")\n\nconfig = {\n    'host': 'localhost',\n    'port': 8080,\n    'debug': True,\n    'timeout': 30\n}\n\nprocess_config(config)\n\nimport os\nif os.path.exists('numbers.txt'):\n    os.remove('numbers.txt')",
              "language": "python"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "- **Type hints are optional** - Not enforced at runtime, for tooling/documentation\n- **Syntax: param: type -> return_type** - Annotate parameters and return values\n- **Use type checkers** - mypy, pyright catch errors before running\n- **Optional[T] means T | None** - Can be the type or None\n- **Union[A, B] means A | B** - Can be either type (Python 3.10+)\n- **TypedDict for structured dicts** - Better than dict[str, Any]\n- **list[str], dict[str, int]** - Use lowercase on Python 3.9+\n- **Benefits: IDE support, documentation, error prevention** - Makes code more maintainable"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "12_05-challenge-4",
              "title": "Interactive Exercise",
              "description": "Add complete type hints to this function:\n- Parameter: list of dictionaries with 'name' (str) and 'score' (int)\n- Return: dictionary mapping names to scores, only for scores >= 70",
              "instructions": "Add complete type hints to this function:\n- Parameter: list of dictionaries with 'name' (str) and 'score' (int)\n- Return: dictionary mapping names to scores, only for scores >= 70",
              "starterCode": "def get_passing_students(students):\n    \"\"\"Return dict of students with passing scores\"\"\"\n    # TODO: Add type hints to function signature\n    return {s['name']: s['score'] for s in students if s['score'] >= 70}\n\n# Test\nstudents = [\n    {'name': 'Alice', 'score': 85},\n    {'name': 'Bob', 'score': 65},\n    {'name': 'Charlie', 'score': 92}\n]\n\nresult = get_passing_students(students)\nprint(result)",
              "solution": "",
              "language": "python",
              "testCases": [
                {
                  "description": "Code runs without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Parameter type: list[dict[str, int | str]]. Return type: dict[str, int]"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "12_06",
          "title": "Regular Expressions",
          "moduleId": "module-12",
          "order": 6,
          "estimatedMinutes": 40,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Concept: Pattern Matching",
              "content": "**Regular Expressions (regex) = Advanced find/replace**\n\n**Think of a search filter:**\n\n❌ **Simple string matching:**\n```python\nif '@' in email and '.' in email:\n    # Too simple!\n    pass\n```\n\n✅ **Regex pattern:**\n```python\nimport re\nif re.match(r'^[\\w.-]+@[\\w.-]+\\.\\w+$', email):\n    # Precise pattern!\n    pass\n```\n\n**What regex can do:**\n\n1. **Validate** ✓\n   - Email addresses\n   - Phone numbers\n   - Passwords\n   - URLs\n\n2. **Extract** 🔍\n   - Dates from text\n   - Phone numbers from documents\n   - URLs from HTML\n\n3. **Replace** 🔄\n   - Format phone numbers\n   - Remove unwanted characters\n   - Transform text patterns\n\n4. **Split** ✂️\n   - Complex delimiters\n   - Multiple separators\n   - Conditional splitting\n\n**Common patterns:**\n- `.` - Any character (except newline)\n- `\\d` - Digit (0-9)\n- `\\w` - Word character (a-z, A-Z, 0-9, _)\n- `\\s` - Whitespace (space, tab, newline)\n- `*` - 0 or more\n- `+` - 1 or more\n- `?` - 0 or 1 (optional)\n- `[]` - Character class\n- `()` - Group\n- `^` - Start of string\n- `$` - End of string"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example: Basic Regular Expressions",
              "content": "**Key regex functions:**\n\n**1. re.match(pattern, string):**\n- Matches at START of string\n- Returns Match object or None\n```python\nre.match(r\"Hello\", \"Hello World\")  # Matches\nre.match(r\"World\", \"Hello World\")  # Doesn't match\n```\n\n**2. re.search(pattern, string):**\n- Searches ANYWHERE in string\n- Returns first match\n```python\nre.search(r\"World\", \"Hello World\")  # Matches\n```\n\n**3. re.findall(pattern, string):**\n- Returns list of ALL matches\n```python\nre.findall(r\"\\d+\", \"10 cats, 20 dogs\")  # ['10', '20']\n```\n\n**4. re.sub(pattern, replacement, string):**\n- Replace matches\n```python\nre.sub(r\"\\d+\", \"X\", \"10 cats\")  # \"X cats\"\n```\n\n**Raw strings (r\"\"):**\n- Use r\"\" for regex patterns\n- Prevents backslash escaping issues\n- r\"\\d\" not \"\\\\d\"",
              "code": "import re\n\nprint(\"=== Basic Matching ===\")\n\n# re.match() - Match at start of string\ntext = \"Hello World\"\nif re.match(r\"Hello\", text):\n    print(f\"'{text}' starts with 'Hello'\")\n\nif not re.match(r\"World\", text):\n    print(f\"'{text}' does NOT start with 'World'\")\n\n# re.search() - Find anywhere in string\nif re.search(r\"World\", text):\n    print(f\"'{text}' contains 'World'\")\n\n# re.findall() - Find all occurrences\ntext = \"The price is $10, $20, and $30\"\nprices = re.findall(r\"\\$\\d+\", text)\nprint(f\"Found prices: {prices}\")\n\nprint(\"\\n=== Character Classes ===\")\n\n# \\d - digits\ntext = \"My phone: 555-1234\"\ndigits = re.findall(r\"\\d\", text)\nprint(f\"All digits: {''.join(digits)}\")\n\n# \\d+ - one or more digits\nnumbers = re.findall(r\"\\d+\", text)\nprint(f\"Number groups: {numbers}\")\n\n# \\w - word characters\ntext = \"Hello, World! 123\"\nwords = re.findall(r\"\\w+\", text)\nprint(f\"Words: {words}\")\n\n# \\s - whitespace\ntext = \"Split   on    spaces\"\nparts = re.split(r\"\\s+\", text)\nprint(f\"Split parts: {parts}\")\n\nprint(\"\\n=== Quantifiers ===\")\n\n# * - zero or more\npattern = r\"a*b\"\nprint(f\"'b' matches: {bool(re.match(pattern, 'b'))}\")\nprint(f\"'ab' matches: {bool(re.match(pattern, 'ab'))}\")\nprint(f\"'aaab' matches: {bool(re.match(pattern, 'aaab'))}\")\n\n# + - one or more\npattern = r\"a+b\"\nprint(f\"\\n'b' matches a+b: {bool(re.match(pattern, 'b'))}\")\nprint(f\"'ab' matches a+b: {bool(re.match(pattern, 'ab'))}\")\n\n# ? - zero or one (optional)\npattern = r\"colou?r\"  # Matches color or colour\nprint(f\"\\n'color' matches: {bool(re.match(pattern, 'color'))}\")\nprint(f\"'colour' matches: {bool(re.match(pattern, 'colour'))}\")\n\n# {n} - exactly n times\npattern = r\"\\d{3}\"  # Exactly 3 digits\nprint(f\"\\n'123' matches \\\\d{{3}}: {bool(re.match(pattern, '123'))}\")\nprint(f\"'12' matches \\\\d{{3}}: {bool(re.match(pattern, '12'))}\")\n\n# {n,m} - between n and m times\npattern = r\"\\d{2,4}\"  # 2 to 4 digits\nprint(f\"\\n'12' matches \\\\d{{2,4}}: {bool(re.match(pattern, '12'))}\")\nprint(f\"'123' matches \\\\d{{2,4}}: {bool(re.match(pattern, '123'))}\")\n\nprint(\"\\n=== Anchors and Boundaries ===\")\n\n# ^ - start of string\npattern = r\"^Hello\"\nprint(f\"'Hello World' starts with Hello: {bool(re.match(pattern, 'Hello World'))}\")\nprint(f\"'Say Hello' starts with Hello: {bool(re.match(pattern, 'Say Hello'))}\")\n\n# $ - end of string\npattern = r\"World$\"\nprint(f\"\\n'Hello World' ends with World: {bool(re.search(pattern, 'Hello World'))}\")\nprint(f\"'World Hello' ends with World: {bool(re.search(pattern, 'World Hello'))}\")\n\n# Combining ^ and $ - full string match\npattern = r\"^\\d{3}$\"  # Exactly 3 digits, nothing else\nprint(f\"\\n'123' is exactly 3 digits: {bool(re.match(pattern, '123'))}\")\nprint(f\"'1234' is exactly 3 digits: {bool(re.match(pattern, '1234'))}\")\n\nprint(\"\\n=== Character Classes ===\")\n\n# [abc] - any of these characters\npattern = r\"[aeiou]\"\nvowels = re.findall(pattern, \"hello world\")\nprint(f\"Vowels in 'hello world': {vowels}\")\n\n# [a-z] - range\npattern = r\"[a-z]+\"\nwords = re.findall(pattern, \"Hello123World456\")\nprint(f\"Lowercase words: {words}\")\n\n# [^abc] - NOT these characters\npattern = r\"[^aeiou]+\"\nconsonants = re.findall(pattern, \"hello world\")\nprint(f\"Consonant groups: {consonants}\")",
              "language": "python"
            },
            {
              "type": "ANALOGY",
              "title": "Syntax Breakdown",
              "content": "**Pattern syntax quick reference:**\n\n**Special characters:**\n```\n.   Any character (except newline)\n\\d  Digit [0-9]\n\\D  Not digit [^0-9]\n\\w  Word char [a-zA-Z0-9_]\n\\W  Not word char\n\\s  Whitespace [ \\t\\n\\r\\f\\v]\n\\S  Not whitespace\n```\n\n**Quantifiers:**\n```\n*      0 or more\n+      1 or more\n?      0 or 1 (optional)\n{3}    Exactly 3\n{2,5}  Between 2 and 5\n{2,}   2 or more\n```\n\n**Anchors:**\n```\n^   Start of string\n$   End of string\n\\b  Word boundary\n```\n\n**Groups:**\n```\n(...)   Capturing group\n(?:...)  Non-capturing group\n|       OR (alternation)\n```\n\n**Character classes:**\n```\n[abc]    Any of a, b, c\n[a-z]    Range (a through z)\n[^abc]   NOT a, b, or c\n```\n\n**Escaping special chars:**\n```\n\\.  Literal dot\n\\$  Literal dollar sign\n\\*  Literal asterisk\nUse \\ before special characters\n```"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example: Groups and Practical Patterns",
              "content": "**Capturing groups:**\n```python\npattern = r\"(\\d{3})-(\\d{3})-(\\d{4})\"\nmatch = re.search(pattern, \"555-123-4567\")\nmatch.group(0)  # Full match: \"555-123-4567\"\nmatch.group(1)  # First group: \"555\"\nmatch.groups()  # All groups: ('555', '123', '4567')\n```\n\n**Named groups:**\n```python\npattern = r\"(?P<area>\\d{3})-(?P<num>\\d{3})\"\nmatch.group('area')  # By name\nmatch.groupdict()    # Dict of named groups\n```\n\n**Substitution with groups:**\n```python\n# Swap first and last name\nre.sub(r'(\\w+) (\\w+)', r'\\2, \\1', \"John Doe\")\n# Result: \"Doe, John\"\n```\n\n**Flags:**\n```python\nre.IGNORECASE  # Case-insensitive\nre.MULTILINE   # ^ and $ match line boundaries\nre.DOTALL      # . matches newlines too\n```",
              "code": "import re\n\nprint(\"=== Capturing Groups ===\")\n\n# Groups with ()\npattern = r\"(\\d{3})-(\\d{3})-(\\d{4})\"\nphone = \"555-123-4567\"\nmatch = re.search(pattern, phone)\n\nif match:\n    print(f\"Full match: {match.group(0)}\")\n    print(f\"Area code: {match.group(1)}\")\n    print(f\"Exchange: {match.group(2)}\")\n    print(f\"Number: {match.group(3)}\")\n    print(f\"All groups: {match.groups()}\")\n\n# Named groups\npattern = r\"(?P<area>\\d{3})-(?P<exchange>\\d{3})-(?P<number>\\d{4})\"\nmatch = re.search(pattern, phone)\n\nif match:\n    print(f\"\\nNamed groups:\")\n    print(f\"Area: {match.group('area')}\")\n    print(f\"Exchange: {match.group('exchange')}\")\n    print(f\"Number: {match.group('number')}\")\n    print(f\"Dict: {match.groupdict()}\")\n\nprint(\"\\n=== Email Validation ===\")\n\nemail_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n\nemails = [\n    \"user@example.com\",\n    \"test.user@domain.co.uk\",\n    \"invalid@\",\n    \"@invalid.com\",\n    \"no-at-sign.com\"\n]\n\nfor email in emails:\n    valid = bool(re.match(email_pattern, email))\n    print(f\"{email:25} {'✓ Valid' if valid else '✗ Invalid'}\")\n\nprint(\"\\n=== URL Extraction ===\")\n\ntext = \"\"\"\nCheck out https://www.example.com and http://test.org\nAlso visit ftp://files.example.com for downloads.\n\"\"\"\n\nurl_pattern = r'https?://[\\w.-]+\\.[a-zA-Z]{2,}'\nurls = re.findall(url_pattern, text)\nprint(f\"Found URLs: {urls}\")\n\nprint(\"\\n=== Phone Number Formatting ===\")\n\ndef format_phone(phone):\n    \"\"\"Extract and format phone number\"\"\"\n    # Remove all non-digits\n    digits = re.sub(r'\\D', '', phone)\n    \n    # Format as (XXX) XXX-XXXX\n    if len(digits) == 10:\n        return f\"({digits[:3]}) {digits[3:6]}-{digits[6:]}\"\n    return phone\n\nphones = [\n    \"5551234567\",\n    \"555-123-4567\",\n    \"(555) 123-4567\",\n    \"555.123.4567\"\n]\n\nfor phone in phones:\n    formatted = format_phone(phone)\n    print(f\"{phone:20} → {formatted}\")\n\nprint(\"\\n=== Date Extraction ===\")\n\ntext = \"Meeting on 2024-01-15, deadline 03/20/2024, event: 12-25-2024\"\n\n# Multiple date formats\ndate_patterns = [\n    r'\\d{4}-\\d{2}-\\d{2}',  # YYYY-MM-DD\n    r'\\d{2}/\\d{2}/\\d{4}',  # MM/DD/YYYY\n    r'\\d{2}-\\d{2}-\\d{4}',  # MM-DD-YYYY\n]\n\nall_dates = []\nfor pattern in date_patterns:\n    dates = re.findall(pattern, text)\n    all_dates.extend(dates)\n\nprint(f\"Dates found: {all_dates}\")\n\nprint(\"\\n=== Text Substitution ===\")\n\n# Replace multiple spaces with single space\ntext = \"Too    many     spaces\"\ncleaned = re.sub(r'\\s+', ' ', text)\nprint(f\"Original: '{text}'\")\nprint(f\"Cleaned:  '{cleaned}'\")\n\n# Remove HTML tags\nhtml = \"<p>Hello <b>World</b>!</p>\"\nplain = re.sub(r'<[^>]+>', '', html)\nprint(f\"\\nHTML: {html}\")\nprint(f\"Plain: {plain}\")\n\n# Censor words\ntext = \"This is damn bad stuff\"\ncensored = re.sub(r'\\b(damn|bad)\\b', '***', text, flags=re.IGNORECASE)\nprint(f\"\\nOriginal: {text}\")\nprint(f\"Censored: {censored}\")\n\nprint(\"\\n=== Split with Regex ===\")\n\n# Split on multiple delimiters\ntext = \"apple;banana,cherry:date|elderberry\"\nfruits = re.split(r'[;,:|\n]+', text)\nprint(f\"Fruits: {fruits}\")\n\n# Split but keep delimiter\ntext = \"Question? Answer! Statement.\"\nparts = re.split(r'([.!?])', text)\nprint(f\"With punctuation: {parts}\")\n\nprint(\"\\n=== Password Validation ===\")\n\ndef validate_password(password):\n    \"\"\"Validate password strength\"\"\"\n    checks = {\n        'length': len(password) >= 8,\n        'uppercase': bool(re.search(r'[A-Z]', password)),\n        'lowercase': bool(re.search(r'[a-z]', password)),\n        'digit': bool(re.search(r'\\d', password)),\n        'special': bool(re.search(r'[!@#$%^&*()]', password))\n    }\n    \n    return all(checks.values()), checks\n\npasswords = [\n    \"weak\",\n    \"StrongPass123!\",\n    \"NoDigits!\",\n    \"ALLUPPER123!\"\n]\n\nfor pwd in passwords:\n    valid, checks = validate_password(pwd)\n    status = \"✓ Valid\" if valid else \"✗ Invalid\"\n    print(f\"{pwd:20} {status}\")\n    if not valid:\n        failed = [k for k, v in checks.items() if not v]\n        print(f\"{'':20} Missing: {', '.join(failed)}\")",
              "language": "python"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "- **re.search() finds anywhere, re.match() only at start** - Most common confusion\n- **Always use raw strings r''** - Prevents backslash escaping issues\n- **\\d digit, \\w word, \\s space** - Most common character classes\n- **+ means 1+, * means 0+, ? means 0 or 1** - Quantifiers\n- **^ start, $ end** - Anchors for full string matching\n- **() creates groups** - Access with match.group(1), match.groups()\n- **Named groups: (?P<name>...)** - Better than numbers\n- **Compile patterns if reusing:** pattern = re.compile(r'...')"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "12_06-challenge-4",
              "title": "Interactive Exercise",
              "description": "Create a log parser that extracts:\n1. Timestamp (YYYY-MM-DD HH:MM:SS)\n2. Log level (INFO, WARNING, ERROR)\n3. Message\nFrom log lines like: \"2024-01-15 10:30:45 [ERROR] Database connection failed\"",
              "instructions": "Create a log parser that extracts:\n1. Timestamp (YYYY-MM-DD HH:MM:SS)\n2. Log level (INFO, WARNING, ERROR)\n3. Message\nFrom log lines like: \"2024-01-15 10:30:45 [ERROR] Database connection failed\"",
              "starterCode": "import re\n\ndef parse_log_line(line):\n    # TODO: Create regex pattern with named groups\n    pattern = r''\n    \n    # TODO: Match and extract groups\n    match = None\n    \n    if match:\n        return match.groupdict()\n    return None\n\nlogs = [\n    \"2024-01-15 10:30:45 [ERROR] Database connection failed\",\n    \"2024-01-15 10:31:12 [INFO] Application started\",\n    \"2024-01-15 10:35:22 [WARNING] High memory usage\"\n]\n\nfor log in logs:\n    parsed = parse_log_line(log)\n    print(parsed)",
              "solution": "",
              "language": "python",
              "testCases": [
                {
                  "description": "Code runs without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use named groups: (?P<name>pattern). Timestamp: \\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}. Level: \\w+."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        }
      ],
      "quizzes": [
        {
          "id": "quiz-12",
          "title": "Module 12: Advanced Topics - Comprehensive Quiz",
          "description": "Test your understanding of decorators, generators, context managers, comprehensions, type hints, and regular expressions. 70% required to pass.",
          "moduleId": "module-12",
          "passingScore": 70,
          "estimatedMinutes": 15,
          "questions": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-12-q1",
              "title": "What does a decorator do to a function?",
              "description": "What does a decorator do to a function?",
              "options": [
                "Deletes it",
                "Wraps it to add functionality without modifying it",
                "Makes it faster",
                "Converts it to a class"
              ],
              "correctAnswer": 1,
              "explanation": "Decorators wrap functions to add additional behavior (logging, timing, validation) without changing the original function's code."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-12-q2",
              "title": "When stacking decorators like @A @B @C, what order are they applied?",
              "description": "When stacking decorators like @A @B @C, what order are they applied?",
              "options": [
                "A, B, C (top to bottom)",
                "C, B, A (bottom to top)",
                "All at once",
                "Random order"
              ],
              "correctAnswer": 1,
              "explanation": "Decorators are applied bottom to top. @A @B @C def func() is equivalent to A(B(C(func)))."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-12-q3",
              "title": "What's the main advantage of generators over lists?",
              "description": "What's the main advantage of generators over lists?",
              "options": [
                "Generators are faster to create",
                "Generators are memory efficient - values generated on demand",
                "Generators can be sorted",
                "Generators are easier to write"
              ],
              "correctAnswer": 1,
              "explanation": "Generators use yield to generate values on demand, avoiding storing all values in memory at once. Perfect for large datasets."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-12-q4",
              "title": "What happens when you iterate through a generator twice?",
              "description": "What happens when you iterate through a generator twice?",
              "options": [
                "You get the same values both times",
                "The second iteration returns nothing (generator exhausted)",
                "An error is raised",
                "The generator resets"
              ],
              "correctAnswer": 1,
              "explanation": "Generators are one-time use. After exhaustion, subsequent iterations yield nothing. You must create a new generator."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-12-q5",
              "title": "What's the difference between (x**2 for x in range(10)) and [x**2 for x in range(10)]?",
              "description": "What's the difference between (x**2 for x in range(10)) and [x**2 for x in range(10)]?",
              "options": [
                "No difference",
                "() creates a generator (lazy), [] creates a list (immediate)",
                "() is faster",
                "[] uses more CPU"
              ],
              "correctAnswer": 1,
              "explanation": "Parentheses create a generator expression (lazy evaluation), square brackets create a list comprehension (evaluated immediately)."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-12-q6",
              "title": "What is the main benefit of context managers?",
              "description": "What is the main benefit of context managers?",
              "options": [
                "They make code faster",
                "They guarantee cleanup code runs, even if exceptions occur",
                "They prevent all errors",
                "They compress files"
              ],
              "correctAnswer": 1,
              "explanation": "Context managers ensure cleanup code (like closing files) runs even if an exception occurs, preventing resource leaks."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-12-q7",
              "title": "What does __exit__ need to return to suppress an exception?",
              "description": "What does __exit__ need to return to suppress an exception?",
              "options": [
                "None",
                "False",
                "True",
                "The exception object"
              ],
              "correctAnswer": 2,
              "explanation": "__exit__ must return True to suppress the exception. Returning False or None propagates the exception normally."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-12-q8",
              "title": "With @contextmanager, where does the code block inside 'with' execute?",
              "description": "With @contextmanager, where does the code block inside 'with' execute?",
              "options": [
                "Before the yield",
                "After the yield",
                "At the yield statement",
                "Never"
              ],
              "correctAnswer": 2,
              "explanation": "Code before yield is setup (__enter__), the with block executes at yield, code after yield is cleanup (__exit__)."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-12-q9",
              "title": "What's the difference between [x for x in items if x > 0] and [x if x > 0 else 0 for x in items]?",
              "description": "What's the difference between [x for x in items if x > 0] and [x if x > 0 else 0 for x in items]?",
              "options": [
                "No difference",
                "First filters (excludes items), second transforms (keeps all items)",
                "Second is invalid",
                "First is faster"
              ],
              "correctAnswer": 1,
              "explanation": "The first filters out negative items. The second transforms all items - positive stay the same, others become 0."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-12-q10",
              "title": "What does {x**2 for x in range(5)} create?",
              "description": "What does {x**2 for x in range(5)} create?",
              "options": [
                "A list",
                "A set",
                "A dictionary",
                "A tuple"
              ],
              "correctAnswer": 1,
              "explanation": "Curly braces with a single expression create a set comprehension, which automatically keeps only unique values."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-12-q11",
              "title": "When should you avoid using comprehensions?",
              "description": "When should you avoid using comprehensions?",
              "options": [
                "Never - always use them",
                "When logic is complex or involves side effects",
                "When iterating over lists",
                "When you need performance"
              ],
              "correctAnswer": 1,
              "explanation": "Avoid comprehensions for complex logic (hard to read) or side effects (printing, file I/O). Use regular loops instead."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-12-q12",
              "title": "What happens if you pass the wrong type to a function with type hints?",
              "description": "What happens if you pass the wrong type to a function with type hints?",
              "options": [
                "Python raises a TypeError",
                "Nothing - type hints aren't enforced at runtime",
                "The program crashes",
                "Python converts the type"
              ],
              "correctAnswer": 1,
              "explanation": "Type hints are not enforced at runtime. They're for documentation and tooling (mypy). Python runs with any type."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-12-q13",
              "title": "What does Optional[str] mean?",
              "description": "What does Optional[str] mean?",
              "options": [
                "The parameter has a default value",
                "The value can be str or None",
                "The string can be empty",
                "The type is uncertain"
              ],
              "correctAnswer": 1,
              "explanation": "Optional[str] means the value can be str or None. Equivalent to Union[str, None] or str | None (Python 3.10+)."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-12-q14",
              "title": "What's the modern Python 3.10+ equivalent of Union[int, str]?",
              "description": "What's the modern Python 3.10+ equivalent of Union[int, str]?",
              "options": [
                "int or str",
                "int | str",
                "int + str",
                "int, str"
              ],
              "correctAnswer": 1,
              "explanation": "Python 3.10+ allows using the pipe operator: int | str instead of Union[int, str]."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-12-q15",
              "title": "Why use raw strings (r'') for regex patterns?",
              "description": "Why use raw strings (r'') for regex patterns?",
              "options": [
                "They make regex faster",
                "They prevent backslash escaping issues",
                "They're required by re module",
                "They enable case-insensitive matching"
              ],
              "correctAnswer": 1,
              "explanation": "Raw strings treat backslashes literally. Without r'', you'd need '\\\\d' instead of r'\\d' for a digit pattern."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-12-q16",
              "title": "What's the difference between re.match() and re.search()?",
              "description": "What's the difference between re.match() and re.search()?",
              "options": [
                "No difference",
                "match() only checks start of string, search() checks anywhere",
                "search() is faster",
                "match() is case-sensitive"
              ],
              "correctAnswer": 1,
              "explanation": "re.match() only matches at the start of the string, re.search() looks for a match anywhere in the string."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-12-q17",
              "title": "What does the regex pattern \\d{3,5} match?",
              "description": "What does the regex pattern \\d{3,5} match?",
              "options": [
                "Exactly 3 or 5 digits",
                "Between 3 and 5 digits",
                "3 digits followed by 5 digits",
                "At most 5 digits"
              ],
              "correctAnswer": 1,
              "explanation": "{3,5} means between 3 and 5 occurrences. So \\d{3,5} matches 3, 4, or 5 consecutive digits."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-12-q18",
              "title": "In regex, what does the ^ anchor match?",
              "description": "In regex, what does the ^ anchor match?",
              "options": [
                "Any character",
                "Start of string",
                "End of string",
                "Word boundary"
              ],
              "correctAnswer": 1,
              "explanation": "^ matches the start of the string. Use with $ for full string matching: ^pattern$ matches only if entire string matches."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-12-q19",
              "title": "What do capturing groups in regex do?",
              "description": "What do capturing groups in regex do?",
              "options": [
                "Make patterns case-insensitive",
                "Extract specific parts of the match",
                "Speed up matching",
                "Create character classes"
              ],
              "correctAnswer": 1,
              "explanation": "Capturing groups (parentheses) extract specific parts. Access with match.group(1), match.group(2), etc."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-12-q20",
              "title": "Which decorator preserves the original function's metadata?",
              "description": "Which decorator preserves the original function's metadata?",
              "options": [
                "@preserve",
                "@wraps from functools",
                "@metadata",
                "@original"
              ],
              "correctAnswer": 1,
              "explanation": "@wraps(func) from functools preserves the original function's __name__, __doc__, and other metadata in the decorated version."
            }
          ]
        }
      ]
    },
    {
      "id": "module-13",
      "title": "Module 13",
      "description": "Python programming fundamentals - Module 13",
      "difficulty": "advanced",
      "estimatedHours": 3,
      "lessons": [
        {
          "id": "13_01",
          "title": "HTTP Basics and the Requests Library",
          "moduleId": "module-13",
          "order": 1,
          "estimatedMinutes": 35,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Concept: How the Web Works",
              "content": "**HTTP = How computers talk on the web**\n\n**Think of it like a restaurant:**\n\n**Client (You) → Server (Kitchen)**\n- You: \"Can I have a burger?\" (REQUEST)\n- Kitchen: \"Here's your burger!\" (RESPONSE)\n\n**HTTP Request Methods:**\n\n1. **GET** 📖 - Read/retrieve data\n   - Like asking to see the menu\n   - \"Show me the user with ID 5\"\n\n2. **POST** ➕ - Create new data\n   - Like placing an order\n   - \"Create a new user account\"\n\n3. **PUT** 📝 - Update existing data\n   - Like changing your order\n   - \"Update user profile\"\n\n4. **DELETE** 🗑️ - Remove data\n   - Like canceling your order\n   - \"Delete this post\"\n\n**HTTP Status Codes:**\n- **2xx (Success)** ✅\n  - 200: OK - Request succeeded\n  - 201: Created - New resource created\n\n- **3xx (Redirect)** ↪️\n  - 301: Moved permanently\n  - 302: Temporary redirect\n\n- **4xx (Client Error)** ❌\n  - 400: Bad request\n  - 401: Unauthorized\n  - 404: Not found\n\n- **5xx (Server Error)** 💥\n  - 500: Internal server error\n  - 503: Service unavailable\n\n**Headers:** Metadata about the request/response\n- Content-Type: application/json\n- Authorization: Bearer token\n- User-Agent: Browser info"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example: Making HTTP Requests",
              "content": "**requests library key features:**\n\n**1. HTTP Methods:**\n```python\nrequests.get(url)     # Retrieve\nrequests.post(url)    # Create\nrequests.put(url)     # Update\nrequests.delete(url)  # Remove\n```\n\n**2. Response object:**\n```python\nresponse.status_code  # 200, 404, etc.\nresponse.ok           # True if 2xx\nresponse.json()       # Parse JSON\nresponse.text         # Raw text\nresponse.headers      # Response headers\n```\n\n**3. Sending data:**\n```python\n# JSON data\nrequests.post(url, json={'key': 'value'})\n\n# Form data\nrequests.post(url, data={'key': 'value'})\n\n# Query parameters\nrequests.get(url, params={'key': 'value'})\n```\n\n**4. Headers:**\n```python\nheaders = {'Authorization': 'Bearer token'}\nrequests.get(url, headers=headers)\n```",
              "code": "import requests\nimport json\n\nprint(\"=== GET Request - Retrieve Data ===\")\n\n# Simple GET request\nresponse = requests.get('https://jsonplaceholder.typicode.com/users/1')\n\nprint(f\"Status Code: {response.status_code}\")\nprint(f\"Success: {response.ok}\")\nprint(f\"\\nResponse Headers:\")\nfor key, value in list(response.headers.items())[:5]:\n    print(f\"  {key}: {value}\")\n\n# Parse JSON response\nuser = response.json()\nprint(f\"\\nUser Data:\")\nprint(f\"  Name: {user['name']}\")\nprint(f\"  Email: {user['email']}\")\nprint(f\"  City: {user['address']['city']}\")\n\nprint(\"\\n=== GET with Query Parameters ===\")\n\n# Get multiple users\nparams = {\n    '_limit': 3,\n    '_sort': 'name'\n}\n\nresponse = requests.get(\n    'https://jsonplaceholder.typicode.com/users',\n    params=params\n)\n\nusers = response.json()\nprint(f\"Retrieved {len(users)} users:\")\nfor user in users:\n    print(f\"  - {user['name']} ({user['email']})\")\n\nprint(\"\\n=== POST Request - Create Data ===\")\n\n# Create new post\nnew_post = {\n    'title': 'My First Post',\n    'body': 'This is the content of my post',\n    'userId': 1\n}\n\nresponse = requests.post(\n    'https://jsonplaceholder.typicode.com/posts',\n    json=new_post\n)\n\nprint(f\"Status Code: {response.status_code}\")\ncreated_post = response.json()\nprint(f\"Created Post:\")\nprint(f\"  ID: {created_post.get('id')}\")\nprint(f\"  Title: {created_post['title']}\")\nprint(f\"  Body: {created_post['body']}\")\n\nprint(\"\\n=== PUT Request - Update Data ===\")\n\n# Update existing post\nupdated_post = {\n    'id': 1,\n    'title': 'Updated Title',\n    'body': 'Updated content',\n    'userId': 1\n}\n\nresponse = requests.put(\n    'https://jsonplaceholder.typicode.com/posts/1',\n    json=updated_post\n)\n\nprint(f\"Status Code: {response.status_code}\")\nresult = response.json()\nprint(f\"Updated Post:\")\nprint(f\"  Title: {result['title']}\")\nprint(f\"  Body: {result['body']}\")\n\nprint(\"\\n=== DELETE Request - Remove Data ===\")\n\nresponse = requests.delete('https://jsonplaceholder.typicode.com/posts/1')\n\nprint(f\"Status Code: {response.status_code}\")\nprint(f\"Deletion successful: {response.status_code == 200}\")\n\nprint(\"\\n=== Custom Headers ===\")\n\nheaders = {\n    'User-Agent': 'Python Training Course/1.0',\n    'Accept': 'application/json',\n    'Custom-Header': 'Custom Value'\n}\n\nresponse = requests.get(\n    'https://httpbin.org/headers',\n    headers=headers\n)\n\nreceived_headers = response.json()\nprint(\"Headers sent and received:\")\nfor key, value in received_headers['headers'].items():\n    print(f\"  {key}: {value}\")\n\nprint(\"\\n=== Error Handling ===\")\n\ntry:\n    response = requests.get('https://jsonplaceholder.typicode.com/users/999')\n    response.raise_for_status()  # Raises exception for 4xx/5xx\n    \n    user = response.json()\n    if not user:\n        print(\"User not found (empty response)\")\n    else:\n        print(f\"Found: {user['name']}\")\nexcept requests.exceptions.HTTPError as e:\n    print(f\"HTTP Error: {e}\")\nexcept requests.exceptions.RequestException as e:\n    print(f\"Request Error: {e}\")\n\nprint(\"\\n=== Timeout and Retries ===\")\n\ntry:\n    response = requests.get(\n        'https://jsonplaceholder.typicode.com/users/1',\n        timeout=5  # 5 second timeout\n    )\n    print(f\"Request completed in {response.elapsed.total_seconds():.3f}s\")\nexcept requests.exceptions.Timeout:\n    print(\"Request timed out!\")",
              "language": "python"
            },
            {
              "type": "ANALOGY",
              "title": "Syntax Breakdown",
              "content": "**Basic request pattern:**\n```python\nimport requests\n\n# GET request\nresponse = requests.get(url)\n\n# Check status\nif response.ok:  # or response.status_code == 200\n    data = response.json()\n```\n\n**With parameters:**\n```python\n# Query parameters (?key=value&key2=value2)\nparams = {'key': 'value', 'key2': 'value2'}\nresponse = requests.get(url, params=params)\n\n# POST with JSON data\ndata = {'name': 'Alice', 'age': 25}\nresponse = requests.post(url, json=data)\n\n# Custom headers\nheaders = {'Authorization': 'Bearer token'}\nresponse = requests.get(url, headers=headers)\n```\n\n**Error handling:**\n```python\ntry:\n    response = requests.get(url, timeout=5)\n    response.raise_for_status()  # Raise exception for errors\n    data = response.json()\nexcept requests.exceptions.HTTPError:\n    print(\"HTTP error\")\nexcept requests.exceptions.Timeout:\n    print(\"Timeout\")\nexcept requests.exceptions.RequestException:\n    print(\"Request failed\")\n```\n\n**Common patterns:**\n```python\n# Check status\nif response.status_code == 200:\n    # Success\n    pass\n\n# Parse response\njson_data = response.json()  # For JSON\ntext_data = response.text    # For text\nbinary = response.content    # For binary\n```"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example: Working with Real APIs",
              "content": "**Building API clients - best practices:**\n\n**1. Use sessions:**\n```python\nsession = requests.Session()\nsession.headers['Authorization'] = 'token'\n# Reuses connection, faster!\n```\n\n**2. Error handling:**\n```python\ntry:\n    response.raise_for_status()\nexcept requests.exceptions.HTTPError:\n    # Handle 4xx/5xx\nexcept requests.exceptions.Timeout:\n    # Handle timeout\n```\n\n**3. Caching:**\n- Store responses temporarily\n- Reduce API calls\n- Faster for repeated requests\n\n**4. Rate limiting:**\n- Respect API limits\n- Avoid being blocked\n- Track request timestamps\n\n**5. Type hints:**\n```python\ndef get_user(username: str) -> Optional[Dict]:\n    ...\n```\nClear what function expects/returns",
              "code": "import requests\nfrom typing import Optional, Dict, List\n\nprint(\"=== GitHub API Example ===\")\n\nclass GitHubAPI:\n    \"\"\"Simple GitHub API client\"\"\"\n    \n    BASE_URL = 'https://api.github.com'\n    \n    def __init__(self, token: Optional[str] = None):\n        self.session = requests.Session()\n        if token:\n            self.session.headers['Authorization'] = f'token {token}'\n        self.session.headers['Accept'] = 'application/vnd.github.v3+json'\n    \n    def get_user(self, username: str) -> Optional[Dict]:\n        \"\"\"Get user information\"\"\"\n        response = self.session.get(f'{self.BASE_URL}/users/{username}')\n        \n        if response.ok:\n            return response.json()\n        return None\n    \n    def get_repos(self, username: str, limit: int = 5) -> List[Dict]:\n        \"\"\"Get user repositories\"\"\"\n        response = self.session.get(\n            f'{self.BASE_URL}/users/{username}/repos',\n            params={'sort': 'updated', 'per_page': limit}\n        )\n        \n        if response.ok:\n            return response.json()\n        return []\n\n# Use the API client\ngh = GitHubAPI()\n\n# Get user info\nuser = gh.get_user('octocat')\nif user:\n    print(f\"User: {user['login']}\")\n    print(f\"Name: {user['name']}\")\n    print(f\"Public Repos: {user['public_repos']}\")\n    print(f\"Followers: {user['followers']}\")\n\n# Get repositories\nrepos = gh.get_repos('octocat', limit=3)\nprint(f\"\\nTop {len(repos)} repositories:\")\nfor repo in repos:\n    print(f\"  - {repo['name']}: {repo['description'] or 'No description'}\")\n    print(f\"    ⭐ {repo['stargazers_count']} stars\")\n\nprint(\"\\n=== Weather API Example (OpenWeatherMap concept) ===\")\n\nclass WeatherAPI:\n    \"\"\"Weather API client (example structure)\"\"\"\n    \n    def __init__(self, api_key: str):\n        self.api_key = api_key\n        self.base_url = 'https://api.openweathermap.org/data/2.5'\n    \n    def get_current_weather(self, city: str) -> Optional[Dict]:\n        \"\"\"Get current weather for a city\"\"\"\n        params = {\n            'q': city,\n            'appid': self.api_key,\n            'units': 'metric'\n        }\n        \n        try:\n            response = requests.get(\n                f'{self.base_url}/weather',\n                params=params,\n                timeout=10\n            )\n            response.raise_for_status()\n            return response.json()\n        except requests.exceptions.RequestException as e:\n            print(f\"Error fetching weather: {e}\")\n            return None\n\n# Example usage (would need real API key)\nprint(\"Weather API structure example (requires API key)\")\nprint(\"  weather = WeatherAPI('your-api-key')\")\nprint(\"  data = weather.get_current_weather('London')\")\n\nprint(\"\\n=== API Response Caching ===\")\n\nimport time\nfrom functools import lru_cache\n\nclass CachedAPI:\n    \"\"\"API client with caching\"\"\"\n    \n    def __init__(self):\n        self.cache = {}\n        self.cache_duration = 300  # 5 minutes\n    \n    def get_data(self, url: str) -> Optional[Dict]:\n        \"\"\"Get data with caching\"\"\"\n        now = time.time()\n        \n        # Check cache\n        if url in self.cache:\n            cached_data, timestamp = self.cache[url]\n            if now - timestamp < self.cache_duration:\n                print(f\"  ✓ Cache hit for {url}\")\n                return cached_data\n        \n        # Make request\n        print(f\"  → Making request to {url}\")\n        try:\n            response = requests.get(url, timeout=5)\n            response.raise_for_status()\n            data = response.json()\n            \n            # Cache the result\n            self.cache[url] = (data, now)\n            return data\n        except requests.exceptions.RequestException as e:\n            print(f\"  ✗ Error: {e}\")\n            return None\n\napi = CachedAPI()\n\nurl = 'https://jsonplaceholder.typicode.com/users/1'\n\nprint(\"First request (will fetch):\")\ndata1 = api.get_data(url)\nif data1:\n    print(f\"  Got: {data1['name']}\")\n\nprint(\"\\nSecond request (will use cache):\")\ndata2 = api.get_data(url)\nif data2:\n    print(f\"  Got: {data2['name']}\")\n\nprint(\"\\n=== Rate Limiting ===\")\n\nimport time\n\nclass RateLimitedAPI:\n    \"\"\"API client with rate limiting\"\"\"\n    \n    def __init__(self, requests_per_minute: int = 60):\n        self.requests_per_minute = requests_per_minute\n        self.request_times = []\n    \n    def _wait_if_needed(self):\n        \"\"\"Wait if rate limit would be exceeded\"\"\"\n        now = time.time()\n        \n        # Remove requests older than 1 minute\n        self.request_times = [\n            t for t in self.request_times \n            if now - t < 60\n        ]\n        \n        # Wait if at limit\n        if len(self.request_times) >= self.requests_per_minute:\n            wait_time = 60 - (now - self.request_times[0])\n            if wait_time > 0:\n                print(f\"  Rate limit reached, waiting {wait_time:.1f}s...\")\n                time.sleep(wait_time)\n                self.request_times = []\n    \n    def get(self, url: str) -> Optional[requests.Response]:\n        \"\"\"Make rate-limited GET request\"\"\"\n        self._wait_if_needed()\n        self.request_times.append(time.time())\n        return requests.get(url)\n\napi = RateLimitedAPI(requests_per_minute=2)\n\nprint(\"Making rate-limited requests:\")\nfor i in range(3):\n    print(f\"  Request {i+1}\")\n    response = api.get('https://jsonplaceholder.typicode.com/users/1')\n    print(f\"    Status: {response.status_code}\")",
              "language": "python"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "- **HTTP methods: GET (read), POST (create), PUT (update), DELETE (remove)**\n- **requests library makes HTTP easy** - requests.get(), .post(), etc.\n- **Always handle errors** - Network can fail, use try/except\n- **response.json() parses JSON** - Most APIs return JSON\n- **Use sessions for multiple requests** - Faster, maintains headers\n- **Set timeouts** - Prevent hanging: timeout=10\n- **Check response.ok or status_code** - Don't assume success\n- **Type hints improve API clients** - Clear interfaces and documentation"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "13_01-challenge-4",
              "title": "Interactive Exercise",
              "description": "Create a simple API client for JSONPlaceholder that:\n- Gets all posts for a specific user\n- Filters posts by keyword in title\n- Returns formatted results\nImplement error handling and use type hints.",
              "instructions": "Create a simple API client for JSONPlaceholder that:\n- Gets all posts for a specific user\n- Filters posts by keyword in title\n- Returns formatted results\nImplement error handling and use type hints.",
              "starterCode": "import requests\nfrom typing import List, Dict, Optional\n\nclass PostsAPI:\n    BASE_URL = 'https://jsonplaceholder.typicode.com'\n    \n    def get_user_posts(self, user_id: int) -> List[Dict]:\n        # TODO: Get all posts for user_id\n        pass\n    \n    def filter_posts_by_keyword(self, posts: List[Dict], keyword: str) -> List[Dict]:\n        # TODO: Filter posts where keyword is in title\n        pass\n    \n    def format_post(self, post: Dict) -> str:\n        # TODO: Return formatted string \"[ID] Title\"\n        pass\n\n# Test\napi = PostsAPI()\nposts = api.get_user_posts(1)\nfiltered = api.filter_posts_by_keyword(posts, 'sunt')\nfor post in filtered:\n    print(api.format_post(post))",
              "solution": "",
              "language": "python",
              "testCases": [
                {
                  "description": "Code runs without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use requests.get with params={'userId': user_id}. Filter with list comprehension checking if keyword in post['title']. Format with f-string."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "13_02",
          "title": "Building REST APIs with Flask",
          "moduleId": "module-13",
          "order": 2,
          "estimatedMinutes": 40,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Concept: Your Own API",
              "content": "**Flask = Lightweight web framework for Python**\n\n**Think of it like a restaurant:**\n- **Routes** = Menu items (what you can order)\n- **Methods** = How to order (dine-in, takeout, delivery)\n- **Responses** = What you get back\n\n**REST API Principles:**\n\n1. **Resources** - Things you work with (users, posts, products)\n2. **URLs** - Addresses for resources (`/api/users`, `/api/posts`)\n3. **HTTP Methods** - Actions on resources\n   - GET `/api/users` - List all users\n   - GET `/api/users/1` - Get user #1\n   - POST `/api/users` - Create new user\n   - PUT `/api/users/1` - Update user #1\n   - DELETE `/api/users/1` - Delete user #1\n\n4. **JSON** - Data format for requests/responses\n\n**Why Flask?**\n- ✅ Lightweight and simple\n- ✅ Perfect for APIs\n- ✅ Easy to learn\n- ✅ Flexible and extensible\n- ✅ Great for microservices"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example: Basic Flask API",
              "content": "**Flask API key concepts:**\n\n**1. Routes:**\n```python\n@app.route('/path', methods=['GET', 'POST'])\ndef function():\n    return jsonify(data)\n```\n\n**2. URL parameters:**\n```python\n@app.route('/users/<int:user_id>')\ndef get_user(user_id):\n    # user_id is extracted from URL\n```\n\n**3. Request data:**\n```python\ndata = request.get_json()  # Parse JSON body\nparams = request.args      # Query parameters\n```\n\n**4. Responses:**\n```python\nreturn jsonify(data)           # 200 OK\nreturn jsonify(data), 201      # Created\nreturn jsonify(error), 404     # Not found\n```\n\n**5. HTTP status codes:**\n- 200: Success\n- 201: Created\n- 400: Bad request\n- 404: Not found\n- 500: Server error",
              "code": "from flask import Flask, jsonify, request\n\napp = Flask(__name__)\n\n# In-memory data store\nusers = [\n    {'id': 1, 'name': 'Alice', 'email': 'alice@example.com'},\n    {'id': 2, 'name': 'Bob', 'email': 'bob@example.com'}\n]\n\nprint(\"=== Basic Routes ===\")\n\n@app.route('/')\ndef home():\n    \"\"\"Root endpoint\"\"\"\n    return jsonify({\n        'message': 'Welcome to the API',\n        'version': '1.0',\n        'endpoints': {\n            'users': '/api/users',\n            'health': '/api/health'\n        }\n    })\n\n@app.route('/api/health')\ndef health():\n    \"\"\"Health check endpoint\"\"\"\n    return jsonify({'status': 'healthy', 'service': 'user-api'})\n\nprint(\"\\n=== GET - Read Resources ===\")\n\n@app.route('/api/users', methods=['GET'])\ndef get_users():\n    \"\"\"Get all users\"\"\"\n    return jsonify({\n        'users': users,\n        'count': len(users)\n    })\n\n@app.route('/api/users/<int:user_id>', methods=['GET'])\ndef get_user(user_id):\n    \"\"\"Get specific user by ID\"\"\"\n    user = next((u for u in users if u['id'] == user_id), None)\n    \n    if user:\n        return jsonify(user)\n    return jsonify({'error': 'User not found'}), 404\n\nprint(\"\\n=== POST - Create Resources ===\")\n\n@app.route('/api/users', methods=['POST'])\ndef create_user():\n    \"\"\"Create new user\"\"\"\n    data = request.get_json()\n    \n    # Validation\n    if not data or 'name' not in data or 'email' not in data:\n        return jsonify({'error': 'Name and email required'}), 400\n    \n    # Create new user\n    new_user = {\n        'id': max([u['id'] for u in users]) + 1 if users else 1,\n        'name': data['name'],\n        'email': data['email']\n    }\n    \n    users.append(new_user)\n    \n    return jsonify(new_user), 201\n\nprint(\"\\n=== PUT - Update Resources ===\")\n\n@app.route('/api/users/<int:user_id>', methods=['PUT'])\ndef update_user(user_id):\n    \"\"\"Update existing user\"\"\"\n    user = next((u for u in users if u['id'] == user_id), None)\n    \n    if not user:\n        return jsonify({'error': 'User not found'}), 404\n    \n    data = request.get_json()\n    \n    # Update fields if provided\n    if 'name' in data:\n        user['name'] = data['name']\n    if 'email' in data:\n        user['email'] = data['email']\n    \n    return jsonify(user)\n\nprint(\"\\n=== DELETE - Remove Resources ===\")\n\n@app.route('/api/users/<int:user_id>', methods=['DELETE'])\ndef delete_user(user_id):\n    \"\"\"Delete user\"\"\"\n    global users\n    user = next((u for u in users if u['id'] == user_id), None)\n    \n    if not user:\n        return jsonify({'error': 'User not found'}), 404\n    \n    users = [u for u in users if u['id'] != user_id]\n    \n    return jsonify({'message': 'User deleted', 'id': user_id})\n\nprint(\"\\n=== Error Handling ===\")\n\n@app.errorhandler(404)\ndef not_found(error):\n    \"\"\"Handle 404 errors\"\"\"\n    return jsonify({'error': 'Resource not found'}), 404\n\n@app.errorhandler(500)\ndef internal_error(error):\n    \"\"\"Handle 500 errors\"\"\"\n    return jsonify({'error': 'Internal server error'}), 500\n\nif __name__ == '__main__':\n    print(\"\\n=== Starting Flask API ===\")\n    print(\"API will run on http://localhost:5000\")\n    print(\"\\nEndpoints:\")\n    print(\"  GET    /api/users       - List all users\")\n    print(\"  GET    /api/users/<id>  - Get specific user\")\n    print(\"  POST   /api/users       - Create user\")\n    print(\"  PUT    /api/users/<id>  - Update user\")\n    print(\"  DELETE /api/users/<id>  - Delete user\")\n    print(\"\\nNote: Run with 'python app.py' to start server\")\n    \n    # For demonstration, we'll show the structure\n    # In real use: app.run(debug=True)",
              "language": "python"
            },
            {
              "type": "ANALOGY",
              "title": "Syntax Breakdown",
              "content": "**Basic Flask app structure:**\n```python\nfrom flask import Flask, jsonify, request\n\napp = Flask(__name__)\n\n@app.route('/path')\ndef handler():\n    return jsonify({'key': 'value'})\n\nif __name__ == '__main__':\n    app.run(debug=True)\n```\n\n**Route patterns:**\n```python\n# Static route\n@app.route('/users')\n\n# With parameter\n@app.route('/users/<user_id>')\n\n# With type converter\n@app.route('/users/<int:user_id>')\n\n# Multiple methods\n@app.route('/users', methods=['GET', 'POST'])\n```\n\n**Request handling:**\n```python\n# Get JSON data\ndata = request.get_json()\n\n# Get query parameters\npage = request.args.get('page', default=1, type=int)\n\n# Get form data\nname = request.form.get('name')\n\n# Get headers\ntoken = request.headers.get('Authorization')\n```\n\n**Response patterns:**\n```python\n# JSON response\nreturn jsonify(data)\n\n# With status code\nreturn jsonify(data), 201\n\n# With headers\nreturn jsonify(data), 200, {'X-Custom': 'value'}\n```"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example: Advanced Flask Features",
              "content": "**Advanced Flask patterns:**\n\n**1. Query parameters:**\n```python\npage = request.args.get('page', 1, type=int)\nsort = request.args.get('sort', 'name')\n```\n\n**2. Validation:**\n- Check required fields\n- Validate data types\n- Return 400 for invalid data\n\n**3. Decorators:**\n```python\n@require_auth\ndef protected_route():\n    ...\n```\n\n**4. Custom error handlers:**\n```python\n@app.errorhandler(CustomError)\ndef handle_error(e):\n    return jsonify(...), 400\n```\n\n**5. Response helpers:**\n- Consistent response format\n- Easier to maintain\n- Better client experience\n\n**6. API versioning:**\n- /api/v1/... for version 1\n- /api/v2/... for version 2\n- Allows breaking changes",
              "code": "from flask import Flask, jsonify, request, abort\nfrom functools import wraps\nimport re\n\napp = Flask(__name__)\n\n# Sample data\ntasks = [\n    {'id': 1, 'title': 'Learn Python', 'completed': True},\n    {'id': 2, 'title': 'Build API', 'completed': False}\n]\n\nprint(\"=== Query Parameters ===\")\n\n@app.route('/api/tasks')\ndef get_tasks():\n    \"\"\"Get tasks with optional filtering\"\"\"\n    # Get query parameters\n    completed = request.args.get('completed')\n    limit = request.args.get('limit', default=10, type=int)\n    \n    filtered_tasks = tasks\n    \n    # Filter by completed status\n    if completed is not None:\n        is_completed = completed.lower() == 'true'\n        filtered_tasks = [t for t in tasks if t['completed'] == is_completed]\n    \n    # Limit results\n    filtered_tasks = filtered_tasks[:limit]\n    \n    return jsonify({\n        'tasks': filtered_tasks,\n        'count': len(filtered_tasks),\n        'filters': {'completed': completed, 'limit': limit}\n    })\n\nprint(\"\\n=== Request Validation ===\")\n\ndef validate_task(data):\n    \"\"\"Validate task data\"\"\"\n    errors = []\n    \n    if not data:\n        return ['No data provided']\n    \n    if 'title' not in data:\n        errors.append('Title is required')\n    elif len(data['title'].strip()) < 3:\n        errors.append('Title must be at least 3 characters')\n    \n    if 'completed' in data and not isinstance(data['completed'], bool):\n        errors.append('Completed must be boolean')\n    \n    return errors\n\n@app.route('/api/tasks', methods=['POST'])\ndef create_task():\n    \"\"\"Create new task with validation\"\"\"\n    data = request.get_json()\n    \n    # Validate\n    errors = validate_task(data)\n    if errors:\n        return jsonify({'errors': errors}), 400\n    \n    # Create task\n    new_task = {\n        'id': max([t['id'] for t in tasks]) + 1 if tasks else 1,\n        'title': data['title'].strip(),\n        'completed': data.get('completed', False)\n    }\n    \n    tasks.append(new_task)\n    \n    return jsonify(new_task), 201\n\nprint(\"\\n=== Decorators for Authentication ===\")\n\ndef require_api_key(f):\n    \"\"\"Decorator to require API key\"\"\"\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        api_key = request.headers.get('X-API-Key')\n        \n        if not api_key or api_key != 'secret-key-123':\n            return jsonify({'error': 'Invalid or missing API key'}), 401\n        \n        return f(*args, **kwargs)\n    return decorated_function\n\n@app.route('/api/admin/tasks', methods=['DELETE'])\n@require_api_key\ndef delete_all_tasks():\n    \"\"\"Delete all tasks (requires API key)\"\"\"\n    global tasks\n    count = len(tasks)\n    tasks = []\n    \n    return jsonify({'message': f'Deleted {count} tasks'})\n\nprint(\"\\n=== Error Handlers ===\")\n\nclass ValidationError(Exception):\n    \"\"\"Custom validation error\"\"\"\n    pass\n\n@app.errorhandler(ValidationError)\ndef handle_validation_error(error):\n    return jsonify({'error': str(error)}), 400\n\n@app.errorhandler(404)\ndef not_found(error):\n    return jsonify({\n        'error': 'Resource not found',\n        'status': 404\n    }), 404\n\nprint(\"\\n=== Response Helpers ===\")\n\ndef success_response(data, message=None, status=200):\n    \"\"\"Create success response\"\"\"\n    response = {'success': True, 'data': data}\n    if message:\n        response['message'] = message\n    return jsonify(response), status\n\ndef error_response(message, status=400):\n    \"\"\"Create error response\"\"\"\n    return jsonify({\n        'success': False,\n        'error': message\n    }), status\n\n@app.route('/api/tasks/<int:task_id>', methods=['PATCH'])\ndef update_task_partial(task_id):\n    \"\"\"Partially update task\"\"\"\n    task = next((t for t in tasks if t['id'] == task_id), None)\n    \n    if not task:\n        return error_response('Task not found', 404)\n    \n    data = request.get_json()\n    \n    if 'title' in data:\n        task['title'] = data['title']\n    if 'completed' in data:\n        task['completed'] = data['completed']\n    \n    return success_response(task, 'Task updated')\n\nprint(\"\\n=== API Versioning ===\")\n\n@app.route('/api/v1/tasks')\ndef get_tasks_v1():\n    \"\"\"Version 1 of tasks endpoint\"\"\"\n    return jsonify({'version': 1, 'tasks': tasks})\n\n@app.route('/api/v2/tasks')\ndef get_tasks_v2():\n    \"\"\"Version 2 with enhanced response\"\"\"\n    return jsonify({\n        'version': 2,\n        'data': {\n            'tasks': tasks,\n            'total': len(tasks),\n            'completed': len([t for t in tasks if t['completed']]),\n            'pending': len([t for t in tasks if not t['completed']])\n        }\n    })\n\nif __name__ == '__main__':\n    print(\"\\n=== Flask API with Advanced Features ===\")\n    print(\"\\nFeatures demonstrated:\")\n    print(\"  ✓ Query parameters\")\n    print(\"  ✓ Request validation\")\n    print(\"  ✓ Authentication decorator\")\n    print(\"  ✓ Custom error handlers\")\n    print(\"  ✓ Response helpers\")\n    print(\"  ✓ API versioning\")\n    print(\"\\nExample requests:\")\n    print(\"  GET /api/tasks?completed=true&limit=5\")\n    print(\"  POST /api/tasks (with JSON body)\")\n    print(\"  DELETE /api/admin/tasks (requires X-API-Key header)\")",
              "language": "python"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "- **Flask makes APIs easy** - Lightweight, simple decorator-based routing\n- **@app.route() defines endpoints** - URL paths that respond to requests\n- **methods=['GET', 'POST']** - Specify which HTTP methods to accept\n- **request.get_json()** - Get JSON data from request body\n- **jsonify()** - Convert Python dict/list to JSON response\n- **Return status codes** - (data, 201) for created, (error, 404) for not found\n- **Validate input** - Always check required fields and data types\n- **Use decorators for reusable logic** - Authentication, validation, etc."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "13_02-challenge-4",
              "title": "Interactive Exercise",
              "description": "Create a Flask API for a simple blog with:\n- GET /api/posts - List all posts\n- GET /api/posts/<id> - Get specific post\n- POST /api/posts - Create post (requires title and content)\n- DELETE /api/posts/<id> - Delete post\nInclude validation and proper status codes.",
              "instructions": "Create a Flask API for a simple blog with:\n- GET /api/posts - List all posts\n- GET /api/posts/<id> - Get specific post\n- POST /api/posts - Create post (requires title and content)\n- DELETE /api/posts/<id> - Delete post\nInclude validation and proper status codes.",
              "starterCode": "from flask import Flask, jsonify, request\n\napp = Flask(__name__)\nposts = []\n\n# TODO: Implement the endpoints\n\nif __name__ == '__main__':\n    app.run(debug=True)",
              "solution": "",
              "language": "python",
              "testCases": [
                {
                  "description": "Code runs without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use @app.route decorator with methods parameter. Validate required fields. Return appropriate status codes (200, 201, 404, 400)."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "13_03",
          "title": "Database Integration with SQLite",
          "moduleId": "module-13",
          "order": 3,
          "estimatedMinutes": 40,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Concept: Persistent Data Storage",
              "content": "**Databases = Permanent data storage**\n\n**Without database:**\n```python\nusers = []  # Lost when server restarts!\n```\n\n**With database:**\n```python\n# Data persists between restarts\nusers = db.get_all_users()\n```\n\n**Why SQLite?**\n- ✅ Built into Python (no installation)\n- ✅ File-based (easy to use)\n- ✅ Perfect for learning\n- ✅ Great for small/medium apps\n- ✅ No server needed\n\n**SQL Basics:**\n\n**CREATE** - Make tables\n```sql\nCREATE TABLE users (\n    id INTEGER PRIMARY KEY,\n    name TEXT,\n    email TEXT UNIQUE\n)\n```\n\n**INSERT** - Add data\n```sql\nINSERT INTO users (name, email) VALUES ('Alice', 'alice@example.com')\n```\n\n**SELECT** - Read data\n```sql\nSELECT * FROM users WHERE id = 1\n```\n\n**UPDATE** - Modify data\n```sql\nUPDATE users SET name = 'Bob' WHERE id = 1\n```\n\n**DELETE** - Remove data\n```sql\nDELETE FROM users WHERE id = 1\n```"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example: SQLite Basics",
              "content": "**SQLite key concepts:**\n\n**1. Connection:**\n```python\nconn = sqlite3.connect('database.db')\n```\n\n**2. Cursor:**\n```python\ncursor = conn.cursor()\ncursor.execute(\"SQL query\")\n```\n\n**3. Parameterized queries (prevent SQL injection):**\n```python\n# GOOD - uses placeholders\ncursor.execute(\"SELECT * FROM users WHERE id = ?\", (user_id,))\n\n# BAD - vulnerable to SQL injection\ncursor.execute(f\"SELECT * FROM users WHERE id = {user_id}\")\n```\n\n**4. Fetching results:**\n```python\ncursor.fetchone()   # Single row\ncursor.fetchall()   # All rows\ncursor.fetchmany(5) # 5 rows\n```\n\n**5. Commit changes:**\n```python\nconn.commit()  # Save INSERT/UPDATE/DELETE\n```\n\n**6. Row factory:**\n```python\nconn.row_factory = sqlite3.Row\n# Access by name: user['name']\n```",
              "code": "import sqlite3\nimport os\n\nprint(\"=== Creating Database ===\")\n\n# Remove old database if exists\nif os.path.exists('example.db'):\n    os.remove('example.db')\n\n# Connect to database (creates if doesn't exist)\nconn = sqlite3.connect('example.db')\ncursor = conn.cursor()\n\nprint(\"Database created: example.db\")\n\nprint(\"\\n=== Creating Table ===\")\n\ncursor.execute('''\n    CREATE TABLE users (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        name TEXT NOT NULL,\n        email TEXT UNIQUE NOT NULL,\n        age INTEGER,\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    )\n''')\n\nprint(\"Table 'users' created\")\n\nprint(\"\\n=== INSERT - Adding Data ===\")\n\n# Single insert\ncursor.execute(\n    \"INSERT INTO users (name, email, age) VALUES (?, ?, ?)\",\n    ('Alice', 'alice@example.com', 25)\n)\nprint(f\"Inserted user, ID: {cursor.lastrowid}\")\n\n# Multiple inserts\nusers_data = [\n    ('Bob', 'bob@example.com', 30),\n    ('Charlie', 'charlie@example.com', 35),\n    ('Diana', 'diana@example.com', 28)\n]\n\ncursor.executemany(\n    \"INSERT INTO users (name, email, age) VALUES (?, ?, ?)\",\n    users_data\n)\nprint(f\"Inserted {cursor.rowcount} users\")\n\n# Commit changes\nconn.commit()\nprint(\"Changes committed\")\n\nprint(\"\\n=== SELECT - Reading Data ===\")\n\n# Get all users\ncursor.execute(\"SELECT * FROM users\")\nusers = cursor.fetchall()\n\nprint(f\"All users ({len(users)}):\")\nfor user in users:\n    print(f\"  ID: {user[0]}, Name: {user[1]}, Email: {user[2]}, Age: {user[3]}\")\n\n# Get specific user\ncursor.execute(\"SELECT * FROM users WHERE id = ?\", (1,))\nuser = cursor.fetchone()\nprint(f\"\\nUser #1: {user}\")\n\n# Get with WHERE clause\ncursor.execute(\"SELECT name, email FROM users WHERE age > ?\", (28,))\nolder_users = cursor.fetchall()\nprint(f\"\\nUsers older than 28:\")\nfor name, email in older_users:\n    print(f\"  {name} ({email})\")\n\nprint(\"\\n=== UPDATE - Modifying Data ===\")\n\ncursor.execute(\n    \"UPDATE users SET age = ? WHERE name = ?\",\n    (26, 'Alice')\n)\nconn.commit()\nprint(f\"Updated {cursor.rowcount} row(s)\")\n\n# Verify update\ncursor.execute(\"SELECT name, age FROM users WHERE name = 'Alice'\")\nname, age = cursor.fetchone()\nprint(f\"Alice's new age: {age}\")\n\nprint(\"\\n=== DELETE - Removing Data ===\")\n\ncursor.execute(\"DELETE FROM users WHERE id = ?\", (4,))\nconn.commit()\nprint(f\"Deleted {cursor.rowcount} row(s)\")\n\n# Count remaining\ncursor.execute(\"SELECT COUNT(*) FROM users\")\ncount = cursor.fetchone()[0]\nprint(f\"Remaining users: {count}\")\n\nprint(\"\\n=== Using Row Factory ===\")\n\n# Make results dict-like\nconn.row_factory = sqlite3.Row\ncursor = conn.cursor()\n\ncursor.execute(\"SELECT * FROM users LIMIT 1\")\nuser = cursor.fetchone()\n\nprint(\"Accessing by column name:\")\nprint(f\"  Name: {user['name']}\")\nprint(f\"  Email: {user['email']}\")\nprint(f\"  Age: {user['age']}\")\n\n# Close connection\nconn.close()\nprint(\"\\nConnection closed\")\n\nprint(\"\\n=== Context Manager Pattern ===\")\n\ndef get_all_users():\n    \"\"\"Get all users using context manager\"\"\"\n    with sqlite3.connect('example.db') as conn:\n        conn.row_factory = sqlite3.Row\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM users\")\n        return cursor.fetchall()\n\nusers = get_all_users()\nprint(f\"Retrieved {len(users)} users using context manager\")\n\n# Cleanup\nos.remove('example.db')",
              "language": "python"
            },
            {
              "type": "ANALOGY",
              "title": "Syntax Breakdown",
              "content": "**Basic SQLite workflow:**\n\n```python\nimport sqlite3\n\n# 1. Connect\nconn = sqlite3.connect('database.db')\ncursor = conn.cursor()\n\n# 2. Execute SQL\ncursor.execute(\"CREATE TABLE ...\")\ncursor.execute(\"INSERT INTO ...\")\ncursor.execute(\"SELECT ...\")\n\n# 3. Fetch results (SELECT only)\nrows = cursor.fetchall()\n\n# 4. Commit changes (INSERT/UPDATE/DELETE)\nconn.commit()\n\n# 5. Close\nconn.close()\n```\n\n**With context manager (recommended):**\n\n```python\nwith sqlite3.connect('database.db') as conn:\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT ...\")\n    results = cursor.fetchall()\n# Auto-commits and closes\n```\n\n**Common SQL patterns:**\n\n```sql\n-- Create table\nCREATE TABLE table_name (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    column1 TEXT NOT NULL,\n    column2 INTEGER DEFAULT 0\n)\n\n-- Insert\nINSERT INTO table_name (col1, col2) VALUES (?, ?)\n\n-- Select\nSELECT * FROM table_name WHERE condition\nSELECT col1, col2 FROM table_name ORDER BY col1\nSELECT * FROM table_name LIMIT 10\n\n-- Update\nUPDATE table_name SET col1 = ? WHERE id = ?\n\n-- Delete\nDELETE FROM table_name WHERE condition\n```"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example: Flask + SQLite Integration",
              "content": "**Flask + SQLite integration patterns:**\n\n**1. Connection management:**\n```python\ndef get_db():\n    # Store in Flask's g object\n    db = g._database = sqlite3.connect(DB)\n    return db\n\n@app.teardown_appcontext\ndef close_db(exception):\n    # Auto-close after request\n    db = getattr(g, '_database', None)\n    if db:\n        db.close()\n```\n\n**2. Row factory:**\n```python\ndb.row_factory = sqlite3.Row\n# Access columns by name: row['name']\n```\n\n**3. Parameterized queries:**\n```python\n# Always use placeholders (?)\ndb.execute('SELECT * FROM users WHERE id = ?', (user_id,))\n```\n\n**4. Transaction handling:**\n```python\ndb.execute('INSERT ...')\ndb.commit()  # Save changes\n```\n\n**5. Database wrapper class:**\n- Encapsulates database logic\n- Reusable across app\n- Easier to test and maintain",
              "code": "from flask import Flask, jsonify, request, g\nimport sqlite3\nimport os\n\napp = Flask(__name__)\nDATABASE = 'api.db'\n\nprint(\"=== Database Helper Functions ===\")\n\ndef get_db():\n    \"\"\"Get database connection\"\"\"\n    db = getattr(g, '_database', None)\n    if db is None:\n        db = g._database = sqlite3.connect(DATABASE)\n        db.row_factory = sqlite3.Row\n    return db\n\n@app.teardown_appcontext\ndef close_connection(exception):\n    \"\"\"Close database connection at end of request\"\"\"\n    db = getattr(g, '_database', None)\n    if db is not None:\n        db.close()\n\ndef init_db():\n    \"\"\"Initialize database with schema\"\"\"\n    with app.app_context():\n        db = get_db()\n        db.execute('''\n            CREATE TABLE IF NOT EXISTS tasks (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                title TEXT NOT NULL,\n                description TEXT,\n                completed BOOLEAN DEFAULT 0,\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n            )\n        ''')\n        db.commit()\n        print(\"Database initialized\")\n\nprint(\"\\n=== API Endpoints with Database ===\")\n\n@app.route('/api/tasks', methods=['GET'])\ndef get_tasks():\n    \"\"\"Get all tasks\"\"\"\n    db = get_db()\n    cursor = db.execute('''\n        SELECT id, title, description, completed, created_at \n        FROM tasks \n        ORDER BY created_at DESC\n    ''')\n    \n    tasks = [\n        {\n            'id': row['id'],\n            'title': row['title'],\n            'description': row['description'],\n            'completed': bool(row['completed']),\n            'created_at': row['created_at']\n        }\n        for row in cursor.fetchall()\n    ]\n    \n    return jsonify({'tasks': tasks, 'count': len(tasks)})\n\n@app.route('/api/tasks/<int:task_id>', methods=['GET'])\ndef get_task(task_id):\n    \"\"\"Get specific task\"\"\"\n    db = get_db()\n    cursor = db.execute(\n        'SELECT * FROM tasks WHERE id = ?',\n        (task_id,)\n    )\n    row = cursor.fetchone()\n    \n    if not row:\n        return jsonify({'error': 'Task not found'}), 404\n    \n    task = {\n        'id': row['id'],\n        'title': row['title'],\n        'description': row['description'],\n        'completed': bool(row['completed']),\n        'created_at': row['created_at']\n    }\n    \n    return jsonify(task)\n\n@app.route('/api/tasks', methods=['POST'])\ndef create_task():\n    \"\"\"Create new task\"\"\"\n    data = request.get_json()\n    \n    if not data or 'title' not in data:\n        return jsonify({'error': 'Title is required'}), 400\n    \n    db = get_db()\n    cursor = db.execute(\n        'INSERT INTO tasks (title, description, completed) VALUES (?, ?, ?)',\n        (data['title'], data.get('description', ''), data.get('completed', False))\n    )\n    db.commit()\n    \n    # Get the created task\n    cursor = db.execute('SELECT * FROM tasks WHERE id = ?', (cursor.lastrowid,))\n    row = cursor.fetchone()\n    \n    task = {\n        'id': row['id'],\n        'title': row['title'],\n        'description': row['description'],\n        'completed': bool(row['completed']),\n        'created_at': row['created_at']\n    }\n    \n    return jsonify(task), 201\n\n@app.route('/api/tasks/<int:task_id>', methods=['PUT'])\ndef update_task(task_id):\n    \"\"\"Update task\"\"\"\n    db = get_db()\n    \n    # Check if task exists\n    cursor = db.execute('SELECT id FROM tasks WHERE id = ?', (task_id,))\n    if not cursor.fetchone():\n        return jsonify({'error': 'Task not found'}), 404\n    \n    data = request.get_json()\n    \n    # Update task\n    db.execute(\n        '''UPDATE tasks \n           SET title = ?, description = ?, completed = ?\n           WHERE id = ?''',\n        (data.get('title'), data.get('description'), \n         data.get('completed', False), task_id)\n    )\n    db.commit()\n    \n    # Return updated task\n    cursor = db.execute('SELECT * FROM tasks WHERE id = ?', (task_id,))\n    row = cursor.fetchone()\n    \n    task = {\n        'id': row['id'],\n        'title': row['title'],\n        'description': row['description'],\n        'completed': bool(row['completed']),\n        'created_at': row['created_at']\n    }\n    \n    return jsonify(task)\n\n@app.route('/api/tasks/<int:task_id>', methods=['DELETE'])\ndef delete_task(task_id):\n    \"\"\"Delete task\"\"\"\n    db = get_db()\n    cursor = db.execute('DELETE FROM tasks WHERE id = ?', (task_id,))\n    db.commit()\n    \n    if cursor.rowcount == 0:\n        return jsonify({'error': 'Task not found'}), 404\n    \n    return jsonify({'message': 'Task deleted', 'id': task_id})\n\nprint(\"\\n=== Database Class Wrapper ===\")\n\nclass TaskDatabase:\n    \"\"\"Database wrapper class\"\"\"\n    \n    def __init__(self, db_path):\n        self.db_path = db_path\n    \n    def get_connection(self):\n        conn = sqlite3.connect(self.db_path)\n        conn.row_factory = sqlite3.Row\n        return conn\n    \n    def get_all(self):\n        with self.get_connection() as conn:\n            cursor = conn.execute('SELECT * FROM tasks ORDER BY created_at DESC')\n            return [dict(row) for row in cursor.fetchall()]\n    \n    def get_by_id(self, task_id):\n        with self.get_connection() as conn:\n            cursor = conn.execute('SELECT * FROM tasks WHERE id = ?', (task_id,))\n            row = cursor.fetchone()\n            return dict(row) if row else None\n    \n    def create(self, title, description='', completed=False):\n        with self.get_connection() as conn:\n            cursor = conn.execute(\n                'INSERT INTO tasks (title, description, completed) VALUES (?, ?, ?)',\n                (title, description, completed)\n            )\n            conn.commit()\n            return cursor.lastrowid\n    \n    def update(self, task_id, title=None, description=None, completed=None):\n        with self.get_connection() as conn:\n            if title is not None:\n                conn.execute('UPDATE tasks SET title = ? WHERE id = ?', (title, task_id))\n            if description is not None:\n                conn.execute('UPDATE tasks SET description = ? WHERE id = ?', (description, task_id))\n            if completed is not None:\n                conn.execute('UPDATE tasks SET completed = ? WHERE id = ?', (completed, task_id))\n            conn.commit()\n    \n    def delete(self, task_id):\n        with self.get_connection() as conn:\n            cursor = conn.execute('DELETE FROM tasks WHERE id = ?', (task_id,))\n            conn.commit()\n            return cursor.rowcount > 0\n\nif __name__ == '__main__':\n    print(\"\\n=== Flask + SQLite API ===\")\n    print(\"Initializing database...\")\n    \n    # Remove old database\n    if os.path.exists(DATABASE):\n        os.remove(DATABASE)\n    \n    init_db()\n    \n    print(\"\\nAPI endpoints:\")\n    print(\"  GET    /api/tasks       - List all tasks\")\n    print(\"  GET    /api/tasks/<id>  - Get task\")\n    print(\"  POST   /api/tasks       - Create task\")\n    print(\"  PUT    /api/tasks/<id>  - Update task\")\n    print(\"  DELETE /api/tasks/<id>  - Delete task\")\n    print(\"\\nDatabase wrapper class also demonstrated\")\n    print(\"\\nRun with: python app.py\")\n    \n    # Cleanup\n    if os.path.exists(DATABASE):\n        os.remove(DATABASE)",
              "language": "python"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "- **SQLite is file-based** - No server needed, perfect for small apps\n- **Use placeholders (?)** - Prevent SQL injection, never use f-strings\n- **Context managers for connections** - with sqlite3.connect() as conn:\n- **Commit changes** - conn.commit() after INSERT/UPDATE/DELETE\n- **Row factory for dict-like access** - conn.row_factory = sqlite3.Row\n- **Validate before database ops** - Check required fields first\n- **fetchone() vs fetchall()** - one() for single row, all() for multiple\n- **AUTOINCREMENT for IDs** - Let database handle ID generation"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "13_03-challenge-4",
              "title": "Interactive Exercise",
              "description": "Create a database-backed Flask API for a simple notes app:\n- Table: notes (id, title, content, created_at)\n- Endpoints: GET all, GET by id, POST create, DELETE\n- Use context manager for database connections\n- Return proper status codes",
              "instructions": "Create a database-backed Flask API for a simple notes app:\n- Table: notes (id, title, content, created_at)\n- Endpoints: GET all, GET by id, POST create, DELETE\n- Use context manager for database connections\n- Return proper status codes",
              "starterCode": "from flask import Flask, jsonify, request\nimport sqlite3\n\napp = Flask(__name__)\nDATABASE = 'notes.db'\n\n# TODO: Initialize database with notes table\n\n# TODO: Implement GET /api/notes\n\n# TODO: Implement GET /api/notes/<id>\n\n# TODO: Implement POST /api/notes\n\n# TODO: Implement DELETE /api/notes/<id>\n\nif __name__ == '__main__':\n    app.run(debug=True)",
              "solution": "",
              "language": "python",
              "testCases": [
                {
                  "description": "Code runs without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use 'with sqlite3.connect(DATABASE) as conn:' for connections. Set row_factory to sqlite3.Row. Use execute with placeholders (?)."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "13_04",
          "title": "Authentication and API Security",
          "moduleId": "module-13",
          "order": 4,
          "estimatedMinutes": 45,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Concept: Securing Your API",
              "content": "**API Security = Protecting your data and endpoints**\n\n**Think of it like a building:**\n- **No Security:** Anyone can walk in and do anything\n- **API Key:** Guests need a key card to enter\n- **JWT Token:** Temporary access badge with permissions\n- **Password Hashing:** Storing passwords safely (not plain text)\n\n**Authentication Methods:**\n\n**1. API Keys** 🔑\n- Simple key in header\n- Good for: Server-to-server communication\n- Example: `X-API-Key: secret-key-123`\n\n**2. JWT (JSON Web Tokens)** 🎫\n- Encoded token with user info\n- Good for: User authentication\n- Expires after time limit\n- Contains: user ID, permissions, expiration\n\n**3. Basic Auth** 🔒\n- Username:password in header\n- Simple but less secure\n- Should use HTTPS\n\n**Security Best Practices:**\n\n1. **Never store plain passwords** - Always hash\n2. **Use HTTPS** - Encrypt data in transit\n3. **Validate all input** - Prevent injection attacks\n4. **Rate limiting** - Prevent abuse\n5. **CORS** - Control which domains can access API\n6. **Token expiration** - Tokens should expire\n7. **Least privilege** - Give minimum permissions needed"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example: API Key Authentication",
              "content": "**Security implementation patterns:**\n\n**1. API Key Authentication:**\n```python\n@require_api_key\ndef protected_route():\n    # Only accessible with valid API key\n    pass\n```\n\n**2. Password Hashing:**\n```python\n# NEVER store plain passwords!\nhashed = hash_password(password)  # Store this\nif verify_password(stored, provided):\n    # Password correct\n```\n\n**3. Rate Limiting:**\n- Track requests per time window\n- Return 429 when limit exceeded\n- Prevents abuse and DoS attacks\n\n**4. CORS:**\n- Controls which domains can access API\n- Required for browser-based clients\n- Set appropriate origins in production\n\n**5. Input Validation:**\n- Validate format (email, etc.)\n- Sanitize to prevent injection\n- Limit length to prevent overflow\n\n**6. Permission-based Access:**\n- Different API keys have different permissions\n- Check permissions before allowing actions",
              "code": "from flask import Flask, jsonify, request\nfrom functools import wraps\nimport secrets\nimport hashlib\nfrom datetime import datetime, timedelta\n\napp = Flask(__name__)\n\n# Simulated API keys database\nAPI_KEYS = {\n    'dev-key-123': {'name': 'Development', 'permissions': ['read', 'write']},\n    'readonly-456': {'name': 'ReadOnly', 'permissions': ['read']}\n}\n\nprint(\"=== API Key Authentication ===\")\n\ndef require_api_key(f):\n    \"\"\"Decorator to require valid API key\"\"\"\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        api_key = request.headers.get('X-API-Key')\n        \n        if not api_key:\n            return jsonify({'error': 'API key required'}), 401\n        \n        if api_key not in API_KEYS:\n            return jsonify({'error': 'Invalid API key'}), 401\n        \n        # Store key info in request context\n        request.api_key_info = API_KEYS[api_key]\n        \n        return f(*args, **kwargs)\n    return decorated_function\n\ndef require_permission(permission):\n    \"\"\"Decorator to require specific permission\"\"\"\n    def decorator(f):\n        @wraps(f)\n        def decorated_function(*args, **kwargs):\n            if permission not in request.api_key_info['permissions']:\n                return jsonify({'error': f'Permission denied: {permission} required'}), 403\n            return f(*args, **kwargs)\n        return decorated_function\n    return decorator\n\n@app.route('/api/public')\ndef public():\n    \"\"\"Public endpoint - no auth required\"\"\"\n    return jsonify({'message': 'This is public'})\n\n@app.route('/api/protected')\n@require_api_key\ndef protected():\n    \"\"\"Protected endpoint - requires API key\"\"\"\n    return jsonify({\n        'message': 'You have access!',\n        'key_name': request.api_key_info['name']\n    })\n\n@app.route('/api/admin')\n@require_api_key\n@require_permission('write')\ndef admin():\n    \"\"\"Admin endpoint - requires write permission\"\"\"\n    return jsonify({\n        'message': 'Admin access granted',\n        'permissions': request.api_key_info['permissions']\n    })\n\nprint(\"\\n=== Password Hashing ===\")\n\nimport hashlib\nimport os\n\ndef hash_password(password):\n    \"\"\"Hash password with salt\"\"\"\n    # Generate random salt\n    salt = os.urandom(32)\n    \n    # Hash password with salt\n    pwdhash = hashlib.pbkdf2_hmac(\n        'sha256',\n        password.encode('utf-8'),\n        salt,\n        100000  # Number of iterations\n    )\n    \n    # Return salt + hash\n    return salt + pwdhash\n\ndef verify_password(stored_password, provided_password):\n    \"\"\"Verify password against hash\"\"\"\n    # Extract salt (first 32 bytes)\n    salt = stored_password[:32]\n    stored_hash = stored_password[32:]\n    \n    # Hash provided password with same salt\n    pwdhash = hashlib.pbkdf2_hmac(\n        'sha256',\n        provided_password.encode('utf-8'),\n        salt,\n        100000\n    )\n    \n    # Compare hashes\n    return pwdhash == stored_hash\n\n# Demo password hashing\noriginal_password = \"MySecurePassword123!\"\nprint(f\"Original password: {original_password}\")\n\nhashed = hash_password(original_password)\nprint(f\"Hashed password length: {len(hashed)} bytes\")\nprint(f\"First 10 bytes (salt): {hashed[:10].hex()}...\")\n\n# Verify correct password\nif verify_password(hashed, original_password):\n    print(\"✓ Correct password verified\")\n\n# Verify wrong password\nif not verify_password(hashed, \"WrongPassword\"):\n    print(\"✗ Wrong password rejected\")\n\nprint(\"\\n=== Rate Limiting ===\")\n\nfrom collections import defaultdict\nimport time\n\nclass RateLimiter:\n    \"\"\"Simple rate limiter\"\"\"\n    \n    def __init__(self, max_requests=10, window=60):\n        self.max_requests = max_requests\n        self.window = window  # Time window in seconds\n        self.requests = defaultdict(list)\n    \n    def is_allowed(self, key):\n        \"\"\"Check if request is allowed\"\"\"\n        now = time.time()\n        \n        # Remove old requests\n        self.requests[key] = [\n            req_time for req_time in self.requests[key]\n            if now - req_time < self.window\n        ]\n        \n        # Check limit\n        if len(self.requests[key]) >= self.max_requests:\n            return False\n        \n        # Record this request\n        self.requests[key].append(now)\n        return True\n\nrate_limiter = RateLimiter(max_requests=5, window=60)\n\ndef rate_limit(f):\n    \"\"\"Decorator for rate limiting\"\"\"\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        # Use API key or IP as identifier\n        api_key = request.headers.get('X-API-Key', 'anonymous')\n        \n        if not rate_limiter.is_allowed(api_key):\n            return jsonify({\n                'error': 'Rate limit exceeded',\n                'retry_after': 60\n            }), 429\n        \n        return f(*args, **kwargs)\n    return decorated_function\n\n@app.route('/api/limited')\n@rate_limit\ndef limited():\n    \"\"\"Rate limited endpoint\"\"\"\n    return jsonify({'message': 'Request successful'})\n\nprint(\"\\n=== CORS (Cross-Origin Resource Sharing) ===\")\n\nfrom flask_cors import CORS\n\n# Enable CORS for all routes\n# CORS(app)\n\n# Or enable for specific origins\n# CORS(app, origins=['https://yourdomain.com'])\n\n# Manual CORS headers\n@app.after_request\ndef add_cors_headers(response):\n    \"\"\"Add CORS headers to response\"\"\"\n    response.headers['Access-Control-Allow-Origin'] = '*'\n    response.headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE, OPTIONS'\n    response.headers['Access-Control-Allow-Headers'] = 'Content-Type, X-API-Key'\n    return response\n\nprint(\"\\n=== Input Validation ===\")\n\nimport re\n\ndef validate_email(email):\n    \"\"\"Validate email format\"\"\"\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return bool(re.match(pattern, email))\n\ndef sanitize_input(text, max_length=200):\n    \"\"\"Sanitize user input\"\"\"\n    # Strip whitespace\n    text = text.strip()\n    \n    # Limit length\n    text = text[:max_length]\n    \n    # Remove potentially dangerous characters\n    # (In real app, use proper HTML escaping)\n    dangerous_chars = ['<', '>', '&', '\"', \"'\"]\n    for char in dangerous_chars:\n        text = text.replace(char, '')\n    \n    return text\n\n@app.route('/api/users', methods=['POST'])\n@require_api_key\ndef create_user():\n    \"\"\"Create user with validation\"\"\"\n    data = request.get_json()\n    \n    # Validate required fields\n    if not data or 'email' not in data or 'name' not in data:\n        return jsonify({'error': 'Email and name required'}), 400\n    \n    # Validate email\n    if not validate_email(data['email']):\n        return jsonify({'error': 'Invalid email format'}), 400\n    \n    # Sanitize inputs\n    name = sanitize_input(data['name'])\n    email = data['email'].lower().strip()\n    \n    return jsonify({\n        'message': 'User created',\n        'user': {'name': name, 'email': email}\n    }), 201\n\nif __name__ == '__main__':\n    print(\"\\n=== Security Features Demo ===\")\n    print(\"\\nFeatures implemented:\")\n    print(\"  ✓ API key authentication\")\n    print(\"  ✓ Permission-based access control\")\n    print(\"  ✓ Password hashing (PBKDF2)\")\n    print(\"  ✓ Rate limiting\")\n    print(\"  ✓ CORS headers\")\n    print(\"  ✓ Input validation and sanitization\")\n    print(\"\\nExample requests:\")\n    print(\"  curl -H 'X-API-Key: dev-key-123' http://localhost:5000/api/protected\")\n    print(\"  curl -H 'X-API-Key: readonly-456' http://localhost:5000/api/admin\")\n    print(\"\\nNote: Use flask-cors package for production CORS handling\")",
              "language": "python"
            },
            {
              "type": "ANALOGY",
              "title": "Syntax Breakdown",
              "content": "**API Key Authentication Pattern:**\n\n```python\ndef require_api_key(f):\n    @wraps(f)\n    def wrapper(*args, **kwargs):\n        key = request.headers.get('X-API-Key')\n        if key not in VALID_KEYS:\n            return jsonify({'error': 'Unauthorized'}), 401\n        return f(*args, **kwargs)\n    return wrapper\n\n@app.route('/protected')\n@require_api_key\ndef protected():\n    return jsonify({'data': 'secret'})\n```\n\n**Password Hashing:**\n\n```python\nimport hashlib\nimport os\n\n# Hash password with salt\nsalt = os.urandom(32)\nhashed = hashlib.pbkdf2_hmac('sha256', password.encode(), salt, 100000)\nstored = salt + hashed  # Store this\n\n# Verify password\nsalt = stored[:32]\nstored_hash = stored[32:]\ntest_hash = hashlib.pbkdf2_hmac('sha256', provided.encode(), salt, 100000)\nif test_hash == stored_hash:\n    # Password correct\n```\n\n**Rate Limiting:**\n\n```python\nfrom collections import defaultdict\nimport time\n\nrequests = defaultdict(list)\n\ndef is_rate_limited(key, max_requests=10, window=60):\n    now = time.time()\n    requests[key] = [t for t in requests[key] if now - t < window]\n    if len(requests[key]) >= max_requests:\n        return True\n    requests[key].append(now)\n    return False\n```\n\n**CORS Headers:**\n\n```python\n@app.after_request\ndef add_cors(response):\n    response.headers['Access-Control-Allow-Origin'] = '*'\n    response.headers['Access-Control-Allow-Methods'] = 'GET, POST'\n    return response\n```"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example: JWT Token Authentication",
              "content": "**JWT Authentication Flow:**\n\n**1. Login:**\n```\nUser → POST /api/login (email, password)\nAPI → Verify credentials\nAPI → Create JWT token\nAPI → Return token to user\n```\n\n**2. Authenticated Request:**\n```\nUser → GET /api/protected\nHeader: Authorization: Bearer <token>\nAPI → Decode token\nAPI → Verify signature and expiration\nAPI → Process request\n```\n\n**3. Token Structure:**\n```json\n{\n  \"user_id\": 1,\n  \"role\": \"admin\",\n  \"exp\": 1234567890,  // Expiration timestamp\n  \"iat\": 1234567000   // Issued at timestamp\n}\n```\n\n**Security Benefits:**\n- Stateless (no server-side sessions)\n- Self-contained (user info in token)\n- Expires automatically\n- Can't be modified without secret key\n- Works across multiple servers\n\n**Best Practices:**\n- Short expiration (1-24 hours)\n- HTTPS only\n- Secure secret key\n- Include minimal info in payload\n- Implement token refresh",
              "code": "from flask import Flask, jsonify, request\nimport jwt\nfrom datetime import datetime, timedelta\nfrom functools import wraps\nimport hashlib\nimport os\n\napp = Flask(__name__)\napp.config['SECRET_KEY'] = 'your-secret-key-change-this-in-production'\n\n# Simulated user database\nUSERS = {\n    'alice@example.com': {\n        'id': 1,\n        'name': 'Alice',\n        'password_hash': None,  # Will be set below\n        'role': 'admin'\n    },\n    'bob@example.com': {\n        'id': 2,\n        'name': 'Bob',\n        'password_hash': None,\n        'role': 'user'\n    }\n}\n\nprint(\"=== JWT Token Authentication ===\")\n\ndef hash_password(password):\n    \"\"\"Simple password hashing for demo\"\"\"\n    salt = b'demo-salt-change-in-production'\n    return hashlib.pbkdf2_hmac('sha256', password.encode(), salt, 100000)\n\n# Set passwords\nUSERS['alice@example.com']['password_hash'] = hash_password('password123')\nUSERS['bob@example.com']['password_hash'] = hash_password('password456')\n\ndef create_token(user_id, role):\n    \"\"\"Create JWT token\"\"\"\n    payload = {\n        'user_id': user_id,\n        'role': role,\n        'exp': datetime.utcnow() + timedelta(hours=24),  # Expires in 24 hours\n        'iat': datetime.utcnow()  # Issued at\n    }\n    \n    token = jwt.encode(\n        payload,\n        app.config['SECRET_KEY'],\n        algorithm='HS256'\n    )\n    \n    return token\n\ndef decode_token(token):\n    \"\"\"Decode and validate JWT token\"\"\"\n    try:\n        payload = jwt.decode(\n            token,\n            app.config['SECRET_KEY'],\n            algorithms=['HS256']\n        )\n        return payload\n    except jwt.ExpiredSignatureError:\n        return None  # Token expired\n    except jwt.InvalidTokenError:\n        return None  # Invalid token\n\ndef token_required(f):\n    \"\"\"Decorator to require valid JWT token\"\"\"\n    @wraps(f)\n    def decorated(*args, **kwargs):\n        token = None\n        \n        # Get token from header\n        if 'Authorization' in request.headers:\n            auth_header = request.headers['Authorization']\n            # Format: \"Bearer <token>\"\n            parts = auth_header.split()\n            if len(parts) == 2 and parts[0] == 'Bearer':\n                token = parts[1]\n        \n        if not token:\n            return jsonify({'error': 'Token required'}), 401\n        \n        # Decode token\n        payload = decode_token(token)\n        if not payload:\n            return jsonify({'error': 'Invalid or expired token'}), 401\n        \n        # Store user info in request\n        request.current_user = payload\n        \n        return f(*args, **kwargs)\n    return decorated\n\ndef admin_required(f):\n    \"\"\"Decorator to require admin role\"\"\"\n    @wraps(f)\n    def decorated(*args, **kwargs):\n        if request.current_user.get('role') != 'admin':\n            return jsonify({'error': 'Admin access required'}), 403\n        return f(*args, **kwargs)\n    return decorated\n\n@app.route('/api/login', methods=['POST'])\ndef login():\n    \"\"\"Login endpoint - returns JWT token\"\"\"\n    data = request.get_json()\n    \n    if not data or 'email' not in data or 'password' not in data:\n        return jsonify({'error': 'Email and password required'}), 400\n    \n    email = data['email']\n    password = data['password']\n    \n    # Find user\n    user = USERS.get(email)\n    if not user:\n        return jsonify({'error': 'Invalid credentials'}), 401\n    \n    # Verify password\n    password_hash = hash_password(password)\n    if password_hash != user['password_hash']:\n        return jsonify({'error': 'Invalid credentials'}), 401\n    \n    # Create token\n    token = create_token(user['id'], user['role'])\n    \n    return jsonify({\n        'message': 'Login successful',\n        'token': token,\n        'user': {\n            'id': user['id'],\n            'name': user['name'],\n            'email': email,\n            'role': user['role']\n        }\n    })\n\n@app.route('/api/me', methods=['GET'])\n@token_required\ndef get_current_user():\n    \"\"\"Get current user info from token\"\"\"\n    return jsonify({\n        'user_id': request.current_user['user_id'],\n        'role': request.current_user['role']\n    })\n\n@app.route('/api/admin/users', methods=['GET'])\n@token_required\n@admin_required\ndef admin_get_users():\n    \"\"\"Admin only endpoint\"\"\"\n    users_list = [\n        {'id': u['id'], 'name': u['name'], 'role': u['role']}\n        for email, u in USERS.items()\n    ]\n    return jsonify({'users': users_list})\n\n@app.route('/api/refresh', methods=['POST'])\n@token_required\ndef refresh_token():\n    \"\"\"Refresh token endpoint\"\"\"\n    # Create new token with same user info\n    new_token = create_token(\n        request.current_user['user_id'],\n        request.current_user['role']\n    )\n    \n    return jsonify({\n        'message': 'Token refreshed',\n        'token': new_token\n    })\n\nprint(\"\\n=== Complete Security Example ===\")\n\nclass SecureAPI:\n    \"\"\"Complete API with all security features\"\"\"\n    \n    def __init__(self):\n        self.app = Flask(__name__)\n        self.app.config['SECRET_KEY'] = os.urandom(32)\n        self.users = {}\n        self.sessions = {}\n        self.setup_routes()\n    \n    def hash_password(self, password):\n        salt = os.urandom(32)\n        hash_obj = hashlib.pbkdf2_hmac('sha256', password.encode(), salt, 100000)\n        return salt + hash_obj\n    \n    def verify_password(self, stored, provided):\n        salt = stored[:32]\n        stored_hash = stored[32:]\n        test_hash = hashlib.pbkdf2_hmac('sha256', provided.encode(), salt, 100000)\n        return test_hash == stored_hash\n    \n    def create_session_token(self, user_id):\n        token = secrets.token_urlsafe(32)\n        self.sessions[token] = {\n            'user_id': user_id,\n            'created_at': datetime.utcnow(),\n            'expires_at': datetime.utcnow() + timedelta(hours=24)\n        }\n        return token\n    \n    def validate_session(self, token):\n        session = self.sessions.get(token)\n        if not session:\n            return None\n        if datetime.utcnow() > session['expires_at']:\n            del self.sessions[token]\n            return None\n        return session\n    \n    def setup_routes(self):\n        @self.app.route('/api/register', methods=['POST'])\n        def register():\n            data = request.get_json()\n            \n            # Validation\n            if not data or 'email' not in data or 'password' not in data:\n                return jsonify({'error': 'Email and password required'}), 400\n            \n            if len(data['password']) < 8:\n                return jsonify({'error': 'Password must be at least 8 characters'}), 400\n            \n            email = data['email'].lower().strip()\n            \n            if email in self.users:\n                return jsonify({'error': 'User already exists'}), 409\n            \n            # Create user\n            self.users[email] = {\n                'id': len(self.users) + 1,\n                'email': email,\n                'password_hash': self.hash_password(data['password']),\n                'created_at': datetime.utcnow().isoformat()\n            }\n            \n            return jsonify({\n                'message': 'User created successfully',\n                'user': {'id': self.users[email]['id'], 'email': email}\n            }), 201\n\nif __name__ == '__main__':\n    print(\"\\n=== JWT Authentication API ===\")\n    print(\"\\nEndpoints:\")\n    print(\"  POST /api/login        - Login and get token\")\n    print(\"  GET  /api/me           - Get current user (requires token)\")\n    print(\"  GET  /api/admin/users  - Admin only (requires admin token)\")\n    print(\"  POST /api/refresh      - Refresh token\")\n    print(\"\\nExample login:\")\n    print('  POST /api/login')\n    print('  {\"email\": \"alice@example.com\", \"password\": \"password123\"}')\n    print(\"\\nExample authenticated request:\")\n    print('  GET /api/me')\n    print('  Header: Authorization: Bearer <token>')\n    print(\"\\nSecurity features:\")\n    print(\"  ✓ JWT tokens with expiration\")\n    print(\"  ✓ Password hashing\")\n    print(\"  ✓ Role-based access control\")\n    print(\"  ✓ Token refresh mechanism\")\n    print(\"  ✓ Decorator-based auth\")",
              "language": "python"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "- **Never store plain passwords** - Always hash with salt (PBKDF2, bcrypt)\n- **JWT tokens for authentication** - Self-contained, stateless, expire automatically\n- **Use decorators for auth** - @require_api_key, @token_required\n- **Validate all input** - Email format, password strength, data sanitization\n- **Rate limiting prevents abuse** - Track requests per time window\n- **CORS for browser clients** - Control which domains can access API\n- **HTTPS in production** - Encrypt data in transit\n- **Principle of least privilege** - Give minimum permissions needed"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "13_04-challenge-4",
              "title": "Interactive Exercise",
              "description": "Create a secure user registration and login system:\n- POST /api/register - Create user with hashed password\n- POST /api/login - Login with email/password, return JWT token\n- GET /api/profile - Get user profile (requires token)\n- Validate email format and password strength (min 8 chars)\n- Hash passwords before storing",
              "instructions": "Create a secure user registration and login system:\n- POST /api/register - Create user with hashed password\n- POST /api/login - Login with email/password, return JWT token\n- GET /api/profile - Get user profile (requires token)\n- Validate email format and password strength (min 8 chars)\n- Hash passwords before storing",
              "starterCode": "from flask import Flask, jsonify, request\nimport jwt\nimport hashlib\nimport os\nfrom datetime import datetime, timedelta\n\napp = Flask(__name__)\napp.config['SECRET_KEY'] = 'change-this-secret-key'\n\nusers = {}  # In-memory user storage\n\n# TODO: Implement password hashing\ndef hash_password(password):\n    pass\n\n# TODO: Implement password verification\ndef verify_password(stored_hash, provided_password):\n    pass\n\n# TODO: Implement JWT token creation\ndef create_token(user_id):\n    pass\n\n# TODO: Implement /api/register endpoint\n\n# TODO: Implement /api/login endpoint\n\n# TODO: Implement /api/profile endpoint with token verification\n\nif __name__ == '__main__':\n    app.run(debug=True)",
              "solution": "",
              "language": "python",
              "testCases": [
                {
                  "description": "Code runs without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use hashlib.pbkdf2_hmac for password hashing. Use jwt.encode() for tokens. Check Authorization header for Bearer token."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        }
      ],
      "quizzes": [
        {
          "id": "quiz-13",
          "title": "Module 13: Web Development & APIs - Comprehensive Quiz",
          "description": "Test your understanding of HTTP, REST APIs, Flask, databases, authentication, security, and API testing. 70% required to pass.",
          "moduleId": "module-13",
          "passingScore": 70,
          "estimatedMinutes": 15,
          "questions": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-13-q1",
              "title": "What does REST stand for in REST API?",
              "description": "What does REST stand for in REST API?",
              "options": [
                "Remote Execution Service Technology",
                "Representational State Transfer",
                "Request-Response State Transaction",
                "Reusable External Service Template"
              ],
              "correctAnswer": 1,
              "explanation": "REST stands for Representational State Transfer. It's an architectural style for designing networked applications using standard HTTP methods."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-13-q2",
              "title": "Which HTTP method should be used to update an existing resource?",
              "description": "Which HTTP method should be used to update an existing resource?",
              "options": [
                "GET",
                "POST",
                "PUT or PATCH",
                "DELETE"
              ],
              "correctAnswer": 2,
              "explanation": "PUT (full update) or PATCH (partial update) are used to modify existing resources. POST creates new resources, GET retrieves data, DELETE removes resources."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-13-q3",
              "title": "What status code should an API return when a resource is successfully created?",
              "description": "What status code should an API return when a resource is successfully created?",
              "options": [
                "200 OK",
                "201 Created",
                "204 No Content",
                "301 Moved Permanently"
              ],
              "correctAnswer": 1,
              "explanation": "201 Created indicates successful resource creation. 200 OK is for general success, 204 for successful deletion with no content, 301 for redirects."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-13-q4",
              "title": "In the requests library, how do you send JSON data in a POST request?",
              "description": "In the requests library, how do you send JSON data in a POST request?",
              "options": [
                "requests.post(url, data={'key': 'value'})",
                "requests.post(url, json={'key': 'value'})",
                "requests.post(url, body={'key': 'value'})",
                "requests.post(url, payload={'key': 'value'})"
              ],
              "correctAnswer": 1,
              "explanation": "Use json={'key': 'value'} parameter. The requests library automatically serializes the dictionary to JSON and sets the Content-Type header."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-13-q5",
              "title": "What is the purpose of response.raise_for_status() in the requests library?",
              "description": "What is the purpose of response.raise_for_status() in the requests library?",
              "options": [
                "It returns the HTTP status code",
                "It raises an exception if the request failed (4xx or 5xx status)",
                "It checks if the response is valid JSON",
                "It validates the response headers"
              ],
              "correctAnswer": 1,
              "explanation": "raise_for_status() raises an HTTPError exception if the status code indicates an error (400-599), making it easy to catch and handle API errors."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-13-q6",
              "title": "In Flask, how do you define a route that handles POST requests?",
              "description": "In Flask, how do you define a route that handles POST requests?",
              "options": [
                "@app.route('/path', method='POST')",
                "@app.route('/path', methods=['POST'])",
                "@app.post('/path')",
                "Both B and C are correct"
              ],
              "correctAnswer": 3,
              "explanation": "Both @app.route('/path', methods=['POST']) and @app.post('/path') work in Flask. The methods parameter accepts a list of HTTP methods."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-13-q7",
              "title": "How do you get JSON data from a request in Flask?",
              "description": "How do you get JSON data from a request in Flask?",
              "options": [
                "request.json()",
                "request.get_json()",
                "request.data.json()",
                "request.json"
              ],
              "correctAnswer": 1,
              "explanation": "request.get_json() parses the request body as JSON and returns a Python dictionary. It returns None if the request doesn't contain valid JSON."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-13-q8",
              "title": "What does the jsonify() function do in Flask?",
              "description": "What does the jsonify() function do in Flask?",
              "options": [
                "Converts a string to JSON",
                "Creates a Response object with JSON data and proper Content-Type header",
                "Validates JSON data",
                "Parses incoming JSON requests"
              ],
              "correctAnswer": 1,
              "explanation": "jsonify() creates a Flask Response object with JSON-serialized data and sets Content-Type to application/json. It's the proper way to return JSON from Flask routes."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-13-q9",
              "title": "What's the main advantage of using parameterized queries (? placeholders) in SQL?",
              "description": "What's the main advantage of using parameterized queries (? placeholders) in SQL?",
              "options": [
                "They make queries run faster",
                "They prevent SQL injection attacks",
                "They automatically validate data types",
                "They allow you to reuse queries"
              ],
              "correctAnswer": 1,
              "explanation": "Parameterized queries prevent SQL injection by separating SQL code from data. The database engine treats parameters as data, not executable SQL code."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-13-q10",
              "title": "What does sqlite3.Row as row_factory do?",
              "description": "What does sqlite3.Row as row_factory do?",
              "options": [
                "It speeds up query execution",
                "It allows accessing columns by name (row['column']) instead of index",
                "It automatically creates table rows",
                "It validates row data before insertion"
              ],
              "correctAnswer": 1,
              "explanation": "Setting row_factory to sqlite3.Row allows you to access columns by name (like a dictionary) instead of by numeric index, making code more readable."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-13-q11",
              "title": "What is the difference between authentication and authorization?",
              "description": "What is the difference between authentication and authorization?",
              "options": [
                "They are the same thing",
                "Authentication verifies who you are, authorization verifies what you can do",
                "Authorization happens before authentication",
                "Authentication is for APIs, authorization is for web pages"
              ],
              "correctAnswer": 1,
              "explanation": "Authentication verifies identity (who you are - login). Authorization verifies permissions (what you can do - access control). Authentication must happen first."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-13-q12",
              "title": "Why should passwords be hashed using algorithms like PBKDF2 instead of SHA256?",
              "description": "Why should passwords be hashed using algorithms like PBKDF2 instead of SHA256?",
              "options": [
                "SHA256 is slower than PBKDF2",
                "PBKDF2 includes a salt and multiple iterations, making it resistant to rainbow tables and brute force",
                "PBKDF2 produces shorter hashes",
                "SHA256 doesn't work with passwords"
              ],
              "correctAnswer": 1,
              "explanation": "PBKDF2 uses a random salt (prevents rainbow tables) and many iterations (100,000+) to slow down brute force attacks. Simple hashing like SHA256 is too fast."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-13-q13",
              "title": "What are the three components of a JWT token?",
              "description": "What are the three components of a JWT token?",
              "options": [
                "Username, password, timestamp",
                "Header, payload, signature",
                "Token, key, expiration",
                "ID, data, hash"
              ],
              "correctAnswer": 1,
              "explanation": "JWT tokens have three parts: header (algorithm info), payload (claims/data), and signature (verification). They're separated by dots: header.payload.signature"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-13-q14",
              "title": "What HTTP status code should be returned when authentication is missing or invalid?",
              "description": "What HTTP status code should be returned when authentication is missing or invalid?",
              "options": [
                "400 Bad Request",
                "401 Unauthorized",
                "403 Forbidden",
                "404 Not Found"
              ],
              "correctAnswer": 1,
              "explanation": "401 Unauthorized means 'authentication required or failed'. 403 Forbidden means 'authenticated but not authorized'. 400 is for bad input, 404 for missing resources."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-13-q15",
              "title": "When should you return 403 Forbidden instead of 401 Unauthorized?",
              "description": "When should you return 403 Forbidden instead of 401 Unauthorized?",
              "options": [
                "When the token is missing",
                "When the token is expired",
                "When the user is authenticated but not authorized to access the resource",
                "When the request is invalid"
              ],
              "correctAnswer": 2,
              "explanation": "403 Forbidden means 'I know who you are (authenticated) but you don't have permission to do this'. 401 means 'I don't know who you are (not authenticated)'."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-13-q16",
              "title": "What is the purpose of pytest fixtures?",
              "description": "What is the purpose of pytest fixtures?",
              "options": [
                "To make tests run faster",
                "To provide reusable setup code with automatic cleanup",
                "To generate random test data",
                "To skip tests that might fail"
              ],
              "correctAnswer": 1,
              "explanation": "Fixtures provide reusable setup code and ensure cleanup happens even if tests fail. They're perfect for creating test databases, auth tokens, or sample data."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-13-q17",
              "title": "In Flask testing, what does app.test_client() return?",
              "description": "In Flask testing, what does app.test_client() return?",
              "options": [
                "A database connection",
                "An object that can make HTTP requests to your API without running a server",
                "A mock user for authentication",
                "A test configuration object"
              ],
              "correctAnswer": 1,
              "explanation": "test_client() returns a test client that can make HTTP requests (GET, POST, etc.) to your Flask app without starting a web server. Perfect for testing!"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-13-q18",
              "title": "What does ON DELETE CASCADE do in a foreign key relationship?",
              "description": "What does ON DELETE CASCADE do in a foreign key relationship?",
              "options": [
                "It prevents the parent record from being deleted",
                "It automatically deletes child records when the parent is deleted",
                "It cascades updates to all related tables",
                "It creates a backup before deletion"
              ],
              "correctAnswer": 1,
              "explanation": "CASCADE means 'automatically delete related records'. When you delete a post, ON DELETE CASCADE automatically deletes all its comments, preventing orphaned data."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-13-q19",
              "title": "Why use SQL JOINs instead of separate queries for related data?",
              "description": "Why use SQL JOINs instead of separate queries for related data?",
              "options": [
                "JOINs are easier to write",
                "JOINs prevent the N+1 query problem and are much faster",
                "JOINs are more secure",
                "You should always use separate queries"
              ],
              "correctAnswer": 1,
              "explanation": "JOINs fetch related data in one query instead of N+1 queries. For 100 posts with authors: separate queries = 101 database calls, JOIN = 1 call. Much faster!"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-13-q20",
              "title": "In a decorator stack like @app.route @token_required @is_author, what order are they applied?",
              "description": "In a decorator stack like @app.route @token_required @is_author, what order are they applied?",
              "options": [
                "Top to bottom (route → token → author)",
                "Bottom to top (author → token → route)",
                "All at once",
                "Random order"
              ],
              "correctAnswer": 1,
              "explanation": "Decorators are applied bottom to top. The route runs first, then token_required checks authentication, then is_author checks authorization, finally the function runs."
            }
          ]
        }
      ]
    },
    {
      "id": "module-14",
      "title": "Module 14",
      "description": "Python programming fundamentals - Module 14",
      "difficulty": "advanced",
      "estimatedHours": 4,
      "lessons": [
        {
          "id": "14_01",
          "title": "Project Planning and Architecture",
          "moduleId": "module-14",
          "order": 1,
          "estimatedMinutes": 40,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Concept: Building a House vs Building Code",
              "content": "**Project architecture = Blueprint for your code**\n\n**Think of building a house:**\n\n**Without planning:**\n- Start building walls randomly\n- Forget about plumbing\n- Add rooms wherever\n- Result: Unusable mess\n\n**With planning:**\n- Draw blueprints first\n- Plan room layout\n- Consider utilities (water, electricity)\n- Result: Livable, maintainable home\n\n**Software is the same!**\n\n**Good project planning includes:**\n\n1. **Requirements** 📋\n   - What should the project do?\n   - Who will use it?\n   - What problems does it solve?\n\n2. **Architecture** 🏗️\n   - How will components interact?\n   - What's the folder structure?\n   - What technologies to use?\n\n3. **Design patterns** 🎨\n   - Common solutions to common problems\n   - MVC, Repository, Factory, etc.\n   - Proven approaches\n\n4. **Data flow** 🔄\n   - How does data move through the system?\n   - Where is data stored?\n   - What transforms the data?\n\n**Key principle:**\n\"Hours of planning save weeks of coding\""
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example: Project Structure",
              "content": "**Project structure breakdown:**\n\n**1. Root level:**\n- `README.md`: First thing people see\n- `requirements.txt`: All dependencies\n- `setup.py`: For pip installation\n- `.gitignore`: Exclude temp files, secrets\n\n**2. Source code (`src/`):**\n- `models/`: Data structures\n- `services/`: Business logic\n- `repositories/`: Database access\n- `api/`: HTTP endpoints\n- `utils/`: Helper functions\n\n**3. Tests (`tests/`):**\n- Mirror src/ structure\n- One test file per source file\n- Use pytest conventions\n\n**4. Documentation (`docs/`):**\n- Architecture decisions\n- API documentation\n- User guides\n\n**Layered architecture:**\n```\nAPI → Services → Repositories → Database\n```\nEach layer only talks to layer below it.",
              "code": "# Standard Python project structure\n\"\"\"\nmy_project/\n│\n├── README.md              # Project overview and setup instructions\n├── requirements.txt       # Dependencies\n├── setup.py              # Package installation config\n├── .gitignore            # Files to ignore in version control\n├── .env.example          # Environment variables template\n│\n├── docs/                 # Documentation\n│   ├── architecture.md\n│   ├── api.md\n│   └── user_guide.md\n│\n├── tests/                # Test files\n│   ├── __init__.py\n│   ├── test_models.py\n│   ├── test_services.py\n│   └── test_utils.py\n│\n├── src/                  # Source code\n│   ├── __init__.py\n│   │\n│   ├── models/           # Data models\n│   │   ├── __init__.py\n│   │   ├── user.py\n│   │   └── post.py\n│   │\n│   ├── services/         # Business logic\n│   │   ├── __init__.py\n│   │   ├── auth_service.py\n│   │   └── post_service.py\n│   │\n│   ├── repositories/     # Data access\n│   │   ├── __init__.py\n│   │   ├── user_repo.py\n│   │   └── post_repo.py\n│   │\n│   ├── api/              # API endpoints\n│   │   ├── __init__.py\n│   │   ├── routes.py\n│   │   └── middleware.py\n│   │\n│   ├── utils/            # Utility functions\n│   │   ├── __init__.py\n│   │   ├── validators.py\n│   │   └── helpers.py\n│   │\n│   └── config.py         # Configuration\n│\n└── scripts/              # Utility scripts\n    ├── setup_db.py\n    └── seed_data.py\n\"\"\"\n\nprint(\"=== Example: Planning a Blog Application ===\")\n\n# Step 1: Define requirements\nrequirements = {\n    \"project_name\": \"Simple Blog\",\n    \"features\": [\n        \"User registration and authentication\",\n        \"Create, read, update, delete posts\",\n        \"Comment on posts\",\n        \"Search functionality\",\n        \"User profiles\"\n    ],\n    \"tech_stack\": {\n        \"backend\": \"Flask\",\n        \"database\": \"SQLite/PostgreSQL\",\n        \"authentication\": \"JWT\",\n        \"testing\": \"pytest\"\n    },\n    \"constraints\": [\n        \"Must be RESTful API\",\n        \"Must handle 100 concurrent users\",\n        \"Response time < 200ms\"\n    ]\n}\n\nprint(\"\\n📋 Project Requirements:\")\nprint(f\"Project: {requirements['project_name']}\")\nprint(f\"\\nFeatures:\")\nfor feature in requirements['features']:\n    print(f\"  - {feature}\")\n\nprint(f\"\\nTech Stack:\")\nfor key, value in requirements['tech_stack'].items():\n    print(f\"  {key}: {value}\")\n\n# Step 2: Design data models\nprint(\"\\n=== Data Models ===\")\n\nclass DesignDoc:\n    \"\"\"Documentation for data model design\"\"\"\n    \n    USER_MODEL = \"\"\"\n    User:\n      - id: int (primary key)\n      - username: str (unique, required)\n      - email: str (unique, required)\n      - password_hash: str (required)\n      - created_at: datetime\n      - updated_at: datetime\n      \n      Relationships:\n        - posts: one-to-many\n        - comments: one-to-many\n    \"\"\"\n    \n    POST_MODEL = \"\"\"\n    Post:\n      - id: int (primary key)\n      - title: str (required, max 200)\n      - content: text (required)\n      - author_id: int (foreign key -> User)\n      - created_at: datetime\n      - updated_at: datetime\n      \n      Relationships:\n        - author: many-to-one (User)\n        - comments: one-to-many\n    \"\"\"\n    \n    COMMENT_MODEL = \"\"\"\n    Comment:\n      - id: int (primary key)\n      - content: text (required)\n      - author_id: int (foreign key -> User)\n      - post_id: int (foreign key -> Post)\n      - created_at: datetime\n      \n      Relationships:\n        - author: many-to-one (User)\n        - post: many-to-one (Post)\n    \"\"\"\n\nprint(\"User Model:\")\nprint(DesignDoc.USER_MODEL)\n\nprint(\"\\nPost Model:\")\nprint(DesignDoc.POST_MODEL)\n\n# Step 3: Define API endpoints\nprint(\"\\n=== API Endpoints Design ===\")\n\napi_design = {\n    \"authentication\": [\n        {\"method\": \"POST\", \"path\": \"/api/auth/register\", \"description\": \"Register new user\"},\n        {\"method\": \"POST\", \"path\": \"/api/auth/login\", \"description\": \"Login user\"},\n        {\"method\": \"POST\", \"path\": \"/api/auth/logout\", \"description\": \"Logout user\"}\n    ],\n    \"posts\": [\n        {\"method\": \"GET\", \"path\": \"/api/posts\", \"description\": \"List all posts\"},\n        {\"method\": \"GET\", \"path\": \"/api/posts/{id}\", \"description\": \"Get single post\"},\n        {\"method\": \"POST\", \"path\": \"/api/posts\", \"description\": \"Create new post\"},\n        {\"method\": \"PUT\", \"path\": \"/api/posts/{id}\", \"description\": \"Update post\"},\n        {\"method\": \"DELETE\", \"path\": \"/api/posts/{id}\", \"description\": \"Delete post\"}\n    ],\n    \"comments\": [\n        {\"method\": \"GET\", \"path\": \"/api/posts/{id}/comments\", \"description\": \"Get post comments\"},\n        {\"method\": \"POST\", \"path\": \"/api/posts/{id}/comments\", \"description\": \"Add comment\"},\n        {\"method\": \"DELETE\", \"path\": \"/api/comments/{id}\", \"description\": \"Delete comment\"}\n    ]\n}\n\nfor category, endpoints in api_design.items():\n    print(f\"\\n{category.upper()}:\")\n    for endpoint in endpoints:\n        print(f\"  {endpoint['method']:6} {endpoint['path']:30} - {endpoint['description']}\")\n\n# Step 4: Architecture diagram (as text)\nprint(\"\\n=== System Architecture ===\")\n\narchitecture = \"\"\"\n┌─────────────┐\n│   Client    │  (Browser, Mobile App)\n└──────┬──────┘\n       │ HTTP/HTTPS\n       ↓\n┌─────────────────────────────────┐\n│         API Layer               │\n│  ┌──────────────────────────┐  │\n│  │  Routes & Middleware     │  │\n│  │  - Authentication        │  │\n│  │  - Validation            │  │\n│  │  - Error handling        │  │\n│  └──────────┬───────────────┘  │\n└─────────────┼───────────────────┘\n              ↓\n┌─────────────────────────────────┐\n│      Business Logic Layer       │\n│  ┌──────────────────────────┐  │\n│  │  Services                │  │\n│  │  - Auth Service          │  │\n│  │  - Post Service          │  │\n│  │  - Comment Service       │  │\n│  └──────────┬───────────────┘  │\n└─────────────┼───────────────────┘\n              ↓\n┌─────────────────────────────────┐\n│      Data Access Layer          │\n│  ┌──────────────────────────┐  │\n│  │  Repositories            │  │\n│  │  - User Repo             │  │\n│  │  - Post Repo             │  │\n│  │  - Comment Repo          │  │\n│  └──────────┬───────────────┘  │\n└─────────────┼───────────────────┘\n              ↓\n┌─────────────────────────────────┐\n│         Database                │\n│  ┌──────────────────────────┐  │\n│  │  SQLite / PostgreSQL     │  │\n│  │  - users table           │  │\n│  │  - posts table           │  │\n│  │  - comments table        │  │\n│  └──────────────────────────┘  │\n└─────────────────────────────────┘\n\"\"\"\n\nprint(architecture)\n\nprint(\"\\n=== Design Principles ===\")\n\nprinciples = [\n    \"Separation of Concerns: Each layer has one responsibility\",\n    \"DRY (Don't Repeat Yourself): Reuse code through functions/classes\",\n    \"SOLID Principles: Single responsibility, Open/closed, etc.\",\n    \"Loose Coupling: Components don't depend tightly on each other\",\n    \"High Cohesion: Related functionality grouped together\",\n    \"Fail Fast: Validate early, catch errors quickly\",\n    \"Security First: Never trust user input, validate everything\"\n]\n\nfor i, principle in enumerate(principles, 1):\n    print(f\"{i}. {principle}\")",
              "language": "python"
            },
            {
              "type": "ANALOGY",
              "title": "Syntax Breakdown: Configuration Management",
              "content": "**Managing configuration:**\n\n**1. Environment variables (.env file):**\n```bash\n# .env (NEVER commit this!)\nDATABASE_URL=postgresql://user:pass@localhost/db\nSECRET_KEY=your-secret-key-here\nDEBUG=True\n```\n\n**2. Config file (config.py):**\n```python\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()  # Load .env file\n\nclass Config:\n    SECRET_KEY = os.getenv('SECRET_KEY')\n    DATABASE_URL = os.getenv('DATABASE_URL')\n    DEBUG = os.getenv('DEBUG', 'False') == 'True'\n    \nclass DevelopmentConfig(Config):\n    DEBUG = True\n    DATABASE_URL = 'sqlite:///dev.db'\n    \nclass ProductionConfig(Config):\n    DEBUG = False\n    # Production database from environment\n    \nconfig = {\n    'development': DevelopmentConfig,\n    'production': ProductionConfig,\n    'default': DevelopmentConfig\n}\n```\n\n**3. requirements.txt:**\n```\nFlask==3.0.0\nSQLAlchemy==2.0.0\npython-dotenv==1.0.0\npytest==7.4.0\n```\n\n**Install dependencies:**\n```bash\npip install -r requirements.txt\n```\n\n**4. .gitignore:**\n```\n# Environment\n.env\nvenv/\n__pycache__/\n\n# Database\n*.db\n*.sqlite\n\n# IDE\n.vscode/\n.idea/\n\n# OS\n.DS_Store\n```"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example: Implementing Layered Architecture",
              "content": "**Layered architecture explained:**\n\n**1. Models (Data structures):**\n- Plain data classes\n- No business logic\n- Just hold data\n\n**2. Repositories (Data access):**\n- CRUD operations only\n- Talks to database\n- No validation or business rules\n\n**3. Services (Business logic):**\n- Validation\n- Business rules\n- Uses repositories\n- Coordinates multiple operations\n\n**4. API/Controllers (HTTP layer):**\n- Handle requests/responses\n- Call services\n- No business logic\n\n**Benefits:**\n- Testable: Mock each layer\n- Maintainable: Change one layer without affecting others\n- Reusable: Services used by API, CLI, tests, etc.\n- Clear responsibilities",
              "code": "# Example: Implementing a simple blog with layered architecture\n\nfrom typing import List, Optional, Dict\nfrom dataclasses import dataclass\nfrom datetime import datetime\n\nprint(\"=== Layer 1: Data Models ===\")\n\n@dataclass\nclass User:\n    \"\"\"User data model\"\"\"\n    id: int\n    username: str\n    email: str\n    created_at: datetime\n\n@dataclass\nclass Post:\n    \"\"\"Post data model\"\"\"\n    id: int\n    title: str\n    content: str\n    author_id: int\n    created_at: datetime\n    \nprint(\"✓ Models defined\")\n\nprint(\"\\n=== Layer 2: Repository Layer (Data Access) ===\")\n\nclass UserRepository:\n    \"\"\"Handles all database operations for users\"\"\"\n    \n    def __init__(self):\n        # In real app, this would be database connection\n        self._users: Dict[int, User] = {}\n        self._next_id = 1\n    \n    def create(self, username: str, email: str) -> User:\n        \"\"\"Create new user\"\"\"\n        user = User(\n            id=self._next_id,\n            username=username,\n            email=email,\n            created_at=datetime.now()\n        )\n        self._users[user.id] = user\n        self._next_id += 1\n        return user\n    \n    def find_by_id(self, user_id: int) -> Optional[User]:\n        \"\"\"Find user by ID\"\"\"\n        return self._users.get(user_id)\n    \n    def find_by_username(self, username: str) -> Optional[User]:\n        \"\"\"Find user by username\"\"\"\n        for user in self._users.values():\n            if user.username == username:\n                return user\n        return None\n    \n    def list_all(self) -> List[User]:\n        \"\"\"List all users\"\"\"\n        return list(self._users.values())\n\nclass PostRepository:\n    \"\"\"Handles all database operations for posts\"\"\"\n    \n    def __init__(self):\n        self._posts: Dict[int, Post] = {}\n        self._next_id = 1\n    \n    def create(self, title: str, content: str, author_id: int) -> Post:\n        \"\"\"Create new post\"\"\"\n        post = Post(\n            id=self._next_id,\n            title=title,\n            content=content,\n            author_id=author_id,\n            created_at=datetime.now()\n        )\n        self._posts[post.id] = post\n        self._next_id += 1\n        return post\n    \n    def find_by_id(self, post_id: int) -> Optional[Post]:\n        \"\"\"Find post by ID\"\"\"\n        return self._posts.get(post_id)\n    \n    def find_by_author(self, author_id: int) -> List[Post]:\n        \"\"\"Find all posts by author\"\"\"\n        return [\n            post for post in self._posts.values()\n            if post.author_id == author_id\n        ]\n    \n    def list_all(self) -> List[Post]:\n        \"\"\"List all posts\"\"\"\n        return list(self._posts.values())\n    \n    def delete(self, post_id: int) -> bool:\n        \"\"\"Delete post\"\"\"\n        if post_id in self._posts:\n            del self._posts[post_id]\n            return True\n        return False\n\nprint(\"✓ Repositories defined\")\n\nprint(\"\\n=== Layer 3: Service Layer (Business Logic) ===\")\n\nclass UserService:\n    \"\"\"Business logic for user operations\"\"\"\n    \n    def __init__(self, user_repo: UserRepository):\n        self.user_repo = user_repo\n    \n    def register_user(self, username: str, email: str) -> Dict:\n        \"\"\"Register new user with validation\"\"\"\n        # Validation\n        if len(username) < 3:\n            return {\"error\": \"Username must be at least 3 characters\"}\n        \n        if '@' not in email:\n            return {\"error\": \"Invalid email format\"}\n        \n        # Check if username exists\n        if self.user_repo.find_by_username(username):\n            return {\"error\": \"Username already taken\"}\n        \n        # Create user\n        user = self.user_repo.create(username, email)\n        \n        return {\n            \"success\": True,\n            \"user\": {\n                \"id\": user.id,\n                \"username\": user.username,\n                \"email\": user.email\n            }\n        }\n    \n    def get_user_profile(self, user_id: int) -> Optional[Dict]:\n        \"\"\"Get user profile\"\"\"\n        user = self.user_repo.find_by_id(user_id)\n        if not user:\n            return None\n        \n        return {\n            \"id\": user.id,\n            \"username\": user.username,\n            \"email\": user.email,\n            \"member_since\": user.created_at.strftime(\"%Y-%m-%d\")\n        }\n\nclass PostService:\n    \"\"\"Business logic for post operations\"\"\"\n    \n    def __init__(self, post_repo: PostRepository, user_repo: UserRepository):\n        self.post_repo = post_repo\n        self.user_repo = user_repo\n    \n    def create_post(self, title: str, content: str, author_id: int) -> Dict:\n        \"\"\"Create new post with validation\"\"\"\n        # Validation\n        if len(title) < 5:\n            return {\"error\": \"Title must be at least 5 characters\"}\n        \n        if len(content) < 10:\n            return {\"error\": \"Content must be at least 10 characters\"}\n        \n        # Verify author exists\n        if not self.user_repo.find_by_id(author_id):\n            return {\"error\": \"Author not found\"}\n        \n        # Create post\n        post = self.post_repo.create(title, content, author_id)\n        \n        return {\n            \"success\": True,\n            \"post\": {\n                \"id\": post.id,\n                \"title\": post.title,\n                \"content\": post.content,\n                \"author_id\": post.author_id\n            }\n        }\n    \n    def get_post_with_author(self, post_id: int) -> Optional[Dict]:\n        \"\"\"Get post with author information\"\"\"\n        post = self.post_repo.find_by_id(post_id)\n        if not post:\n            return None\n        \n        author = self.user_repo.find_by_id(post.author_id)\n        \n        return {\n            \"id\": post.id,\n            \"title\": post.title,\n            \"content\": post.content,\n            \"author\": {\n                \"id\": author.id,\n                \"username\": author.username\n            } if author else None,\n            \"created_at\": post.created_at.strftime(\"%Y-%m-%d %H:%M\")\n        }\n    \n    def get_user_posts(self, user_id: int) -> List[Dict]:\n        \"\"\"Get all posts by a user\"\"\"\n        posts = self.post_repo.find_by_author(user_id)\n        return [\n            {\n                \"id\": post.id,\n                \"title\": post.title,\n                \"content\": post.content[:100] + \"...\"\n            }\n            for post in posts\n        ]\n\nprint(\"✓ Services defined\")\n\nprint(\"\\n=== Testing the Architecture ===\")\n\n# Initialize layers\nuser_repo = UserRepository()\npost_repo = PostRepository()\n\nuser_service = UserService(user_repo)\npost_service = PostService(post_repo, user_repo)\n\n# Test user registration\nprint(\"\\n1. Registering users...\")\nresult1 = user_service.register_user(\"alice\", \"alice@example.com\")\nprint(f\"   Alice: {result1}\")\n\nresult2 = user_service.register_user(\"bob\", \"bob@example.com\")\nprint(f\"   Bob: {result2}\")\n\n# Test validation\nresult3 = user_service.register_user(\"ab\", \"invalid\")\nprint(f\"   Invalid: {result3}\")\n\n# Test duplicate username\nresult4 = user_service.register_user(\"alice\", \"alice2@example.com\")\nprint(f\"   Duplicate: {result4}\")\n\n# Create posts\nprint(\"\\n2. Creating posts...\")\npost1 = post_service.create_post(\n    \"My First Post\",\n    \"This is the content of my first blog post. Hello world!\",\n    1  # Alice's ID\n)\nprint(f\"   Post 1: {post1}\")\n\npost2 = post_service.create_post(\n    \"Python Tips\",\n    \"Here are some great Python tips for beginners and experts alike.\",\n    1  # Alice's ID\n)\nprint(f\"   Post 2: {post2}\")\n\npost3 = post_service.create_post(\n    \"Hello from Bob\",\n    \"Bob's first post on this awesome platform!\",\n    2  # Bob's ID\n)\nprint(f\"   Post 3: {post3}\")\n\n# Get post with author\nprint(\"\\n3. Fetching post with author info...\")\npost_detail = post_service.get_post_with_author(1)\nprint(f\"   Post: {post_detail['title']}\")\nprint(f\"   Author: {post_detail['author']['username']}\")\nprint(f\"   Created: {post_detail['created_at']}\")\n\n# Get user's posts\nprint(\"\\n4. Getting Alice's posts...\")\nalice_posts = post_service.get_user_posts(1)\nprint(f\"   Alice has {len(alice_posts)} posts:\")\nfor post in alice_posts:\n    print(f\"     - {post['title']}\")\n\n# Get user profile\nprint(\"\\n5. Getting user profile...\")\nprofile = user_service.get_user_profile(1)\nprint(f\"   Username: {profile['username']}\")\nprint(f\"   Email: {profile['email']}\")\nprint(f\"   Member since: {profile['member_since']}\")\n\nprint(\"\\n=== Architecture Benefits ===\")\nbenefits = [\n    \"✓ Each layer has single responsibility\",\n    \"✓ Business logic separated from data access\",\n    \"✓ Easy to test each layer independently\",\n    \"✓ Can swap repositories (e.g., in-memory -> database)\",\n    \"✓ Validation centralized in services\",\n    \"✓ Clear data flow: API → Service → Repository → Database\"\n]\n\nfor benefit in benefits:\n    print(benefit)",
              "language": "python"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "- **Plan before coding** - Hours of planning save weeks of debugging\n- **Layered architecture** - Models → Repositories → Services → API\n- **Separation of concerns** - Each layer has one responsibility\n- **Repository pattern** - Isolate data access from business logic\n- **Service layer** - Centralize validation and business rules\n- **Configuration management** - Use .env files, never commit secrets\n- **Project structure** - Organize code logically (src/, tests/, docs/)\n- **Design principles** - DRY, SOLID, loose coupling, high cohesion"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "14_01-challenge-4",
              "title": "Interactive Exercise",
              "description": "Design a simple Task Management System:\n1. Define the data models (Task, User)\n2. Plan the API endpoints\n3. Create a basic repository and service layer\n4. Implement create and list operations",
              "instructions": "Design a simple Task Management System:\n1. Define the data models (Task, User)\n2. Plan the API endpoints\n3. Create a basic repository and service layer\n4. Implement create and list operations",
              "starterCode": "from typing import List, Optional, Dict\nfrom dataclasses import dataclass\nfrom datetime import datetime\n\n# TODO: Define Task model\n# Fields: id, title, description, completed, user_id, created_at\n\n# TODO: Define TaskRepository\n# Methods: create, find_by_id, find_by_user, list_all, update_status\n\n# TODO: Define TaskService  \n# Methods: create_task, get_user_tasks, mark_completed\n# Include validation (title min 3 chars, description min 5 chars)\n\n# Test your implementation\nrepo = TaskRepository()\nservice = TaskService(repo)\n\n# Create tasks\nresult = service.create_task(\n    title=\"Learn Python\",\n    description=\"Complete Module 14\",\n    user_id=1\n)\nprint(result)\n\n# List tasks\ntasks = service.get_user_tasks(1)\nfor task in tasks:\n    print(f\"- {task['title']}\")",
              "solution": "",
              "language": "python",
              "testCases": [
                {
                  "description": "Code runs without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use @dataclass for models. Repository handles storage (dict). Service handles validation and business logic."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "14_02",
          "title": "Version Control with Git",
          "moduleId": "module-14",
          "order": 2,
          "estimatedMinutes": 40,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Concept: Time Machine for Code",
              "content": "**Git = Save points for your code**\n\n**Think of a video game:**\n- Save your progress before boss fight\n- Try different strategies\n- Go back if you fail\n- Keep multiple save files\n\n**Git does this for code!**\n\n**Key concepts:**\n\n1. **Repository (repo)** 📁\n   - Project folder with Git tracking\n   - Contains all history\n   - Local (your computer) + Remote (GitHub)\n\n2. **Commit** 💾\n   - Save point in history\n   - Snapshot of all files\n   - Has message describing changes\n   - Permanent record\n\n3. **Branch** 🌳\n   - Parallel version of code\n   - Experiment without breaking main code\n   - Merge back when ready\n   - main/master = production code\n\n4. **Merge** 🔀\n   - Combine branches\n   - Integrate features\n   - May have conflicts to resolve\n\n5. **Pull Request (PR)** 🤝\n   - Request to merge your changes\n   - Code review\n   - Discussion before merging\n   - Quality control\n\n**Basic workflow:**\n```\n1. Clone repo (copy to your computer)\n2. Create branch (new feature)\n3. Make changes\n4. Commit changes (save point)\n5. Push to GitHub (backup)\n6. Create Pull Request\n7. Review + Merge\n```\n\n**Why use Git:**\n- Track every change ever made\n- Collaborate without overwriting others\n- Experiment safely\n- Revert mistakes\n- Required for professional development"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example: Git Basics",
              "content": "**Git workflow stages:**\n\n```\nWorking Directory  →  Staging Area  →  Repository\n   (changes)          (git add)         (git commit)\n```\n\n**Branch strategy:**\n```\nmain          ○──○──○──○──○\n               \\      /\nfeature         ○──○──○\n```\n\n**Commit message format:**\n```\nShort summary (50 chars max)\n\nLonger description if needed.\nExplain WHY, not what.\n```\n\n**Good commit messages:**\n- \"Add user authentication with JWT\"\n- \"Fix null pointer error in login\"\n- \"Refactor database queries for performance\"\n\n**Bad commit messages:**\n- \"Fix bug\"\n- \"Update\"\n- \"WIP\"\n- \"asdfghjkl\"",
              "code": "# Git commands demonstration (as comments)\n# Run these in your terminal, not Python\n\nprint(\"=== Git Setup (One-time) ===\")\n\"\"\"\n# Configure your identity\ngit config --global user.name \"Your Name\"\ngit config --global user.email \"your.email@example.com\"\n\n# Check configuration\ngit config --list\n\"\"\"\n\nprint(\"\\n=== Creating a Repository ===\")\n\"\"\"\n# Method 1: Start new project\nmkdir my-project\ncd my-project\ngit init\n# Creates .git folder (hidden)\n\n# Method 2: Clone existing\ngit clone https://github.com/username/repo.git\ncd repo\n\"\"\"\n\nprint(\"\\n=== Basic Workflow ===\")\n\"\"\"\n# 1. Check status\ngit status\n# Shows: modified files, staged files, branch\n\n# 2. Stage files (prepare for commit)\ngit add file.py          # Specific file\ngit add .                # All files\ngit add *.py             # All Python files\n\n# 3. Commit changes\ngit commit -m \"Add user authentication\"\n# -m = message describing what changed\n\n# 4. View history\ngit log\ngit log --oneline        # Condensed view\ngit log --graph          # Visual branch graph\n\n# 5. Push to remote (GitHub)\ngit push origin main\n# origin = remote name (default)\n# main = branch name\n\"\"\"\n\nprint(\"\\n=== Working with Branches ===\")\n\"\"\"\n# Create new branch\ngit branch feature/login        # Create\ngit checkout feature/login      # Switch to it\n# Or combined:\ngit checkout -b feature/login   # Create + switch\n\n# List branches\ngit branch                      # Local branches\ngit branch -a                   # All (including remote)\n\n# Switch branches\ngit checkout main\ngit checkout feature/login\n\n# Delete branch\ngit branch -d feature/login     # Safe delete (merged only)\ngit branch -D feature/login     # Force delete\n\"\"\"\n\nprint(\"\\n=== Merging Branches ===\")\n\"\"\"\n# Merge feature into main\ngit checkout main               # Switch to main\ngit merge feature/login         # Merge feature in\n\n# If conflicts occur:\n# 1. Git marks conflicts in files:\n#    <<<<<<< HEAD\n#    code from main\n#    =======\n#    code from feature\n#    >>>>>>> feature/login\n#\n# 2. Manually resolve (edit file)\n# 3. Stage resolved files\n#    git add conflicted-file.py\n# 4. Commit the merge\n#    git commit -m \"Merge feature/login\"\n\"\"\"\n\nprint(\"\\n=== Undoing Changes ===\")\n\"\"\"\n# Discard changes in working directory\ngit checkout -- file.py         # Restore from last commit\n\n# Unstage files (undo git add)\ngit reset HEAD file.py\n\n# Undo last commit (keep changes)\ngit reset --soft HEAD~1\n\n# Undo last commit (discard changes)\ngit reset --hard HEAD~1\n# WARNING: Can't recover discarded changes!\n\n# Create new commit that undoes a previous commit\ngit revert <commit-hash>\n# Safer than reset, keeps history\n\"\"\"\n\nprint(\"\\n=== Remote Operations ===\")\n\"\"\"\n# View remotes\ngit remote -v\n\n# Add remote\ngit remote add origin https://github.com/username/repo.git\n\n# Fetch changes (download, don't merge)\ngit fetch origin\n\n# Pull changes (fetch + merge)\ngit pull origin main\n# Equivalent to:\n#   git fetch origin\n#   git merge origin/main\n\n# Push branch to remote\ngit push -u origin feature/login\n# -u sets upstream tracking\n# After this, just: git push\n\"\"\"\n\nprint(\"\\n=== .gitignore File ===\")\n\"\"\"\n# Create .gitignore in project root\n# Lists files/folders Git should ignore\n\nExample .gitignore:\n```\n# Environment\n.env\nvenv/\n__pycache__/\n*.pyc\n\n# IDE\n.vscode/\n.idea/\n*.swp\n\n# Database\n*.db\n*.sqlite\n\n# OS\n.DS_Store\nThumbs.db\n\n# Logs\n*.log\n```\n\"\"\"\n\nprint(\"\\n=== Common Git Scenarios ===\")\n\n# Scenario demonstrations\nscenarios = [\n    {\n        \"title\": \"Start new feature\",\n        \"commands\": [\n            \"git checkout main\",\n            \"git pull origin main\",\n            \"git checkout -b feature/new-api\",\n            \"# Make changes...\",\n            \"git add .\",\n            \"git commit -m 'Add new API endpoint'\",\n            \"git push -u origin feature/new-api\"\n        ]\n    },\n    {\n        \"title\": \"Fix a bug\",\n        \"commands\": [\n            \"git checkout main\",\n            \"git checkout -b bugfix/login-error\",\n            \"# Fix the bug...\",\n            \"git add file.py\",\n            \"git commit -m 'Fix login validation error'\",\n            \"git push -u origin bugfix/login-error\"\n        ]\n    },\n    {\n        \"title\": \"Update from main\",\n        \"commands\": [\n            \"git checkout feature/my-branch\",\n            \"git fetch origin\",\n            \"git merge origin/main\",\n            \"# Resolve any conflicts...\",\n            \"git push\"\n        ]\n    }\n]\n\nfor scenario in scenarios:\n    print(f\"\\n{scenario['title']}:\")\n    for cmd in scenario['commands']:\n        if cmd.startswith('#'):\n            print(f\"  {cmd}\")\n        else:\n            print(f\"  $ {cmd}\")\n\nprint(\"\\n=== Git Best Practices ===\")\n\nbest_practices = [\n    \"✓ Commit often, push daily\",\n    \"✓ Write clear commit messages\",\n    \"✓ One feature = one branch\",\n    \"✓ Pull before you push\",\n    \"✓ Never commit secrets (.env, passwords)\",\n    \"✓ Keep commits focused (one logical change)\",\n    \"✓ Review changes before committing (git diff)\",\n    \"✓ Use branches for experiments\",\n    \"✓ Delete merged branches\",\n    \"✓ Don't rewrite public history (main branch)\"\n]\n\nfor practice in best_practices:\n    print(practice)",
              "language": "python"
            },
            {
              "type": "ANALOGY",
              "title": "GitHub Workflow",
              "content": "**GitHub = Remote Git hosting + collaboration tools**\n\n**Key features:**\n\n**1. Pull Requests (PRs)**\n- Propose changes\n- Code review\n- Discussion\n- CI/CD checks\n\n**2. Issues**\n- Bug reports\n- Feature requests\n- Task tracking\n- Discussion\n\n**3. Forking**\n- Copy someone's repo\n- Make your changes\n- Contribute back via PR\n\n**Standard workflow:**\n\n```\n1. Fork repo (your copy on GitHub)\n2. Clone fork to your computer\n3. Create feature branch\n4. Make changes + commit\n5. Push to your fork\n6. Open Pull Request\n7. Address review comments\n8. PR gets merged\n9. Delete branch\n```\n\n**Pull Request description template:**\n```markdown\n## What\nBrief description of changes\n\n## Why  \nWhy this change is needed\n\n## How\nHow it was implemented\n\n## Testing\nHow to test these changes\n\n## Screenshots\n(if UI changes)\n```\n\n**Code review etiquette:**\n- Be respectful and constructive\n- Ask questions, don't demand\n- Praise good code\n- Suggest, don't command\n- Focus on code, not person"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example: Python Git Automation",
              "content": "**Python + Git integration:**\n\n**Using subprocess:**\n```python\nimport subprocess\n\nresult = subprocess.run(\n    ['git', 'status'],\n    capture_output=True,\n    text=True\n)\nprint(result.stdout)\n```\n\n**Git hooks:**\n- Scripts that run on Git events\n- Located in `.git/hooks/`\n- Can prevent commits/pushes\n\n**Common hooks:**\n- `pre-commit`: Before commit\n- `commit-msg`: Validate commit message\n- `pre-push`: Before push\n- `post-commit`: After commit\n\n**Use cases:**\n- Run tests before commit\n- Check code style\n- Prevent committing secrets\n- Generate documentation\n- Notify team members",
              "code": "import subprocess\nimport os\nfrom pathlib import Path\nfrom typing import List, Optional\n\nprint(\"=== Git Automation with Python ===\")\n\nclass GitHelper:\n    \"\"\"Helper class for Git operations via Python\"\"\"\n    \n    def __init__(self, repo_path: str = \".\"):\n        self.repo_path = Path(repo_path)\n    \n    def run_command(self, command: List[str]) -> tuple:\n        \"\"\"Run git command and return output\"\"\"\n        try:\n            result = subprocess.run(\n                command,\n                cwd=self.repo_path,\n                capture_output=True,\n                text=True,\n                check=True\n            )\n            return True, result.stdout.strip()\n        except subprocess.CalledProcessError as e:\n            return False, e.stderr.strip()\n    \n    def get_status(self) -> str:\n        \"\"\"Get git status\"\"\"\n        success, output = self.run_command([\"git\", \"status\", \"--short\"])\n        return output if success else \"Error getting status\"\n    \n    def get_current_branch(self) -> str:\n        \"\"\"Get current branch name\"\"\"\n        success, output = self.run_command([\"git\", \"branch\", \"--show-current\"])\n        return output if success else \"unknown\"\n    \n    def get_last_commit(self) -> str:\n        \"\"\"Get last commit message\"\"\"\n        success, output = self.run_command(\n            [\"git\", \"log\", \"-1\", \"--pretty=format:%h - %s\"]\n        )\n        return output if success else \"No commits\"\n    \n    def list_branches(self) -> List[str]:\n        \"\"\"List all local branches\"\"\"\n        success, output = self.run_command([\"git\", \"branch\"])\n        if not success:\n            return []\n        \n        branches = [\n            line.strip().replace(\"* \", \"\")\n            for line in output.split(\"\\n\")\n            if line.strip()\n        ]\n        return branches\n    \n    def create_branch(self, branch_name: str) -> bool:\n        \"\"\"Create new branch\"\"\"\n        success, _ = self.run_command([\"git\", \"checkout\", \"-b\", branch_name])\n        return success\n    \n    def switch_branch(self, branch_name: str) -> bool:\n        \"\"\"Switch to existing branch\"\"\"\n        success, _ = self.run_command([\"git\", \"checkout\", branch_name])\n        return success\n    \n    def add_files(self, files: str = \".\") -> bool:\n        \"\"\"Stage files for commit\"\"\"\n        success, _ = self.run_command([\"git\", \"add\", files])\n        return success\n    \n    def commit(self, message: str) -> bool:\n        \"\"\"Commit staged changes\"\"\"\n        success, _ = self.run_command([\"git\", \"commit\", \"-m\", message])\n        return success\n    \n    def push(self, remote: str = \"origin\", branch: Optional[str] = None) -> bool:\n        \"\"\"Push to remote\"\"\"\n        if branch is None:\n            branch = self.get_current_branch()\n        \n        success, _ = self.run_command([\"git\", \"push\", remote, branch])\n        return success\n    \n    def pull(self, remote: str = \"origin\", branch: Optional[str] = None) -> bool:\n        \"\"\"Pull from remote\"\"\"\n        if branch is None:\n            branch = self.get_current_branch()\n        \n        success, _ = self.run_command([\"git\", \"pull\", remote, branch])\n        return success\n    \n    def get_modified_files(self) -> List[str]:\n        \"\"\"Get list of modified files\"\"\"\n        success, output = self.run_command([\"git\", \"diff\", \"--name-only\"])\n        if not success or not output:\n            return []\n        \n        return output.split(\"\\n\")\n    \n    def get_commit_count(self) -> int:\n        \"\"\"Get total commit count\"\"\"\n        success, output = self.run_command([\"git\", \"rev-list\", \"--count\", \"HEAD\"])\n        if success and output.isdigit():\n            return int(output)\n        return 0\n\nprint(\"\\n=== Using Git Helper ===\")\n\n# Note: This would work in a real Git repository\n# For demonstration, we'll show the usage pattern\n\nprint(\"\\nExample usage:\")\nprint(\"\"\"\ngit = GitHelper()\n\n# Check status\nstatus = git.get_status()\nprint(f\"Status: {status}\")\n\n# Get current branch\nbranch = git.get_current_branch()\nprint(f\"Current branch: {branch}\")\n\n# Create and switch to feature branch\nif git.create_branch('feature/new-feature'):\n    print(\"Branch created successfully\")\n\n# Make some changes to files...\n\n# Stage and commit\nif git.add_files('.'):\n    if git.commit('Add new feature'):\n        print(\"Changes committed\")\n\n# Push to remote\nif git.push():\n    print(\"Pushed to remote\")\n\n# List all branches\nbranches = git.list_branches()\nprint(f\"Branches: {branches}\")\n\n# Get commit count\ncount = git.get_commit_count()\nprint(f\"Total commits: {count}\")\n\"\"\")\n\nprint(\"\\n=== Pre-commit Hook Example ===\")\n\n# Example pre-commit hook script\npre_commit_hook = '''\n#!/usr/bin/env python3\n\"\"\"Pre-commit hook: Run checks before allowing commit\"\"\"\n\nimport subprocess\nimport sys\n\ndef run_tests():\n    \"\"\"Run test suite\"\"\"\n    result = subprocess.run(['pytest', 'tests/'], capture_output=True)\n    return result.returncode == 0\n\ndef check_code_style():\n    \"\"\"Check Python code style with flake8\"\"\"\n    result = subprocess.run(['flake8', '.'], capture_output=True)\n    return result.returncode == 0\n\ndef check_no_debug_prints():\n    \"\"\"Ensure no print() statements in production code\"\"\"\n    result = subprocess.run(\n        ['git', 'diff', '--cached', '--name-only'],\n        capture_output=True,\n        text=True\n    )\n    \n    for file in result.stdout.split():\n        if file.endswith('.py') and 'test' not in file:\n            with open(file) as f:\n                if 'print(' in f.read():\n                    print(f\"❌ Debug print() found in {file}\")\n                    return False\n    return True\n\nif __name__ == '__main__':\n    print(\"Running pre-commit checks...\")\n    \n    checks = [\n        (\"Tests\", run_tests),\n        (\"Code style\", check_code_style),\n        (\"No debug prints\", check_no_debug_prints)\n    ]\n    \n    for name, check_func in checks:\n        print(f\"Checking {name}...\", end=\" \")\n        if check_func():\n            print(\"✓\")\n        else:\n            print(\"✗\")\n            print(f\"\\n❌ {name} check failed. Commit aborted.\")\n            sys.exit(1)\n    \n    print(\"\\n✓ All checks passed. Committing...\")\n    sys.exit(0)\n'''\n\nprint(\"Pre-commit hook script:\")\nprint(pre_commit_hook)\n\nprint(\"\\n=== Git Statistics Script ===\")\n\nstat_script = '''\nimport subprocess\nfrom collections import Counter\n\ndef get_git_stats():\n    \"\"\"Generate repository statistics\"\"\"\n    \n    # Total commits\n    result = subprocess.run(\n        ['git', 'rev-list', '--count', 'HEAD'],\n        capture_output=True,\n        text=True\n    )\n    total_commits = result.stdout.strip()\n    \n    # Contributors\n    result = subprocess.run(\n        ['git', 'shortlog', '-sn', '--all'],\n        capture_output=True,\n        text=True\n    )\n    contributors = result.stdout.strip().split('\\\\n')\n    \n    # Lines of code\n    result = subprocess.run(\n        ['git', 'ls-files'],\n        capture_output=True,\n        text=True\n    )\n    files = result.stdout.strip().split('\\\\n')\n    \n    print(f\"Total commits: {total_commits}\")\n    print(f\"Total files: {len(files)}\")\n    print(f\"\\\\nTop contributors:\")\n    for contributor in contributors[:5]:\n        print(f\"  {contributor}\")\n\nget_git_stats()\n'''\n\nprint(\"Git statistics script:\")\nprint(stat_script)",
              "language": "python"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "- **Git tracks all changes** - Every commit is a save point in history\n- **Branches = safe experimentation** - Work on features without breaking main\n- **Commit often, push daily** - Small, focused commits are better\n- **Write clear commit messages** - Future you will thank you\n- **Pull before push** - Always sync with remote first\n- **Never commit secrets** - Use .gitignore for .env, passwords, keys\n- **GitHub = collaboration platform** - Pull requests enable code review\n- **Python + Git** - Automate Git operations with subprocess module"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "14_02-challenge-4",
              "title": "Interactive Exercise",
              "description": "Create a Python script that:\n1. Checks if you're in a Git repository\n2. Shows current branch and status\n3. Lists uncommitted changes\n4. Prompts to create a commit with validation\n5. Handles errors gracefully",
              "instructions": "Create a Python script that:\n1. Checks if you're in a Git repository\n2. Shows current branch and status\n3. Lists uncommitted changes\n4. Prompts to create a commit with validation\n5. Handles errors gracefully",
              "starterCode": "import subprocess\nfrom typing import Optional\n\nclass GitCommitHelper:\n    def is_git_repo(self) -> bool:\n        # TODO: Check if current directory is Git repo\n        # Hint: Run 'git rev-parse --is-inside-work-tree'\n        pass\n    \n    def get_status(self) -> str:\n        # TODO: Get git status\n        pass\n    \n    def get_branch(self) -> str:\n        # TODO: Get current branch name\n        pass\n    \n    def has_changes(self) -> bool:\n        # TODO: Check if there are uncommitted changes\n        pass\n    \n    def commit_changes(self, message: str) -> bool:\n        # TODO: Stage all changes and commit\n        # Validate message is not empty\n        pass\n\n# Test the helper\nhelper = GitCommitHelper()\nif helper.is_git_repo():\n    print(f\"Branch: {helper.get_branch()}\")\n    if helper.has_changes():\n        message = input(\"Commit message: \")\n        helper.commit_changes(message)",
              "solution": "",
              "language": "python",
              "testCases": [
                {
                  "description": "Code runs without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use subprocess.run() to execute git commands. Check return code for success/failure. Capture output with capture_output=True."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "14_03",
          "title": "Testing Best Practices",
          "moduleId": "module-14",
          "order": 3,
          "estimatedMinutes": 35,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Concept: Testing is Insurance",
              "content": "**Tests = Proof your code works**\n\n**Think of testing like:**\n- Car safety tests before sale\n- Taste-testing food before serving\n- Checking parachute before jumping\n\n**Why test:**\n\n1. **Catch bugs early** 🐛\n   - Before users find them\n   - Cheaper to fix\n   - Build confidence\n\n2. **Prevent regressions** ↩️\n   - New code doesn't break old features\n   - Safe to refactor\n   - Automated checks\n\n3. **Document behavior** 📖\n   - Tests show how code should work\n   - Examples of usage\n   - Living documentation\n\n4. **Design improvement** 🎨\n   - Hard to test = bad design\n   - Forces modular code\n   - Clear interfaces\n\n**Types of tests:**\n\n**1. Unit Tests** 🔬\n- Test single function/class\n- Fast (milliseconds)\n- Isolated (no database, network)\n- Most common\n\n**2. Integration Tests** 🔗\n- Test components together\n- Database, API calls\n- Slower\n- Realistic scenarios\n\n**3. End-to-End (E2E) Tests** 🎬\n- Test entire application\n- User perspective\n- Slowest\n- Most realistic\n\n**Test pyramid:**\n```\n      /\\  \n     /E2E\\      ← Few (expensive, slow)\n    /─────\\\n   /Integr\\     ← Some (moderate speed)\n  /────────\\\n /Unit Tests\\   ← Many (cheap, fast)\n/────────────\\\n```\n\n**Write tests that:**\n✓ Are fast\n✓ Are independent\n✓ Are repeatable\n✓ Validate one thing\n✓ Have clear names"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example: Unit Testing with pytest",
              "content": "**pytest features:**\n\n**1. Simple assertions:**\n```python\nassert result == expected\nassert value > 0\nassert item in list\n```\n\n**2. Testing exceptions:**\n```python\nwith pytest.raises(ValueError):\n    function_that_fails()\n```\n\n**3. Fixtures (setup/teardown):**\n```python\n@pytest.fixture\ndef database():\n    db = create_db()\n    yield db  # Test runs here\n    db.close()\n```\n\n**4. Parametrized tests:**\n```python\n@pytest.mark.parametrize(\"input,expected\", [\n    (1, 2),\n    (2, 4),\n])\ndef test_double(input, expected):\n    assert double(input) == expected\n```\n\n**Test naming:**\n- Prefix with `test_`\n- Descriptive names\n- One test = one concept",
              "code": "# Example functions to test\n\ndef add(a, b):\n    \"\"\"Add two numbers\"\"\"\n    return a + b\n\ndef divide(a, b):\n    \"\"\"Divide two numbers\"\"\"\n    if b == 0:\n        raise ValueError(\"Cannot divide by zero\")\n    return a / b\n\ndef is_palindrome(text):\n    \"\"\"Check if text is a palindrome\"\"\"\n    cleaned = ''.join(c.lower() for c in text if c.isalnum())\n    return cleaned == cleaned[::-1]\n\nclass Calculator:\n    \"\"\"Simple calculator class\"\"\"\n    \n    def __init__(self):\n        self.history = []\n    \n    def add(self, a, b):\n        result = a + b\n        self.history.append(f\"{a} + {b} = {result}\")\n        return result\n    \n    def get_history(self):\n        return self.history.copy()\n\nprint(\"=== Writing Tests with pytest ===\")\n\n# Test file: test_calculator.py\ntest_code = '''\nimport pytest\nfrom calculator import add, divide, is_palindrome, Calculator\n\n# Basic unit tests\ndef test_add_positive_numbers():\n    \"\"\"Test adding positive numbers\"\"\"\n    assert add(2, 3) == 5\n    assert add(10, 20) == 30\n\ndef test_add_negative_numbers():\n    \"\"\"Test adding negative numbers\"\"\"\n    assert add(-1, -1) == -2\n    assert add(-5, 5) == 0\n\ndef test_divide_normal():\n    \"\"\"Test normal division\"\"\"\n    assert divide(10, 2) == 5\n    assert divide(9, 3) == 3\n\ndef test_divide_by_zero():\n    \"\"\"Test division by zero raises error\"\"\"\n    with pytest.raises(ValueError, match=\"Cannot divide by zero\"):\n        divide(10, 0)\n\ndef test_is_palindrome_simple():\n    \"\"\"Test simple palindromes\"\"\"\n    assert is_palindrome(\"racecar\") == True\n    assert is_palindrome(\"hello\") == False\n\ndef test_is_palindrome_case_insensitive():\n    \"\"\"Test case insensitivity\"\"\"\n    assert is_palindrome(\"RaceCar\") == True\n    assert is_palindrome(\"A man a plan a canal Panama\") == True\n\n# Test with fixtures\n@pytest.fixture\ndef calculator():\n    \"\"\"Fixture providing a fresh Calculator instance\"\"\"\n    return Calculator()\n\ndef test_calculator_add(calculator):\n    \"\"\"Test calculator add method\"\"\"\n    result = calculator.add(5, 3)\n    assert result == 8\n\ndef test_calculator_history(calculator):\n    \"\"\"Test calculator maintains history\"\"\"\n    calculator.add(5, 3)\n    calculator.add(10, 2)\n    history = calculator.get_history()\n    assert len(history) == 2\n    assert \"5 + 3 = 8\" in history\n\n# Parametrized tests (test multiple inputs)\n@pytest.mark.parametrize(\"a,b,expected\", [\n    (2, 3, 5),\n    (10, 20, 30),\n    (-1, 1, 0),\n    (0, 0, 0),\n    (100, 200, 300)\n])\ndef test_add_parametrized(a, b, expected):\n    \"\"\"Test add with multiple parameter sets\"\"\"\n    assert add(a, b) == expected\n\n# Test error messages\ndef test_divide_error_message():\n    \"\"\"Test error message is helpful\"\"\"\n    try:\n        divide(10, 0)\n        assert False, \"Should have raised ValueError\"\n    except ValueError as e:\n        assert \"Cannot divide by zero\" in str(e)\n'''\n\nprint(\"Test file example:\")\nprint(test_code)\n\nprint(\"\\n=== Running Tests ===\")\nprint(\"\"\"\nCommand: pytest test_calculator.py\n\nOutput:\n========================= test session starts =========================\ncollected 10 items\n\ntest_calculator.py ..........                                   [100%]\n\n========================= 10 passed in 0.03s =========================\n\nOptions:\n  pytest -v                    # Verbose output\n  pytest -k \"palindrome\"       # Run tests matching name\n  pytest --cov                 # Show code coverage\n  pytest -x                    # Stop on first failure\n  pytest --pdb                 # Drop into debugger on failure\n\"\"\")\n\nprint(\"\\n=== Test Organization ===\")\n\nproject_structure = \"\"\"\nmy_project/\n├── src/\n│   ├── __init__.py\n│   ├── calculator.py\n│   ├── models.py\n│   └── services.py\n│\n├── tests/\n│   ├── __init__.py\n│   ├── conftest.py          # Shared fixtures\n│   ├── test_calculator.py   # Test calculator module\n│   ├── test_models.py       # Test models\n│   └── test_services.py     # Test services\n│\n├── pytest.ini               # pytest configuration\n└── requirements-test.txt    # Test dependencies\n\"\"\"\n\nprint(project_structure)",
              "language": "python"
            },
            {
              "type": "ANALOGY",
              "title": "Test-Driven Development (TDD)",
              "content": "**TDD = Write tests before code**\n\n**The cycle:**\n\n```\n1. 🔴 Red: Write failing test\n   ↓\n2. 🟢 Green: Write minimal code to pass\n   ↓\n3. 🔵 Refactor: Improve code quality\n   ↓\n   Repeat\n```\n\n**Example workflow:**\n\n**Step 1: Red (failing test)**\n```python\ndef test_validate_email():\n    assert validate_email(\"user@example.com\") == True\n    assert validate_email(\"invalid\") == False\n# Test fails - function doesn't exist\n```\n\n**Step 2: Green (make it pass)**\n```python\ndef validate_email(email):\n    return '@' in email\n# Test passes (barely)\n```\n\n**Step 3: Refactor (improve)**\n```python\nimport re\n\ndef validate_email(email):\n    pattern = r'^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$'\n    return bool(re.match(pattern, email))\n# Better implementation, tests still pass\n```\n\n**TDD benefits:**\n- Forces you to think about requirements\n- Every line of code is tested\n- No over-engineering\n- Confidence to refactor\n- Design emerges naturally"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "- **Tests are insurance** - Catch bugs before users do\n- **Unit tests are fastest** - Test small pieces in isolation\n- **pytest makes testing easy** - Simple syntax, powerful features\n- **TDD = Red, Green, Refactor** - Write test, make it pass, improve\n- **One test, one concept** - Keep tests focused and clear\n- **Fixtures for setup** - Reusable test dependencies\n- **Parametrize for multiple inputs** - Test many cases efficiently\n- **Good tests = good design** - Hard to test = bad design"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "14_03-challenge-4",
              "title": "Interactive Exercise",
              "description": "Practice TDD by creating a Password Validator:\n1. Write tests for password requirements:\n   - Min 8 characters\n   - At least one uppercase letter\n   - At least one number\n   - At least one special character\n2. Implement the validator to pass all tests\n3. Use pytest parametrize for multiple test cases",
              "instructions": "Practice TDD by creating a Password Validator:\n1. Write tests for password requirements:\n   - Min 8 characters\n   - At least one uppercase letter\n   - At least one number\n   - At least one special character\n2. Implement the validator to pass all tests\n3. Use pytest parametrize for multiple test cases",
              "starterCode": "import pytest\nimport re\n\n# TODO: Write tests first!\ndef test_password_length():\n    # TODO: Test minimum length\n    pass\n\ndef test_password_uppercase():\n    # TODO: Test uppercase requirement\n    pass\n\n# TODO: Implement after tests\nclass PasswordValidator:\n    def __init__(self, min_length=8):\n        pass\n    \n    def validate(self, password):\n        # TODO: Return True if valid, False otherwise\n        pass\n    \n    def get_errors(self, password):\n        # TODO: Return list of error messages\n        pass",
              "solution": "",
              "language": "python",
              "testCases": [
                {
                  "description": "Code runs without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Start with simple tests. Use regex for character checks. Return helpful error messages."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "14_04",
          "title": "Documentation and Code Quality",
          "moduleId": "module-14",
          "order": 4,
          "estimatedMinutes": 35,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Concept: Code is Read More Than Written",
              "content": "**Documentation = Instructions for humans**\n\n**Think of it like:**\n- Recipe for cooking\n- User manual for appliances\n- Assembly instructions for furniture\n\n**Why documentation matters:**\n\n1. **Future you** 🔮\n   - You'll forget why you wrote code\n   - 6 months = forever\n   - Save yourself debugging time\n\n2. **Other developers** 👥\n   - Team members need to understand\n   - Open source contributors\n   - Code reviews\n\n3. **Users** 👤\n   - How to install\n   - How to use\n   - Troubleshooting\n\n**Types of documentation:**\n\n**1. Code comments** 💬\n```python\n# Explain WHY, not WHAT\n# Good: Cache result to avoid expensive API call\n# Bad: This stores the result\n```\n\n**2. Docstrings** 📝\n```python\ndef calculate_total(items, tax_rate):\n    \"\"\"Calculate total price including tax.\n    \n    Args:\n        items: List of item prices\n        tax_rate: Tax rate as decimal (0.1 = 10%)\n    \n    Returns:\n        Total price with tax applied\n    \"\"\"\n```\n\n**3. README.md** 📄\n- What the project does\n- How to install\n- How to use\n- Examples\n- Contributing guide\n\n**4. API documentation** 🔗\n- Endpoint descriptions\n- Request/response examples\n- Authentication details\n\n**Code quality = Readable, maintainable code**\n\n**PEP 8 (Python Style Guide):**\n- 4 spaces for indentation\n- Max 79 characters per line\n- 2 blank lines between functions\n- snake_case for variables\n- PascalCase for classes\n\n**Tools:**\n- **Black** - Auto-formatter\n- **flake8** - Style checker\n- **pylint** - Code analyzer\n- **mypy** - Type checker"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example: Writing Good Documentation",
              "content": "**Documentation best practices:**\n\n**Docstring format (Google style):**\n```python\ndef function(arg1, arg2):\n    \"\"\"Short description.\n    \n    Longer description if needed.\n    \n    Args:\n        arg1: Description of arg1\n        arg2: Description of arg2\n    \n    Returns:\n        Description of return value\n    \n    Raises:\n        ValueError: When this error occurs\n    \"\"\"\n```\n\n**Type hints:**\n```python\nfrom typing import List, Optional\n\ndef greet(name: str, times: int = 1) -> str:\n    return (\"Hello \" + name + \"! \") * times\n```\n\n**Comments:**\n- Explain WHY, not WHAT\n- Complex logic needs explanation\n- TODO/FIXME for future work\n\n**README sections:**\n1. What it does\n2. Installation\n3. Quick start\n4. Examples\n5. Configuration\n6. Contributing\n7. License",
              "code": "print(\"=== Example 1: Poor vs Good Documentation ===\")\n\n# BAD: No documentation\ndef calc(x, y, z):\n    return (x + y) * z\n\n# GOOD: Clear documentation\ndef calculate_total_with_tax(subtotal, tax_rate, quantity):\n    \"\"\"Calculate final price including tax for multiple items.\n    \n    Args:\n        subtotal (float): Price of single item before tax\n        tax_rate (float): Tax rate as decimal (e.g., 0.08 for 8%)\n        quantity (int): Number of items to purchase\n    \n    Returns:\n        float: Total price including tax\n    \n    Example:\n        >>> calculate_total_with_tax(10.00, 0.08, 3)\n        32.4\n    \"\"\"\n    return (subtotal + subtotal * tax_rate) * quantity\n\nprint(\"\\nBAD function:\")\nprint(f\"calc(10, 0.08, 3) = {calc(10, 0.08, 3)}\")\nprint(\"What does this do? 🤔\")\n\nprint(\"\\nGOOD function:\")\nprint(f\"calculate_total_with_tax(10.00, 0.08, 3) = {calculate_total_with_tax(10.00, 0.08, 3)}\")\nprint(\"Clear what this calculates! ✓\")\n\nprint(\"\\n=== Example 2: Comprehensive Docstrings ===\")\n\nfrom typing import List, Optional\n\nclass User:\n    \"\"\"Represents a user in the system.\n    \n    Attributes:\n        username (str): Unique username for login\n        email (str): User's email address\n        is_active (bool): Whether account is active\n    \"\"\"\n    \n    def __init__(self, username: str, email: str):\n        \"\"\"Initialize a new user.\n        \n        Args:\n            username: Unique identifier for the user\n            email: Contact email address\n        \n        Raises:\n            ValueError: If username or email is empty\n        \"\"\"\n        if not username or not email:\n            raise ValueError(\"Username and email are required\")\n        \n        self.username = username\n        self.email = email\n        self.is_active = True\n    \n    def deactivate(self) -> None:\n        \"\"\"Deactivate the user account.\n        \n        This prevents the user from logging in but preserves\n        their data for potential reactivation.\n        \"\"\"\n        self.is_active = False\n    \n    def send_notification(self, message: str) -> bool:\n        \"\"\"Send notification email to user.\n        \n        Args:\n            message: The notification message to send\n        \n        Returns:\n            True if notification sent successfully, False otherwise\n        \n        Note:\n            This simulates sending an email. In production,\n            integrate with actual email service.\n        \"\"\"\n        print(f\"[Email to {self.email}] {message}\")\n        return True\n\nprint(\"User class with comprehensive docstrings\")\nuser = User(\"alice\", \"alice@example.com\")\nprint(f\"Created user: {user.username}\")\nuser.send_notification(\"Welcome to the platform!\")\n\nprint(\"\\n=== Example 3: README.md Template ===\")\n\nreadme_template = '''\n# Project Name\n\nOne-line description of what this project does.\n\n## Features\n\n- Feature 1: Brief description\n- Feature 2: Brief description\n- Feature 3: Brief description\n\n## Installation\n\n```bash\n# Clone the repository\ngit clone https://github.com/username/project.git\ncd project\n\n# Create virtual environment\npython -m venv venv\nsource venv/bin/activate  # Windows: venv\\\\Scripts\\\\activate\n\n# Install dependencies\npip install -r requirements.txt\n```\n\n## Quick Start\n\n```python\nfrom project import MainClass\n\n# Basic usage example\nobj = MainClass()\nresult = obj.do_something()\nprint(result)\n```\n\n## Usage\n\n### Example 1: Basic Usage\n\n```python\n# Code example\n```\n\n### Example 2: Advanced Usage\n\n```python\n# More complex example\n```\n\n## Configuration\n\nCreate a `.env` file:\n\n```\nDATABASE_URL=postgresql://user:pass@localhost/db\nSECRET_KEY=your-secret-key\nDEBUG=False\n```\n\n## Running Tests\n\n```bash\npytest tests/\n```\n\n## Contributing\n\n1. Fork the repository\n2. Create a feature branch (`git checkout -b feature/amazing-feature`)\n3. Commit your changes (`git commit -m 'Add amazing feature'`)\n4. Push to branch (`git push origin feature/amazing-feature`)\n5. Open a Pull Request\n\n## License\n\nMIT License - see LICENSE file for details\n\n## Contact\n\nYour Name - your.email@example.com\n\nProject Link: https://github.com/username/project\n'''\n\nprint(readme_template)\n\nprint(\"\\n=== Example 4: Code Quality Tools ===\")\n\nprint(\"\\n1. Black (Auto-formatter)\")\nprint(\"\"\"\n# Install\npip install black\n\n# Format all Python files\nblack .\n\n# Check without modifying\nblack --check .\n\n# Configuration: pyproject.toml\n[tool.black]\nline-length = 88\ntarget-version = ['py38']\n\"\"\")\n\nprint(\"\\n2. flake8 (Style checker)\")\nprint(\"\"\"\n# Install\npip install flake8\n\n# Check all files\nflake8 .\n\n# Configuration: .flake8\n[flake8]\nmax-line-length = 88\nexclude = .git,__pycache__,venv\nignore = E203, W503\n\"\"\")\n\nprint(\"\\n3. mypy (Type checker)\")\nprint(\"\"\"\n# Install\npip install mypy\n\n# Check types\nmypy src/\n\n# Configuration: mypy.ini\n[mypy]\npython_version = 3.8\nwarn_return_any = True\nwarn_unused_configs = True\n\"\"\")\n\nprint(\"\\n=== Example 5: Type Hints ===\")\n\ndef process_users(users: List[dict], active_only: bool = True) -> List[str]:\n    \"\"\"Extract usernames from user dictionaries.\n    \n    Args:\n        users: List of user dictionaries with 'username' and 'is_active' keys\n        active_only: If True, only return active users\n    \n    Returns:\n        List of usernames\n    \"\"\"\n    result = []\n    for user in users:\n        if not active_only or user.get('is_active', True):\n            result.append(user['username'])\n    return result\n\n# Better with type hints\nfrom typing import TypedDict\n\nclass UserDict(TypedDict):\n    username: str\n    email: str\n    is_active: bool\n\ndef process_users_typed(users: List[UserDict], active_only: bool = True) -> List[str]:\n    \"\"\"Extract usernames from user dictionaries (type-safe).\"\"\"\n    result = []\n    for user in users:\n        if not active_only or user['is_active']:\n            result.append(user['username'])\n    return result\n\nprint(\"\\nType hints make code more maintainable:\")\ntest_users: List[UserDict] = [\n    {'username': 'alice', 'email': 'alice@example.com', 'is_active': True},\n    {'username': 'bob', 'email': 'bob@example.com', 'is_active': False},\n]\n\nactive_users = process_users_typed(test_users, active_only=True)\nprint(f\"Active users: {active_users}\")",
              "language": "python"
            },
            {
              "type": "ANALOGY",
              "title": "Code Review Checklist",
              "content": "**Code review = Quality gate before merging**\n\n**What to look for:**\n\n**1. Functionality** ✅\n- Does it work as intended?\n- Are edge cases handled?\n- Are errors handled properly?\n\n**2. Tests** 🧪\n- Are there tests?\n- Do tests cover edge cases?\n- Do all tests pass?\n\n**3. Code Quality** 💎\n- Is code readable?\n- Are names descriptive?\n- Is logic clear?\n- DRY (Don't Repeat Yourself)?\n\n**4. Documentation** 📚\n- Are functions documented?\n- Is README updated?\n- Are comments helpful?\n\n**5. Security** 🔒\n- No hardcoded secrets?\n- Input validation?\n- SQL injection prevention?\n\n**6. Performance** ⚡\n- Efficient algorithms?\n- No unnecessary loops?\n- Database queries optimized?\n\n**Review comments:**\n\n**Good:**\n- \"Consider using a dict here for O(1) lookup\"\n- \"Great job handling this edge case!\"\n- \"Could we add a test for the error case?\"\n\n**Bad:**\n- \"This is wrong\"\n- \"Why did you do it this way?\"\n- \"Fix this\""
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "- **Code is read more than written** - Prioritize readability\n- **Docstrings document functions** - Args, Returns, Raises, Examples\n- **Type hints improve safety** - Catch errors before runtime\n- **README is your first impression** - Clear installation and usage\n- **PEP 8 is the Python style guide** - Consistent formatting matters\n- **Black auto-formats code** - Never debate formatting again\n- **Comments explain WHY** - Code shows WHAT, comments show WHY\n- **Code review is quality control** - Catch issues before production"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "14_04-challenge-3",
              "title": "Interactive Exercise",
              "description": "Improve this poorly documented code:\n1. Add comprehensive docstrings\n2. Add type hints\n3. Improve variable names\n4. Add comments where needed\n5. Follow PEP 8 style",
              "instructions": "Improve this poorly documented code:\n1. Add comprehensive docstrings\n2. Add type hints\n3. Improve variable names\n4. Add comments where needed\n5. Follow PEP 8 style",
              "starterCode": "def p(l):\n    r=[]\n    for i in l:\n        if i%2==0:\n            r.append(i*2)\n    return r\n\nclass C:\n    def __init__(self,n,a):\n        self.n=n\n        self.a=a\n    def g(self):\n        return self.n if self.a else None",
              "solution": "",
              "language": "python",
              "testCases": [
                {
                  "description": "Code runs without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use descriptive names. Add docstrings. Format with proper spacing. Add type hints."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "14_05",
          "title": "Deployment and Final Capstone Project",
          "moduleId": "module-14",
          "order": 5,
          "estimatedMinutes": 45,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Concept: Shipping Your Code",
              "content": "**Deployment = Making your app available to users**\n\n**Think of it like:**\n- Opening a restaurant (not just cooking at home)\n- Publishing a book (not just writing it)\n- Launching a rocket (not just building it)\n\n**Development vs Production:**\n\n**Development** 💻\n- On your computer\n- Debug mode enabled\n- Small test database\n- You're the only user\n- Frequent changes\n\n**Production** 🚀\n- On a server\n- Debug mode OFF\n- Real database\n- Many users\n- Stable, tested code\n\n**Deployment platforms:**\n\n**1. Platform-as-a-Service (PaaS)** ☁️\n- Heroku\n- PythonAnywhere\n- Google App Engine\n- Railway\n\n**Pros:**\n- Easy to use\n- Auto-scaling\n- Managed services\n\n**Cons:**\n- More expensive\n- Less control\n\n**2. Infrastructure-as-a-Service (IaaS)** 🏢\n- AWS EC2\n- DigitalOcean\n- Linode\n\n**Pros:**\n- Full control\n- Cheaper at scale\n\n**Cons:**\n- More setup\n- You manage servers\n\n**3. Serverless** ⚡\n- AWS Lambda\n- Vercel\n- Netlify Functions\n\n**Pros:**\n- No servers to manage\n- Pay per use\n\n**Cons:**\n- Cold starts\n- Vendor lock-in\n\n**Deployment checklist:**\n\n```\n1. ✅ Environment variables (.env)\n2. ✅ Production database\n3. ✅ Debug mode = False\n4. ✅ Secret key changed\n5. ✅ Dependencies listed (requirements.txt)\n6. ✅ HTTPS enabled\n7. ✅ Error logging\n8. ✅ Backups configured\n9. ✅ Tests passing\n10. ✅ Performance tested\n```\n\n**CI/CD (Continuous Integration/Deployment):**\n- Automated testing\n- Automated deployment\n- Every push triggers tests\n- Passing tests auto-deploy\n\n**Example workflow:**\n```\nDeveloper → Git Push → Tests Run → Deploy to Server\n```"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example: Preparing for Deployment",
              "content": "**Production deployment steps:**\n\n**1. Configuration:**\n- Separate dev/prod configs\n- Environment variables for secrets\n- Debug mode OFF in production\n\n**2. Dependencies:**\n- requirements.txt for production\n- requirements-dev.txt for development\n- Pin versions (Flask==3.0.0)\n\n**3. Server:**\n- Use gunicorn (not Flask dev server)\n- Multiple workers for concurrency\n- Proper error handling\n\n**4. Monitoring:**\n- Logging to files\n- Error tracking (Sentry)\n- Health check endpoints\n\n**5. Security:**\n- HTTPS only\n- Secure cookies\n- Input validation\n- Regular updates",
              "code": "import os\nfrom pathlib import Path\n\nprint(\"=== Deployment Preparation ===\")\n\nprint(\"\\n1. Environment Configuration\")\n\nconfig_example = '''\n# config.py - Production-ready configuration\n\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nclass Config:\n    \"\"\"Base configuration\"\"\"\n    SECRET_KEY = os.getenv('SECRET_KEY', 'dev-key-change-in-production')\n    SQLALCHEMY_TRACK_MODIFICATIONS = False\n    \nclass DevelopmentConfig(Config):\n    \"\"\"Development environment configuration\"\"\"\n    DEBUG = True\n    DATABASE_URI = 'sqlite:///dev.db'\n    \nclass ProductionConfig(Config):\n    \"\"\"Production environment configuration\"\"\"\n    DEBUG = False\n    DATABASE_URI = os.getenv('DATABASE_URL')\n    \n    # Security settings\n    SESSION_COOKIE_SECURE = True  # HTTPS only\n    SESSION_COOKIE_HTTPONLY = True\n    PERMANENT_SESSION_LIFETIME = 3600  # 1 hour\n    \n    # Logging\n    LOG_LEVEL = 'ERROR'\n    \nclass TestConfig(Config):\n    \"\"\"Test environment configuration\"\"\"\n    TESTING = True\n    DATABASE_URI = 'sqlite:///:memory:'\n\n# Select config based on environment\nconfig = {\n    'development': DevelopmentConfig,\n    'production': ProductionConfig,\n    'test': TestConfig,\n    'default': DevelopmentConfig\n}\n\ndef get_config():\n    env = os.getenv('FLASK_ENV', 'development')\n    return config.get(env, config['default'])\n'''\n\nprint(config_example)\n\nprint(\"\\n2. Requirements Management\")\n\nrequirements_example = '''\n# requirements.txt - Production dependencies\nFlask==3.0.0\nSQLAlchemy==2.0.0\npython-dotenv==1.0.0\ngunicorn==21.2.0  # Production server\npsycopg2-binary==2.9.9  # PostgreSQL\n\n# requirements-dev.txt - Development dependencies\n-r requirements.txt  # Include production deps\npytest==7.4.0\nblack==23.0.0\nflake8==6.0.0\nmypy==1.5.0\n'''\n\nprint(requirements_example)\n\nprint(\"\\n3. Procfile (for Heroku/Railway)\")\n\nprocfile_example = '''\n# Procfile\nweb: gunicorn app:app\n\n# With workers and timeout\nweb: gunicorn app:app --workers 4 --timeout 30\n'''\n\nprint(procfile_example)\n\nprint(\"\\n4. Production-Ready App Structure\")\n\napp_example = '''\n# app.py - Production-ready Flask app\n\nimport os\nimport logging\nfrom flask import Flask, jsonify\nfrom config import get_config\n\n# Initialize Flask app\napp = Flask(__name__)\napp.config.from_object(get_config())\n\n# Configure logging\nif not app.debug:\n    logging.basicConfig(\n        level=logging.ERROR,\n        format='%(asctime)s %(levelname)s: %(message)s'\n    )\n    file_handler = logging.FileHandler('app.log')\n    file_handler.setLevel(logging.ERROR)\n    app.logger.addHandler(file_handler)\n\n# Error handlers\n@app.errorhandler(404)\ndef not_found(error):\n    return jsonify({'error': 'Not found'}), 404\n\n@app.errorhandler(500)\ndef internal_error(error):\n    app.logger.error(f'Server Error: {error}')\n    return jsonify({'error': 'Internal server error'}), 500\n\n# Health check endpoint\n@app.route('/health')\ndef health_check():\n    return jsonify({'status': 'healthy'}), 200\n\n# Main routes\n@app.route('/')\ndef index():\n    return jsonify({'message': 'Welcome to the API'})\n\nif __name__ == '__main__':\n    # For development only\n    port = int(os.getenv('PORT', 5000))\n    app.run(host='0.0.0.0', port=port)\n'''\n\nprint(app_example)\n\nprint(\"\\n5. Docker Deployment (Optional)\")\n\ndockerfile_example = '''\n# Dockerfile\nFROM python:3.11-slim\n\n# Set working directory\nWORKDIR /app\n\n# Copy requirements\nCOPY requirements.txt .\n\n# Install dependencies\nRUN pip install --no-cache-dir -r requirements.txt\n\n# Copy application\nCOPY . .\n\n# Expose port\nEXPOSE 5000\n\n# Run application\nCMD [\"gunicorn\", \"app:app\", \"--bind\", \"0.0.0.0:5000\"]\n'''\n\nprint(dockerfile_example)\n\nprint(\"\\n=== Deployment Workflows ===\")\n\nprint(\"\\n1. Deploying to Heroku:\")\nheroku_steps = '''\n# Install Heroku CLI\n# Visit: https://devcenter.heroku.com/articles/heroku-cli\n\n# Login\nheroku login\n\n# Create app\nheroku create my-app-name\n\n# Set environment variables\nheroku config:set SECRET_KEY=your-secret-key\nheroku config:set DATABASE_URL=postgres://...\nheroku config:set FLASK_ENV=production\n\n# Add PostgreSQL database (optional)\nheroku addons:create heroku-postgresql:mini\n\n# Deploy\ngit push heroku main\n\n# Run migrations (if using database)\nheroku run python migrate.py\n\n# Open app\nheroku open\n\n# View logs\nheroku logs --tail\n'''\n\nprint(heroku_steps)\n\nprint(\"\\n2. Deploying to PythonAnywhere:\")\npythonanywhere_steps = '''\n1. Sign up at pythonanywhere.com\n2. Open Bash console\n3. Clone your repository:\n   git clone https://github.com/username/repo.git\n   cd repo\n   \n4. Create virtual environment:\n   python -m venv venv\n   source venv/bin/activate\n   pip install -r requirements.txt\n   \n5. Configure web app in Web tab:\n   - Source code: /home/username/repo\n   - Working directory: /home/username/repo\n   - Virtualenv: /home/username/repo/venv\n   - WSGI file: Edit to point to your app\n   \n6. Set environment variables in Web tab\n\n7. Reload web app\n'''\n\nprint(pythonanywhere_steps)\n\nprint(\"\\n3. Using GitHub Actions (CI/CD):\")\ngithub_actions = '''\n# .github/workflows/deploy.yml\n\nname: Deploy to Production\n\non:\n  push:\n    branches: [ main ]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    \n    steps:\n    - uses: actions/checkout@v2\n    \n    - name: Set up Python\n      uses: actions/setup-python@v2\n      with:\n        python-version: 3.11\n    \n    - name: Install dependencies\n      run: |\n        pip install -r requirements.txt\n        pip install -r requirements-dev.txt\n    \n    - name: Run tests\n      run: pytest\n    \n    - name: Check code style\n      run: flake8 .\n    \n  deploy:\n    needs: test\n    runs-on: ubuntu-latest\n    if: github.ref == 'refs/heads/main'\n    \n    steps:\n    - uses: actions/checkout@v2\n    \n    - name: Deploy to Heroku\n      uses: akhileshns/heroku-deploy@v3.12.12\n      with:\n        heroku_api_key: ${{secrets.HEROKU_API_KEY}}\n        heroku_app_name: \"my-app-name\"\n        heroku_email: \"your-email@example.com\"\n'''\n\nprint(github_actions)",
              "language": "python"
            },
            {
              "type": "ANALOGY",
              "title": "Final Capstone Project",
              "content": "**Capstone = Bring it all together**\n\n**Project: Task Management API with Authentication**\n\n**Features to implement:**\n\n**1. User Management** 👤\n- Registration (POST /api/auth/register)\n- Login (POST /api/auth/login)\n- Logout (POST /api/auth/logout)\n- Password hashing with bcrypt\n- JWT tokens for authentication\n\n**2. Task CRUD** ✅\n- Create task (POST /api/tasks)\n- List tasks (GET /api/tasks)\n- Get task (GET /api/tasks/{id})\n- Update task (PUT /api/tasks/{id})\n- Delete task (DELETE /api/tasks/{id})\n- Filter by status, priority\n\n**3. Categories** 🏷️\n- Create category (POST /api/categories)\n- Assign tasks to categories\n- List tasks by category\n\n**4. Security** 🔒\n- Authentication required for all endpoints\n- Users can only access their own tasks\n- Input validation\n- Rate limiting\n\n**5. Testing** 🧪\n- Unit tests for all functions\n- Integration tests for API endpoints\n- 80%+ code coverage\n\n**6. Documentation** 📚\n- README with setup instructions\n- API documentation\n- Docstrings for all functions\n- Environment setup guide\n\n**7. Deployment** 🚀\n- Deploy to Heroku or PythonAnywhere\n- Production database (PostgreSQL)\n- Environment variables configured\n- HTTPS enabled\n\n**Tech stack:**\n- Flask (web framework)\n- SQLAlchemy (database ORM)\n- PostgreSQL/SQLite (database)\n- JWT (authentication)\n- pytest (testing)\n- Heroku (deployment)\n\n**Evaluation criteria:**\n- ✅ All features working\n- ✅ Tests passing\n- ✅ Code quality (PEP 8, docstrings)\n- ✅ Git history (clear commits)\n- ✅ Documentation complete\n- ✅ Successfully deployed\n- ✅ Security best practices"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "- **Deployment = shipping code to users** - Production is different from development\n- **Environment variables for secrets** - Never commit passwords or API keys\n- **Use production servers** - gunicorn, not Flask dev server\n- **CI/CD automates deployment** - Tests run automatically, deploy if passing\n- **Monitor your application** - Logging and error tracking are essential\n- **Security matters** - HTTPS, secure cookies, input validation\n- **Capstone demonstrates skills** - Full-stack project shows what you've learned\n- **Keep learning** - Technology evolves, stay curious and keep building"
            }
          ],
          "challenges": []
        }
      ],
      "quizzes": [
        {
          "id": "quiz-14",
          "title": "Module 14 Quiz: Sharing Your Work",
          "description": "Test your knowledge of project planning, version control, testing, documentation, and deployment practices.",
          "moduleId": "module-14",
          "passingScore": 70,
          "estimatedMinutes": 15,
          "questions": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-14-q1",
              "title": "In a layered architecture, which layer should handle business logic and validation?",
              "description": "In a layered architecture, which layer should handle business logic and validation?",
              "options": [
                "Repository layer",
                "Service layer",
                "Model layer",
                "Controller/API layer"
              ],
              "correctAnswer": 1,
              "explanation": "The service layer handles business logic, validation, and coordinates operations between the API layer and repository layer."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-14-q2",
              "title": "What is the purpose of a .gitignore file?",
              "description": "What is the purpose of a .gitignore file?",
              "options": [
                "To track important files",
                "To list files that should not be tracked by Git",
                "To configure Git settings",
                "To document the project"
              ],
              "correctAnswer": 1,
              "explanation": ".gitignore specifies which files and directories Git should not track, such as .env files, virtual environments, and temporary files."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-14-q3",
              "title": "What does the 'git add .' command do?",
              "description": "What does the 'git add .' command do?",
              "options": [
                "Commits all changes",
                "Stages all changes in the current directory",
                "Pushes to remote repository",
                "Creates a new branch"
              ],
              "correctAnswer": 1,
              "explanation": "'git add .' stages all changes in the current directory and subdirectories, preparing them to be committed."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-14-q4",
              "title": "In Test-Driven Development (TDD), what is the correct order of steps?",
              "description": "In Test-Driven Development (TDD), what is the correct order of steps?",
              "options": [
                "Write code → Write tests → Refactor",
                "Red (failing test) → Green (passing code) → Refactor",
                "Refactor → Test → Code",
                "Test → Refactor → Code"
              ],
              "correctAnswer": 1,
              "explanation": "TDD follows Red-Green-Refactor: write a failing test (Red), write minimal code to pass (Green), then improve the code (Refactor)."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-14-q5",
              "title": "In the test pyramid, which type of test should you have the MOST of?",
              "description": "In the test pyramid, which type of test should you have the MOST of?",
              "options": [
                "End-to-end tests",
                "Integration tests",
                "Unit tests",
                "Manual tests"
              ],
              "correctAnswer": 2,
              "explanation": "Unit tests should be most numerous because they're fast, cheap, and test small isolated pieces. The pyramid: many unit tests, some integration tests, few E2E tests."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-14-q6",
              "title": "What is a pytest fixture used for?",
              "description": "What is a pytest fixture used for?",
              "options": [
                "To fix broken tests",
                "To provide reusable setup/teardown code for tests",
                "To mark tests as skipped",
                "To run tests in parallel"
              ],
              "correctAnswer": 1,
              "explanation": "Fixtures provide reusable setup code (like creating test databases or objects) that multiple tests can use. They run before each test."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-14-q7",
              "title": "What is the purpose of a docstring in Python?",
              "description": "What is the purpose of a docstring in Python?",
              "options": [
                "To comment out code",
                "To document what a function/class does, its parameters, and return value",
                "To format code automatically",
                "To check for syntax errors"
              ],
              "correctAnswer": 1,
              "explanation": "Docstrings (triple-quoted strings) document functions, classes, and modules. They describe purpose, parameters, return values, and provide examples."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-14-q8",
              "title": "What does PEP 8 define?",
              "description": "What does PEP 8 define?",
              "options": [
                "Python's syntax rules",
                "Python's style guide for code formatting",
                "Python's performance benchmarks",
                "Python's testing framework"
              ],
              "correctAnswer": 1,
              "explanation": "PEP 8 is Python's official style guide, defining conventions for naming, indentation, spacing, and code layout."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-14-q9",
              "title": "What tool automatically formats Python code to be PEP 8 compliant?",
              "description": "What tool automatically formats Python code to be PEP 8 compliant?",
              "options": [
                "pytest",
                "flake8",
                "Black",
                "mypy"
              ],
              "correctAnswer": 2,
              "explanation": "Black is an opinionated auto-formatter that formats Python code consistently. flake8 checks style, mypy checks types, pytest runs tests."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-14-q10",
              "title": "What should you NEVER do when deploying to production?",
              "description": "What should you NEVER do when deploying to production?",
              "options": [
                "Use environment variables",
                "Enable DEBUG mode",
                "Use HTTPS",
                "Configure logging"
              ],
              "correctAnswer": 1,
              "explanation": "DEBUG mode should NEVER be enabled in production as it exposes sensitive information and allows code execution via the browser."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-14-q11",
              "title": "What is the purpose of a Procfile?",
              "description": "What is the purpose of a Procfile?",
              "options": [
                "To process user input",
                "To tell deployment platforms how to run your app",
                "To process database queries",
                "To configure Python packages"
              ],
              "correctAnswer": 1,
              "explanation": "A Procfile tells platforms like Heroku what command to run to start your application (e.g., 'web: gunicorn app:app')."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-14-q12",
              "title": "What is the main purpose of separating code into layers (Model, Service, Repository)?",
              "description": "What is the main purpose of separating code into layers (Model, Service, Repository)?",
              "options": [
                "To make code run faster",
                "To separate concerns and make code more testable and maintainable",
                "To reduce file size",
                "To comply with Python syntax"
              ],
              "correctAnswer": 1,
              "explanation": "Layered architecture separates concerns, making each layer independently testable, maintainable, and allowing changes to one layer without affecting others."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-14-q13",
              "title": "What is the purpose of a Pull Request in Git workflow?",
              "description": "What is the purpose of a Pull Request in Git workflow?",
              "options": [
                "To download code from remote",
                "To request code review and discuss changes before merging",
                "To delete a branch",
                "To commit changes locally"
              ],
              "correctAnswer": 1,
              "explanation": "A Pull Request is a request to merge your changes into another branch, allowing for code review, discussion, and quality control before merging."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-14-q14",
              "title": "In pytest, what does the @pytest.mark.parametrize decorator do?",
              "description": "In pytest, what does the @pytest.mark.parametrize decorator do?",
              "options": [
                "Marks tests to skip",
                "Runs the same test with multiple sets of input data",
                "Sets up test fixtures",
                "Measures test performance"
              ],
              "correctAnswer": 1,
              "explanation": "@pytest.mark.parametrize allows you to run the same test function with multiple sets of input data, testing many cases efficiently."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-14-q15",
              "title": "What should code comments focus on explaining?",
              "description": "What should code comments focus on explaining?",
              "options": [
                "What the code does (the syntax)",
                "Why the code does it (the reasoning)",
                "How to run Python",
                "The variable names"
              ],
              "correctAnswer": 1,
              "explanation": "Comments should explain WHY the code does something, not WHAT it does. The code itself shows what; comments provide context and reasoning."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-14-q16",
              "title": "Why use gunicorn instead of Flask's development server in production?",
              "description": "Why use gunicorn instead of Flask's development server in production?",
              "options": [
                "Gunicorn is faster and designed for production workloads",
                "Gunicorn is required by Python",
                "Flask's server doesn't work in production",
                "Gunicorn is easier to configure"
              ],
              "correctAnswer": 0,
              "explanation": "Gunicorn is a production-grade WSGI server that handles multiple concurrent requests efficiently. Flask's dev server is single-threaded and not designed for production."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-14-q17",
              "title": "What is CI/CD?",
              "description": "What is CI/CD?",
              "options": [
                "Code Integration/Code Deployment",
                "Continuous Integration/Continuous Deployment - automated testing and deployment",
                "Customer Integration/Customer Development",
                "Code Inspection/Code Documentation"
              ],
              "correctAnswer": 1,
              "explanation": "CI/CD means Continuous Integration and Continuous Deployment - automatically running tests on every commit and deploying passing code to production."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-14-q18",
              "title": "What should NEVER be committed to a Git repository?",
              "description": "What should NEVER be committed to a Git repository?",
              "options": [
                "Python source files",
                "README.md",
                ".env files with secrets and API keys",
                "requirements.txt"
              ],
              "correctAnswer": 2,
              "explanation": "Sensitive files like .env containing secrets, passwords, or API keys should never be committed. Use .gitignore to exclude them."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-14-q19",
              "title": "What is the main benefit of type hints in Python?",
              "description": "What is the main benefit of type hints in Python?",
              "options": [
                "Makes code run faster",
                "Helps catch type errors early and improves IDE support",
                "Required for Python to work",
                "Automatically fixes bugs"
              ],
              "correctAnswer": 1,
              "explanation": "Type hints help catch type-related errors early (with tools like mypy) and provide better IDE autocomplete and documentation."
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "quiz-14-q20",
              "title": "In a professional project, what should a README.md file include?",
              "description": "In a professional project, what should a README.md file include?",
              "options": [
                "Only the project name",
                "Project description, installation instructions, usage examples, and contributing guidelines",
                "Just the source code",
                "Only deployment instructions"
              ],
              "correctAnswer": 1,
              "explanation": "A good README includes: project description, features, installation steps, usage examples, configuration, contributing guidelines, and contact information."
            }
          ]
        }
      ]
    }
  ],
  "metadata": {
    "version": "2.0.0",
    "lastUpdated": "2025-11-14",
    "author": "Code Tutor",
    "interactiveElements": {
      "totalLessons": 39,
      "totalChallenges": 36,
      "totalQuizzes": 14,
      "totalQuestions": 273
    }
  }
}