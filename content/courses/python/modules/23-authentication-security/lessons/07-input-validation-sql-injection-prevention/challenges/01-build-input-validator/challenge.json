{
  "id": "module-21-lesson-07-challenge-1",
  "type": "FREE_CODING",
  "title": "Build Input Validator",
  "description": "Create a comprehensive input validation system for the Finance Tracker that combines Pydantic validation with SQL injection prevention and safe database queries.",
  "instructions": "Complete the InputValidator class to:\n1. Implement Pydantic model for transaction validation\n2. Add SQL injection detection as defense in depth\n3. Create a safe database query builder\n4. Validate query parameters with proper constraints\n5. Ensure all database operations use parameterized queries",
  "startingCode": "from dataclasses import dataclass\nfrom typing import Optional, List, Dict, Any\nfrom decimal import Decimal\nfrom datetime import date\nimport re\n\n# Simulated database for testing\nclass MockDatabase:\n    def __init__(self):\n        self.queries: List[tuple] = []  # Track (query, params)\n    \n    def execute(self, query: str, params: tuple) -> List[Dict]:\n        self.queries.append((query, params))\n        return [{\"id\": 1, \"status\": \"success\"}]\n\n@dataclass\nclass ValidationResult:\n    is_valid: bool\n    errors: List[str]\n    sanitized_data: Optional[Dict] = None\n\nclass TransactionValidator:\n    \"\"\"Validates transaction input data.\"\"\"\n    \n    VALID_CATEGORIES = [\"food\", \"transport\", \"utilities\", \"entertainment\", \"income\", \"other\"]\n    SQL_INJECTION_PATTERNS = [\n        r\"(--|#)\",              # SQL comments\n        r\"(;\\s*DROP)\",          # DROP statements\n        r\"(;\\s*DELETE)\",        # DELETE statements\n        r\"('\\s*OR\\s+'1)\",       # OR injection\n        r\"(UNION\\s+SELECT)\",    # UNION injection\n    ]\n    \n    def validate_amount(self, amount: Any) -> tuple[bool, str, Optional[Decimal]]:\n        \"\"\"Validate transaction amount.\n        \n        Returns: (is_valid, error_message, sanitized_value)\n        \"\"\"\n        # TODO: Check if amount can be converted to Decimal\n        # TODO: Validate amount is positive and <= 1,000,000\n        # TODO: Validate max 2 decimal places\n        pass\n    \n    def validate_description(self, description: Any) -> tuple[bool, str, Optional[str]]:\n        \"\"\"Validate and sanitize description.\n        \n        Returns: (is_valid, error_message, sanitized_value)\n        \"\"\"\n        # TODO: Check if description is a string\n        # TODO: Check length (1-500 characters)\n        # TODO: Check for SQL injection patterns\n        # TODO: Strip HTML tags\n        # TODO: Strip whitespace\n        pass\n    \n    def validate_category(self, category: Any) -> tuple[bool, str, Optional[str]]:\n        \"\"\"Validate category against allowed values.\n        \n        Returns: (is_valid, error_message, sanitized_value)\n        \"\"\"\n        # TODO: Check if category is in VALID_CATEGORIES (case-insensitive)\n        # TODO: Return lowercase category\n        pass\n    \n    def validate_date(self, tx_date: Any) -> tuple[bool, str, Optional[date]]:\n        \"\"\"Validate transaction date.\n        \n        Returns: (is_valid, error_message, sanitized_value)\n        \"\"\"\n        # TODO: If None, return today's date\n        # TODO: If string, parse YYYY-MM-DD format\n        # TODO: If date object, validate not in future\n        pass\n    \n    def detect_sql_injection(self, value: str) -> bool:\n        \"\"\"Check if value contains SQL injection patterns.\"\"\"\n        # TODO: Check value against SQL_INJECTION_PATTERNS\n        # TODO: Return True if any pattern matches\n        pass\n    \n    def validate_transaction(self, data: Dict[str, Any]) -> ValidationResult:\n        \"\"\"Validate complete transaction data.\"\"\"\n        errors = []\n        sanitized = {}\n        \n        # TODO: Validate each field using the methods above\n        # TODO: Collect all errors\n        # TODO: Build sanitized_data dict if valid\n        # TODO: Return ValidationResult\n        pass\n\n\nclass SafeQueryBuilder:\n    \"\"\"Builds parameterized SQL queries.\"\"\"\n    \n    def __init__(self, db: MockDatabase):\n        self.db = db\n    \n    def insert_transaction(\n        self,\n        user_id: int,\n        amount: Decimal,\n        category: str,\n        description: str,\n        tx_date: date\n    ) -> Dict:\n        \"\"\"Insert transaction using parameterized query.\"\"\"\n        # TODO: Build INSERT query with $1, $2, etc. placeholders\n        # TODO: Execute with parameters tuple\n        # TODO: Return result\n        pass\n    \n    def search_transactions(\n        self,\n        user_id: int,\n        category: Optional[str] = None,\n        min_amount: Optional[Decimal] = None,\n        max_amount: Optional[Decimal] = None,\n        limit: int = 20,\n        offset: int = 0\n    ) -> List[Dict]:\n        \"\"\"Search transactions with optional filters using parameterized query.\"\"\"\n        # TODO: Build base query\n        # TODO: Add optional WHERE clauses with parameters\n        # TODO: Add LIMIT and OFFSET\n        # TODO: Execute with all parameters\n        pass\n\n\n# Tests\nprint(\"Input Validation Tests\")\nprint(\"=\" * 50)\n\nvalidator = TransactionValidator()\n\n# Test 1: Valid transaction\nprint(\"\\nTest 1: Valid transaction\")\nresult = validator.validate_transaction({\n    \"amount\": \"99.99\",\n    \"category\": \"Food\",\n    \"description\": \"Grocery shopping\",\n    \"date\": None\n})\nassert result.is_valid, f\"Expected valid, got errors: {result.errors}\"\nassert result.sanitized_data[\"amount\"] == Decimal(\"99.99\")\nassert result.sanitized_data[\"category\"] == \"food\"\nprint(\"Valid transaction accepted\")\n\n# Test 2: Invalid amount\nprint(\"\\nTest 2: Invalid amount\")\nresult = validator.validate_transaction({\n    \"amount\": \"-50\",\n    \"category\": \"food\",\n    \"description\": \"Test\"\n})\nassert not result.is_valid\nassert any(\"amount\" in e.lower() for e in result.errors)\nprint(f\"Rejected with: {result.errors}\")\n\n# Test 3: SQL injection in description\nprint(\"\\nTest 3: SQL injection detection\")\nresult = validator.validate_transaction({\n    \"amount\": \"10.00\",\n    \"category\": \"food\",\n    \"description\": \"Test'; DROP TABLE users; --\"\n})\nassert not result.is_valid\nassert any(\"injection\" in e.lower() or \"invalid\" in e.lower() for e in result.errors)\nprint(f\"SQL injection blocked: {result.errors}\")\n\n# Test 4: Invalid category\nprint(\"\\nTest 4: Invalid category\")\nresult = validator.validate_transaction({\n    \"amount\": \"10.00\",\n    \"category\": \"hacking\",\n    \"description\": \"Test\"\n})\nassert not result.is_valid\nassert any(\"category\" in e.lower() for e in result.errors)\nprint(f\"Invalid category rejected: {result.errors}\")\n\n# Test 5: HTML stripping\nprint(\"\\nTest 5: HTML tag stripping\")\nresult = validator.validate_transaction({\n    \"amount\": \"25.00\",\n    \"category\": \"other\",\n    \"description\": \"<script>alert('xss')</script>Normal text\"\n})\nassert result.is_valid\nassert \"<script>\" not in result.sanitized_data[\"description\"]\nassert \"Normal text\" in result.sanitized_data[\"description\"]\nprint(f\"HTML stripped: {result.sanitized_data['description']}\")\n\n# Test 6: Safe query builder\nprint(\"\\nTest 6: Parameterized queries\")\ndb = MockDatabase()\nbuilder = SafeQueryBuilder(db)\n\nbuilder.insert_transaction(\n    user_id=1,\n    amount=Decimal(\"50.00\"),\n    category=\"food\",\n    description=\"Lunch\",\n    tx_date=date.today()\n)\n\nassert len(db.queries) == 1\nquery, params = db.queries[0]\nassert \"$1\" in query and \"$2\" in query  # Parameterized\nassert \"50.00\" not in query  # Amount not in query string\nassert params == (1, Decimal(\"50.00\"), \"food\", \"Lunch\", date.today())\nprint(f\"Query: {query[:50]}...\")\nprint(f\"Params: {params}\")\n\n# Test 7: Search with filters\nprint(\"\\nTest 7: Search with parameterized filters\")\nbuilder.search_transactions(\n    user_id=1,\n    category=\"food\",\n    min_amount=Decimal(\"10.00\"),\n    limit=10,\n    offset=0\n)\n\nquery, params = db.queries[-1]\nassert \"$1\" in query\nassert \"food\" not in query  # Category not in query string\nassert 1 in params and \"food\" in params\nprint(f\"Query: {query[:60]}...\")\nprint(f\"Params: {params}\")\n\nprint(\"\\n\" + \"=\" * 50)\nprint(\"All input validation tests passed!\")",
  "language": "python",
  "testCases": [
    {
      "id": "test-1",
      "description": "Input validator validates transactions, detects SQL injection, sanitizes HTML, and builds parameterized queries",
      "expectedOutput": "All input validation tests passed!",
      "isVisible": true
    }
  ],
  "hints": [
    {
      "level": 1,
      "text": "**Hint:** Use `Decimal(str(value))` to safely convert amounts. For SQL injection detection, use `re.search()` with `re.IGNORECASE`. For HTML stripping, use `re.sub(r'<[^>]+>', '', text)`. Build parameterized queries by counting parameters ($1, $2, etc.) and collecting values in a list that becomes a tuple."
    }
  ],
  "commonMistakes": [
    {
      "mistake": "Relying only on input validation without parameterized queries",
      "consequence": "SQL injection still possible if validation is bypassed or has bugs",
      "correction": "Always use parameterized queries as the primary defense, with input validation as an additional layer"
    },
    {
      "mistake": "Using string concatenation to build SQL with user input",
      "consequence": "Direct SQL injection vulnerability",
      "correction": "Use $1, $2 placeholders and pass values as a separate tuple"
    },
    {
      "mistake": "Validating on client-side only",
      "consequence": "Attackers can bypass client-side validation entirely",
      "correction": "Always validate on the server; client-side validation is only for UX"
    }
  ],
  "difficulty": "advanced"
}