{
  "id": "module-21-lesson-10-challenge-1",
  "type": "FREE_CODING",
  "title": "Build a Security Audit Script",
  "description": "Create an automated security audit script that checks for common vulnerabilities in a web application configuration.",
  "instructions": "Complete the SecurityAuditor class to:\n1. Check for common security misconfigurations\n2. Validate password policy settings\n3. Verify security headers configuration\n4. Generate a pass/fail report with recommendations",
  "startingCode": "from dataclasses import dataclass\nfrom typing import List, Dict, Any, Optional\nfrom enum import Enum\n\nclass AuditStatus(Enum):\n    PASS = \"PASS\"\n    FAIL = \"FAIL\"\n    WARN = \"WARN\"\n\n@dataclass\nclass AuditCheck:\n    name: str\n    category: str\n    status: AuditStatus\n    message: str\n    recommendation: Optional[str] = None\n\nclass SecurityAuditor:\n    \"\"\"\n    Security auditor that checks application configuration\n    for common security issues.\n    \"\"\"\n    \n    def __init__(self, config: Dict[str, Any]):\n        self.config = config\n        self.checks: List[AuditCheck] = []\n    \n    def audit_password_policy(self) -> List[AuditCheck]:\n        \"\"\"\n        Audit password policy configuration.\n        \n        Check:\n        - Minimum length >= 12\n        - Requires uppercase, lowercase, digits, special chars\n        - Max attempts before lockout <= 5\n        - Lockout duration >= 15 minutes\n        \"\"\"\n        checks = []\n        policy = self.config.get(\"password_policy\", {})\n        \n        # TODO: Check minimum password length\n        min_length = policy.get(\"min_length\", 0)\n        # Add PASS if >= 12, FAIL otherwise\n        \n        # TODO: Check complexity requirements\n        # require_uppercase, require_lowercase, require_digits, require_special\n        \n        # TODO: Check lockout settings\n        # max_attempts <= 5, lockout_minutes >= 15\n        \n        return checks\n    \n    def audit_jwt_config(self) -> List[AuditCheck]:\n        \"\"\"\n        Audit JWT configuration.\n        \n        Check:\n        - Algorithm is not 'none' or 'HS256' with short key\n        - Access token expiry <= 30 minutes\n        - Refresh token expiry <= 7 days\n        - Secret key length >= 32 characters\n        \"\"\"\n        checks = []\n        jwt = self.config.get(\"jwt\", {})\n        \n        # TODO: Check algorithm\n        # FAIL if algorithm is 'none'\n        # WARN if HS256 with key < 32 chars\n        \n        # TODO: Check expiry times\n        # Access token <= 30 min, Refresh token <= 7 days\n        \n        return checks\n    \n    def audit_security_headers(self) -> List[AuditCheck]:\n        \"\"\"\n        Audit security headers configuration.\n        \n        Required headers:\n        - Strict-Transport-Security\n        - X-Content-Type-Options\n        - X-Frame-Options\n        - Content-Security-Policy\n        \"\"\"\n        checks = []\n        headers = self.config.get(\"security_headers\", {})\n        \n        required = [\n            (\"strict_transport_security\", \"HSTS protects against downgrade attacks\"),\n            (\"x_content_type_options\", \"Prevents MIME-type sniffing\"),\n            (\"x_frame_options\", \"Prevents clickjacking attacks\"),\n            (\"content_security_policy\", \"Prevents XSS and injection attacks\")\n        ]\n        \n        # TODO: Check each required header\n        # PASS if present, FAIL if missing\n        \n        return checks\n    \n    def audit_rate_limiting(self) -> List[AuditCheck]:\n        \"\"\"\n        Audit rate limiting configuration.\n        \n        Check:\n        - Rate limiting is enabled\n        - Login endpoint has stricter limits\n        - Limits are reasonable (not too high)\n        \"\"\"\n        checks = []\n        rate_limit = self.config.get(\"rate_limiting\", {})\n        \n        # TODO: Check if rate limiting is enabled\n        # TODO: Check login endpoint limits (<= 10 per minute)\n        # TODO: Check API endpoint limits\n        \n        return checks\n    \n    def run_audit(self) -> Dict[str, Any]:\n        \"\"\"\n        Run all audit checks and generate report.\n        \"\"\"\n        self.checks = []\n        \n        # Run all audits\n        self.checks.extend(self.audit_password_policy())\n        self.checks.extend(self.audit_jwt_config())\n        self.checks.extend(self.audit_security_headers())\n        self.checks.extend(self.audit_rate_limiting())\n        \n        # Calculate results\n        passed = sum(1 for c in self.checks if c.status == AuditStatus.PASS)\n        failed = sum(1 for c in self.checks if c.status == AuditStatus.FAIL)\n        warnings = sum(1 for c in self.checks if c.status == AuditStatus.WARN)\n        \n        return {\n            \"total_checks\": len(self.checks),\n            \"passed\": passed,\n            \"failed\": failed,\n            \"warnings\": warnings,\n            \"overall_status\": \"FAIL\" if failed > 0 else (\"WARN\" if warnings > 0 else \"PASS\"),\n            \"checks\": self.checks\n        }\n    \n    def print_report(self):\n        \"\"\"Print formatted audit report.\"\"\"\n        results = self.run_audit()\n        \n        print(\"\\n\" + \"=\" * 60)\n        print(\"SECURITY AUDIT REPORT\")\n        print(\"=\" * 60)\n        \n        print(f\"\\nTotal Checks: {results['total_checks']}\")\n        print(f\"  Passed: {results['passed']}\")\n        print(f\"  Failed: {results['failed']}\")\n        print(f\"  Warnings: {results['warnings']}\")\n        print(f\"\\nOverall Status: {results['overall_status']}\")\n        \n        # Group by category\n        categories = {}\n        for check in self.checks:\n            if check.category not in categories:\n                categories[check.category] = []\n            categories[check.category].append(check)\n        \n        for category, checks in categories.items():\n            print(f\"\\n--- {category} ---\")\n            for check in checks:\n                symbol = {\"PASS\": \"[+]\", \"FAIL\": \"[-]\", \"WARN\": \"[!]\"}[check.status.value]\n                print(f\"{symbol} {check.name}: {check.message}\")\n                if check.recommendation and check.status != AuditStatus.PASS:\n                    print(f\"    Fix: {check.recommendation}\")\n        \n        print(\"\\n\" + \"=\" * 60)\n        return results[\"overall_status\"] == \"PASS\"\n\n\n# Test configuration (mix of good and bad settings)\ntest_config = {\n    \"password_policy\": {\n        \"min_length\": 8,  # Too short!\n        \"require_uppercase\": True,\n        \"require_lowercase\": True,\n        \"require_digits\": True,\n        \"require_special\": False,  # Missing!\n        \"max_attempts\": 10,  # Too many!\n        \"lockout_minutes\": 5  # Too short!\n    },\n    \"jwt\": {\n        \"algorithm\": \"HS256\",\n        \"secret_key_length\": 64,\n        \"access_token_expiry_minutes\": 60,  # Too long!\n        \"refresh_token_expiry_days\": 30  # Too long!\n    },\n    \"security_headers\": {\n        \"strict_transport_security\": True,\n        \"x_content_type_options\": True,\n        # Missing x_frame_options and CSP!\n    },\n    \"rate_limiting\": {\n        \"enabled\": True,\n        \"login_requests_per_minute\": 20,  # Too high!\n        \"api_requests_per_minute\": 100\n    }\n}\n\nprint(\"Finance Tracker Security Audit\")\nauditor = SecurityAuditor(test_config)\npassed = auditor.print_report()\n\nif not passed:\n    print(\"\\nReview failed checks and update configuration before deployment.\")\nelse:\n    print(\"\\nAll security checks passed!\")",
  "language": "python",
  "testCases": [
    {
      "id": "test-1",
      "description": "Security auditor correctly identifies configuration issues",
      "expectedOutput": "Review failed checks and update configuration before deployment.",
      "isVisible": true
    }
  ],
  "hints": [
    {
      "level": 1,
      "text": "**Hint:** For each check, compare the config value against the security threshold. Create an AuditCheck with PASS if it meets requirements, FAIL if it doesn't, or WARN for non-critical issues. Include helpful recommendations for failed checks."
    }
  ],
  "commonMistakes": [
    {
      "mistake": "Only checking a few security settings",
      "consequence": "Missing critical vulnerabilities in unchecked areas",
      "correction": "Use a comprehensive checklist covering authentication, authorization, input validation, encryption, and more"
    },
    {
      "mistake": "Running security audits only before major releases",
      "consequence": "Vulnerabilities can exist for weeks or months",
      "correction": "Integrate security scanning into CI/CD for every commit"
    }
  ],
  "difficulty": "advanced"
}